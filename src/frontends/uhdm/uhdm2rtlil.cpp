/*
 * UHDM to RTLIL Translation Frontend for Yosys
 * 
 * This file implements a comprehensive SystemVerilog frontend that reads
 * UHDM files (generated by Surelog) and converts them to Yosys RTLIL format.
 * 
 * The implementation is structured similarly to the Yosys Verific frontend,
 * with separate modules for different aspects of the translation.
 */

#include "uhdm2rtlil.h"

USING_YOSYS_NAMESPACE

using namespace UHDM;

// Main UHDM frontend pass
struct ReadUHDMPass : public Frontend {
    ReadUHDMPass() : Frontend("=read_uhdm", "read UHDM design") {}

    void help() override {
        log("\n");
        log("    read_uhdm [options] <filename>\n");
        log("\n");
        log("Read a UHDM design file (created by Surelog) into Yosys.\n");
        log("\n");
        log("    -keep_names      keep original signal names\n");
        log("    -debug           enable debug output\n");
        log("    -formal          enable formal verification constructs\n");
        log("\n");
    }

    void execute(std::istream *&f, std::string filename, std::vector<std::string> args, RTLIL::Design *design) override {
        log_header(design, "Executing UHDM frontend.\n");

        bool keep_names = false;
        bool debug = false;
        bool formal = false;
        
        size_t argidx = 1;
        for (; argidx < args.size(); argidx++) {
            if (args[argidx] == "-keep_names") {
                keep_names = true;
                continue;
            }
            if (args[argidx] == "-debug") {
                debug = true;
                continue;
            }
            if (args[argidx] == "-formal") {
                formal = true;
                continue;
            }
            break;
        }

        if (argidx >= args.size())
            log_cmd_error("Usage: read_uhdm [options] <uhdm_file>\n");

        filename = args[argidx];
        log("Reading UHDM file: %s\n", filename.c_str());

        // Load UHDM file
        Serializer serializer;
        std::vector<vpiHandle> handles;
        std::vector<vpiHandle> designs = serializer.Restore(filename);
        vpiHandle vpi_design = designs.at(0);
        UHDM::design* uhdm_design = UhdmDesignFromVpiHandle(vpi_design);

        if (!uhdm_design)
            log_error("Failed to restore UHDM file.\n");

        if (!uhdm_design->AllModules())
            log_error("No modules found in UHDM design.\n");

        // Create importer and import design
        UhdmImporter importer(design, keep_names, debug);
        importer.mode_formal = formal;
        importer.import_design(uhdm_design);
        
        log("Successfully imported %zu modules from UHDM.\n", 
            uhdm_design->AllModules()->size());
    }
} ReadUHDMPass;

// Plugin entry point for Yosys
extern "C" void yosys_plugin_initialize() {
    // Use the standard registration mechanism
    ReadUHDMPass.run_register();
}

extern "C" const char *yosys_plugin_name() {
    return "uhdm2rtlil";
}

extern "C" const char *yosys_plugin_version() {
    return "1.0";
}

YOSYS_NAMESPACE_BEGIN

// UhdmImporter constructor
UhdmImporter::UhdmImporter(RTLIL::Design *design, bool keep_names, bool debug) :
    design(design), module(nullptr), mode_keep_names(keep_names), mode_debug(debug) {
}

// Import entire UHDM design
void UhdmImporter::import_design(UHDM::design* uhdm_design) {
    log("UHDM: Starting import_design\n");
    
    if (!uhdm_design->AllModules()) {
        log("UHDM: No modules found in design\n");
        return;
    }
    
    log("UHDM: Found %d modules in design\n", (int)uhdm_design->AllModules()->size());
        
    for (const module_inst* uhdm_mod : *uhdm_design->AllModules()) {
        log("UHDM: About to import module\n");
        import_module(uhdm_mod);
    }
    log("UHDM: Finished import_design\n");
}

// Import a single module
void UhdmImporter::import_module(const module_inst* uhdm_module) {
    std::string modname = std::string(uhdm_module->VpiName());
    
    // Debug and validation
    log("UHDM: Processing module, VpiName() returns: '%s'\n", modname.c_str());
    
    // Try alternative name fields if VpiName is empty
    if (modname.empty()) {
        // Try VpiDefName for module definition name
        std::string defname = std::string(uhdm_module->VpiDefName());
        if (!defname.empty()) {
            modname = defname;
            log("UHDM: Using VpiDefName: '%s'\n", modname.c_str());
            
            // Strip work@ prefix if present
            if (modname.find("work@") == 0) {
                modname = modname.substr(5); // Remove "work@"
                log("UHDM: Stripped work@ prefix, using: '%s'\n", modname.c_str());
            }
        } else {
            log_warning("UHDM: Module has empty name, using default name 'unnamed_module'\n");
            modname = "unnamed_module";
        }
    }
    
    RTLIL::IdString mod_id = RTLIL::escape_id(modname);
    
    if (mode_debug)
        log("Importing module: %s (ID: %s)\n", modname.c_str(), mod_id.c_str());
    
    module = design->addModule(mod_id);
    
    // Add source attribute to module
    add_src_attribute(module->attributes, uhdm_module);
    
    // Clear maps for this module
    net_map.clear();
    wire_map.clear();
    name_map.clear();
    
    // Import ports
    if (uhdm_module->Ports()) {
        log("UHDM: Found %d ports to import\n", (int)uhdm_module->Ports()->size());
        for (auto port : *uhdm_module->Ports()) {
            std::string port_name = std::string(port->VpiName());
            log("UHDM: About to import port: '%s'\n", port_name.c_str());
            import_port(port);
        }
    }
    
    // Import parameters
    if (uhdm_module->Parameters()) {
        log("UHDM: Found %d parameters to import\n", (int)uhdm_module->Parameters()->size());
        for (auto param : *uhdm_module->Parameters()) {
            std::string param_name = std::string(param->VpiName());
            log("UHDM: About to import parameter: '%s'\n", param_name.c_str());
            import_parameter(param);
        }
    }
    
    // Import parameter overrides (param_assigns)
    if (uhdm_module->Param_assigns()) {
        log("UHDM: Found %d parameter assignments to import\n", (int)uhdm_module->Param_assigns()->size());
        for (auto param_assign : *uhdm_module->Param_assigns()) {
            if (param_assign->Lhs() && param_assign->Rhs()) {
                std::string param_name = std::string(param_assign->Lhs()->VpiName());
                log("UHDM: Processing parameter assignment for '%s'\n", param_name.c_str());
                
                // Get the assigned value
                RTLIL::SigSpec value_spec = import_expression(static_cast<const expr*>(param_assign->Rhs()));
                if (value_spec.is_fully_const()) {
                    RTLIL::Const param_value = value_spec.as_const();
                    // Override the parameter value
                    RTLIL::IdString param_id = RTLIL::escape_id(param_name);
                    module->avail_parameters(param_id);
                    module->parameter_default_values[param_id] = param_value;
                    log("UHDM: Updated parameter '%s' to value %s\n", 
                        param_name.c_str(), param_value.as_string().c_str());
                } else {
                    log_warning("UHDM: Parameter assignment for '%s' has non-constant value\n", 
                               param_name.c_str());
                }
            }
        }
    }
    
    // Import nets
    if (uhdm_module->Nets()) {
        log("UHDM: Found %d nets to import\n", (int)uhdm_module->Nets()->size());
        for (auto net : *uhdm_module->Nets()) {
            std::string net_name = std::string(net->VpiName());
            log("UHDM: About to import net: '%s'\n", net_name.c_str());
            import_net(net);
        }
    }
    
    // Import memory objects using analysis pass
    analyze_and_generate_memories(uhdm_module);
    
    // Import continuous assignments
    if (uhdm_module->Cont_assigns()) {
        for (auto assign : *uhdm_module->Cont_assigns()) {
            import_continuous_assign(assign);
        }
    }
    
    // Import processes (always blocks) - re-enabled with debugging
    if (uhdm_module->Process()) {
        log("UHDM: Found %d processes to import\n", (int)uhdm_module->Process()->size());
        for (auto process : *uhdm_module->Process()) {
            log("UHDM: About to import process\n");
            try {
                import_process(process);
                log("UHDM: Successfully imported process\n");
            } catch (const std::exception& e) {
                log_error("UHDM: Exception in process import: %s\n", e.what());
            } catch (...) {
                log_error("UHDM: Unknown exception in process import\n");
            }
        }
    }
    
    // Import continuous assignments
    if (uhdm_module->Cont_assigns()) {
        log("UHDM: Found %d continuous assignments to import\n", (int)uhdm_module->Cont_assigns()->size());
        for (auto cont_assign : *uhdm_module->Cont_assigns()) {
            log("UHDM: About to import continuous assignment\n");
            try {
                import_continuous_assign(cont_assign);
                log("UHDM: Successfully imported continuous assignment\n");
            } catch (const std::exception& e) {
                log_error("UHDM: Exception in continuous assignment import: %s\n", e.what());
            } catch (...) {
                log_error("UHDM: Unknown exception in continuous assignment import\n");
            }
        }
    }
    
    // Import module instances via ref_modules
    if (uhdm_module->Ref_modules()) {
        log("UHDM: Found %d ref_modules to import\n", (int)uhdm_module->Ref_modules()->size());
        for (auto ref_mod : *uhdm_module->Ref_modules()) {
            log("UHDM: About to import ref_module instance\n");
            try {
                import_ref_module(ref_mod);
                log("UHDM: Successfully imported module instance\n");
            } catch (const std::exception& e) {
                log_error("UHDM: Exception in module instance import: %s\n", e.what());
            } catch (...) {
                log_error("UHDM: Unknown exception in module instance import\n");
            }
        }
    }
    
    // Finalize module
    module->fixup_ports();
}

// Create a parameterized module based on parameter values in the base module
std::string UhdmImporter::create_parameterized_module(const std::string& base_name, RTLIL::Module* base_module) {
    if (mode_debug)
        log("  Creating parameterized module for base: %s\n", base_name.c_str());
    
    // Build parameter string like Yosys does
    std::string param_string = "";
    for (const auto& [param_name, param_value] : base_module->parameter_default_values) {
        param_string += "\\" + param_name.str().substr(1) + "="; // Remove leading backslash
        
        // Format parameter value (signed 32-bit representation like Yosys)
        if (param_value.flags & RTLIL::CONST_FLAG_SIGNED) {
            param_string += "s";
        }
        param_string += "32'";
        
        // Convert to 32-bit binary representation
        std::string binary_value = "";
        int target_width = 32;
        for (int i = target_width - 1; i >= 0; i--) {
            if (i < param_value.size()) {
                binary_value += (param_value[i] == RTLIL::State::S1) ? "1" : "0";
            } else {
                binary_value += "0"; // Pad with zeros
            }
        }
        param_string += binary_value;
    }
    
    // Generate parameterized module name
    std::string param_module_name;
    if (!param_string.empty()) {
        param_module_name = "$paramod\\" + base_name + param_string;
    } else {
        param_module_name = base_name;
    }
    
    // Create the parameterized module if it doesn't exist
    RTLIL::IdString param_module_id = RTLIL::escape_id(param_module_name);
    if (!design->module(param_module_id)) {
        if (mode_debug)
            log("    Creating new parameterized module: %s\n", param_module_name.c_str());
        
        // Clone the base module
        RTLIL::Module* param_module = design->addModule(param_module_id);
        
        // Copy all the content from base module
        for (auto& [wire_name, wire] : base_module->wires_) {
            RTLIL::Wire* new_wire = param_module->addWire(wire_name, wire->width);
            new_wire->port_input = wire->port_input;
            new_wire->port_output = wire->port_output;
            new_wire->port_id = wire->port_id;
            new_wire->attributes = wire->attributes;
        }
        
        // Copy cells
        for (auto& [cell_name, cell] : base_module->cells_) {
            RTLIL::Cell* new_cell = param_module->addCell(cell_name, cell->type);
            new_cell->parameters = cell->parameters;
            new_cell->attributes = cell->attributes;
            for (auto& [port_name, port_sig] : cell->connections_) {
                new_cell->setPort(port_name, port_sig);
            }
        }
        
        // Copy parameters with current values
        for (const auto& [param_name, param_value] : base_module->parameter_default_values) {
            param_module->avail_parameters(param_name);
            param_module->parameter_default_values[param_name] = param_value;
        }
        
        // Copy attributes
        param_module->attributes = base_module->attributes;
        param_module->attributes[RTLIL::escape_id("hdlname")] = RTLIL::Const(base_name);
        
        param_module->fixup_ports();
    }
    
    return param_module_name;
}

// Note: import_port, import_net, and import_continuous_assign are implemented in module.cpp

YOSYS_NAMESPACE_END
