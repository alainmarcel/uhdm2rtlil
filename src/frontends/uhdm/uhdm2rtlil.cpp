/*
 * UHDM to RTLIL Translation Frontend for Yosys
 * 
 * This file implements a comprehensive SystemVerilog frontend that reads
 * UHDM files (generated by Surelog) and converts them to Yosys RTLIL format.
 * 
 * The implementation is structured similarly to the Yosys Verific frontend,
 * with separate modules for different aspects of the translation.
 */

#include "uhdm2rtlil.h"

USING_YOSYS_NAMESPACE

using namespace UHDM;

// Main UHDM frontend pass
struct ReadUHDMPass : public Frontend {
    ReadUHDMPass() : Frontend("=read_uhdm", "read UHDM design") {}

    void help() override {
        log("\n");
        log("    read_uhdm [options] <filename>\n");
        log("\n");
        log("Read a UHDM design file (created by Surelog) into Yosys.\n");
        log("\n");
        log("    -keep_names      keep original signal names\n");
        log("    -debug           enable debug output\n");
        log("    -formal          enable formal verification constructs\n");
        log("\n");
    }

    void execute(std::istream *&f, std::string filename, std::vector<std::string> args, RTLIL::Design *design) override {
        log_header(design, "Executing UHDM frontend.\n");

        bool keep_names = false;
        bool debug = false;
        bool formal = false;
        
        size_t argidx = 1;
        for (; argidx < args.size(); argidx++) {
            if (args[argidx] == "-keep_names") {
                keep_names = true;
                continue;
            }
            if (args[argidx] == "-debug") {
                debug = true;
                continue;
            }
            if (args[argidx] == "-formal") {
                formal = true;
                continue;
            }
            if (args[argidx] == "-help" || args[argidx] == "--help") {
                help();
                return;
            }
            break;
        }

        if (argidx >= args.size())
            log_cmd_error("Usage: read_uhdm [options] <uhdm_file>\n");

        filename = args[argidx];
        log("Reading UHDM file: %s\n", filename.c_str());

        // Load UHDM file
        Serializer serializer;
        std::vector<vpiHandle> handles;
        std::vector<vpiHandle> designs = serializer.Restore(filename);
        vpiHandle vpi_design = designs.at(0);
        UHDM::design* uhdm_design = UhdmDesignFromVpiHandle(vpi_design);

        if (!uhdm_design)
            log_error("Failed to restore UHDM file.\n");

        if (!uhdm_design->AllModules())
            log_error("No modules found in UHDM design.\n");

        // Create importer and import design
        UhdmImporter importer(design, keep_names, debug);
        importer.mode_formal = formal;
        importer.import_design(uhdm_design);
        
        log("Successfully imported %zu modules from UHDM.\n", 
            uhdm_design->AllModules()->size());
    }
} ReadUHDMPass;

// Plugin entry point for Yosys
extern "C" void yosys_plugin_initialize() {
    // Use the standard registration mechanism
    ReadUHDMPass.run_register();
}

extern "C" const char *yosys_plugin_name() {
    return "uhdm2rtlil";
}

extern "C" const char *yosys_plugin_version() {
    return "1.0";
}

YOSYS_NAMESPACE_BEGIN

// UhdmImporter constructor
UhdmImporter::UhdmImporter(RTLIL::Design *design, bool keep_names, bool debug) :
    design(design), module(nullptr), mode_keep_names(keep_names), mode_debug(debug) {
}

// Import entire UHDM design
void UhdmImporter::import_design(UHDM::design* uhdm_design) {
    log("UHDM: Starting import_design\n");
    
    if (!uhdm_design->AllModules()) {
        log("UHDM: No modules found in design\n");
        return;
    }
    
    log("UHDM: Found %d modules in design\n", (int)uhdm_design->AllModules()->size());
        
    // First, import all interfaces
    if (uhdm_design->AllInterfaces()) {
        log("UHDM: Found %d interfaces in design\n", (int)uhdm_design->AllInterfaces()->size());
        for (const interface_inst* uhdm_interface : *uhdm_design->AllInterfaces()) {
            log("UHDM: About to import interface\n");
            import_interface(uhdm_interface);
        }
    }
    
    for (const module_inst* uhdm_mod : *uhdm_design->AllModules()) {
        log("UHDM: About to import module\n");
        import_module(uhdm_mod);
    }
    
    // Post-process to create parameterized modules
    log("UHDM: Creating parameterized modules\n");
    create_parameterized_modules();
    
    log("UHDM: Finished import_design\n");
}

// Create parameterized modules based on cell parameters
void UhdmImporter::create_parameterized_modules() {
    std::map<std::string, std::set<int>> module_widths;
    
    // Collect all parameterized cell instances
    for (auto &mod_pair : design->modules_) {
        RTLIL::Module* mod = mod_pair.second;
        for (auto &cell_pair : mod->cells_) {
            RTLIL::Cell* cell = cell_pair.second;
            
            // Check if this cell has a WIDTH parameter
            if (cell->hasParam(RTLIL::escape_id("WIDTH"))) {
                std::string base_module = cell->type.str();
                if (base_module[0] == '\\') base_module = base_module.substr(1);
                
                int width = cell->getParam(RTLIL::escape_id("WIDTH")).as_int();
                module_widths[base_module].insert(width);
                
                if (mode_debug)
                    log("    Found parameterized cell %s/%s: %s with WIDTH=%d\n", 
                        mod->name.c_str(), cell->name.c_str(), base_module.c_str(), width);
            }
        }
    }
    
    // Create parameterized modules for each base module and width combination
    for (auto &entry : module_widths) {
        std::string base_module_name = entry.first;
        std::set<int> widths = entry.second;
        
        RTLIL::Module* base_mod = design->module(RTLIL::escape_id(base_module_name));
        if (!base_mod) {
            log_warning("Base module '%s' not found for parameterization\n", base_module_name.c_str());
            continue;
        }
        
        for (int width : widths) {
            // Generate parameterized module name
            std::string param_value = stringf("s32'%s", RTLIL::Const(width, 32).as_string().c_str());
            std::string param_module_name = stringf("$paramod\\%s\\WIDTH=%s", base_module_name.c_str(), param_value.c_str());
            
            RTLIL::IdString param_mod_id = RTLIL::escape_id(param_module_name);
            if (design->module(param_mod_id)) {
                // Already exists
                continue;
            }
            
            if (mode_debug)
                log("    Creating parameterized module: %s\n", param_module_name.c_str());
            
            RTLIL::Module* param_mod = design->addModule(param_mod_id);
            
            // Copy attributes from base module
            param_mod->attributes = base_mod->attributes;
            param_mod->avail_parameters = base_mod->avail_parameters;
            param_mod->parameter_default_values = base_mod->parameter_default_values;
            
            // Update the WIDTH parameter
            RTLIL::IdString width_param = RTLIL::escape_id("WIDTH");
            param_mod->parameter_default_values[width_param] = RTLIL::Const(width, 32);
            
            // Wire mapping for connection updates
            std::map<RTLIL::Wire*, RTLIL::Wire*> wire_map;
            
            // Copy and resize wires/ports
            for (auto &wire_pair : base_mod->wires_) {
                RTLIL::Wire* base_wire = wire_pair.second;
                RTLIL::Wire* param_wire = param_mod->addWire(base_wire->name, width);
                param_wire->attributes = base_wire->attributes;
                param_wire->port_id = base_wire->port_id;
                param_wire->port_input = base_wire->port_input;
                param_wire->port_output = base_wire->port_output;
                wire_map[base_wire] = param_wire;
            }
            
            // Fixup ports
            param_mod->fixup_ports();
            
            // Copy and update cells
            for (auto &cell_pair : base_mod->cells_) {
                RTLIL::Cell* base_cell = cell_pair.second;
                RTLIL::Cell* param_cell = param_mod->addCell(base_cell->name, base_cell->type);
                param_cell->attributes = base_cell->attributes;
                param_cell->parameters = base_cell->parameters;
                
                // Update width-related parameters
                for (auto &param_pair : param_cell->parameters) {
                    if (param_pair.first.in("\\A_WIDTH", "\\B_WIDTH", "\\Y_WIDTH")) {
                        param_pair.second = RTLIL::Const(width, 32);
                    }
                }
                
                // Copy connections with wire mapping and width expansion
                for (auto &conn_pair : base_cell->connections_) {
                    RTLIL::SigSpec mapped_sig;
                    for (auto &chunk : conn_pair.second.chunks()) {
                        if (chunk.wire) {
                            if (wire_map.count(chunk.wire)) {
                                RTLIL::Wire* mapped_wire = wire_map[chunk.wire];
                                // If the original chunk was the full 1-bit wire and the new wire is wider,
                                // expand to use the full new wire
                                if (chunk.offset == 0 && chunk.width == chunk.wire->width && 
                                    chunk.wire->width == 1 && mapped_wire->width > 1) {
                                    mapped_sig.append(RTLIL::SigChunk(mapped_wire, 0, mapped_wire->width));
                                } else {
                                    mapped_sig.append(RTLIL::SigChunk(mapped_wire, chunk.offset, chunk.width));
                                }
                            } else {
                                log_warning("Wire mapping not found for %s\n", chunk.wire->name.c_str());
                                mapped_sig.append(chunk);
                            }
                        } else {
                            mapped_sig.append(chunk);
                        }
                    }
                    param_cell->setPort(conn_pair.first, mapped_sig);
                }
            }
            
            // Copy connections with wire mapping and width expansion
            for (auto &conn : base_mod->connections_) {
                RTLIL::SigSpec mapped_left, mapped_right;
                
                // Map left side with width expansion
                for (auto &chunk : conn.first.chunks()) {
                    if (chunk.wire && wire_map.count(chunk.wire)) {
                        RTLIL::Wire* mapped_wire = wire_map[chunk.wire];
                        // Expand 1-bit full wire connections to full width
                        if (chunk.offset == 0 && chunk.width == chunk.wire->width && 
                            chunk.wire->width == 1 && mapped_wire->width > 1) {
                            mapped_left.append(RTLIL::SigChunk(mapped_wire, 0, mapped_wire->width));
                        } else {
                            mapped_left.append(RTLIL::SigChunk(mapped_wire, chunk.offset, chunk.width));
                        }
                    } else {
                        mapped_left.append(chunk);
                    }
                }
                
                // Map right side with width expansion
                for (auto &chunk : conn.second.chunks()) {
                    if (chunk.wire && wire_map.count(chunk.wire)) {
                        RTLIL::Wire* mapped_wire = wire_map[chunk.wire];
                        // Expand 1-bit full wire connections to full width
                        if (chunk.offset == 0 && chunk.width == chunk.wire->width && 
                            chunk.wire->width == 1 && mapped_wire->width > 1) {
                            mapped_right.append(RTLIL::SigChunk(mapped_wire, 0, mapped_wire->width));
                        } else {
                            mapped_right.append(RTLIL::SigChunk(mapped_wire, chunk.offset, chunk.width));
                        }
                    } else {
                        mapped_right.append(chunk);
                    }
                }
                
                param_mod->connect(mapped_left, mapped_right);
            }
        }
    }
    
    // Update cell types to reference parameterized modules
    for (auto &mod_pair : design->modules_) {
        RTLIL::Module* mod = mod_pair.second;
        for (auto &cell_pair : mod->cells_) {
            RTLIL::Cell* cell = cell_pair.second;
            
            // Check if this cell has a WIDTH parameter
            if (cell->hasParam(RTLIL::escape_id("WIDTH"))) {
                std::string base_module = cell->type.str();
                if (base_module[0] == '\\') base_module = base_module.substr(1);
                
                int width = cell->getParam(RTLIL::escape_id("WIDTH")).as_int();
                
                // Generate parameterized module name
                std::string param_value = stringf("s32'%s", RTLIL::Const(width, 32).as_string().c_str());
                std::string param_module_name = stringf("$paramod\\%s\\WIDTH=%s", base_module.c_str(), param_value.c_str());
                
                // Update cell type to reference parameterized module
                cell->type = RTLIL::escape_id(param_module_name);
                
                // Remove the WIDTH parameter from the cell (it's now part of the module name)
                cell->parameters.erase(RTLIL::escape_id("WIDTH"));
                
                if (mode_debug)
                    log("    Updated cell %s/%s to use module %s\n", 
                        mod->name.c_str(), cell->name.c_str(), param_module_name.c_str());
            }
        }
    }
}

// Import a single module
void UhdmImporter::import_module(const module_inst* uhdm_module) {
    std::string modname = std::string(uhdm_module->VpiName());
    
    // Debug and validation
    log("UHDM: Processing module, VpiName() returns: '%s'\n", modname.c_str());
    
    // Try alternative name fields if VpiName is empty
    if (modname.empty()) {
        // Try VpiDefName for module definition name
        std::string defname = std::string(uhdm_module->VpiDefName());
        if (!defname.empty()) {
            modname = defname;
            log("UHDM: Using VpiDefName: '%s'\n", modname.c_str());
            
            // Strip work@ prefix if present
            if (modname.find("work@") == 0) {
                modname = modname.substr(5); // Remove "work@"
                log("UHDM: Stripped work@ prefix, using: '%s'\n", modname.c_str());
            }
        } else {
            log_warning("UHDM: Module has empty name, using default name 'unnamed_module'\n");
            modname = "unnamed_module";
        }
    }
    
    RTLIL::IdString mod_id = RTLIL::escape_id(modname);
    
    if (mode_debug)
        log("Importing module: %s (ID: %s)\n", modname.c_str(), mod_id.c_str());
    
    module = design->addModule(mod_id);
    
    // Add source attribute to module
    add_src_attribute(module->attributes, uhdm_module);
    
    // Clear maps for this module
    net_map.clear();
    wire_map.clear();
    name_map.clear();
    
    // Import ports
    if (uhdm_module->Ports()) {
        log("UHDM: Found %d ports to import\n", (int)uhdm_module->Ports()->size());
        for (auto port : *uhdm_module->Ports()) {
            std::string port_name = std::string(port->VpiName());
            log("UHDM: About to import port: '%s'\n", port_name.c_str());
            import_port(port);
        }
    }
    
    // Import parameters
    if (uhdm_module->Parameters()) {
        log("UHDM: Found %d parameters to import\n", (int)uhdm_module->Parameters()->size());
        for (auto param : *uhdm_module->Parameters()) {
            std::string param_name = std::string(param->VpiName());
            log("UHDM: About to import parameter: '%s'\n", param_name.c_str());
            import_parameter(param);
        }
    }
    
    // Import parameter overrides (param_assigns)
    if (uhdm_module->Param_assigns()) {
        log("UHDM: Found %d parameter assignments to import\n", (int)uhdm_module->Param_assigns()->size());
        for (auto param_assign : *uhdm_module->Param_assigns()) {
            if (param_assign->Lhs() && param_assign->Rhs()) {
                std::string param_name = std::string(param_assign->Lhs()->VpiName());
                log("UHDM: Processing parameter assignment for '%s'\n", param_name.c_str());
                
                // Get the assigned value
                RTLIL::SigSpec value_spec = import_expression(static_cast<const expr*>(param_assign->Rhs()));
                if (value_spec.is_fully_const()) {
                    RTLIL::Const param_value = value_spec.as_const();
                    // Override the parameter value
                    RTLIL::IdString param_id = RTLIL::escape_id(param_name);
                    module->avail_parameters(param_id);
                    module->parameter_default_values[param_id] = param_value;
                    log("UHDM: Updated parameter '%s' to value %s\n", 
                        param_name.c_str(), param_value.as_string().c_str());
                } else {
                    log_warning("UHDM: Parameter assignment for '%s' has non-constant value\n", 
                               param_name.c_str());
                }
            }
        }
    }
    
    // Import nets
    if (uhdm_module->Nets()) {
        log("UHDM: Found %d nets to import\n", (int)uhdm_module->Nets()->size());
        for (auto net : *uhdm_module->Nets()) {
            std::string net_name = std::string(net->VpiName());
            log("UHDM: About to import net: '%s'\n", net_name.c_str());
            import_net(net);
        }
    }
    
    // Import interface instances
    import_interface_instances(uhdm_module);
    
    // Import memory objects using analysis pass
    analyze_and_generate_memories(uhdm_module);
    
    // Import continuous assignments
    if (uhdm_module->Cont_assigns()) {
        for (auto assign : *uhdm_module->Cont_assigns()) {
            import_continuous_assign(assign);
        }
    }
    
    // Import processes (always blocks) - re-enabled with debugging
    if (uhdm_module->Process()) {
        log("UHDM: Found %d processes to import\n", (int)uhdm_module->Process()->size());
        for (auto process : *uhdm_module->Process()) {
            log("UHDM: About to import process\n");
            try {
                import_process(process);
                log("UHDM: Successfully imported process\n");
            } catch (const std::exception& e) {
                log_error("UHDM: Exception in process import: %s\n", e.what());
            } catch (...) {
                log_error("UHDM: Unknown exception in process import\n");
            }
        }
    }
    
    // Import continuous assignments
    if (uhdm_module->Cont_assigns()) {
        log("UHDM: Found %d continuous assignments to import\n", (int)uhdm_module->Cont_assigns()->size());
        for (auto cont_assign : *uhdm_module->Cont_assigns()) {
            log("UHDM: About to import continuous assignment\n");
            try {
                import_continuous_assign(cont_assign);
                log("UHDM: Successfully imported continuous assignment\n");
            } catch (const std::exception& e) {
                log_error("UHDM: Exception in continuous assignment import: %s\n", e.what());
            } catch (...) {
                log_error("UHDM: Unknown exception in continuous assignment import\n");
            }
        }
    }
    
    // Import module instances via ref_modules
    if (uhdm_module->Ref_modules()) {
        log("UHDM: Found %d ref_modules to import\n", (int)uhdm_module->Ref_modules()->size());
        for (auto ref_mod : *uhdm_module->Ref_modules()) {
            log("UHDM: About to import ref_module instance\n");
            try {
                import_ref_module(ref_mod);
                log("UHDM: Successfully imported module instance\n");
            } catch (const std::exception& e) {
                log_error("UHDM: Exception in module instance import: %s\n", e.what());
            } catch (...) {
                log_error("UHDM: Unknown exception in module instance import\n");
            }
        }
    }
    
    // Finalize module
    module->fixup_ports();
}

// Create a parameterized module based on parameter values in the base module
std::string UhdmImporter::create_parameterized_module(const std::string& base_name, RTLIL::Module* base_module) {
    if (mode_debug)
        log("  Creating parameterized module for base: %s\n", base_name.c_str());
    
    // Build parameter string like Yosys does
    std::string param_string = "";
    for (const auto& [param_name, param_value] : base_module->parameter_default_values) {
        param_string += "\\" + param_name.str().substr(1) + "="; // Remove leading backslash
        
        // Format parameter value (signed 32-bit representation like Yosys)
        if (param_value.flags & RTLIL::CONST_FLAG_SIGNED) {
            param_string += "s";
        }
        param_string += "32'";
        
        // Convert to 32-bit binary representation
        std::string binary_value = "";
        int target_width = 32;
        for (int i = target_width - 1; i >= 0; i--) {
            if (i < param_value.size()) {
                binary_value += (param_value[i] == RTLIL::State::S1) ? "1" : "0";
            } else {
                binary_value += "0"; // Pad with zeros
            }
        }
        param_string += binary_value;
    }
    
    // Generate parameterized module name
    std::string param_module_name;
    if (!param_string.empty()) {
        param_module_name = "$paramod\\" + base_name + param_string;
    } else {
        param_module_name = base_name;
    }
    
    // Create the parameterized module if it doesn't exist
    RTLIL::IdString param_module_id = RTLIL::escape_id(param_module_name);
    if (!design->module(param_module_id)) {
        if (mode_debug)
            log("    Creating new parameterized module: %s\n", param_module_name.c_str());
        
        // Clone the base module
        RTLIL::Module* param_module = design->addModule(param_module_id);
        
        // Copy all the content from base module
        for (auto& [wire_name, wire] : base_module->wires_) {
            RTLIL::Wire* new_wire = param_module->addWire(wire_name, wire->width);
            new_wire->port_input = wire->port_input;
            new_wire->port_output = wire->port_output;
            new_wire->port_id = wire->port_id;
            new_wire->attributes = wire->attributes;
        }
        
        // Copy cells
        for (auto& [cell_name, cell] : base_module->cells_) {
            RTLIL::Cell* new_cell = param_module->addCell(cell_name, cell->type);
            new_cell->parameters = cell->parameters;
            new_cell->attributes = cell->attributes;
            for (auto& [port_name, port_sig] : cell->connections_) {
                new_cell->setPort(port_name, port_sig);
            }
        }
        
        // Copy parameters with current values
        for (const auto& [param_name, param_value] : base_module->parameter_default_values) {
            param_module->avail_parameters(param_name);
            param_module->parameter_default_values[param_name] = param_value;
        }
        
        // Copy attributes
        param_module->attributes = base_module->attributes;
        param_module->attributes[RTLIL::escape_id("hdlname")] = RTLIL::Const(base_name);
        
        param_module->fixup_ports();
    }
    
    return param_module_name;
}

// Import interface as a module with interface attribute
void UhdmImporter::import_interface(const interface_inst* uhdm_interface) {
    if (mode_debug)
        log("UHDM: Starting import_interface\n");
    
    std::string interface_name = std::string(uhdm_interface->VpiName());
    if (interface_name.empty()) {
        std::string defname = std::string(uhdm_interface->VpiDefName());
        if (!defname.empty()) {
            interface_name = defname;
            // Strip work@ prefix if present
            if (interface_name.find("work@") == 0) {
                interface_name = interface_name.substr(5);
            }
        }
    }
    
    if (interface_name.empty()) {
        log_warning("UHDM: Interface has empty name, skipping\n");
        return;
    }
    
    if (mode_debug)
        log("UHDM: Processing interface: %s\n", interface_name.c_str());
    
    // Create interface module with parameterized name
    std::string param_interface_name = interface_name;
    
    // Add parameter information to the name if available
    if (uhdm_interface->Parameters()) {
        if (mode_debug)
            log("UHDM: Interface has %d parameters\n", (int)uhdm_interface->Parameters()->size());
        
        for (auto param : *uhdm_interface->Parameters()) {
            if (!param) {
                if (mode_debug)
                    log("UHDM: Skipping null parameter\n");
                continue;
            }
            
            std::string param_name = std::string(param->VpiName());
            if (mode_debug)
                log("UHDM: Processing parameter: %s\n", param_name.c_str());
                
            if (param_name == "WIDTH") {
                // Skip parameter handling for now to avoid crash
                if (mode_debug)
                    log("UHDM: Skipping WIDTH parameter handling to avoid crash\n");
            }
        }
    }
    
    RTLIL::IdString interface_id = RTLIL::escape_id(param_interface_name);
    RTLIL::Module* interface_module = design->addModule(interface_id);
    module = interface_module;
    
    // Set interface attributes
    interface_module->attributes[RTLIL::escape_id("hdlname")] = RTLIL::Const(interface_name);
    interface_module->attributes[RTLIL::escape_id("is_interface")] = RTLIL::Const(1);
    interface_module->attributes[RTLIL::escape_id("dynports")] = RTLIL::Const(1);
    
    // Import interface variables as ports
    if (uhdm_interface->Variables()) {
        if (mode_debug)
            log("UHDM: Interface has %d variables\n", (int)uhdm_interface->Variables()->size());
            
        for (auto var : *uhdm_interface->Variables()) {
            std::string var_name = std::string(var->VpiName());
            int width = get_width(var);
            if (width <= 0) width = 8; // Default to 8 for interface signals instead of 1
            
            if (mode_debug)
                log("UHDM: Creating interface signal: %s (width=%d)\n", var_name.c_str(), width);
            
            RTLIL::Wire* wire = interface_module->addWire(RTLIL::escape_id(var_name), width);
            name_map[var_name] = wire;
        }
    } else {
        if (mode_debug)
            log("UHDM: Interface has no variables\n");
    }
    
    // Handle parameters
    if (uhdm_interface->Parameters()) {
        for (auto param : *uhdm_interface->Parameters()) {
            import_parameter(param);
        }
    }
    
    interface_module->fixup_ports();
    
    if (mode_debug)
        log("UHDM: Finished importing interface: %s\n", interface_name.c_str());
}

// Import interface instances within a module
void UhdmImporter::import_interface_instances(const UHDM::module_inst* uhdm_module) {
    if (mode_debug)
        log("UHDM: Starting import_interface_instances\n");
    
    // Import interface instances
    if (uhdm_module->Interfaces()) {
        for (auto interface : *uhdm_module->Interfaces()) {
            std::string interface_name = std::string(interface->VpiName());
            if (mode_debug)
                log("UHDM: Processing interface instance: %s\n", interface_name.c_str());
            
            // Create interface signals in the module
            if (interface->Variables()) {
                for (auto var : *interface->Variables()) {
                    std::string var_name = std::string(var->VpiName());
                    std::string full_name = interface_name + "." + var_name;
                    int width = get_width(var);
                    if (width <= 0) width = 1;
                    
                    if (mode_debug)
                        log("UHDM: Creating interface signal: %s (width=%d)\n", full_name.c_str(), width);
                    
                    RTLIL::Wire* wire = create_wire(full_name, width);
                    name_map[full_name] = wire;
                }
            }
            
            // Create interface cell
            std::string interface_type = std::string(interface->VpiDefName());
            if (interface_type.find("work@") == 0) {
                interface_type = interface_type.substr(5);
            }
            
            // Add parameter to type name if needed
            if (interface->Parameters()) {
                for (auto param : *interface->Parameters()) {
                    if (!param) continue;
                    
                    std::string param_name = std::string(param->VpiName());
                    if (param_name == "WIDTH") {
                        // Skip parameter handling for now to avoid crash
                        if (mode_debug)
                            log("UHDM: Skipping WIDTH parameter handling in interface instances\n");
                    }
                }
            }
            
            RTLIL::Cell* interface_cell = module->addCell(RTLIL::escape_id(interface_name), RTLIL::escape_id(interface_type));
            interface_cell->attributes[RTLIL::escape_id("is_interface")] = RTLIL::Const(1);
        }
    }
    
    if (mode_debug)
        log("UHDM: Finished import_interface_instances\n");
}

// Note: import_port, import_net, and import_continuous_assign are implemented in module.cpp

YOSYS_NAMESPACE_END
