/*
 * UHDM to RTLIL Translation Frontend for Yosys
 * 
 * This file implements a comprehensive SystemVerilog frontend that reads
 * UHDM files (generated by Surelog) and converts them to Yosys RTLIL format.
 * 
 * The implementation is structured similarly to the Yosys Verific frontend,
 * with separate modules for different aspects of the translation.
 */

#include "uhdm2rtlil.h"
#include <uhdm/vpi_visitor.h>

USING_YOSYS_NAMESPACE

using namespace UHDM;

// Main UHDM frontend pass
struct ReadUHDMPass : public Frontend {
    ReadUHDMPass() : Frontend("=read_uhdm", "read UHDM design") {}

    void help() override {
        log("\n");
        log("    read_uhdm [options] <filename>\n");
        log("\n");
        log("Read a UHDM design file (created by Surelog) into Yosys.\n");
        log("\n");
        log("    -keep_names      keep original signal names\n");
        log("    -debug           enable debug output\n");
        log("    -formal          enable formal verification constructs\n");
        log("\n");
    }

    void execute(std::istream *&f, std::string filename, std::vector<std::string> args, RTLIL::Design *design) override {
        log_header(design, "Executing UHDM frontend.\n");

        bool keep_names = false;
        bool debug = false;
        bool formal = false;
        
        size_t argidx = 1;
        for (; argidx < args.size(); argidx++) {
            if (args[argidx] == "-keep_names") {
                keep_names = true;
                continue;
            }
            if (args[argidx] == "-debug") {
                debug = true;
                continue;
            }
            if (args[argidx] == "-formal") {
                formal = true;
                continue;
            }
            if (args[argidx] == "-help" || args[argidx] == "--help") {
                help();
                return;
            }
            break;
        }

        if (argidx >= args.size())
            log_cmd_error("Usage: read_uhdm [options] <uhdm_file>\n");

        filename = args[argidx];
        log("Reading UHDM file: %s\n", filename.c_str());

        // Load UHDM file
        Serializer serializer;
        std::vector<vpiHandle> handles;
        std::vector<vpiHandle> designs = serializer.Restore(filename);
        vpiHandle vpi_design = designs.at(0);
        UHDM::design* uhdm_design = UhdmDesignFromVpiHandle(vpi_design);

        if (!uhdm_design)
            log_error("Failed to restore UHDM file.\n");

        // If UHDM is not already elaborated/uniquified (uhdm db was saved by a
        // different process pre-elaboration), then optionally elaborate it:
        if (uhdm_design && (!vpi_get(vpiElaborated, vpi_design))) {
            log("UHDM Elaboration...\n");
            UHDM::ElaboratorContext* elaboratorContext =
                new UHDM::ElaboratorContext(&serializer, true);
            elaboratorContext->m_elaborator.listenDesigns(designs);
            delete elaboratorContext;
        }

        vpi_show_ids(true);
        visit_designs({vpi_design}, std::cout);

        if (!uhdm_design->AllModules())
            log_error("No modules found in UHDM design.\n");

        // Create importer and import design
        UhdmImporter importer(design, keep_names, debug);
        importer.mode_formal = formal;
        importer.import_design(uhdm_design);
        
        log("Successfully imported %zu modules from UHDM.\n", 
            uhdm_design->AllModules()->size());
    }
} ReadUHDMPass;

// Plugin entry point for Yosys
extern "C" void yosys_plugin_initialize() {
    // Use the standard registration mechanism
    ReadUHDMPass.run_register();
}

extern "C" const char *yosys_plugin_name() {
    return "uhdm2rtlil";
}

extern "C" const char *yosys_plugin_version() {
    return "1.0";
}

YOSYS_NAMESPACE_BEGIN

// UhdmImporter constructor
UhdmImporter::UhdmImporter(RTLIL::Design *design, bool keep_names, bool debug) :
    design(design), module(nullptr), mode_keep_names(keep_names), mode_debug(debug) {
}

// Import entire UHDM design
void UhdmImporter::import_design(UHDM::design* uhdm_design) {
    log("UHDM: Starting import_design\n");
    
    // Store the design for later access
    this->uhdm_design = uhdm_design;
    
    // First, identify top-level modules by checking vpiTop property
    std::set<std::string> top_level_module_names;
    if (uhdm_design->TopModules()) {
        for (const module_inst* top_mod : *uhdm_design->TopModules()) {
            if (top_mod->VpiTop()) {
                std::string mod_name = std::string(top_mod->VpiDefName());
                if (mod_name.find("work@") == 0) {
                    mod_name = mod_name.substr(5);
                }
                top_level_module_names.insert(mod_name);
                log("UHDM: Identified top-level module: %s\n", mod_name.c_str());
            }
        }
    }
    
    // Store in class member for use during import
    this->top_level_modules = top_level_module_names;
    
    // First, import all packages
    if (uhdm_design->AllPackages()) {
        log("UHDM: Found %d packages in design\n", (int)uhdm_design->AllPackages()->size());
        for (const package* uhdm_package : *uhdm_design->AllPackages()) {
            log("UHDM: About to import package: %s\n", uhdm_package->VpiDefName().data());
            import_package(uhdm_package);
        }
    }
    
    // Then, import all interfaces
    if (uhdm_design->AllInterfaces()) {
        log("UHDM: Found %d interfaces in design\n", (int)uhdm_design->AllInterfaces()->size());
        for (const interface_inst* uhdm_interface : *uhdm_design->AllInterfaces()) {
            log("UHDM: About to import interface\n");
            // Import interface with default WIDTH=8
            import_interface(uhdm_interface);
            
            // Also create a WIDTH=16 version for bus3
            // This is a temporary solution - ideally we should discover all parameter values
            // Create a copy of the interface with WIDTH=16
            if (std::string(uhdm_interface->VpiDefName()).find("data_bus_if") != std::string::npos) {
                // Create WIDTH=16 version
                create_interface_module_with_width("data_bus_if", 16);
            }
        }
    }
    
    // Also need to create interface modules for all parameter combinations found in the design
    // Collect all unique interface instances with their parameters
    std::set<std::string> interface_module_names;
    
    // Function to collect interface instances from a module
    std::function<void(const UHDM::module_inst*)> collect_interfaces;
    collect_interfaces = [&](const UHDM::module_inst* mod) {
        if (mod->Interfaces()) {
            for (auto interface : *mod->Interfaces()) {
                std::string interface_type = std::string(interface->VpiDefName());
                if (interface_type.find("work@") == 0) {
                    interface_type = interface_type.substr(5);
                }
                
                // Build parameterized module name
                std::string param_module_name = "$paramod\\" + interface_type;
                
                if (interface->Param_assigns()) {
                    for (auto param_assign : *interface->Param_assigns()) {
                        if (param_assign->Lhs() && param_assign->Rhs()) {
                            std::string param_name;
                            if (auto param = dynamic_cast<const parameter*>(param_assign->Lhs())) {
                                param_name = std::string(param->VpiName());
                            }
                            
                            if (!param_name.empty()) {
                                if (auto const_val = dynamic_cast<const constant*>(param_assign->Rhs())) {
                                    std::string val_str = std::string(const_val->VpiValue());
                                    size_t colon_pos = val_str.find(':');
                                    if (colon_pos != std::string::npos) {
                                        val_str = val_str.substr(colon_pos + 1);
                                    }
                                    int param_value = std::stoi(val_str);
                                    
                                    param_module_name += "\\" + param_name + "=s32'";
                                    for (int i = 31; i >= 0; i--) {
                                        param_module_name += ((param_value >> i) & 1) ? "1" : "0";
                                    }
                                }
                            }
                        }
                    }
                }
                
                // Check if we need to create this interface module
                if (!design->module(RTLIL::escape_id(param_module_name))) {
                    interface_module_names.insert(param_module_name);
                    import_interface(interface);
                }
            }
        }
        
        // Recursively check child modules
        if (mod->Modules()) {
            for (auto child : *mod->Modules()) {
                collect_interfaces(child);
            }
        }
    };
    
    // Collect interfaces from all top modules
    if (uhdm_design->TopModules()) {
        for (auto top_mod : *uhdm_design->TopModules()) {
            collect_interfaces(top_mod);
        }
    }
    
    // First import all module definitions from AllModules if available
    // This ensures we have all the base module definitions before creating instances
    if (uhdm_design->AllModules()) {
        log("UHDM: Found %d module definitions in AllModules\n", (int)uhdm_design->AllModules()->size());
        for (const module_inst* uhdm_mod : *uhdm_design->AllModules()) {
            std::string mod_name = std::string(uhdm_mod->VpiDefName());
            if (mod_name.find("work@") == 0) {
                mod_name = mod_name.substr(5);
            }
            
            // Skip top-level modules as they will be imported from the hierarchy
            // with their generate blocks intact
            if (top_level_module_names.find(mod_name) != top_level_module_names.end()) {
                log("UHDM: Skipping top module %s from AllModules (will import from hierarchy)\n", mod_name.c_str());
                continue;
            }
            
            log("UHDM: Importing module definition: %s\n", uhdm_mod->VpiDefName().data());
            import_module(uhdm_mod);
        }
    }
    
    // Then import from TopModules which contains the elaborated hierarchy with instances
    if (uhdm_design->TopModules()) {
        log("UHDM: Found %d top modules in design\n", (int)uhdm_design->TopModules()->size());
        
        // Recursively import the instantiation tree starting from top modules
        for (const module_inst* top_mod : *uhdm_design->TopModules()) {
            log("UHDM: Importing top module hierarchy starting from: %s\n", 
                !top_mod->VpiName().empty() ? top_mod->VpiName().data() : top_mod->VpiDefName().data());
            import_module_hierarchy(top_mod);
        }
    } else {
        log("UHDM: No top modules found in design\n");
    }
    
    // Post-process to create parameterized modules is no longer needed
    // as we handle parameterization during hierarchy traversal
    
    // Post-process: Mark interface connection wires with is_interface attribute
    log("UHDM: Post-processing to mark interface connection wires\n");
    for (auto module : design->modules()) {
        for (auto cell : module->cells()) {
            // Check if this is an interface cell by looking at the module it references
            RTLIL::Module* cell_module = design->module(cell->type);
            if (cell_module && cell_module->attributes.count(RTLIL::escape_id("is_interface"))) {
                // This is an interface cell
                // Look for any wires that connect to this interface from other cells
                std::string interface_name = cell->name.str();
                if (interface_name[0] == '\\') {
                    interface_name = interface_name.substr(1);
                }
                
                // Look for connection wires with pattern $dummywireforinterface\<interface_name>
                std::string conn_wire_name = "$dummywireforinterface\\" + interface_name;
                RTLIL::Wire* conn_wire = module->wire(RTLIL::escape_id(conn_wire_name));
                if (conn_wire && !conn_wire->attributes.count(RTLIL::escape_id("is_interface"))) {
                    conn_wire->attributes[RTLIL::escape_id("is_interface")] = RTLIL::Const(1);
                    log("UHDM: Marked wire '%s' as interface connection in module %s\n", 
                        conn_wire_name.c_str(), module->name.c_str());
                }
            }
        }
    }
    
    // Expand interfaces - replace interface instances with their signals
    log("UHDM: Starting interface expansion\n");
    expand_interfaces();
    
    log("UHDM: Finished import_design\n");
    log_flush();
    
    // Debug: Log all created wires and memories
    log("UHDM: Final debug - listing all created objects\n");
    log_flush();
    for (auto mod : design->modules()) {
        log("  Module: %s\n", log_id(mod->name));
        log_flush();
        for (auto wire : mod->wires()) {
            log("    Wire: %s (width=%d) [raw name: %s]\n", log_id(wire->name), wire->width, wire->name.c_str());
            log_flush();
        }
        for (auto &mem_pair : mod->memories) {
            log("    Memory: %s (width=%d, size=%d)\n", log_id(mem_pair.first), 
                mem_pair.second->width, mem_pair.second->size);
            log_flush();
        }
        for (auto cell : mod->cells()) {
            log("    Cell: %s (type=%s) [raw name: %s]\n", log_id(cell->name), log_id(cell->type), cell->name.c_str());
            log_flush();
        }
        for (auto &proc_pair : mod->processes) {
            log("    Process: %s\n", log_id(proc_pair.first));
            log_flush();
        }
    }
    log("UHDM: End of debug listing\n");
    log_flush();
}

// Recursively import module hierarchy starting from a module instance
void UhdmImporter::import_module_hierarchy(const module_inst* uhdm_module, bool create_instances) {
    if (!uhdm_module) return;
    
    // Get module name
    std::string module_name = std::string(uhdm_module->VpiDefName());
    if (module_name.find("work@") == 0) {
        module_name = module_name.substr(5);
    }
    
    // Build parameter signature
    std::string param_signature = module_name;
    if (uhdm_module->Param_assigns()) {
        log("UHDM: Found param_assigns for %s\n", module_name.c_str());
        for (auto param_assign : *uhdm_module->Param_assigns()) {
            if (param_assign->Lhs() && param_assign->Rhs()) {
                std::string param_name;
                // Get parameter name from LHS
                if (auto ref = dynamic_cast<const parameter*>(param_assign->Lhs())) {
                    param_name = std::string(ref->VpiName());
                }
                
                if (!param_name.empty()) {
                    param_signature += "$" + param_name + "=";
                    // Get parameter value from RHS
                    if (auto const_val = dynamic_cast<const constant*>(param_assign->Rhs())) {
                        // Get the actual integer value
                        std::string val_str;
                        log("UHDM: Constant type: %d\n", const_val->VpiConstType());
                        log("UHDM: VpiDecompile: '%s'\n", std::string(const_val->VpiDecompile()).c_str());
                        log("UHDM: VpiValue: '%s'\n", const_val->VpiValue().data());
                        
                        if (const_val->VpiConstType() == vpiUIntConst || const_val->VpiConstType() == vpiIntConst) {
                            // Use VpiDecompile which contains the actual value
                            val_str = const_val->VpiDecompile();
                        } else {
                            val_str = std::string(const_val->VpiValue());
                        }
                        
                        // If val_str is empty, try to use import_expression
                        if (val_str.empty()) {
                            log("UHDM: VpiDecompile/VpiValue empty, trying import_expression\n");
                            // Save current module context
                            RTLIL::Module* saved_module = this->module;
                            // Create a temporary module for expression evaluation
                            this->module = design->addModule(NEW_ID);
                            
                            RTLIL::SigSpec val_spec = this->import_expression(any_cast<const expr*>(param_assign->Rhs()));
                            if (val_spec.is_fully_const()) {
                                val_str = std::to_string(val_spec.as_int());
                                log("UHDM: Got value from import_expression: %s\n", val_str.c_str());
                            }
                            
                            // Remove temporary module and restore context
                            design->remove(this->module);
                            this->module = saved_module;
                        }
                        
                        param_signature += val_str;
                        log("UHDM: Added parameter %s=%s to signature\n", param_name.c_str(), val_str.c_str());
                    }
                }
            }
        }
    } else {
        log("UHDM: No param_assigns found for %s\n", module_name.c_str());
    }
    
    // Update param_signature to include interface information if needed
    param_signature = build_interface_module_name(module_name, param_signature, uhdm_module);
    
    // Check if we've already imported this module definition with these parameters
    bool module_already_imported = imported_module_signatures.count(param_signature) > 0;
    
    if (!module_already_imported) {
        // Mark as imported
        imported_module_signatures.insert(param_signature);
        
        // Import the module definition
        log("UHDM: Final param_signature: %s\n", param_signature.c_str());
        log("UHDM: Importing module from hierarchy: %s\n", param_signature.c_str());
        log_flush();
        
        // Save current context before importing child module
        RTLIL::Module* saved_module = module;
        const module_inst* saved_instance = current_instance;
        auto saved_wire_map = wire_map;
        auto saved_name_map = name_map;
        auto saved_net_map = net_map;
        
        // Clear maps before importing new module to avoid cross-module wire references
        wire_map.clear();
        name_map.clear();
        net_map.clear();
        
        import_module(uhdm_module);
        
        // Restore parent context
        module = saved_module;
        current_instance = saved_instance;
        wire_map = saved_wire_map;
        name_map = saved_name_map;
        net_map = saved_net_map;
    } else {
        log("UHDM: Module definition %s already imported, but will still create instance\n", param_signature.c_str());
        
        // Look up the existing module so we can create cells
        // First try the parameterized Yosys format
        std::string yosys_modname = module_name;
        if (!param_signature.empty() && param_signature != module_name) {
            // Extract just the parameter part
            size_t param_start = param_signature.find('$');
            if (param_start != std::string::npos) {
                std::string param_part = param_signature.substr(param_start);
                // Convert to Yosys format: $paramod\module_name\PARAM=value
                yosys_modname = "$paramod\\" + module_name;
                
                // Parse parameters to create proper Yosys format
                size_t pos = 0;
                while ((pos = param_part.find('$', pos)) != std::string::npos) {
                    size_t eq_pos = param_part.find('=', pos);
                    if (eq_pos != std::string::npos) {
                        std::string param_name = param_part.substr(pos + 1, eq_pos - pos - 1);
                        size_t next_dollar = param_part.find('$', eq_pos);
                        std::string param_value = param_part.substr(eq_pos + 1, 
                            (next_dollar != std::string::npos) ? next_dollar - eq_pos - 1 : std::string::npos);
                        
                        // Convert to Yosys format
                        yosys_modname += "\\" + param_name + "=s32'";
                        // Pad value to 32 bits
                        try {
                            int val = std::stoi(param_value);
                            for (int i = 31; i >= 0; i--) {
                                yosys_modname += ((val >> i) & 1) ? "1" : "0";
                            }
                        } catch (const std::invalid_argument& e) {
                            log_error("UHDM: Failed to parse parameter value '%s' as integer\n", param_value.c_str());
                        }
                    }
                    pos = eq_pos;
                    if (pos == std::string::npos) break;
                    pos++;
                }
            }
        }
        
        RTLIL::IdString mod_id = RTLIL::escape_id(yosys_modname);
        module = design->module(mod_id);
        if (!module) {
            // Try the original param_signature
            mod_id = RTLIL::escape_id(param_signature);
            module = design->module(mod_id);
        }
        if (!module) {
            // Try without parameter signature
            mod_id = RTLIL::escape_id(module_name);
            module = design->module(mod_id);
        }
        
        if (module) {
            log("UHDM: Found existing module %s for instance\n", module->name.c_str());
        } else {
            log("UHDM: WARNING: Could not find module for %s (tried %s)\n", param_signature.c_str(), yosys_modname.c_str());
        }
    }
    
    // Recursively import child modules through Modules() which contains elaborated instances
    if (uhdm_module->Modules()) {
        log("UHDM: Found %d child module instances in %s\n", (int)uhdm_module->Modules()->size(), param_signature.c_str());
        int child_index = 0;
        for (auto child : *uhdm_module->Modules()) {
            log("UHDM: Processing child %d: %s (def: %s)\n", child_index++, 
                child->VpiName().data(), child->VpiDefName().data());
            import_module_hierarchy(child);
        }
    } else {
        log("UHDM: No child modules found in %s\n", param_signature.c_str());
    }
    
    // Also need to import the actual instantiations through RefModule
    // This happens after we've imported all the module definitions
    log("UHDM: Checking if we should create cell: module=%p, has_parent=%d, create_instances=%d\n", 
        module, (uhdm_module->VpiParent() != nullptr), create_instances);
    if (create_instances && module && uhdm_module->VpiParent()) {
        // This is a child module instance - we need to create a cell in the parent
        if (auto parent_mod = dynamic_cast<const module_inst*>(uhdm_module->VpiParent())) {
            std::string parent_name = std::string(parent_mod->VpiDefName());
            if (parent_name.find("work@") == 0) {
                parent_name = parent_name.substr(5);
            }
            
            RTLIL::Module* parent_rtlil_module = design->module(RTLIL::escape_id(parent_name));
            if (parent_rtlil_module) {
                // Create the cell in the parent module
                std::string inst_name = std::string(uhdm_module->VpiName());
                
                // Generate parameterized module name
                std::string cell_type = module_name;
                if (!param_signature.empty() && param_signature != module_name) {
                    // Extract just the parameter part
                    size_t param_start = param_signature.find('$');
                    if (param_start != std::string::npos) {
                        std::string param_part = param_signature.substr(param_start);
                        // Convert to Yosys format: $paramod\module_name\PARAM=value
                        cell_type = "$paramod\\" + module_name;
                        
                        // Parse parameters to create proper Yosys format
                        size_t pos = 0;
                        while ((pos = param_part.find('$', pos)) != std::string::npos) {
                            size_t eq_pos = param_part.find('=', pos);
                            if (eq_pos != std::string::npos) {
                                std::string param_name = param_part.substr(pos + 1, eq_pos - pos - 1);
                                size_t next_dollar = param_part.find('$', eq_pos);
                                std::string param_value = param_part.substr(eq_pos + 1, 
                                    (next_dollar != std::string::npos) ? next_dollar - eq_pos - 1 : std::string::npos);
                                
                                // Convert to Yosys format
                                cell_type += "\\" + param_name + "=s32'";
                                // Pad value to 32 bits
                                try {
                                    int val = std::stoi(param_value);
                                    for (int i = 31; i >= 0; i--) {
                                        cell_type += ((val >> i) & 1) ? "1" : "0";
                                    }
                                } catch (const std::invalid_argument& e) {
                                    log_error("UHDM: Failed to parse parameter value '%s' as integer\n", param_value.c_str());
                                }
                            }
                            pos = eq_pos;
                            if (pos == std::string::npos) break;
                            pos++;
                        }
                    }
                }
                
                log("UHDM: Creating cell %s of type %s in parent %s\n", 
                    inst_name.c_str(), cell_type.c_str(), parent_name.c_str());
                
                // Save current module context and maps
                RTLIL::Module* saved_module = this->module;
                auto saved_name_map = this->name_map;
                auto saved_wire_map = this->wire_map;
                
                this->module = parent_rtlil_module;
                
                // Build name_map for parent module
                this->name_map.clear();
                for (auto &wire_pair : parent_rtlil_module->wires_) {
                    std::string wire_name = wire_pair.first.str();
                    if (wire_name[0] == '\\') wire_name = wire_name.substr(1);
                    this->name_map[wire_name] = wire_pair.second;
                }
                
                // Create the cell
                RTLIL::Cell* cell = parent_rtlil_module->addCell(
                    RTLIL::escape_id(inst_name), 
                    RTLIL::escape_id(cell_type)
                );
                
                // Import port connections
                if (uhdm_module->Ports()) {
                    for (auto port : *uhdm_module->Ports()) {
                        std::string port_name = std::string(port->VpiName());
                        if (port->High_conn()) {
                            RTLIL::SigSpec conn = import_expression(any_cast<const expr*>(port->High_conn()));
                            cell->setPort(RTLIL::escape_id(port_name), conn);
                            log("UHDM: Connected port %s\n", port_name.c_str());
                        }
                    }
                }
                
                // Restore module context and maps
                this->module = saved_module;
                this->name_map = saved_name_map;
                this->wire_map = saved_wire_map;
            }
        }
    }
}

// Create parameterized modules based on cell parameters
void UhdmImporter::create_parameterized_modules() {
    std::map<std::string, std::set<int>> module_widths;
    
    // Collect all parameterized cell instances
    for (auto &mod_pair : design->modules_) {
        RTLIL::Module* mod = mod_pair.second;
        for (auto &cell_pair : mod->cells_) {
            RTLIL::Cell* cell = cell_pair.second;
            
            // Check if this cell has a WIDTH parameter
            if (cell->hasParam(RTLIL::escape_id("WIDTH"))) {
                std::string base_module = cell->type.str();
                if (base_module[0] == '\\') base_module = base_module.substr(1);
                
                int width = cell->getParam(RTLIL::escape_id("WIDTH")).as_int();
                module_widths[base_module].insert(width);
                
                if (mode_debug)
                    log("    Found parameterized cell %s/%s: %s with WIDTH=%d\n", 
                        mod->name.c_str(), cell->name.c_str(), base_module.c_str(), width);
            }
        }
    }
    
    // Create parameterized modules for each base module and width combination
    for (auto &entry : module_widths) {
        std::string base_module_name = entry.first;
        std::set<int> widths = entry.second;
        
        RTLIL::Module* base_mod = design->module(RTLIL::escape_id(base_module_name));
        if (!base_mod) {
            log_warning("Base module '%s' not found for parameterization\n", base_module_name.c_str());
            continue;
        }
        
        for (int width : widths) {
            // Generate parameterized module name
            std::string param_value = stringf("s32'%s", RTLIL::Const(width, 32).as_string().c_str());
            std::string param_module_name = stringf("$paramod\\%s\\WIDTH=%s", base_module_name.c_str(), param_value.c_str());
            
            RTLIL::IdString param_mod_id = RTLIL::escape_id(param_module_name);
            if (design->module(param_mod_id)) {
                // Already exists
                continue;
            }
            
            if (mode_debug)
                log("    Creating parameterized module: %s\n", param_module_name.c_str());
            
            RTLIL::Module* param_mod = design->addModule(param_mod_id);
            
            // Copy attributes from base module
            param_mod->attributes = base_mod->attributes;
            param_mod->avail_parameters = base_mod->avail_parameters;
            param_mod->parameter_default_values = base_mod->parameter_default_values;
            
            // Add hdlname attribute with the original module name
            param_mod->attributes[RTLIL::escape_id("hdlname")] = RTLIL::Const(base_module_name);
            param_mod->attributes[RTLIL::escape_id("dynports")] = RTLIL::Const(1);
            
            // Update the WIDTH parameter
            RTLIL::IdString width_param = RTLIL::escape_id("WIDTH");
            param_mod->parameter_default_values[width_param] = RTLIL::Const(width, 32);
            
            // Wire mapping for connection updates
            std::map<RTLIL::Wire*, RTLIL::Wire*> wire_map;
            
            // Copy and resize wires/ports
            for (auto &wire_pair : base_mod->wires_) {
                RTLIL::Wire* base_wire = wire_pair.second;
                RTLIL::Wire* param_wire = param_mod->addWire(base_wire->name, width);
                param_wire->attributes = base_wire->attributes;
                param_wire->port_id = base_wire->port_id;
                param_wire->port_input = base_wire->port_input;
                param_wire->port_output = base_wire->port_output;
                wire_map[base_wire] = param_wire;
            }
            
            // Fixup ports
            param_mod->fixup_ports();
            
            // Copy and update cells
            for (auto &cell_pair : base_mod->cells_) {
                RTLIL::Cell* base_cell = cell_pair.second;
                RTLIL::Cell* param_cell = param_mod->addCell(base_cell->name, base_cell->type);
                param_cell->attributes = base_cell->attributes;
                param_cell->parameters = base_cell->parameters;
                
                // Update width-related parameters
                for (auto &param_pair : param_cell->parameters) {
                    if (param_pair.first.in("\\A_WIDTH", "\\B_WIDTH", "\\Y_WIDTH")) {
                        param_pair.second = RTLIL::Const(width, 32);
                    }
                }
                
                // Copy connections with wire mapping and width expansion
                for (auto &conn_pair : base_cell->connections_) {
                    RTLIL::SigSpec mapped_sig;
                    for (auto &chunk : conn_pair.second.chunks()) {
                        if (chunk.wire) {
                            if (wire_map.count(chunk.wire)) {
                                RTLIL::Wire* mapped_wire = wire_map[chunk.wire];
                                // If the original chunk was the full 1-bit wire and the new wire is wider,
                                // expand to use the full new wire
                                if (chunk.offset == 0 && chunk.width == chunk.wire->width && 
                                    chunk.wire->width == 1 && mapped_wire->width > 1) {
                                    mapped_sig.append(RTLIL::SigChunk(mapped_wire, 0, mapped_wire->width));
                                } else {
                                    mapped_sig.append(RTLIL::SigChunk(mapped_wire, chunk.offset, chunk.width));
                                }
                            } else {
                                log_warning("Wire mapping not found for %s\n", chunk.wire->name.c_str());
                                mapped_sig.append(chunk);
                            }
                        } else {
                            mapped_sig.append(chunk);
                        }
                    }
                    param_cell->setPort(conn_pair.first, mapped_sig);
                }
            }
            
            // Copy connections with wire mapping and width expansion
            for (auto &conn : base_mod->connections_) {
                RTLIL::SigSpec mapped_left, mapped_right;
                
                // Map left side with width expansion
                for (auto &chunk : conn.first.chunks()) {
                    if (chunk.wire && wire_map.count(chunk.wire)) {
                        RTLIL::Wire* mapped_wire = wire_map[chunk.wire];
                        // Expand 1-bit full wire connections to full width
                        if (chunk.offset == 0 && chunk.width == chunk.wire->width && 
                            chunk.wire->width == 1 && mapped_wire->width > 1) {
                            mapped_left.append(RTLIL::SigChunk(mapped_wire, 0, mapped_wire->width));
                        } else {
                            mapped_left.append(RTLIL::SigChunk(mapped_wire, chunk.offset, chunk.width));
                        }
                    } else {
                        mapped_left.append(chunk);
                    }
                }
                
                // Map right side with width expansion
                for (auto &chunk : conn.second.chunks()) {
                    if (chunk.wire && wire_map.count(chunk.wire)) {
                        RTLIL::Wire* mapped_wire = wire_map[chunk.wire];
                        // Expand 1-bit full wire connections to full width
                        if (chunk.offset == 0 && chunk.width == chunk.wire->width && 
                            chunk.wire->width == 1 && mapped_wire->width > 1) {
                            mapped_right.append(RTLIL::SigChunk(mapped_wire, 0, mapped_wire->width));
                        } else {
                            mapped_right.append(RTLIL::SigChunk(mapped_wire, chunk.offset, chunk.width));
                        }
                    } else {
                        mapped_right.append(chunk);
                    }
                }
                
                param_mod->connect(mapped_left, mapped_right);
            }
        }
    }
    
    // Update cell types to reference parameterized modules
    for (auto &mod_pair : design->modules_) {
        RTLIL::Module* mod = mod_pair.second;
        for (auto &cell_pair : mod->cells_) {
            RTLIL::Cell* cell = cell_pair.second;
            
            // Check if this cell has a WIDTH parameter
            if (cell->hasParam(RTLIL::escape_id("WIDTH"))) {
                std::string base_module = cell->type.str();
                if (base_module[0] == '\\') base_module = base_module.substr(1);
                
                int width = cell->getParam(RTLIL::escape_id("WIDTH")).as_int();
                
                // Generate parameterized module name
                std::string param_value = stringf("s32'%s", RTLIL::Const(width, 32).as_string().c_str());
                std::string param_module_name = stringf("$paramod\\%s\\WIDTH=%s", base_module.c_str(), param_value.c_str());
                
                // Update cell type to reference parameterized module
                cell->type = RTLIL::escape_id(param_module_name);
                
                // Remove the WIDTH parameter from the cell (it's now part of the module name)
                cell->parameters.erase(RTLIL::escape_id("WIDTH"));
                
                if (mode_debug)
                    log("    Updated cell %s/%s to use module %s\n", 
                        mod->name.c_str(), cell->name.c_str(), param_module_name.c_str());
            }
        }
    }
}

// Import a single module
void UhdmImporter::import_module(const module_inst* uhdm_module) {
    // Null check
    if (!uhdm_module) {
        log_error("UHDM: import_module called with null module\n");
        return;
    }
    
    // Set current instance context for expression evaluation
    const module_inst* saved_instance = current_instance;
    current_instance = uhdm_module;
    
    // For module instances, we want the definition name, not the instance name
    std::string base_modname;
    if (uhdm_module->VpiDefName().data()) {
        base_modname = std::string(uhdm_module->VpiDefName());
    }
    
    // Debug and validation
    log("UHDM: Processing module, VpiDefName() returns: '%s', VpiName() returns: '%s'\n", 
        base_modname.c_str(), 
        uhdm_module->VpiName().data() ? uhdm_module->VpiName().data() : "<null>");
    
    // Try VpiName if VpiDefName is empty
    if (base_modname.empty()) {
        base_modname = std::string(uhdm_module->VpiName());
        if (!base_modname.empty()) {
            log("UHDM: Using VpiName: '%s'\n", base_modname.c_str());
        } else {
            log_warning("UHDM: Module has empty name, using default name 'unnamed_module'\n");
            base_modname = "unnamed_module";
        }
    }
    
    // Strip work@ prefix if present
    if (base_modname.find("work@") == 0) {
        base_modname = base_modname.substr(5); // Remove "work@"
        log("UHDM: Stripped work@ prefix, using: '%s'\n", base_modname.c_str());
    }
    
    // Build parameterized module name if parameters exist
    std::string modname = base_modname;
    
    // Check if this is a top-level module
    bool is_top_level = top_level_modules.count(base_modname) > 0;
    
    // Use param_assigns which contain the actual parameter values in the instantiation hierarchy
    // BUT: Top-level modules should not have parameters in their names
    // Also, modules from AllModules should be imported as base modules without parameters
    bool is_base_module_def = (uhdm_module->VpiParent() == nullptr || 
                              dynamic_cast<const UHDM::design*>(uhdm_module->VpiParent()) != nullptr);
    
    if (uhdm_module->Param_assigns() && !is_top_level && !is_base_module_def) {
        // Build Yosys-style parameterized module name
        std::string param_string;
        for (auto param_assign : *uhdm_module->Param_assigns()) {
            if (param_assign->Lhs() && param_assign->Rhs()) {
                std::string param_name;
                // Get parameter name from LHS
                if (auto param = dynamic_cast<const parameter*>(param_assign->Lhs())) {
                    param_name = std::string(param->VpiName());
                }
                
                if (!param_name.empty()) {
                    if (auto const_val = dynamic_cast<const constant*>(param_assign->Rhs())) {
                        // Get the actual integer value
                        std::string val_str = std::string(const_val->VpiValue());
                        
                        // Parse value from format like "UINT:8" or "INT:8"
                        size_t colon_pos = val_str.find(':');
                        if (colon_pos != std::string::npos) {
                            val_str = val_str.substr(colon_pos + 1);
                        }
                        
                        if (!val_str.empty()) {
                            // Convert to Yosys format
                            param_string += "\\" + param_name + "=s32'";
                            // Pad value to 32 bits
                            int val = std::stoi(val_str);
                            for (int i = 31; i >= 0; i--) {
                                param_string += ((val >> i) & 1) ? "1" : "0";
                            }
                        }
                    }
                }
            }
        }
        if (!param_string.empty()) {
            modname = "$paramod\\" + base_modname + param_string;
        }
    }
    
    // Update module name to include interface information if needed
    modname = build_interface_module_name(base_modname, modname, uhdm_module);
    
    RTLIL::IdString mod_id = RTLIL::escape_id(modname);
    
    if (mode_debug)
        log("Importing module: %s (ID: %s)\n", modname.c_str(), mod_id.c_str());
    
    // Check if module already exists
    if (design->module(mod_id)) {
        if (mode_debug)
            log("Module %s already exists, skipping\n", modname.c_str());
        return;
    }
    
    module = design->addModule(mod_id);
    
    // Add source attribute to module
    add_src_attribute(module->attributes, uhdm_module);
    
    // Clear maps for this module
    net_map.clear();
    wire_map.clear();
    name_map.clear();
    
    // Import parameters
    if (uhdm_module->Parameters()) {
        log("UHDM: Found %d parameters to import\n", (int)uhdm_module->Parameters()->size());
        for (auto param : *uhdm_module->Parameters()) {
            std::string param_name = std::string(param->VpiName());
            log("UHDM: About to import parameter: '%s'\n", param_name.c_str());
            import_parameter(param);
        }
    }

    // Import parameter overrides (param_assigns)
    if (uhdm_module->Param_assigns()) {
        log("UHDM: Found %d parameter assignments to import\n", (int)uhdm_module->Param_assigns()->size());
        for (auto param_assign : *uhdm_module->Param_assigns()) {
            if (param_assign->Lhs() && param_assign->Rhs()) {
                std::string param_name;
                // Get parameter name from LHS
                if (auto param = dynamic_cast<const parameter*>(param_assign->Lhs())) {
                    param_name = std::string(param->VpiName());
                }
                
                if (!param_name.empty()) {
                    log("UHDM: Processing parameter assignment for '%s'\n", param_name.c_str());
                    
                    // Get the assigned value
                    RTLIL::SigSpec value_spec = import_expression(any_cast<const expr*>(param_assign->Rhs()));
                    if (value_spec.is_fully_const()) {
                        RTLIL::Const param_value = value_spec.as_const();
                        // Override the parameter value
                        RTLIL::IdString param_id = RTLIL::escape_id(param_name);
                        module->avail_parameters(param_id);
                        module->parameter_default_values[param_id] = param_value;
                        log("UHDM: Updated parameter '%s' to value %s\n", 
                            param_name.c_str(), param_value.as_string().c_str());
                    } else {
                        log_warning("UHDM: Parameter assignment for '%s' has non-constant value\n", 
                                   param_name.c_str());
                    }
                }
            }
        }
    }
    
    // Import ports
    if (uhdm_module->Ports()) {
        log("UHDM: Found %d ports to import\n", (int)uhdm_module->Ports()->size());
        for (auto port : *uhdm_module->Ports()) {
            std::string port_name = std::string(port->VpiName());
            any* high_conn = port->High_conn();
            if (high_conn) {
              if (high_conn->UhdmType() == uhdmref_obj) {
                ref_obj* ref = (ref_obj*) high_conn;
                any* actual = ref->Actual_group();
                if (actual) {
                    if (actual->UhdmType() == uhdminterface_inst) {
                        //log("UHDM: Skip importing port as it is an interface: '%s'\n", port_name.c_str());
                        //continue;
                    }
                }
              }
            }
            log("UHDM: About to import port: '%s'\n", port_name.c_str());
            import_port(port);
        }
    }

    // Import module-level variables (logic declarations)
    if (uhdm_module->Variables()) {
        log("UHDM: Found %d variables to import\n", (int)uhdm_module->Variables()->size());
        for (auto var : *uhdm_module->Variables()) {
            // Check if this is an array_var (memory array)
            if (var->UhdmType() == uhdmarray_var) {
                auto array_var = any_cast<const UHDM::array_var*>(var);
                std::string array_name = std::string(array_var->VpiName());
                log("UHDM: Found array_var: '%s'\n", array_name.c_str());
                
                // Check if it should be imported as memory
                if (is_memory_array(array_var)) {
                    log("UHDM: Array_var '%s' detected as memory array\n", array_name.c_str());
                    create_memory_from_array(array_var);
                } else {
                    // Otherwise, handle as a regular array of wires
                    log("UHDM: Array_var '%s' does not have packed dimensions, treating as regular variable\n", array_name.c_str());
                    // For now, just create a single wire with the array name
                    RTLIL::IdString wire_id = RTLIL::escape_id(array_name);
                    if (!module->wire(wire_id)) {
                        RTLIL::Wire* wire = module->addWire(wire_id, 1);
                        wire_map[var] = wire;
                        name_map[array_name] = wire;
                        add_src_attribute(wire->attributes, var);
                        log("UHDM: Created wire '%s' for array_var\n", wire->name.c_str());
                    }
                }
            } else {
                // Regular variable
                std::string var_name = std::string(var->VpiName());
                int width = get_width(var, uhdm_module);
                log("UHDM: Importing variable '%s' (width=%d)\n", var_name.c_str(), width);
                
                // Check if this wire already exists (might have been created as a port)
                RTLIL::IdString wire_id = RTLIL::escape_id(var_name);
                if (!module->wire(wire_id)) {
                    RTLIL::Wire* wire = module->addWire(wire_id, width);
                    wire_map[var] = wire;
                    name_map[var_name] = wire;
                    add_src_attribute(wire->attributes, var);
                    
                    // Add wiretype attribute for struct types
                    if (auto logic_var = dynamic_cast<const UHDM::logic_var*>(var)) {
                        if (auto ref_typespec = logic_var->Typespec()) {
                            if (auto actual_typespec = ref_typespec->Actual_typespec()) {
                                if (actual_typespec->UhdmType() == uhdmstruct_typespec) {
                                    // Get the struct type name
                                    std::string type_name;
                                    if (!ref_typespec->VpiName().empty()) {
                                        type_name = ref_typespec->VpiName();
                                    } else if (!actual_typespec->VpiName().empty()) {
                                        type_name = actual_typespec->VpiName();
                                    }
                                    
                                    if (!type_name.empty()) {
                                        wire->attributes[RTLIL::escape_id("wiretype")] = RTLIL::escape_id(type_name);
                                        log("UHDM: Added wiretype attribute '\\%s' to wire '%s'\n", type_name.c_str(), wire->name.c_str());
                                    }
                                }
                            }
                        }
                    }
                    
                    log("UHDM: Created wire '%s' for variable\n", wire->name.c_str());
                } else {
                    log("UHDM: Variable '%s' already exists as wire, skipping\n", var_name.c_str());
                }
            }
        }
    }
    
    // Import nets
    if (uhdm_module->Nets()) {
        log("UHDM: Found %d nets to import\n", (int)uhdm_module->Nets()->size());
        log_flush();
        int net_index = 0;
        for (auto net : *uhdm_module->Nets()) {
            std::string net_name = std::string(net->VpiName());
            log("UHDM: About to import net %d/%d: '%s'\n", net_index+1, (int)uhdm_module->Nets()->size(), net_name.c_str());
            log_flush();
            import_net(net, uhdm_module);
            net_index++;
        }
        log("UHDM: Finished importing all nets\n");
        log_flush();
    }
    
    log("UHDM: Checking for array nets...\n");
    log_flush();
    
    // Import array nets (memory arrays)
    try {
        if (uhdm_module->Array_nets()) {
            log("UHDM: Array_nets() is not null\n");
            log_flush();
            log("UHDM: Found %d array nets to import\n", (int)uhdm_module->Array_nets()->size());
            log_flush();
        } else {
            log("UHDM: No array nets found (Array_nets() is null)\n");
            log_flush();
        }
    } catch (...) {
        log("UHDM: Exception while checking Array_nets()\n");
        log_flush();
    }
    
    if (uhdm_module->Array_nets()) {
        for (auto array : *uhdm_module->Array_nets()) {
            std::string array_name = std::string(array->VpiName());
            log("UHDM: About to import array net: '%s'\n", array_name.c_str());
            
            // Only create memory if it has both packed and unpacked dimensions
            if (is_memory_array(array)) {
                log("UHDM: Array net '%s' detected as memory array\n", array_name.c_str());
                create_memory_from_array(array);
            } else {
                // Otherwise, handle as a regular array of wires
                log("UHDM: Array net '%s' does not have packed dimensions, skipping memory creation\n", array_name.c_str());
                // TODO: Import as array of individual wires if needed
            }
        }
    }
    
    // Import interface instances
    if (module) {
        log("UHDM: About to import interface instances for module %s\n", log_id(module->name));
        log_flush();
    } else {
        log("UHDM: ERROR - module is null!\n");
        log_flush();
        return;
    }
    import_interface_instances(uhdm_module);
    log("UHDM: Finished importing interface instances\n");
    log_flush();
    
    // Import generate scopes (generate blocks)
    log("UHDM: About to import generate scopes for module %s\n", log_id(module->name));
    log_flush();
    import_generate_scopes(uhdm_module);
    log("UHDM: Finished importing generate scopes\n");
    log_flush();
    
    // Import memory objects using analysis pass
    analyze_and_generate_memories(uhdm_module);
    
    // Import processes (always blocks) - re-enabled with debugging
    log("UHDM: Checking for processes...\n");
    log_flush();
    if (uhdm_module->Process()) {
        log("UHDM: Found %d processes to import\n", (int)uhdm_module->Process()->size());
        log_flush();
        for (auto process : *uhdm_module->Process()) {
            log("UHDM: About to import process\n");
            log_flush();
            try {
                import_process(process);
                log("UHDM: Successfully imported process\n");
                log_flush();
            } catch (const std::exception& e) {
                log_error("UHDM: Exception in process import: %s\n", e.what());
            } catch (...) {
                log_error("UHDM: Unknown exception in process import\n");
            }
        }
    } else {
        log("UHDM: No processes found\n");
        log_flush();
    }
    
    // Import continuous assignments
    if (uhdm_module->Cont_assigns()) {
        log("UHDM: Found %d continuous assignments to import\n", (int)uhdm_module->Cont_assigns()->size());
        for (auto cont_assign : *uhdm_module->Cont_assigns()) {
            log("UHDM: About to import continuous assignment\n");
            try {
                import_continuous_assign(cont_assign);
                log("UHDM: Successfully imported continuous assignment\n");
            } catch (const std::exception& e) {
                log_error("UHDM: Exception in continuous assignment import: %s\n", e.what());
            } catch (...) {
                log_error("UHDM: Unknown exception in continuous assignment import\n");
            }
        }
    }
    
    // Import primitive gates
    import_primitives(uhdm_module);
    
    // Import primitive gate arrays
    import_primitive_arrays(uhdm_module);
    
    // Module instances are imported through the hierarchy traversal
    // (TopModules), not through ref_modules
    
    // Add dynports attribute if module has parameters
    if (!module->avail_parameters.empty()) {
        module->attributes[RTLIL::escape_id("dynports")] = RTLIL::Const(1);
    }
    
    // Add hdlname attribute if this is a parameterized module
    if (modname.find("$paramod\\") == 0) {
        module->attributes[RTLIL::escape_id("hdlname")] = RTLIL::Const(base_modname);
    }
    
    // Add interfaces_replaced_in_module attribute if module has interface ports
    if (module_has_interface_ports(uhdm_module)) {
        module->attributes[RTLIL::escape_id("interfaces_replaced_in_module")] = RTLIL::Const(1);
    }
    
    // Finalize module
    module->fixup_ports();
    
    // Restore saved instance context
    current_instance = saved_instance;
}

// Create a parameterized module based on parameter values in the base module
std::string UhdmImporter::create_parameterized_module(const std::string& base_name, RTLIL::Module* base_module) {
    if (mode_debug)
        log("  Creating parameterized module for base: %s\n", base_name.c_str());
    
    // Build parameter string like Yosys does
    std::string param_string = "";
    for (const auto& [param_name, param_value] : base_module->parameter_default_values) {
        param_string += "\\" + param_name.str().substr(1) + "="; // Remove leading backslash
        
        // Format parameter value (signed 32-bit representation like Yosys)
        if (param_value.flags & RTLIL::CONST_FLAG_SIGNED) {
            param_string += "s";
        }
        param_string += "32'";
        
        // Convert to 32-bit binary representation
        std::string binary_value = "";
        int target_width = 32;
        for (int i = target_width - 1; i >= 0; i--) {
            if (i < param_value.size()) {
                binary_value += (param_value[i] == RTLIL::State::S1) ? "1" : "0";
            } else {
                binary_value += "0"; // Pad with zeros
            }
        }
        param_string += binary_value;
    }
    
    // Generate parameterized module name
    std::string param_module_name;
    if (!param_string.empty()) {
        param_module_name = "$paramod\\" + base_name + param_string;
    } else {
        param_module_name = base_name;
    }
    
    // Create the parameterized module if it doesn't exist
    RTLIL::IdString param_module_id = RTLIL::escape_id(param_module_name);
    if (!design->module(param_module_id)) {
        if (mode_debug)
            log("    Creating new parameterized module: %s\n", param_module_name.c_str());
        
        // Clone the base module
        RTLIL::Module* param_module = design->addModule(param_module_id);
        
        // Copy all the content from base module
        for (auto& [wire_name, wire] : base_module->wires_) {
            RTLIL::Wire* new_wire = param_module->addWire(wire_name, wire->width);
            new_wire->port_input = wire->port_input;
            new_wire->port_output = wire->port_output;
            new_wire->port_id = wire->port_id;
            new_wire->attributes = wire->attributes;
        }
        
        // Copy cells
        for (auto& [cell_name, cell] : base_module->cells_) {
            RTLIL::Cell* new_cell = param_module->addCell(cell_name, cell->type);
            new_cell->parameters = cell->parameters;
            new_cell->attributes = cell->attributes;
            for (auto& [port_name, port_sig] : cell->connections_) {
                new_cell->setPort(port_name, port_sig);
            }
        }
        
        // Copy parameters with current values
        for (const auto& [param_name, param_value] : base_module->parameter_default_values) {
            param_module->avail_parameters(param_name);
            param_module->parameter_default_values[param_name] = param_value;
        }
        
        // Copy attributes
        param_module->attributes = base_module->attributes;
        param_module->attributes[RTLIL::escape_id("hdlname")] = RTLIL::Const(base_name);
        param_module->attributes[RTLIL::escape_id("dynports")] = RTLIL::Const(1);
        
        param_module->fixup_ports();
    }
    
    return param_module_name;
}


// Note: import_port, import_net, and import_continuous_assign are implemented in module.cpp

// Expand interfaces - replace interface instances with their signals
void UhdmImporter::expand_interfaces() {
    log("UHDM: Expanding interfaces in design\n");
    
    // First, collect all interface modules and interface cells
    std::set<RTLIL::Module*> interface_modules;
    std::vector<std::pair<RTLIL::Module*, RTLIL::Cell*>> interface_cells_to_remove;
    
    // Map from dummy wire to interface instance name
    std::map<RTLIL::IdString, std::string> dummy_wire_to_interface;
    
    // Identify interface modules and cells
    for (auto module : design->modules()) {
        if (module->attributes.count(RTLIL::escape_id("is_interface"))) {
            interface_modules.insert(module);
            log("UHDM: Found interface module: %s\n", module->name.c_str());
        }
        
        // Find interface cells in this module
        for (auto cell : module->cells()) {
            RTLIL::Module* cell_module = design->module(cell->type);
            if (cell_module && cell_module->attributes.count(RTLIL::escape_id("is_interface"))) {
                interface_cells_to_remove.push_back(std::make_pair(module, cell));
                log("UHDM: Found interface cell %s of type %s in module %s\n", 
                    cell->name.c_str(), cell->type.c_str(), module->name.c_str());
                
                // Map dummy wires to interface names
                std::string interface_name = cell->name.str();
                if (interface_name[0] == '\\') {
                    interface_name = interface_name.substr(1);
                }
                
                // Look for dummy wires that correspond to this interface
                for (auto wire : module->wires()) {
                    if (wire->name.str().find("$dummywireforinterface\\" + interface_name) == 0) {
                        dummy_wire_to_interface[wire->name] = interface_name;
                        log("UHDM: Mapped dummy wire %s to interface %s\n", 
                            wire->name.c_str(), interface_name.c_str());
                    }
                }
            }
        }
    }
    
    // Process each module to expand interface ports and connections
    for (auto module : design->modules()) {
        // Skip interface modules themselves
        if (interface_modules.count(module)) {
            continue;
        }
        
        log("UHDM: Processing module %s for interface expansion\n", module->name.c_str());
        
        // Find cells with interface ports
        std::vector<RTLIL::Cell*> cells_to_update;
        for (auto cell : module->cells()) {
            // Check if this cell has interface port connections
            bool has_interface_port = false;
            
            // Check the cell's module to see if it has interface ports
            RTLIL::Module* cell_module = design->module(cell->type);
            if (cell_module) {
                for (auto wire : cell_module->wires()) {
                    if (wire->attributes.count(RTLIL::escape_id("is_interface")) && wire->port_id > 0) {
                        has_interface_port = true;
                        break;
                    }
                }
            }
            
            if (has_interface_port) {
                cells_to_update.push_back(cell);
                log("UHDM: Cell %s has interface ports (module %s has interface ports)\n", 
                    cell->name.c_str(), cell->type.c_str());
            }
        }
        
        // Update cells with interface ports
        for (auto cell : cells_to_update) {
            std::map<RTLIL::IdString, RTLIL::SigSpec> new_connections;
            
            // First check what interface signals exist in the cell's module
            RTLIL::Module* cell_module = design->module(cell->type);
            std::set<std::string> cell_interface_signals;
            if (cell_module) {
                for (auto wire : cell_module->wires()) {
                    std::string wire_name = wire->name.str();
                    if (wire_name.find("\\bus.") == 0) {
                        cell_interface_signals.insert(wire_name);
                        log("UHDM: Cell module %s has interface signal %s\n", 
                            cell->type.c_str(), wire_name.c_str());
                    }
                }
            }
            
            for (auto &conn : cell->connections()) {
                RTLIL::IdString port_name = conn.first;
                RTLIL::SigSpec port_sig = conn.second;
                
                // Check if this is an interface port
                RTLIL::Wire* port_wire = nullptr;
                if (port_sig.is_wire()) {
                    port_wire = port_sig.as_wire();
                }
                
                if (port_wire && port_wire->attributes.count(RTLIL::escape_id("is_interface"))) {
                    log("UHDM: Expanding interface port %s on cell %s\n", 
                        port_name.c_str(), cell->name.c_str());
                    
                    // Find which interface this dummy wire corresponds to
                    std::string interface_name;
                    
                    // First check if it's in our dummy wire map
                    if (dummy_wire_to_interface.count(port_wire->name)) {
                        interface_name = dummy_wire_to_interface[port_wire->name];
                        log("UHDM: Found interface %s from dummy wire map\n", interface_name.c_str());
                    } else {
                        // Try to extract from the wire name itself
                        std::string wire_name = port_wire->name.str();
                        if (wire_name.find("$dummywireforinterface\\") == 0) {
                            interface_name = wire_name.substr(23); // Skip "$dummywireforinterface\"
                            log("UHDM: Extracted interface %s from wire name\n", interface_name.c_str());
                        } else {
                            // The wire might have been renamed by Yosys, try to find it by checking connections
                            // Look for any interface signal wires that exist for this cell
                            for (auto wire : module->wires()) {
                                std::string wire_str = wire->name.str();
                                // Check if this is an interface signal wire (contains a dot)
                                size_t dot_pos = wire_str.find('.');
                                if (dot_pos != std::string::npos && dot_pos > 0) {
                                    std::string potential_interface = wire_str.substr(0, dot_pos);
                                    // Check if there's an interface cell with this name
                                    for (auto &pair : interface_cells_to_remove) {
                                        if (pair.first == module) {
                                            std::string cell_interface_name = pair.second->name.str();
                                            if (cell_interface_name[0] == '\\') {
                                                cell_interface_name = cell_interface_name.substr(1);
                                            }
                                            if (cell_interface_name == potential_interface) {
                                                interface_name = potential_interface;
                                                log("UHDM: Found interface %s by searching module wires\n", interface_name.c_str());
                                                break;
                                            }
                                        }
                                    }
                                    if (!interface_name.empty()) break;
                                }
                            }
                        }
                    }
                    
                    if (!interface_name.empty()) {
                        // Find the interface cell to get its type
                        RTLIL::Cell* interface_cell = nullptr;
                        for (auto &pair : interface_cells_to_remove) {
                            if (pair.first == module) {
                                std::string cell_interface_name = pair.second->name.str();
                                if (cell_interface_name[0] == '\\') {
                                    cell_interface_name = cell_interface_name.substr(1);
                                }
                                if (cell_interface_name == interface_name) {
                                    interface_cell = pair.second;
                                    break;
                                }
                            }
                        }
                        
                        if (interface_cell) {
                            // Get the interface module to find its signals
                            RTLIL::Module* interface_module = design->module(interface_cell->type);
                            if (interface_module) {
                                log("UHDM: Interface module %s has the following signals:\n", interface_module->name.c_str());
                                
                                // Get all signals from the interface module
                                for (auto iface_wire : interface_module->wires()) {
                                    std::string signal_name = iface_wire->name.str();
                                    if (signal_name[0] == '\\') {
                                        signal_name = signal_name.substr(1);
                                    }
                                    
                                    // Find the corresponding wire in the parent module
                                    std::string expanded_wire_name = interface_name + "." + signal_name;
                                    RTLIL::Wire* parent_wire = module->wire(RTLIL::escape_id(expanded_wire_name));
                                    
                                    if (parent_wire) {
                                        // Create connection to the expanded signal
                                        RTLIL::IdString expanded_port = RTLIL::escape_id(port_name.str() + "." + signal_name);
                                        new_connections[expanded_port] = parent_wire;
                                        log("UHDM: Connected port %s to wire %s\n", expanded_port.c_str(), parent_wire->name.c_str());
                                    } else {
                                        log_warning("UHDM: Could not find wire %s in parent module\n", expanded_wire_name.c_str());
                                    }
                                }
                            } else {
                                log_warning("UHDM: Could not find interface module %s\n", interface_cell->type.c_str());
                            }
                        } else {
                            log_warning("UHDM: Could not find interface cell for %s\n", interface_name.c_str());
                        }
                    } else {
                        log_warning("UHDM: Could not find interface instance for wire %s\n", port_wire->name.c_str());
                    }
                } else {
                    // Keep non-interface connections as-is
                    new_connections[port_name] = port_sig;
                }
            }
            
            // Update cell connections
            cell->connections_.clear();
            for (auto &conn : new_connections) {
                cell->setPort(conn.first, conn.second);
            }
        }
    }
    
    // Remove interface cells
    for (auto &pair : interface_cells_to_remove) {
        RTLIL::Module* module = pair.first;
        RTLIL::Cell* cell = pair.second;
        log("UHDM: Removing interface cell %s from module %s\n", 
            cell->name.c_str(), module->name.c_str());
        module->remove(cell);
    }
    
    // Remove interface modules
    for (auto iface_module : interface_modules) {
        log("UHDM: Removing interface module %s\n", iface_module->name.c_str());
        design->remove(iface_module);
    }
    
    // Clean up dummy interface wires
    for (auto module : design->modules()) {
        pool<RTLIL::Wire*> wires_to_remove;
        for (auto wire : module->wires()) {
            if (wire->name.str().find("$dummywireforinterface") == 0) {
                wires_to_remove.insert(wire);
            }
        }
        if (!wires_to_remove.empty()) {
            for (auto wire : wires_to_remove) {
                log("UHDM: Removing dummy interface wire %s\n", wire->name.c_str());
            }
            module->remove(wires_to_remove);
        }
    }
    
    // Also expand interface ports in modules that use them
    for (auto module : design->modules()) {
        // Skip interface modules themselves
        if (interface_modules.count(module)) {
            continue;
        }
        
        // Check if this module has interface ports (wires with is_interface attribute)
        std::vector<RTLIL::Wire*> interface_port_wires;
        for (auto wire : module->wires()) {
            if (wire->attributes.count(RTLIL::escape_id("is_interface")) && wire->port_id > 0) {
                interface_port_wires.push_back(wire);
                log("UHDM: Module %s has interface port %s\n", module->name.c_str(), wire->name.c_str());
            }
        }
        
        if (!interface_port_wires.empty()) {
            // This module has interface ports that need to be expanded
            for (auto interface_wire : interface_port_wires) {
                std::string port_name = interface_wire->name.str();
                if (port_name[0] == '\\') {
                    port_name = port_name.substr(1);
                }
                
                // Find all interface signal wires (bus.a, bus.b, bus.c)
                std::vector<RTLIL::Wire*> signal_wires;
                std::string prefix = port_name + ".";
                std::string escaped_prefix = "\\" + port_name + ".";
                
                for (auto wire : module->wires()) {
                    std::string wire_name = wire->name.str();
                    // Check both escaped and unescaped versions
                    if (wire_name.find(prefix) == 0 || wire_name.find(escaped_prefix) == 0) {
                        signal_wires.push_back(wire);
                        log("UHDM: Found interface signal wire %s\n", wire_name.c_str());
                    }
                }
                
                // Convert interface signal wires to ports
                int max_port_id = 0;
                for (auto wire : module->wires()) {
                    if (wire->port_id > max_port_id) {
                        max_port_id = wire->port_id;
                    }
                }
                
                for (auto signal_wire : signal_wires) {
                    // Make it a port
                    signal_wire->port_input = interface_wire->port_input;
                    signal_wire->port_output = interface_wire->port_output;
                    signal_wire->port_id = ++max_port_id;
                    log("UHDM: Converted %s to port (id=%d)\n", signal_wire->name.c_str(), signal_wire->port_id);
                }
                
                // Remove the interface port wire
                interface_wire->port_input = false;
                interface_wire->port_output = false;
                interface_wire->port_id = 0;
                log("UHDM: Removed interface port status from %s\n", interface_wire->name.c_str());
            }
            
            // Remove interface port wires
            pool<RTLIL::Wire*> wires_to_remove;
            for (auto wire : interface_port_wires) {
                wires_to_remove.insert(wire);
            }
            module->remove(wires_to_remove);
            
            // Fix port IDs to be contiguous
            module->fixup_ports();
        }
    }
    
    log("UHDM: Finished expanding interfaces\n");
}

YOSYS_NAMESPACE_END
