/*
 * UHDM to RTLIL Translation Frontend for Yosys
 * 
 * This file implements a comprehensive SystemVerilog frontend that reads
 * UHDM files (generated by Surelog) and converts them to Yosys RTLIL format.
 * 
 * The implementation is structured similarly to the Yosys Verific frontend,
 * with separate modules for different aspects of the translation.
 */

#include "uhdm2rtlil.h"

USING_YOSYS_NAMESPACE

using namespace UHDM;

// Main UHDM frontend pass
struct ReadUHDMPass : public Frontend {
    ReadUHDMPass() : Frontend("=read_uhdm", "read UHDM design") {}

    void help() override {
        log("\n");
        log("    read_uhdm [options] <filename>\n");
        log("\n");
        log("Read a UHDM design file (created by Surelog) into Yosys.\n");
        log("\n");
        log("    -keep_names      keep original signal names\n");
        log("    -debug           enable debug output\n");
        log("    -formal          enable formal verification constructs\n");
        log("\n");
    }

    void execute(std::istream *&f, std::string filename, std::vector<std::string> args, RTLIL::Design *design) override {
        log_header(design, "Executing UHDM frontend.\n");

        bool keep_names = false;
        bool debug = false;
        bool formal = false;
        
        size_t argidx = 1;
        for (; argidx < args.size(); argidx++) {
            if (args[argidx] == "-keep_names") {
                keep_names = true;
                continue;
            }
            if (args[argidx] == "-debug") {
                debug = true;
                continue;
            }
            if (args[argidx] == "-formal") {
                formal = true;
                continue;
            }
            break;
        }

        if (argidx >= args.size())
            log_cmd_error("Usage: read_uhdm [options] <uhdm_file>\n");

        filename = args[argidx];
        log("Reading UHDM file: %s\n", filename.c_str());

        // Load UHDM file
        Serializer serializer;
        std::vector<vpiHandle> handles;
        std::vector<vpiHandle> designs = serializer.Restore(filename);
        vpiHandle vpi_design = designs.at(0);
        UHDM::design* uhdm_design = UhdmDesignFromVpiHandle(vpi_design);

        if (!uhdm_design)
            log_error("Failed to restore UHDM file.\n");

        if (!uhdm_design->AllModules())
            log_error("No modules found in UHDM design.\n");

        // Create importer and import design
        UhdmImporter importer(design, keep_names, debug);
        importer.mode_formal = formal;
        importer.import_design(uhdm_design);
        
        log("Successfully imported %zu modules from UHDM.\n", 
            uhdm_design->AllModules()->size());
    }
} ReadUHDMPass;

// Plugin entry point for Yosys
extern "C" void yosys_plugin_initialize() {
    // Use the standard registration mechanism
    ReadUHDMPass.run_register();
}

extern "C" const char *yosys_plugin_name() {
    return "uhdm2rtlil";
}

extern "C" const char *yosys_plugin_version() {
    return "1.0";
}

YOSYS_NAMESPACE_BEGIN

// UhdmImporter constructor
UhdmImporter::UhdmImporter(RTLIL::Design *design, bool keep_names, bool debug) :
    design(design), module(nullptr), mode_keep_names(keep_names), mode_debug(debug) {
}

// Import entire UHDM design
void UhdmImporter::import_design(UHDM::design* uhdm_design) {
    if (!uhdm_design->AllModules())
        return;
        
    for (const module_inst* uhdm_mod : *uhdm_design->AllModules()) {
        import_module(uhdm_mod);
    }
}

// Import a single module
void UhdmImporter::import_module(const module_inst* uhdm_module) {
    std::string modname = std::string(uhdm_module->VpiName());
    
    // Debug and validation
    log("UHDM: Processing module, VpiName() returns: '%s'\n", modname.c_str());
    
    // Try alternative name fields if VpiName is empty
    if (modname.empty()) {
        // Try VpiDefName for module definition name
        std::string defname = std::string(uhdm_module->VpiDefName());
        if (!defname.empty()) {
            modname = defname;
            log("UHDM: Using VpiDefName: '%s'\n", modname.c_str());
            
            // Strip work@ prefix if present
            if (modname.find("work@") == 0) {
                modname = modname.substr(5); // Remove "work@"
                log("UHDM: Stripped work@ prefix, using: '%s'\n", modname.c_str());
            }
        } else {
            log_warning("UHDM: Module has empty name, using default name 'unnamed_module'\n");
            modname = "unnamed_module";
        }
    }
    
    RTLIL::IdString mod_id = RTLIL::escape_id(modname);
    
    if (mode_debug)
        log("Importing module: %s (ID: %s)\n", modname.c_str(), mod_id.c_str());
    
    module = design->addModule(mod_id);
    
    // Clear maps for this module
    net_map.clear();
    wire_map.clear();
    name_map.clear();
    
    // Import ports
    if (uhdm_module->Ports()) {
        for (auto port : *uhdm_module->Ports()) {
            import_port(port);
        }
    }
    
    // Import nets
    if (uhdm_module->Nets()) {
        for (auto net : *uhdm_module->Nets()) {
            import_net(net);
        }
    }
    
    // Import continuous assignments
    if (uhdm_module->Cont_assigns()) {
        for (auto assign : *uhdm_module->Cont_assigns()) {
            import_continuous_assign(assign);
        }
    }
    
    // Import processes (always blocks)
    if (uhdm_module->Process()) {
        for (auto process : *uhdm_module->Process()) {
            import_process(process);
        }
    }
    
    // Import module instances - TODO: implement when other modules are ready
    
    // Finalize module
    module->fixup_ports();
}

// Note: import_port, import_net, and import_continuous_assign are implemented in module.cpp

YOSYS_NAMESPACE_END
