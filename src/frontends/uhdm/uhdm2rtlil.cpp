/*
 * UHDM to RTLIL Translation Frontend for Yosys
 * 
 * This file implements a comprehensive SystemVerilog frontend that reads
 * UHDM files (generated by Surelog) and converts them to Yosys RTLIL format.
 * 
 * The implementation is structured similarly to the Yosys Verific frontend,
 * with separate modules for different aspects of the translation.
 */

#include "uhdm2rtlil.h"

USING_YOSYS_NAMESPACE

using namespace UHDM;

// Main UHDM frontend pass
struct ReadUHDMPass : public Frontend {
    ReadUHDMPass() : Frontend("=read_uhdm", "read UHDM design") {}

    void help() override {
        log("\n");
        log("    read_uhdm [options] <filename>\n");
        log("\n");
        log("Read a UHDM design file (created by Surelog) into Yosys.\n");
        log("\n");
        log("    -keep_names      keep original signal names\n");
        log("    -debug           enable debug output\n");
        log("    -formal          enable formal verification constructs\n");
        log("\n");
    }

    void execute(std::istream *&f, std::string filename, std::vector<std::string> args, RTLIL::Design *design) override {
        log_header(design, "Executing UHDM frontend.\n");

        bool keep_names = false;
        bool debug = false;
        bool formal = false;
        
        size_t argidx = 1;
        for (; argidx < args.size(); argidx++) {
            if (args[argidx] == "-keep_names") {
                keep_names = true;
                continue;
            }
            if (args[argidx] == "-debug") {
                debug = true;
                continue;
            }
            if (args[argidx] == "-formal") {
                formal = true;
                continue;
            }
            break;
        }

        if (argidx >= args.size())
            log_cmd_error("Usage: read_uhdm [options] <uhdm_file>\n");

        filename = args[argidx];
        log("Reading UHDM file: %s\n", filename.c_str());

        // Load UHDM file
        Serializer serializer;
        std::vector<vpiHandle> handles;
        std::vector<vpiHandle> designs = serializer.Restore(filename);
        vpiHandle vpi_design = designs.at(0);
        UHDM::design* uhdm_design = UhdmDesignFromVpiHandle(vpi_design);

        if (!uhdm_design)
            log_error("Failed to restore UHDM file.\n");

        if (!uhdm_design->AllModules())
            log_error("No modules found in UHDM design.\n");

        // Create importer and import design
        UhdmImporter importer(design, keep_names, debug);
        importer.mode_formal = formal;
        importer.import_design(uhdm_design);
        
        log("Successfully imported %zu modules from UHDM.\n", 
            uhdm_design->AllModules()->size());
    }
} ReadUHDMPass;

// Plugin entry point for Yosys
extern "C" void yosys_plugin_initialize() {
    // Use the standard registration mechanism
    ReadUHDMPass.run_register();
}

extern "C" const char *yosys_plugin_name() {
    return "uhdm2rtlil";
}

extern "C" const char *yosys_plugin_version() {
    return "1.0";
}

YOSYS_NAMESPACE_BEGIN

// UhdmImporter constructor
UhdmImporter::UhdmImporter(RTLIL::Design *design, bool keep_names, bool debug) :
    design(design), module(nullptr), mode_keep_names(keep_names), mode_debug(debug) {
}

// Import entire UHDM design
void UhdmImporter::import_design(UHDM::design* uhdm_design) {
    log("UHDM: Starting import_design\n");
    
    if (!uhdm_design->AllModules()) {
        log("UHDM: No modules found in design\n");
        return;
    }
    
    log("UHDM: Found %d modules in design\n", (int)uhdm_design->AllModules()->size());
        
    for (const module_inst* uhdm_mod : *uhdm_design->AllModules()) {
        log("UHDM: About to import module\n");
        import_module(uhdm_mod);
    }
    log("UHDM: Finished import_design\n");
}

// Import a single module
void UhdmImporter::import_module(const module_inst* uhdm_module) {
    std::string modname = std::string(uhdm_module->VpiName());
    
    // Debug and validation
    log("UHDM: Processing module, VpiName() returns: '%s'\n", modname.c_str());
    
    // Try alternative name fields if VpiName is empty
    if (modname.empty()) {
        // Try VpiDefName for module definition name
        std::string defname = std::string(uhdm_module->VpiDefName());
        if (!defname.empty()) {
            modname = defname;
            log("UHDM: Using VpiDefName: '%s'\n", modname.c_str());
            
            // Strip work@ prefix if present
            if (modname.find("work@") == 0) {
                modname = modname.substr(5); // Remove "work@"
                log("UHDM: Stripped work@ prefix, using: '%s'\n", modname.c_str());
            }
        } else {
            log_warning("UHDM: Module has empty name, using default name 'unnamed_module'\n");
            modname = "unnamed_module";
        }
    }
    
    RTLIL::IdString mod_id = RTLIL::escape_id(modname);
    
    if (mode_debug)
        log("Importing module: %s (ID: %s)\n", modname.c_str(), mod_id.c_str());
    
    module = design->addModule(mod_id);
    
    // Add source attribute to module
    add_src_attribute(module->attributes, uhdm_module);
    
    // Clear maps for this module
    net_map.clear();
    wire_map.clear();
    name_map.clear();
    
    // Import ports
    if (uhdm_module->Ports()) {
        log("UHDM: Found %d ports to import\n", (int)uhdm_module->Ports()->size());
        for (auto port : *uhdm_module->Ports()) {
            std::string port_name = std::string(port->VpiName());
            log("UHDM: About to import port: '%s'\n", port_name.c_str());
            import_port(port);
        }
    }
    
    // Import parameters
    if (uhdm_module->Parameters()) {
        log("UHDM: Found %d parameters to import\n", (int)uhdm_module->Parameters()->size());
        for (auto param : *uhdm_module->Parameters()) {
            std::string param_name = std::string(param->VpiName());
            log("UHDM: About to import parameter: '%s'\n", param_name.c_str());
            import_parameter(param);
        }
    }
    
    // Import parameter overrides (param_assigns)
    if (uhdm_module->Param_assigns()) {
        log("UHDM: Found %d parameter assignments to import\n", (int)uhdm_module->Param_assigns()->size());
        for (auto param_assign : *uhdm_module->Param_assigns()) {
            if (param_assign->Lhs() && param_assign->Rhs()) {
                std::string param_name = std::string(param_assign->Lhs()->VpiName());
                log("UHDM: Processing parameter assignment for '%s'\n", param_name.c_str());
                
                // Get the assigned value
                RTLIL::SigSpec value_spec = import_expression(static_cast<const expr*>(param_assign->Rhs()));
                if (value_spec.is_fully_const()) {
                    RTLIL::Const param_value = value_spec.as_const();
                    // Override the parameter value
                    RTLIL::IdString param_id = RTLIL::escape_id(param_name);
                    module->avail_parameters(param_id);
                    module->parameter_default_values[param_id] = param_value;
                    log("UHDM: Updated parameter '%s' to value %s\n", 
                        param_name.c_str(), param_value.as_string().c_str());
                } else {
                    log_warning("UHDM: Parameter assignment for '%s' has non-constant value\n", 
                               param_name.c_str());
                }
            }
        }
    }
    
    // Import nets
    if (uhdm_module->Nets()) {
        log("UHDM: Found %d nets to import\n", (int)uhdm_module->Nets()->size());
        for (auto net : *uhdm_module->Nets()) {
            std::string net_name = std::string(net->VpiName());
            log("UHDM: About to import net: '%s'\n", net_name.c_str());
            import_net(net);
        }
    }
    
    // Import memory objects using analysis pass
    analyze_and_generate_memories(uhdm_module);
    
    // Import continuous assignments
    if (uhdm_module->Cont_assigns()) {
        for (auto assign : *uhdm_module->Cont_assigns()) {
            import_continuous_assign(assign);
        }
    }
    
    // Import processes (always blocks) - re-enabled with debugging
    if (uhdm_module->Process()) {
        log("UHDM: Found %d processes to import\n", (int)uhdm_module->Process()->size());
        for (auto process : *uhdm_module->Process()) {
            log("UHDM: About to import process\n");
            try {
                import_process(process);
                log("UHDM: Successfully imported process\n");
            } catch (const std::exception& e) {
                log_error("UHDM: Exception in process import: %s\n", e.what());
            } catch (...) {
                log_error("UHDM: Unknown exception in process import\n");
            }
        }
    }
    
    // Import module instances - TODO: implement when other modules are ready
    
    // Finalize module
    module->fixup_ports();
}

// Note: import_port, import_net, and import_continuous_assign are implemented in module.cpp

YOSYS_NAMESPACE_END
