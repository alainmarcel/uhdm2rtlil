
// Generated from SV3_1aParser.g4 by ANTLR 4.13.2


#include "SV3_1aParserListener.h"

#include "SV3_1aParser.h"


using namespace antlrcpp;
using namespace SURELOG;

using namespace antlr4;

namespace {

struct SV3_1aParserStaticData final {
  SV3_1aParserStaticData(std::vector<std::string> ruleNames,
                        std::vector<std::string> literalNames,
                        std::vector<std::string> symbolicNames)
      : ruleNames(std::move(ruleNames)), literalNames(std::move(literalNames)),
        symbolicNames(std::move(symbolicNames)),
        vocabulary(this->literalNames, this->symbolicNames) {}

  SV3_1aParserStaticData(const SV3_1aParserStaticData&) = delete;
  SV3_1aParserStaticData(SV3_1aParserStaticData&&) = delete;
  SV3_1aParserStaticData& operator=(const SV3_1aParserStaticData&) = delete;
  SV3_1aParserStaticData& operator=(SV3_1aParserStaticData&&) = delete;

  std::vector<antlr4::dfa::DFA> decisionToDFA;
  antlr4::atn::PredictionContextCache sharedContextCache;
  const std::vector<std::string> ruleNames;
  const std::vector<std::string> literalNames;
  const std::vector<std::string> symbolicNames;
  const antlr4::dfa::Vocabulary vocabulary;
  antlr4::atn::SerializedATNView serializedATN;
  std::unique_ptr<antlr4::atn::ATN> atn;
};

::antlr4::internal::OnceFlag sv3_1aparserParserOnceFlag;
#if ANTLR4_USE_THREAD_LOCAL_CACHE
static thread_local
#endif
std::unique_ptr<SV3_1aParserStaticData> sv3_1aparserParserStaticData = nullptr;

void sv3_1aparserParserInitialize() {
#if ANTLR4_USE_THREAD_LOCAL_CACHE
  if (sv3_1aparserParserStaticData != nullptr) {
    return;
  }
#else
  assert(sv3_1aparserParserStaticData == nullptr);
#endif
  auto staticData = std::make_unique<SV3_1aParserStaticData>(
    std::vector<std::string>{
      "top_level_rule", "top_level_library_rule", "library_text", "library_descriptions", 
      "library_declaration", "file_path_spec", "include_statement", "source_text", 
      "null_rule", "description", "module_nonansi_header", "module_ansi_header", 
      "module_declaration", "module_keyword", "interface_nonansi_header", 
      "interface_ansi_header", "interface_declaration", "program_nonansi_header", 
      "program_ansi_header", "checker_declaration", "program_declaration", 
      "class_declaration", "interface_class_type", "interface_class_declaration", 
      "interface_class_item", "interface_class_method", "package_declaration", 
      "timeunits_declaration", "parameter_port_list", "parameter_port_declaration", 
      "list_of_ports", "list_of_port_declarations", "port_declaration", 
      "port", "port_expression", "port_reference", "port_direction", "net_port_header", 
      "variable_port_header", "interface_port_header", "ansi_port_declaration", 
      "elaboration_system_task", "module_common_item", "module_item", "module_or_generate_item", 
      "module_or_generate_item_declaration", "non_port_module_item", "parameter_override", 
      "bind_directive", "bind_instantiation", "interface_or_generate_item", 
      "extern_tf_declaration", "interface_item", "non_port_interface_item", 
      "program_item", "non_port_program_item", "program_generate_item", 
      "checker_port_list", "checker_port_item", "checker_or_generate_item", 
      "checker_or_generate_item_declaration", "checker_generate_item", "class_item", 
      "class_property", "pure_virtual_qualifier", "extern_qualifier", "class_method", 
      "class_constructor_prototype", "class_constraint", "class_item_qualifier", 
      "property_qualifier", "method_qualifier", "method_prototype", "super_dot_new", 
      "class_constructor_declaration", "constraint_declaration", "constraint_block", 
      "constraint_block_item", "solve_before_list", "constraint_primary", 
      "constraint_expression", "uniqueness_constraint", "constraint_set", 
      "dist_list", "dist_item", "dist_weight", "constraint_prototype", "extern_constraint_declaration", 
      "identifier_list", "package_item", "package_or_generate_item_declaration", 
      "anonymous_program", "anonymous_program_item", "local_parameter_declaration", 
      "parameter_declaration", "specparam_declaration", "inout_declaration", 
      "input_declaration", "output_declaration", "interface_port_declaration", 
      "ref_declaration", "data_declaration", "variable_impl_declaration", 
      "variable_declaration", "package_import_declaration", "package_import_item", 
      "package_export_declaration", "genvar_declaration", "net_declaration", 
      "type_declaration", "enum_keyword", "struct_keyword", "union_keyword", 
      "class_keyword", "interface_class_keyword", "net_type_declaration", 
      "lifetime", "casting_type", "data_type", "packed_keyword", "string_type", 
      "string_value", "chandle_type", "event_type", "const_type", "var_type", 
      "data_type_or_implicit", "implicit_data_type", "enum_base_type", "enum_name_declaration", 
      "class_scope", "class_type", "integer_type", "integer_atom_type", 
      "integer_vector_type", "non_integer_type", "net_type", "net_port_type", 
      "variable_port_type", "var_data_type", "signing", "simple_type", "random_qualifier", 
      "struct_union_member", "data_type_or_void", "struct_union", "tagged_keyword", 
      "type_reference", "drive_strength", "strength0", "strength1", "charge_strength", 
      "delay3", "delay2", "pound_delay_value", "delay_value", "list_of_defparam_assignments", 
      "list_of_interface_identifiers", "list_of_net_decl_assignments", "list_of_param_assignments", 
      "list_of_port_identifiers", "list_of_specparam_assignments", "list_of_tf_variable_identifiers", 
      "list_of_type_assignments", "list_of_variable_decl_assignments", "list_of_variable_identifiers", 
      "list_of_variable_port_identifiers", "list_of_virtual_interface_decl", 
      "defparam_assignment", "net_decl_assignment", "param_assignment", 
      "specparam_assignment", "pulse_control_specparam", "variable_decl_assignment", 
      "class_new", "dynamic_array_new", "unpacked_dimension", "packed_dimension", 
      "associative_dimension", "variable_dimension", "queue_dimension", 
      "unsized_dimension", "function_data_type", "function_data_type_or_implicit", 
      "function_declaration", "function_body_declaration", "function_prototype", 
      "dpi_import_export", "context_keyword", "function_name_decl", "task_name_decl", 
      "pure_keyword", "task_declaration", "task_body_declaration", "tf_item_declaration", 
      "tf_port_list", "tf_port_item", "tf_port_direction", "tf_port_declaration", 
      "task_prototype", "block_item_declaration", "overload_declaration", 
      "overload_operator", "overload_proto_formals", "virtual_interface_declaration", 
      "modport_item", "modport_ports_declaration", "modport_simple_ports_declaration", 
      "modport_simple_port", "modport_hierarchical_ports_declaration", "modport_tf_ports_declaration", 
      "modport_tf_port", "concurrent_assertion_item", "concurrent_assertion_statement", 
      "assert_property_statement", "assume_property_statement", "cover_property_statement", 
      "expect_property_statement", "cover_sequence_statement", "restrict_property_statement", 
      "property_instance", "property_actual_arg", "concurrent_assertion_item_declaration", 
      "assertion_item_declaration", "property_declaration", "property_port_list", 
      "property_port_item", "property_lvar_port_direction", "property_formal_type", 
      "property_spec", "property_expr", "property_case_item", "sequence_declaration", 
      "sequence_expr", "cycle_delay_range", "sequence_method_call", "sequence_match_item", 
      "sequence_port_list", "sequence_port_item", "sequence_lvar_port_direction", 
      "sequence_formal_type", "sequence_instance", "sequence_arg", "sequence_list_of_arguments", 
      "sequence_actual_arg", "actual_arg_list", "actual_arg_expr", "boolean_abbrev", 
      "consecutive_repetition", "non_consecutive_repetition", "goto_repetition", 
      "const_or_range_expression", "cycle_delay_const_range_expression", 
      "expression_or_dist", "assertion_variable_declaration", "let_declaration", 
      "let_port_list", "let_port_item", "let_formal_type", "covergroup_declaration", 
      "coverage_spec_or_option", "coverage_option", "coverage_spec", "coverage_event", 
      "block_event_expression", "hierarchical_btf_identifier", "cover_point", 
      "bins_or_empty", "bins_or_options", "bins_keyword", "range_list", 
      "trans_list", "trans_set", "trans_range_list", "repeat_range", "cover_cross", 
      "list_of_cross_items", "cross_item", "cross_body", "cross_body_item", 
      "bins_selection_or_option", "bins_selection", "select_expression", 
      "select_condition", "bins_expression", "open_range_list", "gate_instantiation", 
      "cmos_switch_instance", "enable_gate_instance", "mos_switch_instance", 
      "n_input_gate_instance", "n_output_gate_instance", "pass_switch_instance", 
      "pass_enable_switch_instance", "pull_gate_instance", "pulldown_strength", 
      "pullup_strength", "cmos_switchtype", "enable_gatetype", "mos_switchtype", 
      "n_input_gatetype", "n_output_gatetype", "pass_en_switchtype", "pass_switchtype", 
      "module_instantiation", "parameter_value_assignment", "list_of_parameter_assignments", 
      "ordered_parameter_assignment", "named_parameter_assignment", "hierarchical_instance", 
      "name_of_instance", "list_of_port_connections", "ordered_port_connection", 
      "named_port_connection", "checker_instantiation", "list_of_checker_port_connections", 
      "ordered_checker_port_connection", "named_checker_port_connection", 
      "generated_module_instantiation", "generate_module_item", "generate_module_conditional_statement", 
      "generate_module_case_statement", "genvar_module_case_item", "generate_module_loop_statement", 
      "genvar_assignment", "genvar_decl_assignment", "generate_module_named_block", 
      "generate_module_block", "generated_interface_instantiation", "generate_interface_item", 
      "generate_interface_conditional_statement", "generate_interface_case_statement", 
      "genvar_interface_case_item", "generate_interface_loop_statement", 
      "generate_interface_named_block", "generate_interface_block", "generate_region", 
      "loop_generate_construct", "genvar_initialization", "genvar_iteration", 
      "conditional_generate_construct", "if_generate_construct", "case_generate_construct", 
      "case_generate_item", "generate_begin_end_block", "generate_item", 
      "udp_nonansi_declaration", "udp_ansi_declaration", "udp_declaration", 
      "udp_port_list", "udp_declaration_port_list", "udp_port_declaration", 
      "udp_output_declaration", "udp_input_declaration", "udp_reg_declaration", 
      "udp_body", "combinational_body", "combinational_entry", "sequential_body", 
      "udp_initial_statement", "init_val", "sequential_entry", "seq_input_list", 
      "level_input_list", "edge_input_list", "edge_indicator", "next_state", 
      "output_symbol", "level_symbol", "edge_symbol", "udp_instantiation", 
      "udp_instance", "continuous_assign", "list_of_net_assignments", "list_of_variable_assignments", 
      "net_alias", "net_assignment", "initial_construct", "always_construct", 
      "always_keyword", "blocking_assignment", "operator_assignment", "assignment_operator", 
      "nonblocking_assignment", "procedural_continuous_assignment", "variable_assignment", 
      "action_block", "seq_block", "par_block", "join_keyword", "join_any_keyword", 
      "join_none_keyword", "statement_or_null", "statement", "statement_item", 
      "function_statement_or_null", "procedural_timing_control_statement", 
      "delay_or_event_control", "delay_control", "event_control", "event_expression", 
      "or_operator", "comma_operator", "procedural_timing_control", "jump_statement", 
      "final_construct", "wait_statement", "event_trigger", "disable_statement", 
      "conditional_statement", "unique_priority", "cond_predicate", "expression_or_cond_pattern", 
      "matches", "case_statement", "case_keyword", "case_item", "case_pattern_item", 
      "case_inside_item", "randcase_statement", "randcase_item", "pattern", 
      "assignment_pattern", "structure_pattern_key", "array_pattern_key", 
      "assignment_pattern_key", "assignment_pattern_expression", "assignment_pattern_expression_type", 
      "constant_assignment_pattern_expression", "assignment_pattern_net_lvalue", 
      "assignment_pattern_variable_lvalue", "loop_statement", "for_initialization", 
      "for_variable_declaration", "for_step", "for_step_assignment", "comma", 
      "loop_variables", "subroutine_call_statement", "assertion_item", "deferred_immediate_assertion_item", 
      "procedural_assertion_statement", "immediate_assertion_statement", 
      "simple_immediate_assertion_statement", "simple_immediate_assert_statement", 
      "simple_immediate_assume_statement", "simple_immediate_cover_statement", 
      "deferred_immediate_assertion_statement", "deferred_immediate_assert_statement", 
      "deferred_immediate_assume_statement", "deferred_immediate_cover_statement", 
      "clocking_declaration", "clocking_event", "clocking_item", "default_skew", 
      "clocking_direction", "list_of_clocking_decl_assign", "clocking_decl_assign", 
      "clocking_skew", "edge_identifier", "clocking_drive", "cycle_delay", 
      "clockvar", "clockvar_expression", "randsequence_statement", "production", 
      "rs_rule", "rs_production_list", "rs_code_block", "rs_prod", "production_item", 
      "rs_if_else", "rs_repeat", "rs_case", "rs_case_item", "specify_block", 
      "specify_item", "pulsestyle_declaration", "showcancelled_declaration", 
      "path_declaration", "simple_path_declaration", "parallel_path_description", 
      "full_path_description", "list_of_path_inputs", "list_of_path_outputs", 
      "specify_input_terminal_descriptor", "specify_output_terminal_descriptor", 
      "path_delay_value", "list_of_path_delay_expressions", "t_path_delay_expression", 
      "trise_path_delay_expression", "tfall_path_delay_expression", "tz_path_delay_expression", 
      "t01_path_delay_expression", "t10_path_delay_expression", "t0z_path_delay_expression", 
      "tz1_path_delay_expression", "t1z_path_delay_expression", "tz0_path_delay_expression", 
      "t0x_path_delay_expression", "tx1_path_delay_expression", "t1x_path_delay_expression", 
      "tx0_path_delay_expression", "txz_path_delay_expression", "tzx_path_delay_expression", 
      "path_delay_expression", "edge_sensitive_path_declaration", "parallel_edge_sensitive_path_description", 
      "full_edge_sensitive_path_description", "state_dependent_path_declaration", 
      "system_timing_check", "dollar_setup_timing_check", "dollar_hold_timing_check", 
      "dollar_setuphold_timing_check", "dollar_recovery_timing_check", "dollar_removal_timing_check", 
      "dollar_recrem_timing_check", "dollar_skew_timing_check", "dollar_timeskew_timing_check", 
      "dollar_fullskew_timing_check", "dollar_period_timing_check", "dollar_width_timing_check", 
      "dollar_nochange_timing_check", "delayed_data", "delayed_reference", 
      "end_edge_offset", "event_based_flag", "notifier", "reference_event", 
      "remain_active_flag", "stamptime_condition", "start_edge_offset", 
      "threshold", "timing_check_limit", "timing_check_event", "controlled_timing_check_event", 
      "timing_check_event_control", "specify_terminal_descriptor", "edge_control_specifier", 
      "edge_descriptor", "timing_check_condition", "scalar_timing_check_condition", 
      "scalar_constant", "concatenation", "constant_concatenation", "array_member_label", 
      "constant_multiple_concatenation", "module_path_concatenation", "module_path_multiple_concatenation", 
      "multiple_concatenation", "streaming_concatenation", "stream_operator", 
      "slice_size", "stream_concatenation", "stream_expression", "array_range_expression", 
      "empty_queue", "subroutine_call", "argument", "list_of_arguments", 
      "method_call", "method_call_body", "built_in_method_call", "array_manipulation_call", 
      "randomize_call", "method_call_root", "array_method_name", "unique_call", 
      "and_call", "or_call", "xor_call", "inc_or_dec_expression", "constant_expression", 
      "conditional_operator", "constant_mintypmax_expression", "constant_param_expression", 
      "param_expression", "constant_range_expression", "constant_part_select_range", 
      "constant_range", "constant_indexed_range", "expression", "value_range", 
      "mintypmax_expression", "module_path_expression", "module_path_mintypmax_expression", 
      "range_expression", "part_select_range", "part_select_op", "part_select_op_colon", 
      "indexed_range", "constant_primary", "module_path_primary", "complex_func_call", 
      "primary", "this_keyword", "super_keyword", "dollar_keyword", "dollar_root_keyword", 
      "this_dot_super", "null_keyword", "time_literal", "time_unit", "implicit_class_handle", 
      "bit_select", "select", "nonrange_select", "constant_bit_select", 
      "constant_select", "primary_literal", "constant_cast", "cast", "net_lvalue", 
      "variable_lvalue", "nonrange_variable_lvalue", "inc_or_dec_operator", 
      "unary_module_path_operator", "binary_module_path_operator", "number", 
      "unbased_unsized_literal", "attribute_instance", "attr_spec", "attr_name", 
      "hierarchical_identifier", "identifier", "interface_identifier", "package_scope", 
      "ps_identifier", "ps_or_hierarchical_identifier", "ps_or_hierarchical_array_identifier", 
      "ps_or_hierarchical_sequence_identifier", "ps_type_identifier", "system_task", 
      "system_task_names", "top_directives", "pragma_directive", "pragma_expression", 
      "pragma_value", "timescale_directive", "begin_keywords_directive", 
      "end_keywords_directive", "unconnected_drive_directive", "nounconnected_drive_directive", 
      "default_nettype_directive", "uselib_directive", "celldefine_directive", 
      "endcelldefine_directive", "protect_directive", "endprotect_directive", 
      "protected_directive", "endprotected_directive", "expand_vectornets_directive", 
      "noexpand_vectornets_directive", "autoexpand_vectornets_directive", 
      "disable_portfaults_directive", "enable_portfaults_directive", "nosuppress_faults_directive", 
      "suppress_faults_directive", "signed_directive", "unsigned_directive", 
      "remove_gatename_directive", "noremove_gatenames_directive", "remove_netname_directive", 
      "noremove_netnames_directive", "accelerate_directive", "noaccelerate_directive", 
      "default_trireg_strenght_directive", "default_decay_time_directive", 
      "delay_mode_distributed_directive", "delay_mode_path_directive", "delay_mode_unit_directive", 
      "delay_mode_zero_directive", "surelog_macro_not_defined", "slline", 
      "config_declaration", "design_statement", "config_rule_statement", 
      "default_clause", "inst_clause", "inst_name", "cell_clause", "liblist_clause", 
      "use_clause_config", "use_clause"
    },
    std::vector<std::string>{
      "", "'\\u003F'", "''b0'", "''b1'", "''B0'", "''B1'", "''0'", "''1'", 
      "'1'b0'", "'1'b1'", "'1'bx'", "'1'bX'", "'1'B0'", "'1'B1'", "'1'Bx'", 
      "'1'BX'", "", "", "", "", "", "", "", "", "", "", "", "'include'", 
      "'library'", "'-incdir'", "','", "';'", "'::'", "':'", "'design'", 
      "'.'", "'default'", "'instance'", "'cell'", "'liblist'", "'use'", 
      "'module'", "'endmodule'", "'('", "')'", "'*'", "'extern'", "'macromodule'", 
      "'interface'", "'endinterface'", "'program'", "'endprogram'", "'virtual'", 
      "'class'", "'endclass'", "'extends'", "'package'", "'endpackage'", 
      "'timeunit'", "'timeprecision'", "'checker'", "'endchecker'", "'config'", 
      "'endconfig'", "'type'", "'untyped'", "'input'", "'output'", "'inout'", 
      "'ref'", "'clocking'", "'defparam'", "'bind'", "'forkjoin'", "'const'", 
      "'function'", "'new'", "'static'", "'protected'", "'local'", "'rand'", 
      "'randc'", "'super'", "'endfunction'", "'constraint'", "'{'", "'}'", 
      "'solve'", "'before'", "'->'", "'if'", "'else'", "'foreach'", "':='", 
      "'automatic'", "'localparam'", "'parameter'", "'specparam'", "'import'", 
      "'genvar'", "'vectored'", "'scalared'", "'typedef'", "'enum'", "'struct'", 
      "'union'", "'packed'", "'string'", "'chandle'", "'event'", "'['", 
      "']'", "'byte'", "'shortint'", "'int'", "'longint'", "'integer'", 
      "'time'", "'bit'", "'logic'", "'reg'", "'shortreal'", "'real'", "'realtime'", 
      "'nexttime'", "'s_nexttime'", "'s_always'", "'until_with'", "'s_until_with'", 
      "'accept_on'", "'reject_on'", "'sync_accept_on'", "'sync_reject_on'", 
      "'eventually'", "'s_eventually'", "'supply0'", "'supply1'", "'tri'", 
      "'triand'", "'trior'", "'tri0'", "'tri1'", "'wire'", "'uwire'", "'wand'", 
      "'wor'", "'trireg'", "'signed'", "'unsigned'", "'interconnect'", "'var'", 
      "'void'", "'highz0'", "'highz1'", "'strong'", "'weak'", "'strong0'", 
      "'pull0'", "'weak0'", "'strong1'", "'pull1'", "'weak1'", "'(small)'", 
      "'(medium)'", "'(large)'", "'PATHPULSE'", "'$'", "'export'", "'context'", 
      "'pure'", "'implements'", "'endtask'", "'++'", "'+'", "'--'", "'-'", 
      "'*::*'", "'**'", "'/'", "'%'", "'=='", "'!='", "'<'", "'<='", "'>'", 
      "'<->'", "'>='", "'modport'", "", "'(*'", "'*)'", "'assert'", "'property'", 
      "'assume'", "'cover'", "'expect'", "'endproperty'", "'disable'", "'iff'", 
      "'|->'", "'|=>'", "'not'", "'or'", "'and'", "'sequence'", "'endsequence'", 
      "'intersect'", "'first_match'", "'throughout'", "'within'", "'##'", 
      "'#-#'", "'#=#'", "'#'", "'[*'", "'[='", "'[->'", "'dist'", "'covergroup'", 
      "'endgroup'", "", "", "'@@'", "'begin'", "'end'", "'wildcard'", "'bins'", 
      "'illegal_bins'", "'ignore_bins'", "'=>'", "'!'", "'soft'", "'until'", 
      "'s_until'", "'implies'", "'&&'", "'||'", "'binsof'", "'pulldown'", 
      "'pullup'", "'cmos'", "'rcmos'", "'bufif0'", "'bufif1'", "'notif0'", 
      "'notif1'", "'nmos'", "'pmos'", "'rnmos'", "'rpmos'", "'nand'", "'nor'", 
      "'xor'", "'xnor'", "'buf'", "'tranif0'", "'tranif1'", "'rtranif1'", 
      "'rtranif0'", "'tran'", "'rtran'", "'.*'", "'generate'", "'endgenerate'", 
      "'case'", "'endcase'", "'for'", "'global'", "'primitive'", "'endprimitive'", 
      "'table'", "'endtable'", "'initial'", "'assign'", "'alias'", "'always'", 
      "'always_comb'", "'always_latch'", "'always_ff'", "'+='", "'-='", 
      "'*='", "'/='", "'%='", "'&='", "'|='", "'^='", "'<<='", "'>>='", 
      "'deassign'", "'force'", "'release'", "'fork'", "'join'", "'join_any'", 
      "'join_none'", "'repeat'", "'@'", "'return'", "'break'", "'continue'", 
      "'wait'", "'wait_order'", "'unique'", "'unique0'", "'priority'", "'matches'", 
      "'casez'", "'casex'", "'randcase'", "'tagged'", "'forever'", "'while'", 
      "'do'", "'restrict'", "'let'", "'''", "'endclocking'", "'randsequence'", 
      "'>>'", "'<<'", "'with'", "'+:'", "'-:'", "'inside'", "'null'", "'this'", 
      "", "'randomize'", "'final'", "'task'", "'coverpoint'", "'cross'", 
      "'posedge'", "'negedge'", "'specify'", "'endspecify'", "'pulsestyle_onevent'", 
      "'pulsestyle_ondetect'", "'showcancelled'", "'noshowcancelled'", "'ifnone'", 
      "'sample'", "'edge'", "'->>'", "'>>>'", "'<<<'", "'<<<='", "'>>>='", 
      "'==='", "'!=='", "'==\\u003F'", "'!=\\u003F'", "'*>'", "'&&&'", "'&'", 
      "'|'", "'~|'", "'~&'", "'^~'", "'=\\u003F='", "'!\\u003F='", "'='", 
      "'nettype'", "", "'~'", "'^'", "'~^'", "", "'`line'", "'`timescale'", 
      "'`begin_keywords'", "'`end_keywords'", "'`unconnected_drive'", "'`nounconnected_drive'", 
      "'`celldefine'", "'`endcelldefine'", "'`default_nettype'", "'`default_decay_time'", 
      "'`default_trireg_strength'", "'`delay_mode_distributed'", "'`delay_mode_path'", 
      "'`delay_mode_unit'", "'`delay_mode_zero'", "'`accelerate'", "'`noaccelerate'", 
      "'`protect'", "'`disable_portfaults'", "'`enable_portfaults'", "'`nosuppress_faults'", 
      "'`suppress_faults'", "'`signed'", "'`unsigned'", "'`endprotect'", 
      "'`protected'", "'`endprotected'", "'`expand_vectornets'", "'`noexpand_vectornets'", 
      "'`autoexpand_vectornets'", "'`remove_gatename'", "'`noremove_gatenames'", 
      "'`remove_netname'", "'`noremove_netnames'", "'1step'", "'`uselib'", 
      "'`pragma'", "'`'"
    },
    std::vector<std::string>{
      "", "QMARK", "TICK_b0", "TICK_b1", "TICK_B0", "TICK_B1", "TICK_0", 
      "TICK_1", "ONE_TICK_b0", "ONE_TICK_b1", "ONE_TICK_bx", "ONE_TICK_bX", 
      "ONE_TICK_B0", "ONE_TICK_B1", "ONE_TICK_Bx", "ONE_TICK_BX", "Pound_Pound_delay", 
      "Pound_delay", "Integral_number", "Real_number", "String", "One_line_comment", 
      "Block_comment", "ASSOCIATIVE_UNSPECIFIED", "ATSTAR", "AT_PARENS_STAR", 
      "White_space", "INCLUDE", "LIBRARY", "INCDIR", "COMMA", "SEMICOLON", 
      "COLONCOLON", "COLON", "DESIGN", "DOT", "DEFAULT", "INSTANCE", "CELL", 
      "LIBLIST", "USE", "MODULE", "ENDMODULE", "OPEN_PARENS", "CLOSE_PARENS", 
      "STAR", "EXTERN", "MACROMODULE", "INTERFACE", "ENDINTERFACE", "PROGRAM", 
      "ENDPROGRAM", "VIRTUAL", "CLASS", "ENDCLASS", "EXTENDS", "PACKAGE", 
      "ENDPACKAGE", "TIMEUNIT", "TIMEPRECISION", "CHECKER", "ENDCHECKER", 
      "CONFIG", "ENDCONFIG", "TYPE", "UNTYPED", "INPUT", "OUTPUT", "INOUT", 
      "REF", "CLOCKING", "DEFPARAM", "BIND", "FORKJOIN", "CONST", "FUNCTION", 
      "NEW", "STATIC", "PROTECTED", "LOCAL", "RAND", "RANDC", "SUPER", "ENDFUNCTION", 
      "CONSTRAINT", "OPEN_CURLY", "CLOSE_CURLY", "SOLVE", "BEFORE", "IMPLY", 
      "IF", "ELSE", "FOREACH", "ASSIGN_VALUE", "AUTOMATIC", "LOCALPARAM", 
      "PARAMETER", "SPECPARAM", "IMPORT", "GENVAR", "VECTORED", "SCALARED", 
      "TYPEDEF", "ENUM", "STRUCT", "UNION", "PACKED", "STRING", "CHANDLE", 
      "EVENT", "OPEN_BRACKET", "CLOSE_BRACKET", "BYTE", "SHORTINT", "INT", 
      "LONGINT", "INTEGER", "TIME", "BIT", "LOGIC", "REG", "SHORTREAL", 
      "REAL", "REALTIME", "NEXTTIME", "S_NEXTTIME", "S_ALWAYS", "UNTIL_WITH", 
      "S_UNTIL_WITH", "ACCEPT_ON", "REJECT_ON", "SYNC_ACCEPT_ON", "SYNC_REJECT_ON", 
      "EVENTUALLY", "S_EVENTUALLY", "SUPPLY0", "SUPPLY1", "TRI", "TRIAND", 
      "TRIOR", "TRI0", "TRI1", "WIRE", "UWIRE", "WAND", "WOR", "TRIREG", 
      "SIGNED", "UNSIGNED", "INTERCONNECT", "VAR", "VOID", "HIGHZ0", "HIGHZ1", 
      "STRONG", "WEAK", "STRONG0", "PULL0", "WEAK0", "STRONG1", "PULL1", 
      "WEAK1", "SMALL", "MEDIUM", "LARGE", "PATHPULSE", "DOLLAR", "EXPORT", 
      "CONTEXT", "PURE", "IMPLEMENTS", "ENDTASK", "PLUSPLUS", "PLUS", "MINUSMINUS", 
      "MINUS", "STARCOLONCOLONSTAR", "STARSTAR", "DIV", "PERCENT", "EQUIV", 
      "NOTEQUAL", "LESS", "LESS_EQUAL", "GREATER", "EQUIVALENCE", "GREATER_EQUAL", 
      "MODPORT", "DOLLAR_UNIT", "OPEN_PARENS_STAR", "STAR_CLOSE_PARENS", 
      "ASSERT", "PROPERTY", "ASSUME", "COVER", "EXPECT", "ENDPROPERTY", 
      "DISABLE", "IFF", "OVERLAP_IMPLY", "NON_OVERLAP_IMPLY", "NOT", "OR", 
      "AND", "SEQUENCE", "ENDSEQUENCE", "INTERSECT", "FIRST_MATCH", "THROUGHOUT", 
      "WITHIN", "POUNDPOUND", "OVERLAPPED", "NONOVERLAPPED", "POUND", "CONSECUTIVE_REP", 
      "NON_CONSECUTIVE_REP", "GOTO_REP", "DIST", "COVERGROUP", "ENDGROUP", 
      "OPTION_DOT", "TYPE_OPTION_DOT", "ATAT", "BEGIN", "END", "WILDCARD", 
      "BINS", "ILLEGAL_BINS", "IGNORE_BINS", "TRANSITION_OP", "BANG", "SOFT", 
      "UNTIL", "S_UNTIL", "IMPLIES", "LOGICAL_AND", "LOGICAL_OR", "BINSOF", 
      "PULLDOWN", "PULLUP", "CMOS", "RCMOS", "BUFIF0", "BUFIF1", "NOTIF0", 
      "NOTIF1", "NMOS", "PMOS", "RNMOS", "RPMOS", "NAND", "NOR", "XOR", 
      "XNOR", "BUF", "TRANIF0", "TRANIF1", "RTRANIF1", "RTRANIF0", "TRAN", 
      "RTRAN", "DOTSTAR", "GENERATE", "ENDGENERATE", "CASE", "ENDCASE", 
      "FOR", "GLOBAL", "PRIMITIVE", "ENDPRIMITIVE", "TABLE", "ENDTABLE", 
      "INITIAL", "ASSIGN", "ALIAS", "ALWAYS", "ALWAYS_COMB", "ALWAYS_LATCH", 
      "ALWAYS_FF", "ADD_ASSIGN", "SUB_ASSIGN", "MULT_ASSIGN", "DIV_ASSIGN", 
      "MODULO_ASSIGN", "BITW_AND_ASSIGN", "BITW_OR_ASSIGN", "BITW_XOR_ASSIGN", 
      "BITW_LEFT_SHIFT_ASSIGN", "BITW_RIGHT_SHIFT_ASSIGN", "DEASSIGN", "FORCE", 
      "RELEASE", "FORK", "JOIN", "JOIN_ANY", "JOIN_NONE", "REPEAT", "AT", 
      "RETURN", "BREAK", "CONTINUE", "WAIT", "WAIT_ORDER", "UNIQUE", "UNIQUE0", 
      "PRIORITY", "MATCHES", "CASEZ", "CASEX", "RANDCASE", "TAGGED", "FOREVER", 
      "WHILE", "DO", "RESTRICT", "LET", "TICK", "ENDCLOCKING", "RANDSEQUENCE", 
      "SHIFT_RIGHT", "SHIFT_LEFT", "WITH", "INC_PART_SELECT_OP", "DEC_PART_SELECT_OP", 
      "INSIDE", "NULL_KEYWORD", "THIS", "DOLLAR_ROOT", "RANDOMIZE", "FINAL", 
      "TASK", "COVERPOINT", "CROSS", "POSEDGE", "NEGEDGE", "SPECIFY", "ENDSPECIFY", 
      "PULSESTYLE_ONEVENT", "PULSESTYLE_ONDETECT", "SHOWCANCELLED", "NOSHOWCANCELLED", 
      "IFNONE", "SAMPLE", "EDGE", "NON_BLOCKING_TRIGGER_EVENT_OP", "ARITH_SHIFT_RIGHT", 
      "ARITH_SHIFT_LEFT", "ARITH_SHIFT_LEFT_ASSIGN", "ARITH_SHIFT_RIGHT_ASSIGN", 
      "FOUR_STATE_LOGIC_EQUAL", "FOUR_STATE_LOGIC_NOTEQUAL", "BINARY_WILDCARD_EQUAL", 
      "BINARY_WILDCARD_NOTEQUAL", "FULL_CONN_OP", "COND_PRED_OP", "BITW_AND", 
      "BITW_OR", "REDUCTION_NOR", "REDUCTION_NAND", "REDUCTION_XNOR1", "WILD_EQUAL_OP", 
      "WILD_NOTEQUAL_OP", "ASSIGN_OP", "NETTYPE", "Escaped_identifier", 
      "TILDA", "BITW_XOR", "REDUCTION_XNOR2", "Simple_identifier", "TICK_LINE", 
      "TICK_TIMESCALE", "TICK_BEGIN_KEYWORDS", "TICK_END_KEYWORDS", "TICK_UNCONNECTED_DRIVE", 
      "TICK_NOUNCONNECTED_DRIVE", "TICK_CELLDEFINE", "TICK_ENDCELLDEFINE", 
      "TICK_DEFAULT_NETTYPE", "TICK_DEFAULT_DECAY_TIME", "TICK_DEFAULT_TRIREG_STRENGTH", 
      "TICK_DELAY_MODE_DISTRIBUTED", "TICK_DELAY_MODE_PATH", "TICK_DELAY_MODE_UNIT", 
      "TICK_DELAY_MODE_ZERO", "TICK_ACCELERATE", "TICK_NOACCELERATE", "TICK_PROTECT", 
      "TICK_DISABLE_PORTFAULTS", "TICK_ENABLE_PORTFAULTS", "TICK_NOSUPPRESS_FAULTS", 
      "TICK_SUPPRESS_FAULTS", "TICK_SIGNED", "TICK_UNSIGNED", "TICK_ENDPROTECT", 
      "TICK_PROTECTED", "TICK_ENDPROTECTED", "TICK_EXPAND_VECTORNETS", "TICK_NOEXPAND_VECTORNETS", 
      "TICK_AUTOEXPAND_VECTORNETS", "TICK_REMOVE_GATENAME", "TICK_NOREMOVE_GATENAMES", 
      "TICK_REMOVE_NETNAME", "TICK_NOREMOVE_NETNAMES", "ONESTEP", "TICK_USELIB", 
      "TICK_PRAGMA", "BACK_TICK", "SURELOG_MACRO_NOT_DEFINED", "ANY"
    }
  );
  static const int32_t serializedATNSegment[] = {
  	4,1,408,10006,2,0,7,0,2,1,7,1,2,2,7,2,2,3,7,3,2,4,7,4,2,5,7,5,2,6,7,6,
  	2,7,7,7,2,8,7,8,2,9,7,9,2,10,7,10,2,11,7,11,2,12,7,12,2,13,7,13,2,14,
  	7,14,2,15,7,15,2,16,7,16,2,17,7,17,2,18,7,18,2,19,7,19,2,20,7,20,2,21,
  	7,21,2,22,7,22,2,23,7,23,2,24,7,24,2,25,7,25,2,26,7,26,2,27,7,27,2,28,
  	7,28,2,29,7,29,2,30,7,30,2,31,7,31,2,32,7,32,2,33,7,33,2,34,7,34,2,35,
  	7,35,2,36,7,36,2,37,7,37,2,38,7,38,2,39,7,39,2,40,7,40,2,41,7,41,2,42,
  	7,42,2,43,7,43,2,44,7,44,2,45,7,45,2,46,7,46,2,47,7,47,2,48,7,48,2,49,
  	7,49,2,50,7,50,2,51,7,51,2,52,7,52,2,53,7,53,2,54,7,54,2,55,7,55,2,56,
  	7,56,2,57,7,57,2,58,7,58,2,59,7,59,2,60,7,60,2,61,7,61,2,62,7,62,2,63,
  	7,63,2,64,7,64,2,65,7,65,2,66,7,66,2,67,7,67,2,68,7,68,2,69,7,69,2,70,
  	7,70,2,71,7,71,2,72,7,72,2,73,7,73,2,74,7,74,2,75,7,75,2,76,7,76,2,77,
  	7,77,2,78,7,78,2,79,7,79,2,80,7,80,2,81,7,81,2,82,7,82,2,83,7,83,2,84,
  	7,84,2,85,7,85,2,86,7,86,2,87,7,87,2,88,7,88,2,89,7,89,2,90,7,90,2,91,
  	7,91,2,92,7,92,2,93,7,93,2,94,7,94,2,95,7,95,2,96,7,96,2,97,7,97,2,98,
  	7,98,2,99,7,99,2,100,7,100,2,101,7,101,2,102,7,102,2,103,7,103,2,104,
  	7,104,2,105,7,105,2,106,7,106,2,107,7,107,2,108,7,108,2,109,7,109,2,110,
  	7,110,2,111,7,111,2,112,7,112,2,113,7,113,2,114,7,114,2,115,7,115,2,116,
  	7,116,2,117,7,117,2,118,7,118,2,119,7,119,2,120,7,120,2,121,7,121,2,122,
  	7,122,2,123,7,123,2,124,7,124,2,125,7,125,2,126,7,126,2,127,7,127,2,128,
  	7,128,2,129,7,129,2,130,7,130,2,131,7,131,2,132,7,132,2,133,7,133,2,134,
  	7,134,2,135,7,135,2,136,7,136,2,137,7,137,2,138,7,138,2,139,7,139,2,140,
  	7,140,2,141,7,141,2,142,7,142,2,143,7,143,2,144,7,144,2,145,7,145,2,146,
  	7,146,2,147,7,147,2,148,7,148,2,149,7,149,2,150,7,150,2,151,7,151,2,152,
  	7,152,2,153,7,153,2,154,7,154,2,155,7,155,2,156,7,156,2,157,7,157,2,158,
  	7,158,2,159,7,159,2,160,7,160,2,161,7,161,2,162,7,162,2,163,7,163,2,164,
  	7,164,2,165,7,165,2,166,7,166,2,167,7,167,2,168,7,168,2,169,7,169,2,170,
  	7,170,2,171,7,171,2,172,7,172,2,173,7,173,2,174,7,174,2,175,7,175,2,176,
  	7,176,2,177,7,177,2,178,7,178,2,179,7,179,2,180,7,180,2,181,7,181,2,182,
  	7,182,2,183,7,183,2,184,7,184,2,185,7,185,2,186,7,186,2,187,7,187,2,188,
  	7,188,2,189,7,189,2,190,7,190,2,191,7,191,2,192,7,192,2,193,7,193,2,194,
  	7,194,2,195,7,195,2,196,7,196,2,197,7,197,2,198,7,198,2,199,7,199,2,200,
  	7,200,2,201,7,201,2,202,7,202,2,203,7,203,2,204,7,204,2,205,7,205,2,206,
  	7,206,2,207,7,207,2,208,7,208,2,209,7,209,2,210,7,210,2,211,7,211,2,212,
  	7,212,2,213,7,213,2,214,7,214,2,215,7,215,2,216,7,216,2,217,7,217,2,218,
  	7,218,2,219,7,219,2,220,7,220,2,221,7,221,2,222,7,222,2,223,7,223,2,224,
  	7,224,2,225,7,225,2,226,7,226,2,227,7,227,2,228,7,228,2,229,7,229,2,230,
  	7,230,2,231,7,231,2,232,7,232,2,233,7,233,2,234,7,234,2,235,7,235,2,236,
  	7,236,2,237,7,237,2,238,7,238,2,239,7,239,2,240,7,240,2,241,7,241,2,242,
  	7,242,2,243,7,243,2,244,7,244,2,245,7,245,2,246,7,246,2,247,7,247,2,248,
  	7,248,2,249,7,249,2,250,7,250,2,251,7,251,2,252,7,252,2,253,7,253,2,254,
  	7,254,2,255,7,255,2,256,7,256,2,257,7,257,2,258,7,258,2,259,7,259,2,260,
  	7,260,2,261,7,261,2,262,7,262,2,263,7,263,2,264,7,264,2,265,7,265,2,266,
  	7,266,2,267,7,267,2,268,7,268,2,269,7,269,2,270,7,270,2,271,7,271,2,272,
  	7,272,2,273,7,273,2,274,7,274,2,275,7,275,2,276,7,276,2,277,7,277,2,278,
  	7,278,2,279,7,279,2,280,7,280,2,281,7,281,2,282,7,282,2,283,7,283,2,284,
  	7,284,2,285,7,285,2,286,7,286,2,287,7,287,2,288,7,288,2,289,7,289,2,290,
  	7,290,2,291,7,291,2,292,7,292,2,293,7,293,2,294,7,294,2,295,7,295,2,296,
  	7,296,2,297,7,297,2,298,7,298,2,299,7,299,2,300,7,300,2,301,7,301,2,302,
  	7,302,2,303,7,303,2,304,7,304,2,305,7,305,2,306,7,306,2,307,7,307,2,308,
  	7,308,2,309,7,309,2,310,7,310,2,311,7,311,2,312,7,312,2,313,7,313,2,314,
  	7,314,2,315,7,315,2,316,7,316,2,317,7,317,2,318,7,318,2,319,7,319,2,320,
  	7,320,2,321,7,321,2,322,7,322,2,323,7,323,2,324,7,324,2,325,7,325,2,326,
  	7,326,2,327,7,327,2,328,7,328,2,329,7,329,2,330,7,330,2,331,7,331,2,332,
  	7,332,2,333,7,333,2,334,7,334,2,335,7,335,2,336,7,336,2,337,7,337,2,338,
  	7,338,2,339,7,339,2,340,7,340,2,341,7,341,2,342,7,342,2,343,7,343,2,344,
  	7,344,2,345,7,345,2,346,7,346,2,347,7,347,2,348,7,348,2,349,7,349,2,350,
  	7,350,2,351,7,351,2,352,7,352,2,353,7,353,2,354,7,354,2,355,7,355,2,356,
  	7,356,2,357,7,357,2,358,7,358,2,359,7,359,2,360,7,360,2,361,7,361,2,362,
  	7,362,2,363,7,363,2,364,7,364,2,365,7,365,2,366,7,366,2,367,7,367,2,368,
  	7,368,2,369,7,369,2,370,7,370,2,371,7,371,2,372,7,372,2,373,7,373,2,374,
  	7,374,2,375,7,375,2,376,7,376,2,377,7,377,2,378,7,378,2,379,7,379,2,380,
  	7,380,2,381,7,381,2,382,7,382,2,383,7,383,2,384,7,384,2,385,7,385,2,386,
  	7,386,2,387,7,387,2,388,7,388,2,389,7,389,2,390,7,390,2,391,7,391,2,392,
  	7,392,2,393,7,393,2,394,7,394,2,395,7,395,2,396,7,396,2,397,7,397,2,398,
  	7,398,2,399,7,399,2,400,7,400,2,401,7,401,2,402,7,402,2,403,7,403,2,404,
  	7,404,2,405,7,405,2,406,7,406,2,407,7,407,2,408,7,408,2,409,7,409,2,410,
  	7,410,2,411,7,411,2,412,7,412,2,413,7,413,2,414,7,414,2,415,7,415,2,416,
  	7,416,2,417,7,417,2,418,7,418,2,419,7,419,2,420,7,420,2,421,7,421,2,422,
  	7,422,2,423,7,423,2,424,7,424,2,425,7,425,2,426,7,426,2,427,7,427,2,428,
  	7,428,2,429,7,429,2,430,7,430,2,431,7,431,2,432,7,432,2,433,7,433,2,434,
  	7,434,2,435,7,435,2,436,7,436,2,437,7,437,2,438,7,438,2,439,7,439,2,440,
  	7,440,2,441,7,441,2,442,7,442,2,443,7,443,2,444,7,444,2,445,7,445,2,446,
  	7,446,2,447,7,447,2,448,7,448,2,449,7,449,2,450,7,450,2,451,7,451,2,452,
  	7,452,2,453,7,453,2,454,7,454,2,455,7,455,2,456,7,456,2,457,7,457,2,458,
  	7,458,2,459,7,459,2,460,7,460,2,461,7,461,2,462,7,462,2,463,7,463,2,464,
  	7,464,2,465,7,465,2,466,7,466,2,467,7,467,2,468,7,468,2,469,7,469,2,470,
  	7,470,2,471,7,471,2,472,7,472,2,473,7,473,2,474,7,474,2,475,7,475,2,476,
  	7,476,2,477,7,477,2,478,7,478,2,479,7,479,2,480,7,480,2,481,7,481,2,482,
  	7,482,2,483,7,483,2,484,7,484,2,485,7,485,2,486,7,486,2,487,7,487,2,488,
  	7,488,2,489,7,489,2,490,7,490,2,491,7,491,2,492,7,492,2,493,7,493,2,494,
  	7,494,2,495,7,495,2,496,7,496,2,497,7,497,2,498,7,498,2,499,7,499,2,500,
  	7,500,2,501,7,501,2,502,7,502,2,503,7,503,2,504,7,504,2,505,7,505,2,506,
  	7,506,2,507,7,507,2,508,7,508,2,509,7,509,2,510,7,510,2,511,7,511,2,512,
  	7,512,2,513,7,513,2,514,7,514,2,515,7,515,2,516,7,516,2,517,7,517,2,518,
  	7,518,2,519,7,519,2,520,7,520,2,521,7,521,2,522,7,522,2,523,7,523,2,524,
  	7,524,2,525,7,525,2,526,7,526,2,527,7,527,2,528,7,528,2,529,7,529,2,530,
  	7,530,2,531,7,531,2,532,7,532,2,533,7,533,2,534,7,534,2,535,7,535,2,536,
  	7,536,2,537,7,537,2,538,7,538,2,539,7,539,2,540,7,540,2,541,7,541,2,542,
  	7,542,2,543,7,543,2,544,7,544,2,545,7,545,2,546,7,546,2,547,7,547,2,548,
  	7,548,2,549,7,549,2,550,7,550,2,551,7,551,2,552,7,552,2,553,7,553,2,554,
  	7,554,2,555,7,555,2,556,7,556,2,557,7,557,2,558,7,558,2,559,7,559,2,560,
  	7,560,2,561,7,561,2,562,7,562,2,563,7,563,2,564,7,564,2,565,7,565,2,566,
  	7,566,2,567,7,567,2,568,7,568,2,569,7,569,2,570,7,570,2,571,7,571,2,572,
  	7,572,2,573,7,573,2,574,7,574,2,575,7,575,2,576,7,576,2,577,7,577,2,578,
  	7,578,2,579,7,579,2,580,7,580,2,581,7,581,2,582,7,582,2,583,7,583,2,584,
  	7,584,2,585,7,585,2,586,7,586,2,587,7,587,2,588,7,588,2,589,7,589,2,590,
  	7,590,2,591,7,591,2,592,7,592,2,593,7,593,2,594,7,594,2,595,7,595,2,596,
  	7,596,2,597,7,597,2,598,7,598,2,599,7,599,2,600,7,600,2,601,7,601,2,602,
  	7,602,2,603,7,603,2,604,7,604,2,605,7,605,2,606,7,606,2,607,7,607,2,608,
  	7,608,2,609,7,609,2,610,7,610,2,611,7,611,2,612,7,612,2,613,7,613,2,614,
  	7,614,2,615,7,615,2,616,7,616,2,617,7,617,2,618,7,618,2,619,7,619,2,620,
  	7,620,2,621,7,621,2,622,7,622,2,623,7,623,2,624,7,624,2,625,7,625,2,626,
  	7,626,2,627,7,627,2,628,7,628,2,629,7,629,2,630,7,630,2,631,7,631,2,632,
  	7,632,2,633,7,633,2,634,7,634,2,635,7,635,2,636,7,636,2,637,7,637,2,638,
  	7,638,2,639,7,639,2,640,7,640,2,641,7,641,2,642,7,642,2,643,7,643,2,644,
  	7,644,2,645,7,645,2,646,7,646,2,647,7,647,2,648,7,648,2,649,7,649,2,650,
  	7,650,2,651,7,651,2,652,7,652,2,653,7,653,2,654,7,654,2,655,7,655,2,656,
  	7,656,2,657,7,657,2,658,7,658,2,659,7,659,2,660,7,660,2,661,7,661,2,662,
  	7,662,2,663,7,663,2,664,7,664,2,665,7,665,2,666,7,666,2,667,7,667,2,668,
  	7,668,2,669,7,669,2,670,7,670,2,671,7,671,2,672,7,672,2,673,7,673,2,674,
  	7,674,2,675,7,675,2,676,7,676,2,677,7,677,2,678,7,678,2,679,7,679,2,680,
  	7,680,2,681,7,681,2,682,7,682,2,683,7,683,1,0,1,0,1,0,1,0,1,1,1,1,1,1,
  	1,1,1,2,5,2,1378,8,2,10,2,12,2,1381,9,2,1,3,1,3,1,3,1,3,3,3,1387,8,3,
  	1,4,1,4,1,4,1,4,1,4,5,4,1394,8,4,10,4,12,4,1397,9,4,1,4,1,4,1,4,1,4,5,
  	4,1403,8,4,10,4,12,4,1406,9,4,3,4,1408,8,4,1,4,1,4,1,5,4,5,1413,8,5,11,
  	5,12,5,1414,1,6,1,6,1,6,1,6,1,7,3,7,1422,8,7,1,7,5,7,1425,8,7,10,7,12,
  	7,1428,9,7,1,8,1,8,1,9,1,9,1,9,1,9,1,9,1,9,1,9,5,9,1439,8,9,10,9,12,9,
  	1442,9,9,1,9,1,9,3,9,1446,8,9,1,9,1,9,3,9,1450,8,9,1,10,5,10,1453,8,10,
  	10,10,12,10,1456,9,10,1,10,1,10,3,10,1460,8,10,1,10,1,10,5,10,1464,8,
  	10,10,10,12,10,1467,9,10,1,10,3,10,1470,8,10,1,10,1,10,1,10,1,11,5,11,
  	1476,8,11,10,11,12,11,1479,9,11,1,11,1,11,3,11,1483,8,11,1,11,1,11,5,
  	11,1487,8,11,10,11,12,11,1490,9,11,1,11,3,11,1493,8,11,1,11,3,11,1496,
  	8,11,1,11,1,11,1,12,1,12,3,12,1502,8,12,1,12,5,12,1505,8,12,10,12,12,
  	12,1508,9,12,1,12,1,12,1,12,3,12,1513,8,12,1,12,1,12,3,12,1517,8,12,1,
  	12,5,12,1520,8,12,10,12,12,12,1523,9,12,1,12,1,12,1,12,3,12,1528,8,12,
  	1,12,5,12,1531,8,12,10,12,12,12,1534,9,12,1,12,1,12,3,12,1538,8,12,1,
  	12,1,12,1,12,1,12,1,12,1,12,1,12,3,12,1547,8,12,1,12,5,12,1550,8,12,10,
  	12,12,12,1553,9,12,1,12,1,12,1,12,3,12,1558,8,12,1,12,1,12,1,12,1,12,
  	3,12,1564,8,12,1,13,1,13,1,14,5,14,1569,8,14,10,14,12,14,1572,9,14,1,
  	14,1,14,3,14,1576,8,14,1,14,1,14,5,14,1580,8,14,10,14,12,14,1583,9,14,
  	1,14,3,14,1586,8,14,1,14,1,14,1,14,1,15,5,15,1592,8,15,10,15,12,15,1595,
  	9,15,1,15,1,15,3,15,1599,8,15,1,15,1,15,5,15,1603,8,15,10,15,12,15,1606,
  	9,15,1,15,3,15,1609,8,15,1,15,3,15,1612,8,15,1,15,1,15,1,16,1,16,3,16,
  	1618,8,16,1,16,5,16,1621,8,16,10,16,12,16,1624,9,16,1,16,1,16,1,16,3,
  	16,1629,8,16,1,16,1,16,3,16,1633,8,16,1,16,5,16,1636,8,16,10,16,12,16,
  	1639,9,16,1,16,1,16,1,16,3,16,1644,8,16,1,16,3,16,1647,8,16,1,16,1,16,
  	1,16,1,16,1,16,1,16,1,16,1,16,3,16,1657,8,16,1,16,5,16,1660,8,16,10,16,
  	12,16,1663,9,16,1,16,1,16,1,16,3,16,1668,8,16,1,16,1,16,1,16,1,16,3,16,
  	1674,8,16,1,17,1,17,1,17,3,17,1679,8,17,1,17,1,17,5,17,1683,8,17,10,17,
  	12,17,1686,9,17,1,17,3,17,1689,8,17,1,17,1,17,1,17,1,18,5,18,1695,8,18,
  	10,18,12,18,1698,9,18,1,18,1,18,3,18,1702,8,18,1,18,1,18,5,18,1706,8,
  	18,10,18,12,18,1709,9,18,1,18,3,18,1712,8,18,1,18,3,18,1715,8,18,1,18,
  	1,18,1,19,1,19,1,19,1,19,3,19,1723,8,19,1,19,3,19,1726,8,19,1,19,1,19,
  	5,19,1730,8,19,10,19,12,19,1733,9,19,1,19,5,19,1736,8,19,10,19,12,19,
  	1739,9,19,1,19,1,19,1,19,3,19,1744,8,19,1,20,1,20,3,20,1748,8,20,1,20,
  	5,20,1751,8,20,10,20,12,20,1754,9,20,1,20,1,20,1,20,3,20,1759,8,20,1,
  	20,1,20,3,20,1763,8,20,1,20,5,20,1766,8,20,10,20,12,20,1769,9,20,1,20,
  	1,20,1,20,3,20,1774,8,20,1,20,5,20,1777,8,20,10,20,12,20,1780,9,20,1,
  	20,1,20,1,20,1,20,1,20,1,20,1,20,1,20,3,20,1790,8,20,1,20,5,20,1793,8,
  	20,10,20,12,20,1796,9,20,1,20,1,20,1,20,3,20,1801,8,20,1,20,1,20,1,20,
  	1,20,3,20,1807,8,20,1,21,3,21,1810,8,21,1,21,1,21,3,21,1814,8,21,1,21,
  	1,21,3,21,1818,8,21,1,21,1,21,1,21,1,21,1,21,1,21,3,21,1826,8,21,3,21,
  	1828,8,21,1,21,1,21,1,21,1,21,5,21,1834,8,21,10,21,12,21,1837,9,21,3,
  	21,1839,8,21,1,21,1,21,5,21,1843,8,21,10,21,12,21,1846,9,21,1,21,1,21,
  	1,21,3,21,1851,8,21,1,22,1,22,3,22,1855,8,22,1,23,1,23,1,23,1,23,3,23,
  	1861,8,23,1,23,1,23,1,23,1,23,5,23,1867,8,23,10,23,12,23,1870,9,23,3,
  	23,1872,8,23,1,23,1,23,5,23,1876,8,23,10,23,12,23,1879,9,23,1,23,1,23,
  	1,23,3,23,1884,8,23,1,24,1,24,5,24,1888,8,24,10,24,12,24,1891,9,24,1,
  	24,1,24,1,24,1,24,1,24,1,24,1,24,1,24,1,24,1,24,3,24,1903,8,24,1,25,1,
  	25,1,25,1,25,1,26,5,26,1910,8,26,10,26,12,26,1913,9,26,1,26,1,26,1,26,
  	1,26,3,26,1919,8,26,1,26,5,26,1922,8,26,10,26,12,26,1925,9,26,1,26,5,
  	26,1928,8,26,10,26,12,26,1931,9,26,1,26,1,26,1,26,3,26,1936,8,26,1,27,
  	1,27,1,27,1,27,1,27,1,27,1,27,1,27,1,27,1,27,1,27,1,27,1,27,1,27,1,27,
  	1,27,1,27,1,27,1,27,1,27,1,27,1,27,1,27,1,27,1,27,1,27,1,27,1,27,3,27,
  	1966,8,27,1,28,1,28,1,28,1,28,1,28,5,28,1973,8,28,10,28,12,28,1976,9,
  	28,1,28,1,28,1,28,1,28,1,28,1,28,1,28,5,28,1985,8,28,10,28,12,28,1988,
  	9,28,1,28,1,28,1,28,1,28,1,28,3,28,1995,8,28,1,29,1,29,1,29,1,29,1,29,
  	1,29,1,29,3,29,2004,8,29,1,30,1,30,1,30,1,30,5,30,2010,8,30,10,30,12,
  	30,2013,9,30,1,30,1,30,1,31,1,31,5,31,2019,8,31,10,31,12,31,2022,9,31,
  	1,31,1,31,1,31,5,31,2027,8,31,10,31,12,31,2030,9,31,1,31,5,31,2033,8,
  	31,10,31,12,31,2036,9,31,3,31,2038,8,31,1,31,1,31,1,32,5,32,2043,8,32,
  	10,32,12,32,2046,9,32,1,32,1,32,1,32,1,32,1,32,3,32,2053,8,32,1,33,3,
  	33,2056,8,33,1,33,1,33,1,33,1,33,3,33,2062,8,33,1,33,1,33,3,33,2066,8,
  	33,1,34,1,34,1,34,1,34,1,34,5,34,2073,8,34,10,34,12,34,2076,9,34,1,34,
  	1,34,3,34,2080,8,34,1,35,1,35,1,35,1,36,1,36,1,37,3,37,2088,8,37,1,37,
  	1,37,1,38,3,38,2093,8,38,1,38,1,38,1,39,1,39,1,39,3,39,2100,8,39,1,39,
  	1,39,1,39,3,39,2105,8,39,3,39,2107,8,39,1,40,1,40,3,40,2111,8,40,1,40,
  	1,40,5,40,2115,8,40,10,40,12,40,2118,9,40,1,40,1,40,3,40,2122,8,40,1,
  	40,3,40,2125,8,40,1,40,1,40,5,40,2129,8,40,10,40,12,40,2132,9,40,1,40,
  	1,40,3,40,2136,8,40,1,40,1,40,3,40,2140,8,40,1,40,1,40,1,40,1,40,3,40,
  	2146,8,40,1,40,1,40,3,40,2150,8,40,1,41,1,41,1,41,1,41,1,41,1,41,3,41,
  	2158,8,41,1,41,1,41,3,41,2162,8,41,1,41,1,41,1,41,1,41,1,41,3,41,2169,
  	8,41,1,41,3,41,2172,8,41,1,42,1,42,1,42,1,42,1,42,1,42,1,42,1,42,1,42,
  	1,42,1,42,1,42,1,42,3,42,2187,8,42,1,43,1,43,1,43,1,43,3,43,2193,8,43,
  	1,44,5,44,2196,8,44,10,44,12,44,2199,9,44,1,44,1,44,1,44,1,44,1,44,3,
  	44,2206,8,44,1,45,1,45,1,45,1,45,1,45,1,45,1,45,1,45,1,45,1,45,1,45,1,
  	45,1,45,1,45,3,45,2222,8,45,1,46,1,46,1,46,1,46,5,46,2228,8,46,10,46,
  	12,46,2231,9,46,1,46,1,46,1,46,1,46,1,46,1,46,1,46,1,46,1,46,3,46,2242,
  	8,46,1,47,1,47,1,47,1,47,1,48,1,48,1,48,3,48,2251,8,48,1,48,1,48,1,48,
  	1,48,1,48,1,48,5,48,2259,8,48,10,48,12,48,2262,9,48,3,48,2264,8,48,1,
  	48,1,48,1,49,1,49,3,49,2270,8,49,1,50,5,50,2273,8,50,10,50,12,50,2276,
  	9,50,1,50,1,50,1,50,1,50,1,50,5,50,2283,8,50,10,50,12,50,2286,9,50,1,
  	50,1,50,1,50,3,50,2291,8,50,1,51,1,51,1,51,1,51,1,51,1,51,1,51,1,51,1,
  	51,3,51,2302,8,51,1,52,1,52,1,52,1,52,3,52,2308,8,52,1,53,1,53,5,53,2312,
  	8,53,10,53,12,53,2315,9,53,1,53,1,53,1,53,1,53,1,53,1,53,3,53,2323,8,
  	53,1,54,1,54,1,54,1,54,3,54,2329,8,54,1,55,5,55,2332,8,55,10,55,12,55,
  	2335,9,55,1,55,1,55,1,55,1,55,1,55,1,55,3,55,2343,8,55,1,55,1,55,1,55,
  	3,55,2348,8,55,1,56,1,56,1,56,1,56,3,56,2354,8,56,1,57,1,57,1,57,5,57,
  	2359,8,57,10,57,12,57,2362,9,57,1,58,5,58,2365,8,58,10,58,12,58,2368,
  	9,58,1,58,3,58,2371,8,58,1,58,1,58,1,58,5,58,2376,8,58,10,58,12,58,2379,
  	9,58,1,58,1,58,3,58,2383,8,58,1,59,1,59,1,59,1,59,1,59,1,59,1,59,3,59,
  	2392,8,59,1,60,5,60,2395,8,60,10,60,12,60,2398,9,60,1,60,1,60,1,60,1,
  	60,1,60,1,60,1,60,1,60,1,60,1,60,1,60,1,60,1,60,1,60,1,60,1,60,1,60,1,
  	60,1,60,1,60,1,60,3,60,2421,8,60,1,61,1,61,1,61,1,61,3,61,2427,8,61,1,
  	62,5,62,2430,8,62,10,62,12,62,2433,9,62,1,62,1,62,1,62,1,62,1,62,1,62,
  	3,62,2441,8,62,1,62,1,62,1,62,1,62,1,62,1,62,1,62,1,62,3,62,2451,8,62,
  	1,63,3,63,2454,8,63,1,63,5,63,2457,8,63,10,63,12,63,2460,9,63,1,63,1,
  	63,1,63,5,63,2465,8,63,10,63,12,63,2468,9,63,1,63,1,63,1,63,1,63,3,63,
  	2474,8,63,1,63,1,63,3,63,2478,8,63,1,64,1,64,1,64,1,65,1,65,1,66,5,66,
  	2486,8,66,10,66,12,66,2489,9,66,1,66,1,66,1,66,3,66,2494,8,66,1,66,1,
  	66,5,66,2498,8,66,10,66,12,66,2501,9,66,1,66,1,66,1,66,1,66,1,66,5,66,
  	2508,8,66,10,66,12,66,2511,9,66,1,66,1,66,1,66,1,66,3,66,2517,8,66,3,
  	66,2519,8,66,1,67,1,67,1,67,1,67,3,67,2525,8,67,1,67,3,67,2528,8,67,1,
  	68,1,68,3,68,2532,8,68,1,69,1,69,1,69,3,69,2537,8,69,1,70,1,70,1,70,3,
  	70,2542,8,70,1,71,1,71,3,71,2546,8,71,1,72,1,72,3,72,2550,8,72,1,73,1,
  	73,1,73,1,73,1,74,1,74,3,74,2558,8,74,1,74,1,74,1,74,3,74,2563,8,74,1,
  	74,3,74,2566,8,74,1,74,1,74,5,74,2570,8,74,10,74,12,74,2573,9,74,1,74,
  	1,74,1,74,1,74,1,74,3,74,2580,8,74,1,74,1,74,3,74,2584,8,74,1,74,5,74,
  	2587,8,74,10,74,12,74,2590,9,74,1,74,1,74,1,74,3,74,2595,8,74,1,75,3,
  	75,2598,8,75,1,75,1,75,1,75,1,75,1,76,1,76,5,76,2606,8,76,10,76,12,76,
  	2609,9,76,1,76,1,76,1,77,1,77,1,77,1,77,1,77,1,77,1,77,3,77,2620,8,77,
  	1,78,1,78,1,78,5,78,2625,8,78,10,78,12,78,2628,9,78,1,79,1,79,1,79,1,
  	79,3,79,2634,8,79,1,79,3,79,2637,8,79,1,79,1,79,1,79,1,79,1,79,5,79,2644,
  	8,79,10,79,12,79,2647,9,79,1,79,1,79,5,79,2651,8,79,10,79,12,79,2654,
  	9,79,1,79,1,79,1,80,3,80,2659,8,80,1,80,1,80,1,80,1,80,1,80,1,80,1,80,
  	1,80,1,80,1,80,1,80,1,80,1,80,1,80,1,80,1,80,1,80,3,80,2678,8,80,1,80,
  	1,80,1,80,1,80,1,80,1,80,1,80,1,80,1,80,1,80,1,80,1,80,1,80,1,80,3,80,
  	2694,8,80,1,81,1,81,1,81,1,81,1,81,1,82,1,82,1,82,5,82,2704,8,82,10,82,
  	12,82,2707,9,82,1,82,3,82,2710,8,82,1,83,1,83,1,83,5,83,2715,8,83,10,
  	83,12,83,2718,9,83,1,84,1,84,3,84,2722,8,84,1,85,1,85,1,85,1,85,1,85,
  	3,85,2729,8,85,1,86,1,86,3,86,2733,8,86,1,86,3,86,2736,8,86,1,86,1,86,
  	1,86,1,86,1,87,3,87,2743,8,87,1,87,1,87,1,87,1,87,1,87,1,88,1,88,1,88,
  	5,88,2753,8,88,10,88,12,88,2756,9,88,1,89,1,89,1,89,1,89,1,89,3,89,2763,
  	8,89,1,90,1,90,1,90,1,90,1,90,1,90,1,90,1,90,1,90,1,90,1,90,1,90,1,90,
  	1,90,1,90,1,90,1,90,1,90,1,90,1,90,3,90,2785,8,90,1,91,1,91,1,91,5,91,
  	2790,8,91,10,91,12,91,2793,9,91,1,91,1,91,1,92,1,92,1,92,1,92,1,92,1,
  	92,1,92,3,92,2804,8,92,1,93,1,93,1,93,3,93,2809,8,93,1,93,1,93,1,94,1,
  	94,1,94,3,94,2816,8,94,1,94,1,94,1,95,1,95,3,95,2822,8,95,1,95,1,95,1,
  	95,1,96,1,96,1,96,1,96,1,97,1,97,1,97,1,97,1,97,3,97,2836,8,97,1,97,3,
  	97,2839,8,97,1,98,1,98,1,98,1,98,1,98,3,98,2846,8,98,1,98,3,98,2849,8,
  	98,1,99,1,99,1,99,1,99,1,99,1,99,1,99,1,99,3,99,2859,8,99,1,100,1,100,
  	1,100,1,100,1,101,3,101,2866,8,101,1,101,3,101,2869,8,101,1,101,1,101,
  	1,101,3,101,2874,8,101,1,101,1,101,3,101,2878,8,101,1,101,1,101,1,101,
  	3,101,2883,8,101,1,102,1,102,1,102,5,102,2888,8,102,10,102,12,102,2891,
  	9,102,1,102,4,102,2894,8,102,11,102,12,102,2895,3,102,2898,8,102,1,102,
  	1,102,1,102,1,103,1,103,1,103,5,103,2906,8,103,10,103,12,103,2909,9,103,
  	1,103,4,103,2912,8,103,11,103,12,103,2913,3,103,2916,8,103,1,103,1,103,
  	1,103,1,104,1,104,1,104,1,104,5,104,2925,8,104,10,104,12,104,2928,9,104,
  	1,104,1,104,1,105,1,105,1,105,1,105,3,105,2936,8,105,1,106,1,106,1,106,
  	1,106,1,106,1,106,1,106,3,106,2945,8,106,1,106,1,106,3,106,2949,8,106,
  	1,107,1,107,1,107,1,107,1,108,1,108,1,108,3,108,2958,8,108,1,108,3,108,
  	2961,8,108,1,108,1,108,3,108,2965,8,108,1,108,1,108,1,108,1,108,1,108,
  	3,108,2972,8,108,1,108,1,108,1,108,1,108,1,108,1,108,3,108,2980,8,108,
  	1,108,1,108,5,108,2984,8,108,10,108,12,108,2987,9,108,1,108,1,108,1,108,
  	5,108,2992,8,108,10,108,12,108,2995,9,108,3,108,2997,8,108,1,108,1,108,
  	3,108,3001,8,108,1,109,1,109,1,109,3,109,3006,8,109,1,109,1,109,5,109,
  	3010,8,109,10,109,12,109,3013,9,109,1,109,1,109,1,109,1,109,1,109,1,109,
  	1,109,1,109,1,109,1,109,1,109,3,109,3026,8,109,1,109,3,109,3029,8,109,
  	1,109,1,109,1,110,1,110,1,111,1,111,1,112,1,112,1,113,1,113,1,114,1,114,
  	1,114,1,115,1,115,1,115,1,115,1,115,1,115,3,115,3050,8,115,1,115,3,115,
  	3053,8,115,1,115,1,115,3,115,3057,8,115,1,115,1,115,1,115,3,115,3062,
  	8,115,1,115,1,115,1,116,1,116,3,116,3068,8,116,1,117,1,117,1,117,1,117,
  	3,117,3074,8,117,1,117,1,117,1,117,1,117,1,117,1,117,3,117,3082,8,117,
  	1,117,1,117,1,117,1,117,1,117,1,117,1,117,1,117,3,117,3092,8,117,1,118,
  	1,118,3,118,3096,8,118,1,118,5,118,3099,8,118,10,118,12,118,3102,9,118,
  	1,118,1,118,3,118,3106,8,118,1,118,1,118,1,118,1,118,3,118,3112,8,118,
  	3,118,3114,8,118,1,118,1,118,1,118,5,118,3119,8,118,10,118,12,118,3122,
  	9,118,1,118,1,118,5,118,3126,8,118,10,118,12,118,3129,9,118,1,118,1,118,
  	3,118,3133,8,118,1,118,1,118,1,118,1,118,5,118,3139,8,118,10,118,12,118,
  	3142,9,118,1,118,1,118,1,118,1,118,1,118,1,118,3,118,3150,8,118,1,118,
  	1,118,3,118,3154,8,118,1,118,1,118,3,118,3158,8,118,1,118,1,118,3,118,
  	3162,8,118,1,118,1,118,4,118,3166,8,118,11,118,12,118,3167,1,118,3,118,
  	3171,8,118,1,118,1,118,1,118,3,118,3176,8,118,5,118,3178,8,118,10,118,
  	12,118,3181,9,118,3,118,3183,8,118,1,118,1,118,3,118,3187,8,118,1,119,
  	1,119,1,120,1,120,1,121,1,121,1,122,1,122,1,123,1,123,1,124,1,124,1,125,
  	1,125,1,126,1,126,3,126,3205,8,126,1,126,5,126,3208,8,126,10,126,12,126,
  	3211,9,126,3,126,3213,8,126,1,127,3,127,3216,8,127,1,127,5,127,3219,8,
  	127,10,127,12,127,3222,9,127,1,128,1,128,3,128,3226,8,128,1,128,1,128,
  	3,128,3230,8,128,1,128,3,128,3233,8,128,1,128,1,128,3,128,3237,8,128,
  	3,128,3239,8,128,1,129,1,129,1,129,1,129,1,129,3,129,3246,8,129,1,129,
  	3,129,3249,8,129,1,129,1,129,3,129,3253,8,129,1,130,1,130,1,130,1,131,
  	1,131,3,131,3260,8,131,1,131,1,131,1,131,3,131,3265,8,131,5,131,3267,
  	8,131,10,131,12,131,3270,9,131,1,132,1,132,3,132,3274,8,132,1,133,1,133,
  	1,134,1,134,1,135,1,135,1,136,1,136,1,137,3,137,3285,8,137,1,137,1,137,
  	1,137,1,137,3,137,3291,8,137,1,138,1,138,1,138,1,138,1,138,3,138,3298,
  	8,138,1,139,1,139,1,139,1,139,3,139,3304,8,139,1,140,1,140,1,141,1,141,
  	1,141,3,141,3311,8,141,1,142,1,142,3,142,3315,8,142,1,143,5,143,3318,
  	8,143,10,143,12,143,3321,9,143,1,143,3,143,3324,8,143,1,143,1,143,1,143,
  	1,143,1,144,1,144,3,144,3332,8,144,1,145,1,145,1,145,3,145,3337,8,145,
  	3,145,3339,8,145,1,146,1,146,1,147,1,147,1,147,1,147,3,147,3347,8,147,
  	1,147,1,147,1,148,1,148,1,148,1,148,1,148,1,148,1,148,1,148,1,148,1,148,
  	1,148,1,148,1,148,1,148,1,148,1,148,1,148,1,148,1,148,1,148,3,148,3371,
  	8,148,1,149,1,149,1,150,1,150,1,151,1,151,1,152,1,152,1,152,1,152,1,152,
  	1,152,1,152,1,152,3,152,3387,8,152,3,152,3389,8,152,1,152,1,152,3,152,
  	3393,8,152,1,153,1,153,1,153,1,153,1,153,1,153,3,153,3401,8,153,1,153,
  	1,153,3,153,3405,8,153,1,154,1,154,3,154,3409,8,154,1,154,1,154,3,154,
  	3413,8,154,1,154,1,154,3,154,3417,8,154,1,155,1,155,1,155,1,155,1,155,
  	1,155,3,155,3425,8,155,1,156,1,156,1,156,5,156,3430,8,156,10,156,12,156,
  	3433,9,156,1,157,1,157,5,157,3437,8,157,10,157,12,157,3440,9,157,1,157,
  	1,157,1,157,5,157,3445,8,157,10,157,12,157,3448,9,157,5,157,3450,8,157,
  	10,157,12,157,3453,9,157,1,158,1,158,1,158,5,158,3458,8,158,10,158,12,
  	158,3461,9,158,1,159,1,159,1,159,5,159,3466,8,159,10,159,12,159,3469,
  	9,159,1,160,1,160,5,160,3473,8,160,10,160,12,160,3476,9,160,1,160,1,160,
  	1,160,5,160,3481,8,160,10,160,12,160,3484,9,160,5,160,3486,8,160,10,160,
  	12,160,3489,9,160,1,161,1,161,1,161,5,161,3494,8,161,10,161,12,161,3497,
  	9,161,1,162,1,162,5,162,3501,8,162,10,162,12,162,3504,9,162,1,162,1,162,
  	3,162,3508,8,162,1,162,1,162,1,162,5,162,3513,8,162,10,162,12,162,3516,
  	9,162,1,162,1,162,3,162,3520,8,162,5,162,3522,8,162,10,162,12,162,3525,
  	9,162,1,163,1,163,1,163,3,163,3530,8,163,1,163,1,163,1,163,1,163,3,163,
  	3536,8,163,5,163,3538,8,163,10,163,12,163,3541,9,163,1,164,1,164,1,164,
  	5,164,3546,8,164,10,164,12,164,3549,9,164,1,165,1,165,5,165,3553,8,165,
  	10,165,12,165,3556,9,165,1,165,1,165,1,165,5,165,3561,8,165,10,165,12,
  	165,3564,9,165,5,165,3566,8,165,10,165,12,165,3569,9,165,1,166,1,166,
  	5,166,3573,8,166,10,166,12,166,3576,9,166,1,166,1,166,3,166,3580,8,166,
  	1,166,1,166,1,166,5,166,3585,8,166,10,166,12,166,3588,9,166,1,166,1,166,
  	3,166,3592,8,166,5,166,3594,8,166,10,166,12,166,3597,9,166,1,167,1,167,
  	1,167,3,167,3602,8,167,1,167,1,167,1,167,1,167,3,167,3608,8,167,5,167,
  	3610,8,167,10,167,12,167,3613,9,167,1,168,1,168,3,168,3617,8,168,1,168,
  	1,168,1,168,1,169,1,169,5,169,3624,8,169,10,169,12,169,3627,9,169,1,169,
  	1,169,3,169,3631,8,169,1,170,1,170,5,170,3635,8,170,10,170,12,170,3638,
  	9,170,1,170,1,170,3,170,3642,8,170,1,171,1,171,1,171,1,171,1,171,3,171,
  	3649,8,171,1,172,1,172,1,172,1,172,1,172,1,172,1,172,3,172,3658,8,172,
  	1,172,1,172,1,172,1,172,1,172,1,172,1,172,1,172,1,172,1,172,1,172,1,172,
  	1,172,3,172,3673,8,172,1,172,1,172,1,172,3,172,3678,8,172,1,173,1,173,
  	1,173,1,173,1,173,5,173,3685,8,173,10,173,12,173,3688,9,173,1,173,1,173,
  	3,173,3692,8,173,1,173,1,173,1,173,1,173,1,173,1,173,3,173,3700,8,173,
  	1,173,5,173,3703,8,173,10,173,12,173,3706,9,173,1,173,1,173,3,173,3710,
  	8,173,3,173,3712,8,173,1,174,3,174,3715,8,174,1,174,1,174,1,174,1,174,
  	1,174,1,174,3,174,3723,8,174,1,175,1,175,1,175,1,175,1,175,1,175,1,175,
  	1,175,3,175,3733,8,175,1,176,1,176,1,176,1,176,1,176,1,176,1,176,1,176,
  	1,176,3,176,3744,8,176,1,177,1,177,1,177,1,177,1,177,3,177,3751,8,177,
  	1,178,1,178,1,178,1,178,1,178,3,178,3758,8,178,1,179,1,179,1,179,1,179,
  	3,179,3764,8,179,1,180,1,180,1,180,1,180,3,180,3770,8,180,1,180,1,180,
  	1,181,1,181,1,181,1,182,1,182,3,182,3779,8,182,1,183,1,183,3,183,3783,
  	8,183,1,183,5,183,3786,8,183,10,183,12,183,3789,9,183,3,183,3791,8,183,
  	1,184,1,184,3,184,3795,8,184,1,184,1,184,1,185,1,185,1,185,1,185,1,185,
  	3,185,3804,8,185,1,185,1,185,1,185,5,185,3809,8,185,10,185,12,185,3812,
  	9,185,1,185,5,185,3815,8,185,10,185,12,185,3818,9,185,1,185,1,185,1,185,
  	3,185,3823,8,185,1,185,1,185,1,185,1,185,1,185,3,185,3830,8,185,1,185,
  	1,185,1,185,3,185,3835,8,185,1,185,1,185,1,185,5,185,3840,8,185,10,185,
  	12,185,3843,9,185,1,185,5,185,3846,8,185,10,185,12,185,3849,9,185,1,185,
  	1,185,1,185,3,185,3854,8,185,3,185,3856,8,185,1,186,1,186,1,186,1,186,
  	1,186,3,186,3863,8,186,1,186,3,186,3866,8,186,1,187,1,187,1,187,1,187,
  	3,187,3872,8,187,1,187,1,187,3,187,3876,8,187,1,187,1,187,1,187,1,187,
  	1,187,1,187,3,187,3884,8,187,1,187,1,187,3,187,3888,8,187,1,187,1,187,
  	1,187,1,187,1,187,1,187,1,187,3,187,3897,8,187,1,187,1,187,3,187,3901,
  	8,187,1,187,1,187,3,187,3905,8,187,1,188,1,188,1,189,1,189,1,189,1,190,
  	1,190,1,190,1,191,1,191,1,192,1,192,3,192,3919,8,192,1,192,1,192,1,193,
  	1,193,1,193,1,193,3,193,3927,8,193,1,193,1,193,1,193,5,193,3932,8,193,
  	10,193,12,193,3935,9,193,1,193,5,193,3938,8,193,10,193,12,193,3941,9,
  	193,1,193,1,193,1,193,3,193,3946,8,193,1,193,1,193,1,193,1,193,3,193,
  	3952,8,193,1,193,1,193,1,193,3,193,3957,8,193,1,193,1,193,1,193,5,193,
  	3962,8,193,10,193,12,193,3965,9,193,1,193,5,193,3968,8,193,10,193,12,
  	193,3971,9,193,1,193,1,193,1,193,3,193,3976,8,193,3,193,3978,8,193,1,
  	194,1,194,3,194,3982,8,194,1,195,1,195,1,195,5,195,3987,8,195,10,195,
  	12,195,3990,9,195,1,196,5,196,3993,8,196,10,196,12,196,3996,9,196,1,196,
  	3,196,3999,8,196,1,196,3,196,4002,8,196,1,196,1,196,1,196,5,196,4007,
  	8,196,10,196,12,196,4010,9,196,1,196,1,196,3,196,4014,8,196,1,197,1,197,
  	1,197,1,197,1,197,1,197,3,197,4022,8,197,1,198,5,198,4025,8,198,10,198,
  	12,198,4028,9,198,1,198,1,198,3,198,4032,8,198,1,198,1,198,1,198,1,198,
  	1,199,1,199,1,199,1,199,3,199,4042,8,199,1,199,3,199,4045,8,199,1,200,
  	5,200,4048,8,200,10,200,12,200,4051,9,200,1,200,1,200,1,200,1,200,1,200,
  	1,200,1,200,1,200,1,200,3,200,4062,8,200,1,201,1,201,1,201,1,201,1,201,
  	1,201,1,201,1,201,1,201,1,201,1,202,1,202,1,202,1,202,1,202,1,202,1,202,
  	1,202,1,202,1,202,1,202,1,202,1,202,1,202,1,202,3,202,4089,8,202,1,203,
  	1,203,1,203,5,203,4094,8,203,10,203,12,203,4097,9,203,1,204,1,204,3,204,
  	4101,8,204,1,204,1,204,1,204,1,204,1,205,1,205,1,205,1,205,1,205,5,205,
  	4112,8,205,10,205,12,205,4115,9,205,1,205,1,205,1,206,5,206,4120,8,206,
  	10,206,12,206,4123,9,206,1,206,1,206,1,206,1,206,1,206,3,206,4130,8,206,
  	1,207,1,207,1,207,1,207,5,207,4136,8,207,10,207,12,207,4139,9,207,1,208,
  	1,208,1,208,1,208,1,208,5,208,4146,8,208,10,208,12,208,4149,9,208,1,208,
  	1,208,3,208,4153,8,208,1,209,1,209,1,209,1,209,1,209,3,209,4160,8,209,
  	1,209,1,209,1,209,1,210,1,210,1,210,1,210,5,210,4169,8,210,10,210,12,
  	210,4172,9,210,1,211,1,211,3,211,4176,8,211,1,212,1,212,1,212,3,212,4181,
  	8,212,1,212,1,212,3,212,4185,8,212,1,213,1,213,1,213,1,213,1,213,3,213,
  	4192,8,213,1,214,1,214,1,214,1,214,1,214,1,214,1,214,1,215,1,215,1,215,
  	1,215,1,215,1,215,1,215,1,216,1,216,1,216,1,216,1,216,1,216,1,216,1,217,
  	1,217,1,217,1,217,1,217,1,217,1,218,1,218,1,218,1,218,3,218,4225,8,218,
  	1,218,1,218,1,218,1,218,1,218,1,218,3,218,4233,8,218,1,218,1,218,1,218,
  	1,218,1,219,1,219,1,219,1,219,1,219,1,219,1,219,1,220,1,220,1,220,3,220,
  	4249,8,220,1,220,3,220,4252,8,220,1,221,1,221,3,221,4256,8,221,1,222,
  	1,222,3,222,4260,8,222,1,223,1,223,1,223,3,223,4265,8,223,1,224,1,224,
  	1,224,1,224,3,224,4271,8,224,1,224,3,224,4274,8,224,1,224,1,224,5,224,
  	4278,8,224,10,224,12,224,4281,9,224,1,224,1,224,3,224,4285,8,224,1,224,
  	1,224,1,224,3,224,4290,8,224,1,225,1,225,1,225,5,225,4295,8,225,10,225,
  	12,225,4298,9,225,1,226,5,226,4301,8,226,10,226,12,226,4304,9,226,1,226,
  	1,226,3,226,4308,8,226,3,226,4310,8,226,1,226,1,226,1,226,5,226,4315,
  	8,226,10,226,12,226,4318,9,226,1,226,1,226,3,226,4322,8,226,1,227,1,227,
  	1,228,1,228,3,228,4328,8,228,1,229,3,229,4331,8,229,1,229,1,229,1,229,
  	1,229,1,229,1,229,3,229,4339,8,229,1,229,1,229,1,230,1,230,1,230,1,230,
  	1,230,1,230,1,230,1,230,1,230,1,230,1,230,1,230,1,230,1,230,1,230,1,230,
  	1,230,1,230,1,230,1,230,1,230,1,230,1,230,1,230,1,230,1,230,1,230,1,230,
  	1,230,1,230,1,230,1,230,1,230,3,230,4376,8,230,1,230,1,230,1,230,1,230,
  	1,230,1,230,5,230,4384,8,230,10,230,12,230,4387,9,230,1,230,1,230,1,230,
  	1,230,1,230,1,230,1,230,1,230,1,230,1,230,1,230,1,230,1,230,1,230,1,230,
  	1,230,1,230,1,230,1,230,1,230,1,230,1,230,1,230,1,230,1,230,1,230,1,230,
  	1,230,1,230,1,230,1,230,1,230,1,230,1,230,1,230,1,230,1,230,1,230,1,230,
  	1,230,1,230,1,230,1,230,1,230,1,230,1,230,1,230,1,230,1,230,1,230,1,230,
  	1,230,1,230,1,230,1,230,1,230,1,230,1,230,1,230,1,230,1,230,1,230,1,230,
  	1,230,1,230,1,230,1,230,1,230,1,230,1,230,1,230,1,230,1,230,1,230,1,230,
  	1,230,1,230,1,230,1,230,1,230,1,230,1,230,3,230,4471,8,230,1,230,1,230,
  	1,230,1,230,1,230,1,230,1,230,1,230,1,230,1,230,1,230,1,230,1,230,1,230,
  	1,230,1,230,1,230,1,230,1,230,1,230,1,230,1,230,1,230,1,230,5,230,4497,
  	8,230,10,230,12,230,4500,9,230,1,231,1,231,1,231,5,231,4505,8,231,10,
  	231,12,231,4508,9,231,1,231,1,231,1,231,3,231,4513,8,231,1,231,1,231,
  	3,231,4517,8,231,1,231,1,231,3,231,4521,8,231,3,231,4523,8,231,1,232,
  	1,232,1,232,1,232,3,232,4529,8,232,1,232,3,232,4532,8,232,1,232,1,232,
  	5,232,4536,8,232,10,232,12,232,4539,9,232,1,232,1,232,3,232,4543,8,232,
  	1,232,1,232,1,232,3,232,4548,8,232,1,233,1,233,1,233,1,233,1,233,1,233,
  	5,233,4556,8,233,10,233,12,233,4559,9,233,1,233,1,233,3,233,4563,8,233,
  	1,233,1,233,1,233,1,233,5,233,4569,8,233,10,233,12,233,4572,9,233,1,233,
  	1,233,3,233,4576,8,233,1,233,1,233,3,233,4580,8,233,1,233,1,233,1,233,
  	1,233,5,233,4586,8,233,10,233,12,233,4589,9,233,1,233,1,233,3,233,4593,
  	8,233,1,233,1,233,1,233,1,233,1,233,5,233,4600,8,233,10,233,12,233,4603,
  	9,233,1,233,1,233,1,233,1,233,1,233,1,233,1,233,1,233,1,233,3,233,4614,
  	8,233,1,233,1,233,1,233,1,233,1,233,1,233,1,233,1,233,1,233,1,233,1,233,
  	1,233,1,233,1,233,1,233,1,233,1,233,1,233,5,233,4634,8,233,10,233,12,
  	233,4637,9,233,5,233,4639,8,233,10,233,12,233,4642,9,233,1,234,1,234,
  	1,234,1,234,1,234,1,234,1,234,1,234,1,234,1,234,1,234,1,234,1,234,1,234,
  	3,234,4658,8,234,1,235,1,235,1,235,1,235,1,236,1,236,1,236,3,236,4667,
  	8,236,1,237,1,237,1,237,5,237,4672,8,237,10,237,12,237,4675,9,237,1,238,
  	5,238,4678,8,238,10,238,12,238,4681,9,238,1,238,1,238,3,238,4685,8,238,
  	3,238,4687,8,238,1,238,1,238,1,238,5,238,4692,8,238,10,238,12,238,4695,
  	9,238,1,238,1,238,3,238,4699,8,238,1,239,1,239,1,239,3,239,4704,8,239,
  	1,240,1,240,1,240,3,240,4709,8,240,1,241,1,241,1,241,1,241,1,241,3,241,
  	4716,8,241,1,242,3,242,4719,8,242,1,243,3,243,4722,8,243,1,243,1,243,
  	5,243,4726,8,243,10,243,12,243,4729,9,243,1,243,1,243,1,243,1,243,1,243,
  	3,243,4736,8,243,1,243,1,243,5,243,4740,8,243,10,243,12,243,4743,9,243,
  	1,243,1,243,1,243,1,243,3,243,4749,8,243,1,243,1,243,1,243,1,243,1,243,
  	1,243,3,243,4757,8,243,1,243,1,243,5,243,4761,8,243,10,243,12,243,4764,
  	9,243,3,243,4766,8,243,1,244,1,244,3,244,4770,8,244,1,245,1,245,1,245,
  	5,245,4775,8,245,10,245,12,245,4778,9,245,1,245,1,245,1,245,1,245,1,245,
  	1,245,1,245,1,245,1,245,1,245,1,245,1,245,5,245,4792,8,245,10,245,12,
  	245,4795,9,245,3,245,4797,8,245,1,246,1,246,3,246,4801,8,246,1,247,1,
  	247,1,247,3,247,4806,8,247,1,248,1,248,1,248,1,248,1,248,1,248,1,248,
  	1,248,3,248,4816,8,248,1,249,1,249,1,249,1,249,1,250,1,250,1,250,1,250,
  	1,251,1,251,3,251,4828,8,251,1,252,1,252,1,252,1,252,1,252,1,252,1,252,
  	1,252,3,252,4838,8,252,1,253,1,253,1,253,1,253,1,253,1,253,3,253,4846,
  	8,253,1,254,1,254,1,254,1,254,1,255,1,255,1,255,1,255,3,255,4856,8,255,
  	1,255,3,255,4859,8,255,1,255,1,255,1,255,1,255,1,256,1,256,1,256,5,256,
  	4868,8,256,10,256,12,256,4871,9,256,1,257,5,257,4874,8,257,10,257,12,
  	257,4877,9,257,1,257,1,257,1,257,5,257,4882,8,257,10,257,12,257,4885,
  	9,257,1,257,1,257,3,257,4889,8,257,1,258,1,258,3,258,4893,8,258,1,259,
  	1,259,1,259,1,259,3,259,4899,8,259,1,259,3,259,4902,8,259,1,259,3,259,
  	4905,8,259,1,259,1,259,5,259,4909,8,259,10,259,12,259,4912,9,259,1,259,
  	1,259,1,259,3,259,4917,8,259,1,260,5,260,4920,8,260,10,260,12,260,4923,
  	9,260,1,260,1,260,1,260,1,260,3,260,4929,8,260,1,261,1,261,1,261,1,261,
  	1,261,1,261,1,261,1,261,1,261,1,261,3,261,4941,8,261,1,262,1,262,3,262,
  	4945,8,262,1,263,1,263,1,263,1,263,1,263,1,263,3,263,4953,8,263,1,263,
  	1,263,1,263,1,263,1,263,1,263,3,263,4961,8,263,1,264,1,264,1,264,1,264,
  	1,264,3,264,4968,8,264,1,264,1,264,1,264,5,264,4973,8,264,10,264,12,264,
  	4976,9,264,1,265,1,265,3,265,4980,8,265,1,265,1,265,1,265,1,265,1,265,
  	5,265,4987,8,265,10,265,12,265,4990,9,265,1,265,1,265,5,265,4994,8,265,
  	10,265,12,265,4997,9,265,1,265,3,265,5000,8,265,1,265,1,265,3,265,5004,
  	8,265,1,266,1,266,1,266,1,266,3,266,5010,8,266,1,266,1,266,1,266,1,266,
  	1,266,1,266,1,266,3,266,5019,8,266,1,266,1,266,1,267,1,267,5,267,5025,
  	8,267,10,267,12,267,5028,9,267,1,267,1,267,1,267,5,267,5033,8,267,10,
  	267,12,267,5036,9,267,1,267,1,267,3,267,5040,8,267,1,268,1,268,3,268,
  	5044,8,268,1,268,1,268,1,268,1,268,3,268,5050,8,268,1,268,3,268,5053,
  	8,268,1,268,1,268,1,268,1,268,1,268,1,268,1,268,1,268,1,268,3,268,5064,
  	8,268,1,268,1,268,1,268,1,268,1,268,3,268,5071,8,268,1,268,3,268,5074,
  	8,268,1,268,1,268,1,268,1,268,3,268,5080,8,268,1,268,3,268,5083,8,268,
  	1,268,1,268,1,268,1,268,1,268,1,268,1,268,3,268,5092,8,268,1,268,1,268,
  	1,268,1,268,1,268,3,268,5099,8,268,1,268,3,268,5102,8,268,1,268,1,268,
  	1,268,1,268,3,268,5108,8,268,1,268,3,268,5111,8,268,1,268,1,268,1,268,
  	1,268,1,268,1,268,1,268,3,268,5120,8,268,1,268,3,268,5123,8,268,1,268,
  	1,268,1,268,3,268,5128,8,268,1,268,1,268,1,268,1,268,1,268,1,268,1,268,
  	3,268,5137,8,268,1,268,1,268,1,268,1,268,3,268,5143,8,268,1,268,3,268,
  	5146,8,268,1,268,1,268,1,268,1,268,1,268,1,268,1,268,3,268,5155,8,268,
  	1,268,1,268,1,268,1,268,1,268,1,268,1,268,1,268,1,268,1,268,3,268,5167,
  	8,268,3,268,5169,8,268,1,269,1,269,1,269,3,269,5174,8,269,1,270,1,270,
  	1,270,5,270,5179,8,270,10,270,12,270,5182,9,270,1,271,1,271,1,271,1,271,
  	1,271,1,271,1,271,1,271,5,271,5192,8,271,10,271,12,271,5195,9,271,1,272,
  	1,272,1,272,5,272,5200,8,272,10,272,12,272,5203,9,272,1,273,1,273,1,273,
  	1,273,1,273,1,273,1,273,1,273,1,273,1,273,1,273,1,273,1,273,1,273,1,273,
  	1,273,3,273,5221,8,273,1,274,1,274,1,274,1,274,1,274,3,274,5228,8,274,
  	1,275,1,275,1,275,3,275,5233,8,275,1,275,1,275,1,275,1,275,1,275,1,275,
  	1,275,3,275,5242,8,275,1,275,1,275,1,276,1,276,1,276,1,276,1,276,5,276,
  	5251,8,276,10,276,12,276,5254,9,276,1,277,1,277,1,278,1,278,5,278,5260,
  	8,278,10,278,12,278,5263,9,278,1,278,1,278,3,278,5267,8,278,1,279,1,279,
  	1,279,1,279,3,279,5273,8,279,1,280,5,280,5276,8,280,10,280,12,280,5279,
  	9,280,1,280,1,280,3,280,5283,8,280,1,281,1,281,1,281,1,281,1,281,1,281,
  	1,281,1,281,1,281,3,281,5294,8,281,1,282,1,282,1,282,1,282,1,282,1,282,
  	1,282,1,282,1,282,1,282,1,282,1,282,1,282,3,282,5309,8,282,3,282,5311,
  	8,282,1,282,1,282,1,282,1,282,1,282,1,282,1,282,1,282,1,282,1,282,1,282,
  	3,282,5324,8,282,5,282,5326,8,282,10,282,12,282,5329,9,282,1,283,1,283,
  	1,283,1,283,1,283,1,283,1,283,1,283,1,283,3,283,5340,8,283,1,284,1,284,
  	1,284,3,284,5345,8,284,1,285,1,285,1,285,5,285,5350,8,285,10,285,12,285,
  	5353,9,285,1,286,1,286,3,286,5357,8,286,1,286,1,286,1,286,5,286,5362,
  	8,286,10,286,12,286,5365,9,286,1,286,1,286,1,286,1,286,3,286,5371,8,286,
  	1,286,3,286,5374,8,286,1,286,1,286,1,286,5,286,5379,8,286,10,286,12,286,
  	5382,9,286,1,286,1,286,1,286,1,286,3,286,5388,8,286,1,286,1,286,1,286,
  	5,286,5393,8,286,10,286,12,286,5396,9,286,1,286,1,286,1,286,1,286,3,286,
  	5402,8,286,1,286,3,286,5405,8,286,1,286,1,286,1,286,5,286,5410,8,286,
  	10,286,12,286,5413,9,286,1,286,1,286,1,286,1,286,3,286,5419,8,286,1,286,
  	3,286,5422,8,286,1,286,1,286,1,286,5,286,5427,8,286,10,286,12,286,5430,
  	9,286,1,286,1,286,1,286,1,286,3,286,5436,8,286,1,286,1,286,1,286,5,286,
  	5441,8,286,10,286,12,286,5444,9,286,1,286,1,286,1,286,1,286,1,286,1,286,
  	5,286,5452,8,286,10,286,12,286,5455,9,286,1,286,1,286,1,286,1,286,3,286,
  	5461,8,286,1,286,1,286,1,286,5,286,5466,8,286,10,286,12,286,5469,9,286,
  	1,286,1,286,1,286,1,286,3,286,5475,8,286,1,286,1,286,1,286,5,286,5480,
  	8,286,10,286,12,286,5483,9,286,1,286,1,286,3,286,5487,8,286,1,287,3,287,
  	5490,8,287,1,287,1,287,1,287,1,287,1,287,1,287,1,287,1,287,1,287,1,287,
  	1,288,3,288,5503,8,288,1,288,1,288,1,288,1,288,1,288,1,288,1,288,1,288,
  	1,289,3,289,5514,8,289,1,289,1,289,1,289,1,289,1,289,1,289,1,289,1,289,
  	1,290,3,290,5525,8,290,1,290,1,290,1,290,1,290,1,290,1,290,5,290,5533,
  	8,290,10,290,12,290,5536,9,290,1,290,1,290,1,291,3,291,5541,8,291,1,291,
  	1,291,1,291,1,291,5,291,5547,8,291,10,291,12,291,5550,9,291,1,291,1,291,
  	1,291,1,291,1,292,3,292,5557,8,292,1,292,1,292,1,292,1,292,1,292,1,292,
  	1,293,3,293,5566,8,293,1,293,1,293,1,293,1,293,1,293,1,293,1,293,1,293,
  	1,294,3,294,5577,8,294,1,294,1,294,1,294,1,294,1,295,1,295,1,295,1,295,
  	1,295,1,295,1,295,1,295,1,295,1,295,1,295,1,295,1,295,1,295,1,295,1,295,
  	3,295,5599,8,295,1,296,1,296,1,296,1,296,1,296,1,296,1,296,1,296,1,296,
  	1,296,1,296,1,296,1,296,1,296,1,296,1,296,3,296,5617,8,296,1,297,1,297,
  	3,297,5621,8,297,1,298,1,298,1,298,1,298,3,298,5627,8,298,1,299,1,299,
  	1,299,1,299,3,299,5633,8,299,1,300,1,300,1,300,1,300,1,300,1,300,3,300,
  	5641,8,300,1,301,1,301,3,301,5645,8,301,1,302,1,302,1,302,1,302,3,302,
  	5651,8,302,1,303,1,303,3,303,5655,8,303,1,304,1,304,3,304,5659,8,304,
  	1,304,1,304,1,304,5,304,5664,8,304,10,304,12,304,5667,9,304,1,304,1,304,
  	1,305,1,305,1,305,3,305,5674,8,305,1,305,1,305,1,305,1,305,3,305,5680,
  	8,305,1,306,1,306,1,306,5,306,5685,8,306,10,306,12,306,5688,9,306,1,306,
  	1,306,1,306,5,306,5693,8,306,10,306,12,306,5696,9,306,3,306,5698,8,306,
  	1,307,1,307,1,308,1,308,1,308,1,308,3,308,5706,8,308,1,308,1,308,1,309,
  	1,309,1,309,1,309,1,309,1,310,1,310,5,310,5717,8,310,10,310,12,310,5720,
  	9,310,1,311,1,311,1,311,5,311,5725,8,311,10,311,12,311,5728,9,311,1,311,
  	1,311,1,311,5,311,5733,8,311,10,311,12,311,5736,9,311,3,311,5738,8,311,
  	1,312,5,312,5741,8,312,10,312,12,312,5744,9,312,1,312,3,312,5747,8,312,
  	1,313,5,313,5750,8,313,10,313,12,313,5753,9,313,1,313,1,313,1,313,1,313,
  	3,313,5759,8,313,1,313,3,313,5762,8,313,1,313,3,313,5765,8,313,1,314,
  	1,314,1,314,1,314,1,314,1,314,1,314,1,315,1,315,1,315,3,315,5777,8,315,
  	1,315,1,315,1,315,3,315,5782,8,315,3,315,5784,8,315,1,316,5,316,5787,
  	8,316,10,316,12,316,5790,9,316,1,316,3,316,5793,8,316,1,317,5,317,5796,
  	8,317,10,317,12,317,5799,9,317,1,317,1,317,1,317,1,317,3,317,5805,8,317,
  	1,317,3,317,5808,8,317,1,317,3,317,5811,8,317,1,318,1,318,5,318,5815,
  	8,318,10,318,12,318,5818,9,318,1,318,1,318,1,319,1,319,1,319,1,319,1,
  	319,1,319,3,319,5828,8,319,1,319,1,319,3,319,5832,8,319,1,320,1,320,1,
  	320,1,320,1,320,1,320,1,320,3,320,5841,8,320,1,321,1,321,1,321,1,321,
  	1,321,1,321,5,321,5849,8,321,10,321,12,321,5852,9,321,1,321,1,321,1,322,
  	1,322,1,322,5,322,5859,8,322,10,322,12,322,5862,9,322,1,322,1,322,1,322,
  	1,322,1,322,3,322,5869,8,322,1,322,3,322,5872,8,322,1,323,1,323,1,323,
  	1,323,1,323,1,323,1,323,1,323,1,323,1,323,1,324,1,324,1,324,1,324,1,324,
  	1,324,1,324,1,324,1,324,1,324,3,324,5894,8,324,1,325,3,325,5897,8,325,
  	1,325,1,325,1,325,1,325,1,326,1,326,1,326,1,326,5,326,5907,8,326,10,326,
  	12,326,5910,9,326,1,326,1,326,1,326,3,326,5915,8,326,1,326,1,326,1,326,
  	1,326,3,326,5921,8,326,1,327,1,327,1,327,3,327,5926,8,327,1,327,5,327,
  	5929,8,327,10,327,12,327,5932,9,327,1,327,1,327,1,327,3,327,5937,8,327,
  	1,328,1,328,5,328,5941,8,328,10,328,12,328,5944,9,328,1,328,1,328,1,329,
  	1,329,1,329,1,329,1,329,1,329,1,329,1,329,1,329,3,329,5957,8,329,1,330,
  	1,330,1,330,1,330,1,330,1,330,1,330,3,330,5966,8,330,1,331,1,331,1,331,
  	1,331,1,331,1,331,5,331,5974,8,331,10,331,12,331,5977,9,331,1,331,1,331,
  	1,332,1,332,1,332,5,332,5984,8,332,10,332,12,332,5987,9,332,1,332,1,332,
  	1,332,1,332,1,332,3,332,5994,8,332,1,332,3,332,5997,8,332,1,333,1,333,
  	1,333,1,333,1,333,1,333,1,333,1,333,1,333,1,333,1,334,1,334,1,334,1,334,
  	5,334,6013,8,334,10,334,12,334,6016,9,334,1,334,1,334,1,334,3,334,6021,
  	8,334,1,334,1,334,1,334,1,334,3,334,6027,8,334,1,335,1,335,1,335,3,335,
  	6032,8,335,1,335,5,335,6035,8,335,10,335,12,335,6038,9,335,1,335,1,335,
  	1,335,3,335,6043,8,335,1,336,1,336,5,336,6047,8,336,10,336,12,336,6050,
  	9,336,1,336,1,336,1,337,1,337,1,337,1,337,1,337,1,337,1,337,1,337,1,337,
  	1,337,1,338,3,338,6065,8,338,1,338,1,338,1,338,1,338,1,339,1,339,1,339,
  	1,339,1,339,1,339,1,339,1,339,1,339,1,339,3,339,6081,8,339,1,340,1,340,
  	3,340,6085,8,340,1,341,1,341,1,341,1,341,1,341,1,341,1,341,1,341,3,341,
  	6095,8,341,1,342,1,342,1,342,1,342,1,342,4,342,6102,8,342,11,342,12,342,
  	6103,1,342,1,342,1,343,1,343,1,343,5,343,6111,8,343,10,343,12,343,6114,
  	9,343,1,343,1,343,1,343,1,343,1,343,3,343,6121,8,343,1,343,3,343,6124,
  	8,343,1,344,1,344,1,344,3,344,6129,8,344,1,344,1,344,1,344,1,344,3,344,
  	6135,8,344,1,344,5,344,6138,8,344,10,344,12,344,6141,9,344,1,344,1,344,
  	1,344,1,344,3,344,6147,8,344,1,345,1,345,5,345,6151,8,345,10,345,12,345,
  	6154,9,345,1,345,1,345,1,345,1,345,5,345,6160,8,345,10,345,12,345,6163,
  	9,345,1,345,1,345,1,345,3,345,6168,8,345,1,345,1,345,1,345,3,345,6173,
  	8,345,1,346,5,346,6176,8,346,10,346,12,346,6179,9,346,1,346,1,346,1,346,
  	1,346,1,346,1,346,1,346,1,347,5,347,6189,8,347,10,347,12,347,6192,9,347,
  	1,347,1,347,1,347,1,347,1,347,1,347,1,347,1,348,1,348,1,348,5,348,6204,
  	8,348,10,348,12,348,6207,9,348,1,348,1,348,1,348,1,348,3,348,6213,8,348,
  	1,348,1,348,1,348,1,348,1,348,3,348,6220,8,348,1,348,1,348,1,348,1,348,
  	1,348,5,348,6227,8,348,10,348,12,348,6230,9,348,1,348,1,348,1,348,1,348,
  	1,348,1,348,1,348,5,348,6239,8,348,10,348,12,348,6242,9,348,1,348,1,348,
  	1,348,1,348,3,348,6248,8,348,3,348,6250,8,348,1,349,1,349,1,349,1,349,
  	1,349,5,349,6257,8,349,10,349,12,349,6260,9,349,1,350,1,350,1,350,1,350,
  	1,350,5,350,6267,8,350,10,350,12,350,6270,9,350,1,351,1,351,1,351,1,351,
  	1,351,1,351,1,351,1,351,1,351,3,351,6281,8,351,1,352,5,352,6284,8,352,
  	10,352,12,352,6287,9,352,1,352,1,352,1,352,1,352,1,352,1,352,1,352,3,
  	352,6296,8,352,3,352,6298,8,352,1,353,5,353,6301,8,353,10,353,12,353,
  	6304,9,353,1,353,1,353,1,353,1,354,5,354,6310,8,354,10,354,12,354,6313,
  	9,354,1,354,1,354,1,354,1,355,1,355,3,355,6320,8,355,1,356,1,356,1,356,
  	5,356,6325,8,356,10,356,12,356,6328,9,356,1,356,1,356,1,357,1,357,1,357,
  	1,357,1,357,1,358,3,358,6338,8,358,1,358,1,358,1,358,5,358,6343,8,358,
  	10,358,12,358,6346,9,358,1,358,1,358,1,359,1,359,1,359,1,359,1,359,1,
  	359,1,360,1,360,1,360,1,360,1,360,1,360,1,360,1,360,1,360,3,360,6365,
  	8,360,1,361,1,361,1,361,1,361,1,361,1,361,1,361,1,362,1,362,3,362,6376,
  	8,362,1,363,1,363,5,363,6380,8,363,10,363,12,363,6383,9,363,1,364,5,364,
  	6386,8,364,10,364,12,364,6389,9,364,1,364,1,364,5,364,6393,8,364,10,364,
  	12,364,6396,9,364,1,365,1,365,4,365,6400,8,365,11,365,12,365,6401,1,365,
  	1,365,1,365,3,365,6407,8,365,1,366,1,366,3,366,6411,8,366,1,367,1,367,
  	1,368,1,368,1,369,1,369,1,370,1,370,3,370,6421,8,370,1,370,3,370,6424,
  	8,370,1,370,1,370,1,370,5,370,6429,8,370,10,370,12,370,6432,9,370,1,370,
  	1,370,1,371,3,371,6437,8,371,1,371,1,371,1,371,1,371,1,371,1,371,5,371,
  	6445,8,371,10,371,12,371,6448,9,371,1,371,1,371,1,372,1,372,3,372,6454,
  	8,372,1,372,3,372,6457,8,372,1,372,1,372,1,372,1,372,1,372,3,372,6464,
  	8,372,1,372,1,372,1,372,3,372,6469,8,372,1,373,1,373,1,373,5,373,6474,
  	8,373,10,373,12,373,6477,9,373,1,374,1,374,1,374,5,374,6482,8,374,10,
  	374,12,374,6485,9,374,1,375,1,375,1,375,1,375,4,375,6491,8,375,11,375,
  	12,375,6492,1,375,1,375,1,376,1,376,1,376,1,376,1,377,1,377,1,377,1,378,
  	1,378,1,378,1,379,1,379,1,380,1,380,1,380,1,380,1,380,1,380,1,380,1,380,
  	1,380,1,380,1,380,1,380,1,380,1,380,3,380,6523,8,380,1,380,1,380,3,380,
  	6527,8,380,1,380,1,380,1,380,1,380,1,380,3,380,6534,8,380,1,381,1,381,
  	1,381,1,381,1,382,1,382,1,383,1,383,1,383,3,383,6545,8,383,1,383,1,383,
  	1,384,1,384,1,384,1,384,1,384,1,384,1,384,3,384,6556,8,384,1,384,1,384,
  	1,384,3,384,6561,8,384,3,384,6563,8,384,1,385,1,385,1,385,1,385,1,386,
  	1,386,3,386,6571,8,386,1,386,1,386,3,386,6575,8,386,1,387,1,387,1,387,
  	3,387,6580,8,387,1,387,5,387,6583,8,387,10,387,12,387,6586,9,387,1,387,
  	5,387,6589,8,387,10,387,12,387,6592,9,387,1,387,1,387,1,387,3,387,6597,
  	8,387,1,388,1,388,1,388,3,388,6602,8,388,1,388,5,388,6605,8,388,10,388,
  	12,388,6608,9,388,1,388,5,388,6611,8,388,10,388,12,388,6614,9,388,1,388,
  	1,388,1,388,3,388,6619,8,388,1,388,1,388,3,388,6623,8,388,1,389,1,389,
  	1,390,1,390,1,391,1,391,1,392,1,392,5,392,6633,8,392,10,392,12,392,6636,
  	9,392,1,392,3,392,6639,8,392,1,393,1,393,1,393,3,393,6644,8,393,1,393,
  	5,393,6647,8,393,10,393,12,393,6650,9,393,1,393,1,393,1,394,1,394,1,394,
  	1,394,1,394,1,394,1,394,1,394,1,394,1,394,1,394,1,394,1,394,1,394,1,394,
  	1,394,1,394,1,394,1,394,1,394,1,394,1,394,1,394,1,394,1,394,1,394,1,394,
  	1,394,1,394,1,394,1,394,3,394,6685,8,394,1,395,1,395,5,395,6689,8,395,
  	10,395,12,395,6692,9,395,1,395,3,395,6695,8,395,1,396,1,396,1,396,1,397,
  	1,397,1,397,1,397,1,397,1,397,1,397,1,397,3,397,6708,8,397,1,398,1,398,
  	1,398,1,398,1,398,1,398,3,398,6716,8,398,1,399,1,399,1,399,1,399,1,399,
  	1,399,1,399,1,399,1,399,3,399,6727,8,399,1,400,1,400,3,400,6731,8,400,
  	1,400,1,400,1,400,3,400,6736,8,400,1,400,1,400,1,400,3,400,6741,8,400,
  	1,400,1,400,1,400,1,400,3,400,6747,8,400,1,400,1,400,1,400,3,400,6752,
  	8,400,1,400,1,400,5,400,6756,8,400,10,400,12,400,6759,9,400,1,401,1,401,
  	1,402,1,402,1,403,1,403,1,403,3,403,6768,8,403,1,404,1,404,3,404,6772,
  	8,404,1,404,1,404,1,404,1,404,1,404,3,404,6779,8,404,1,405,1,405,1,405,
  	1,406,1,406,1,406,1,406,1,406,1,406,1,406,1,406,3,406,6792,8,406,1,406,
  	1,406,1,406,1,406,3,406,6798,8,406,1,406,1,406,1,406,3,406,6803,8,406,
  	5,406,6805,8,406,10,406,12,406,6808,9,406,1,406,1,406,1,406,3,406,6813,
  	8,406,1,407,1,407,1,407,3,407,6818,8,407,1,407,1,407,1,407,1,407,3,407,
  	6824,8,407,1,407,1,407,3,407,6828,8,407,1,407,1,407,3,407,6832,8,407,
  	1,408,1,408,1,408,1,408,3,408,6838,8,408,1,408,1,408,1,409,3,409,6843,
  	8,409,1,409,1,409,1,409,1,409,1,409,1,409,1,409,1,409,3,409,6853,8,409,
  	1,410,1,410,1,411,1,411,1,411,5,411,6860,8,411,10,411,12,411,6863,9,411,
  	1,412,1,412,1,412,1,412,3,412,6869,8,412,1,413,1,413,1,414,3,414,6874,
  	8,414,1,414,1,414,1,414,1,414,1,414,1,414,5,414,6882,8,414,10,414,12,
  	414,6885,9,414,1,414,1,414,1,414,5,414,6890,8,414,10,414,12,414,6893,
  	9,414,1,414,1,414,1,414,5,414,6898,8,414,10,414,12,414,6901,9,414,3,414,
  	6903,8,414,1,414,1,414,1,415,1,415,1,416,1,416,1,416,5,416,6912,8,416,
  	10,416,12,416,6915,9,416,1,416,1,416,1,416,1,416,1,416,3,416,6922,8,416,
  	1,416,3,416,6925,8,416,1,417,1,417,1,417,3,417,6930,8,417,1,417,1,417,
  	1,417,1,417,1,417,3,417,6937,8,417,1,417,3,417,6940,8,417,1,418,1,418,
  	1,418,1,418,1,418,1,418,3,418,6948,8,418,1,418,3,418,6951,8,418,1,419,
  	1,419,1,419,5,419,6956,8,419,10,419,12,419,6959,9,419,1,419,1,419,1,420,
  	1,420,1,420,1,420,1,421,1,421,1,421,1,421,1,421,1,421,1,421,3,421,6974,
  	8,421,1,421,1,421,1,421,1,421,1,421,5,421,6981,8,421,10,421,12,421,6984,
  	9,421,1,421,1,421,1,421,1,421,1,421,1,421,1,421,1,421,1,421,1,421,1,421,
  	1,421,5,421,6998,8,421,10,421,12,421,7001,9,421,1,421,1,421,3,421,7005,
  	8,421,1,422,1,422,1,422,1,422,1,422,5,422,7012,8,422,10,422,12,422,7015,
  	9,422,1,422,1,422,1,422,1,422,1,422,1,422,1,422,1,422,1,422,1,422,1,422,
  	1,422,5,422,7029,8,422,10,422,12,422,7032,9,422,1,422,1,422,1,422,1,422,
  	1,422,1,422,1,422,1,422,1,422,1,422,1,422,1,422,5,422,7046,8,422,10,422,
  	12,422,7049,9,422,1,422,1,422,1,422,1,422,1,422,1,422,1,422,1,422,1,422,
  	1,422,5,422,7061,8,422,10,422,12,422,7064,9,422,1,422,1,422,5,422,7068,
  	8,422,10,422,12,422,7071,9,422,1,422,3,422,7074,8,422,1,422,1,422,1,422,
  	1,422,1,422,3,422,7081,8,422,1,423,1,423,3,423,7085,8,423,1,424,1,424,
  	3,424,7089,8,424,1,425,1,425,3,425,7093,8,425,1,426,3,426,7096,8,426,
  	1,426,1,426,1,427,1,427,1,427,1,427,3,427,7104,8,427,1,428,1,428,1,429,
  	1,429,1,429,1,429,1,429,5,429,7113,8,429,10,429,12,429,7116,9,429,1,429,
  	1,429,1,430,1,430,1,430,1,430,1,430,5,430,7125,8,430,10,430,12,430,7128,
  	9,430,1,430,1,430,1,431,1,431,1,431,1,431,1,431,1,431,1,431,1,431,1,431,
  	1,431,1,431,3,431,7143,8,431,1,431,1,431,3,431,7147,8,431,1,431,1,431,
  	3,431,7151,8,431,1,431,1,431,1,431,1,431,1,431,1,431,1,431,1,431,1,431,
  	1,431,1,431,1,431,1,431,1,431,1,431,1,431,1,431,1,431,1,431,1,431,3,431,
  	7173,8,431,1,431,1,431,1,431,3,431,7178,8,431,1,432,1,432,1,432,1,432,
  	5,432,7184,8,432,10,432,12,432,7187,9,432,3,432,7189,8,432,1,433,3,433,
  	7192,8,433,1,433,1,433,1,433,1,433,1,433,1,433,1,433,1,433,1,433,5,433,
  	7203,8,433,10,433,12,433,7206,9,433,1,434,1,434,1,434,5,434,7211,8,434,
  	10,434,12,434,7214,9,434,1,435,1,435,1,435,3,435,7219,8,435,1,436,1,436,
  	1,437,3,437,7224,8,437,1,437,1,437,3,437,7228,8,437,5,437,7230,8,437,
  	10,437,12,437,7233,9,437,1,438,1,438,1,438,1,438,1,438,1,438,1,438,1,
  	438,1,438,1,438,3,438,7245,8,438,1,439,1,439,3,439,7249,8,439,1,440,1,
  	440,1,440,3,440,7254,8,440,1,440,1,440,1,441,1,441,1,441,3,441,7261,8,
  	441,1,442,1,442,3,442,7265,8,442,1,443,1,443,1,443,3,443,7270,8,443,1,
  	444,1,444,1,444,1,444,1,444,1,444,1,445,1,445,1,445,1,445,1,445,1,445,
  	1,446,1,446,1,446,1,446,1,446,1,446,1,447,1,447,1,447,3,447,7293,8,447,
  	1,448,1,448,1,448,1,448,1,448,1,448,1,448,1,448,1,448,1,448,1,448,1,448,
  	3,448,7307,8,448,1,449,1,449,1,449,1,449,1,449,1,449,1,449,1,449,1,449,
  	1,449,1,449,1,449,1,449,1,449,3,449,7323,8,449,1,450,1,450,1,450,1,450,
  	1,450,1,450,1,450,1,450,1,450,1,450,1,450,1,450,1,450,1,450,3,450,7339,
  	8,450,1,451,3,451,7342,8,451,1,451,1,451,3,451,7346,8,451,1,451,1,451,
  	1,451,5,451,7351,8,451,10,451,12,451,7354,9,451,1,451,1,451,1,451,3,451,
  	7359,8,451,1,451,1,451,1,451,3,451,7364,8,451,1,451,1,451,1,451,1,451,
  	1,451,3,451,7371,8,451,3,451,7373,8,451,1,452,1,452,1,452,1,452,1,452,
  	1,452,1,452,3,452,7382,8,452,1,453,1,453,1,453,1,453,1,453,1,453,1,453,
  	1,453,1,453,5,453,7393,8,453,10,453,12,453,7396,9,453,1,453,3,453,7399,
  	8,453,1,454,1,454,1,454,1,454,1,454,1,454,1,454,1,454,1,454,3,454,7410,
  	8,454,1,455,1,455,3,455,7414,8,455,1,455,1,455,3,455,7418,8,455,1,455,
  	1,455,3,455,7422,8,455,1,455,1,455,3,455,7426,8,455,1,455,3,455,7429,
  	8,455,1,456,1,456,1,456,5,456,7434,8,456,10,456,12,456,7437,9,456,1,457,
  	1,457,1,457,3,457,7442,8,457,1,458,1,458,3,458,7446,8,458,1,458,3,458,
  	7449,8,458,1,459,1,459,1,460,1,460,1,460,3,460,7456,8,460,1,460,1,460,
  	1,460,1,460,1,460,1,460,1,460,3,460,7465,8,460,1,461,1,461,1,461,1,461,
  	1,461,1,461,1,461,1,461,1,461,1,461,3,461,7477,8,461,1,462,3,462,7480,
  	8,462,1,462,1,462,1,462,1,462,1,462,5,462,7487,8,462,10,462,12,462,7490,
  	9,462,1,462,1,462,5,462,7494,8,462,10,462,12,462,7497,9,462,1,463,1,463,
  	1,463,1,464,1,464,1,464,3,464,7505,8,464,1,464,1,464,1,464,5,464,7510,
  	8,464,10,464,12,464,7513,9,464,1,464,1,464,1,465,3,465,7518,8,465,1,465,
  	1,465,1,465,1,465,1,465,3,465,7525,8,465,1,465,1,465,1,465,1,465,5,465,
  	7531,8,465,10,465,12,465,7534,9,465,1,465,1,465,1,466,1,466,1,466,1,466,
  	3,466,7542,8,466,3,466,7544,8,466,1,467,1,467,5,467,7548,8,467,10,467,
  	12,467,7551,9,467,1,467,1,467,1,467,1,467,1,467,1,467,3,467,7559,8,467,
  	1,467,1,467,1,467,5,467,7564,8,467,10,467,12,467,7567,9,467,3,467,7569,
  	8,467,1,468,1,468,5,468,7573,8,468,10,468,12,468,7576,9,468,1,468,5,468,
  	7579,8,468,10,468,12,468,7582,9,468,1,468,1,468,1,469,1,469,1,469,1,469,
  	1,469,3,469,7591,8,469,1,470,1,470,1,470,1,470,1,470,3,470,7598,8,470,
  	1,471,1,471,1,471,1,471,1,471,1,471,1,471,3,471,7607,8,471,1,472,1,472,
  	1,472,1,472,1,472,1,472,1,473,1,473,1,473,1,473,1,473,1,473,5,473,7621,
  	8,473,10,473,12,473,7624,9,473,1,473,1,473,1,474,1,474,1,474,5,474,7631,
  	8,474,10,474,12,474,7634,9,474,1,474,1,474,1,474,1,474,1,474,3,474,7641,
  	8,474,1,474,3,474,7644,8,474,1,475,1,475,5,475,7648,8,475,10,475,12,475,
  	7651,9,475,1,475,1,475,1,476,1,476,1,476,1,476,1,476,3,476,7660,8,476,
  	1,477,1,477,1,477,1,477,1,477,1,477,1,477,1,477,3,477,7670,8,477,1,478,
  	1,478,1,478,1,478,1,478,1,478,1,478,1,478,3,478,7680,8,478,1,479,1,479,
  	1,479,1,479,1,479,1,479,1,479,1,479,1,479,3,479,7691,8,479,1,480,1,480,
  	1,480,1,480,1,480,1,480,1,480,1,480,3,480,7701,8,480,1,481,1,481,1,481,
  	3,481,7706,8,481,1,481,1,481,1,481,1,481,1,482,1,482,1,482,3,482,7715,
  	8,482,1,482,1,482,1,482,1,482,1,483,1,483,1,483,5,483,7724,8,483,10,483,
  	12,483,7727,9,483,1,484,1,484,1,484,5,484,7732,8,484,10,484,12,484,7735,
  	9,484,1,485,1,485,1,485,1,485,1,485,3,485,7742,8,485,1,485,1,485,1,485,
  	1,485,3,485,7748,8,485,1,486,1,486,1,486,1,486,1,486,3,486,7755,8,486,
  	1,486,1,486,1,486,1,486,3,486,7761,8,486,1,487,1,487,1,487,1,487,1,487,
  	3,487,7768,8,487,1,488,1,488,1,488,1,488,1,488,1,488,1,488,1,488,1,488,
  	1,488,1,488,1,488,1,488,1,488,1,488,1,488,1,488,1,488,1,488,1,488,1,488,
  	1,488,1,488,1,488,1,488,1,488,1,488,1,488,1,488,1,488,1,488,1,488,1,488,
  	1,488,1,488,1,488,1,488,1,488,1,488,1,488,1,488,1,488,1,488,1,488,1,488,
  	1,488,1,488,3,488,7817,8,488,1,489,1,489,1,490,1,490,1,491,1,491,1,492,
  	1,492,1,493,1,493,1,494,1,494,1,495,1,495,1,496,1,496,1,497,1,497,1,498,
  	1,498,1,499,1,499,1,500,1,500,1,501,1,501,1,502,1,502,1,503,1,503,1,504,
  	1,504,1,505,1,505,1,506,1,506,1,506,1,506,1,506,1,506,1,506,1,506,3,506,
  	7861,8,506,1,507,1,507,3,507,7865,8,507,1,507,1,507,1,507,1,507,1,507,
  	1,507,1,507,1,507,1,507,1,508,1,508,3,508,7878,8,508,1,508,1,508,1,508,
  	1,508,1,508,1,508,1,508,1,508,1,508,1,509,1,509,1,509,1,509,1,509,1,509,
  	1,509,1,509,1,509,1,509,1,509,1,509,1,509,1,509,3,509,7903,8,509,1,510,
  	1,510,1,510,1,510,1,510,1,510,1,510,1,510,1,510,1,510,1,510,1,510,3,510,
  	7917,8,510,1,511,1,511,1,511,1,511,1,511,1,511,1,511,1,511,1,511,1,511,
  	3,511,7929,8,511,3,511,7931,8,511,1,511,1,511,1,511,1,512,1,512,1,512,
  	1,512,1,512,1,512,1,512,1,512,1,512,1,512,3,512,7946,8,512,3,512,7948,
  	8,512,1,512,1,512,1,512,1,513,1,513,1,513,1,513,1,513,1,513,1,513,1,513,
  	1,513,1,513,1,513,1,513,3,513,7965,8,513,1,513,1,513,3,513,7969,8,513,
  	1,513,1,513,3,513,7973,8,513,1,513,1,513,3,513,7977,8,513,1,513,1,513,
  	3,513,7981,8,513,3,513,7983,8,513,3,513,7985,8,513,3,513,7987,8,513,3,
  	513,7989,8,513,3,513,7991,8,513,1,513,1,513,1,513,1,514,1,514,1,514,1,
  	514,1,514,1,514,1,514,1,514,1,514,1,514,3,514,8006,8,514,3,514,8008,8,
  	514,1,514,1,514,1,514,1,515,1,515,1,515,1,515,1,515,1,515,1,515,1,515,
  	1,515,1,515,3,515,8023,8,515,3,515,8025,8,515,1,515,1,515,1,515,1,516,
  	1,516,1,516,1,516,1,516,1,516,1,516,1,516,1,516,1,516,1,516,1,516,3,516,
  	8042,8,516,1,516,1,516,3,516,8046,8,516,1,516,1,516,3,516,8050,8,516,
  	1,516,1,516,3,516,8054,8,516,1,516,1,516,3,516,8058,8,516,3,516,8060,
  	8,516,3,516,8062,8,516,3,516,8064,8,516,3,516,8066,8,516,3,516,8068,8,
  	516,1,516,1,516,1,516,1,517,1,517,1,517,1,517,1,517,1,517,1,517,1,517,
  	1,517,1,517,3,517,8083,8,517,3,517,8085,8,517,1,517,1,517,1,517,1,518,
  	1,518,1,518,1,518,1,518,1,518,1,518,1,518,1,518,1,518,3,518,8100,8,518,
  	1,518,1,518,3,518,8104,8,518,1,518,1,518,3,518,8108,8,518,3,518,8110,
  	8,518,3,518,8112,8,518,3,518,8114,8,518,1,518,1,518,1,518,1,519,1,519,
  	1,519,1,519,1,519,1,519,1,519,1,519,1,519,1,519,1,519,1,519,3,519,8131,
  	8,519,1,519,1,519,3,519,8135,8,519,1,519,1,519,3,519,8139,8,519,3,519,
  	8141,8,519,3,519,8143,8,519,3,519,8145,8,519,1,519,1,519,1,519,1,520,
  	1,520,1,520,1,520,1,520,1,520,1,520,1,520,3,520,8158,8,520,3,520,8160,
  	8,520,1,520,1,520,1,520,1,521,1,521,1,521,1,521,1,521,1,521,1,521,1,521,
  	1,521,1,521,3,521,8175,8,521,3,521,8177,8,521,1,521,1,521,1,521,1,522,
  	1,522,1,522,1,522,1,522,1,522,1,522,1,522,1,522,1,522,1,522,1,522,3,522,
  	8194,8,522,3,522,8196,8,522,1,522,1,522,1,522,1,523,1,523,1,523,1,523,
  	1,523,3,523,8206,8,523,1,524,1,524,1,524,1,524,1,524,3,524,8213,8,524,
  	1,525,1,525,1,526,1,526,1,527,1,527,1,528,1,528,1,529,1,529,1,530,1,530,
  	1,531,1,531,1,532,1,532,1,533,1,533,1,534,3,534,8234,8,534,1,534,1,534,
  	1,534,3,534,8239,8,534,1,535,1,535,1,535,1,535,3,535,8245,8,535,1,536,
  	1,536,1,536,3,536,8250,8,536,1,537,1,537,3,537,8254,8,537,1,538,1,538,
  	1,538,1,538,1,538,5,538,8261,8,538,10,538,12,538,8264,9,538,1,538,1,538,
  	1,539,1,539,1,539,1,539,1,539,3,539,8273,8,539,1,540,1,540,1,540,1,540,
  	1,540,3,540,8280,8,540,1,541,1,541,1,541,1,541,1,541,1,541,1,541,1,541,
  	1,541,1,541,1,541,1,541,1,541,1,541,1,541,1,541,1,541,1,541,1,541,3,541,
  	8301,8,541,1,542,1,542,1,542,1,542,1,542,1,542,1,542,1,542,1,542,3,542,
  	8312,8,542,1,543,1,543,1,543,1,543,5,543,8318,8,543,10,543,12,543,8321,
  	9,543,1,543,1,543,1,543,1,543,1,543,1,543,1,543,1,543,1,543,1,543,1,543,
  	5,543,8334,8,543,10,543,12,543,8337,9,543,1,543,1,543,3,543,8341,8,543,
  	1,544,1,544,1,544,1,544,5,544,8347,8,544,10,544,12,544,8350,9,544,1,544,
  	1,544,1,544,1,544,1,544,1,544,1,544,1,544,1,544,1,544,1,544,5,544,8363,
  	8,544,10,544,12,544,8366,9,544,1,544,1,544,3,544,8370,8,544,1,545,1,545,
  	1,545,3,545,8375,8,545,1,546,1,546,1,546,1,546,1,546,1,547,1,547,1,547,
  	1,547,5,547,8386,8,547,10,547,12,547,8389,9,547,1,547,1,547,1,548,1,548,
  	1,548,1,548,1,548,1,549,1,549,1,549,1,549,1,549,1,550,1,550,1,550,3,550,
  	8406,8,550,1,550,1,550,1,550,1,551,1,551,1,552,1,552,3,552,8415,8,552,
  	1,553,1,553,1,553,1,553,5,553,8421,8,553,10,553,12,553,8424,9,553,1,553,
  	1,553,1,554,1,554,1,554,1,554,1,554,1,554,3,554,8434,8,554,1,555,1,555,
  	1,555,1,555,1,555,3,555,8441,8,555,1,556,1,556,1,556,1,557,1,557,1,557,
  	1,557,1,557,1,557,3,557,8452,8,557,1,557,3,557,8455,8,557,1,557,1,557,
  	1,557,1,557,1,557,5,557,8462,8,557,10,557,12,557,8465,9,557,1,557,5,557,
  	8468,8,557,10,557,12,557,8471,9,557,1,557,1,557,1,557,1,557,1,557,3,557,
  	8478,8,557,1,557,1,557,3,557,8482,8,557,1,557,3,557,8485,8,557,1,558,
  	3,558,8488,8,558,1,559,3,559,8491,8,559,1,559,1,559,5,559,8495,8,559,
  	10,559,12,559,8498,9,559,1,559,1,559,1,559,1,559,1,559,3,559,8505,8,559,
  	1,559,1,559,5,559,8509,8,559,10,559,12,559,8512,9,559,1,559,1,559,1,559,
  	1,559,3,559,8518,8,559,1,559,1,559,1,559,1,559,1,559,1,559,3,559,8526,
  	8,559,1,559,1,559,5,559,8530,8,559,10,559,12,559,8533,9,559,3,559,8535,
  	8,559,1,560,1,560,1,560,1,560,1,560,1,560,1,560,1,560,3,560,8545,8,560,
  	1,561,1,561,5,561,8549,8,561,10,561,12,561,8552,9,561,1,561,1,561,1,561,
  	1,561,3,561,8558,8,561,1,561,3,561,8561,8,561,1,562,1,562,3,562,8565,
  	8,562,1,563,1,563,5,563,8569,8,563,10,563,12,563,8572,9,563,1,563,1,563,
  	1,563,1,563,3,563,8578,8,563,1,563,1,563,1,563,1,563,1,563,3,563,8585,
  	8,563,1,564,1,564,5,564,8589,8,564,10,564,12,564,8592,9,564,1,564,1,564,
  	1,564,3,564,8597,8,564,1,564,3,564,8600,8,564,1,564,1,564,1,564,3,564,
  	8605,8,564,1,564,3,564,8608,8,564,1,564,3,564,8611,8,564,1,565,1,565,
  	1,565,3,565,8616,8,565,1,565,3,565,8619,8,565,1,565,1,565,1,565,1,565,
  	1,565,5,565,8626,8,565,10,565,12,565,8629,9,565,1,565,1,565,5,565,8633,
  	8,565,10,565,12,565,8636,9,565,1,565,1,565,3,565,8640,8,565,1,566,1,566,
  	1,566,1,566,1,566,3,566,8647,8,566,1,567,1,567,1,568,1,568,1,569,1,569,
  	1,570,1,570,1,571,1,571,5,571,8659,8,571,10,571,12,571,8662,9,571,1,571,
  	1,571,1,571,1,571,5,571,8668,8,571,10,571,12,571,8671,9,571,1,571,1,571,
  	3,571,8675,8,571,1,572,1,572,1,572,1,572,5,572,8681,8,572,10,572,12,572,
  	8684,9,572,1,572,1,572,3,572,8688,8,572,1,572,1,572,1,572,5,572,8693,
  	8,572,10,572,12,572,8696,9,572,1,572,1,572,1,572,1,572,5,572,8702,8,572,
  	10,572,12,572,8705,9,572,1,572,1,572,1,572,1,572,5,572,8711,8,572,10,
  	572,12,572,8714,9,572,1,572,1,572,1,572,1,572,5,572,8720,8,572,10,572,
  	12,572,8723,9,572,1,572,1,572,1,572,1,572,5,572,8729,8,572,10,572,12,
  	572,8732,9,572,1,572,1,572,1,572,1,572,5,572,8738,8,572,10,572,12,572,
  	8741,9,572,1,572,1,572,1,572,1,572,5,572,8747,8,572,10,572,12,572,8750,
  	9,572,1,572,1,572,1,572,1,572,5,572,8756,8,572,10,572,12,572,8759,9,572,
  	1,572,1,572,1,572,1,572,5,572,8765,8,572,10,572,12,572,8768,9,572,1,572,
  	1,572,1,572,1,572,5,572,8774,8,572,10,572,12,572,8777,9,572,1,572,1,572,
  	1,572,1,572,5,572,8783,8,572,10,572,12,572,8786,9,572,1,572,1,572,1,572,
  	1,572,5,572,8792,8,572,10,572,12,572,8795,9,572,1,572,1,572,5,572,8799,
  	8,572,10,572,12,572,8802,9,572,1,572,1,572,1,572,1,572,1,572,1,572,1,
  	572,5,572,8811,8,572,10,572,12,572,8814,9,572,1,572,5,572,8817,8,572,
  	10,572,12,572,8820,9,572,1,573,1,573,1,574,1,574,1,574,1,574,1,574,1,
  	574,3,574,8830,8,574,1,575,1,575,1,575,3,575,8835,8,575,1,576,1,576,1,
  	576,3,576,8840,8,576,1,577,1,577,3,577,8844,8,577,1,578,1,578,3,578,8848,
  	8,578,1,579,1,579,1,579,1,579,1,580,1,580,1,580,1,580,1,581,1,581,1,581,
  	1,581,1,581,1,581,1,581,1,581,5,581,8866,8,581,10,581,12,581,8869,9,581,
  	1,581,1,581,1,581,5,581,8874,8,581,10,581,12,581,8877,9,581,1,581,1,581,
  	1,581,5,581,8882,8,581,10,581,12,581,8885,9,581,1,581,1,581,1,581,1,581,
  	1,581,1,581,1,581,1,581,1,581,1,581,1,581,1,581,1,581,1,581,5,581,8901,
  	8,581,10,581,12,581,8904,9,581,1,581,1,581,1,581,5,581,8909,8,581,10,
  	581,12,581,8912,9,581,1,581,1,581,1,581,1,581,1,581,1,581,1,581,3,581,
  	8921,8,581,3,581,8923,8,581,1,581,1,581,1,581,5,581,8928,8,581,10,581,
  	12,581,8931,9,581,1,581,1,581,1,581,1,581,5,581,8937,8,581,10,581,12,
  	581,8940,9,581,1,581,1,581,1,581,1,581,5,581,8946,8,581,10,581,12,581,
  	8949,9,581,1,581,1,581,1,581,1,581,5,581,8955,8,581,10,581,12,581,8958,
  	9,581,1,581,1,581,1,581,1,581,5,581,8964,8,581,10,581,12,581,8967,9,581,
  	1,581,1,581,1,581,1,581,5,581,8973,8,581,10,581,12,581,8976,9,581,1,581,
  	1,581,1,581,1,581,5,581,8982,8,581,10,581,12,581,8985,9,581,1,581,1,581,
  	1,581,1,581,5,581,8991,8,581,10,581,12,581,8994,9,581,1,581,1,581,1,581,
  	1,581,5,581,9000,8,581,10,581,12,581,9003,9,581,1,581,1,581,1,581,1,581,
  	5,581,9009,8,581,10,581,12,581,9012,9,581,1,581,1,581,1,581,1,581,5,581,
  	9018,8,581,10,581,12,581,9021,9,581,1,581,1,581,1,581,1,581,5,581,9027,
  	8,581,10,581,12,581,9030,9,581,1,581,1,581,5,581,9034,8,581,10,581,12,
  	581,9037,9,581,1,581,1,581,1,581,1,581,1,581,1,581,1,581,5,581,9046,8,
  	581,10,581,12,581,9049,9,581,1,581,1,581,1,581,1,581,1,581,1,581,5,581,
  	9057,8,581,10,581,12,581,9060,9,581,1,581,1,581,5,581,9064,8,581,10,581,
  	12,581,9067,9,581,1,581,1,581,1,581,1,581,1,581,1,581,1,581,1,581,1,581,
  	1,581,5,581,9079,8,581,10,581,12,581,9082,9,581,1,582,1,582,1,582,1,582,
  	1,582,1,582,1,582,3,582,9091,8,582,1,583,1,583,1,583,1,583,1,583,1,583,
  	3,583,9099,8,583,1,584,1,584,1,584,1,584,5,584,9105,8,584,10,584,12,584,
  	9108,9,584,1,584,1,584,3,584,9112,8,584,1,584,1,584,1,584,5,584,9117,
  	8,584,10,584,12,584,9120,9,584,1,584,1,584,1,584,1,584,1,584,5,584,9127,
  	8,584,10,584,12,584,9130,9,584,1,584,1,584,1,584,1,584,5,584,9136,8,584,
  	10,584,12,584,9139,9,584,1,585,1,585,1,585,1,585,1,585,1,585,3,585,9147,
  	8,585,1,586,1,586,3,586,9151,8,586,1,587,1,587,3,587,9155,8,587,1,588,
  	1,588,1,589,1,589,1,590,1,590,1,590,1,590,1,591,1,591,1,591,3,591,9168,
  	8,591,1,591,1,591,1,591,1,591,1,591,1,591,3,591,9176,8,591,1,591,1,591,
  	1,591,1,591,1,591,3,591,9183,8,591,1,591,1,591,1,591,1,591,1,591,3,591,
  	9190,8,591,1,591,1,591,1,591,1,591,1,591,1,591,1,591,1,591,1,591,1,591,
  	1,591,1,591,3,591,9204,8,591,1,591,1,591,3,591,9208,8,591,1,592,1,592,
  	1,592,1,592,1,592,1,592,1,592,1,592,1,592,3,592,9219,8,592,1,593,1,593,
  	1,593,1,593,1,593,1,593,1,593,1,593,3,593,9229,8,593,1,593,3,593,9232,
  	8,593,1,593,1,593,1,593,1,593,1,593,5,593,9239,8,593,10,593,12,593,9242,
  	9,593,1,593,1,593,5,593,9246,8,593,10,593,12,593,9249,9,593,1,593,5,593,
  	9252,8,593,10,593,12,593,9255,9,593,1,593,1,593,1,593,1,593,1,593,3,593,
  	9262,8,593,1,593,1,593,3,593,9266,8,593,1,594,1,594,1,594,1,594,3,594,
  	9272,8,594,1,594,1,594,1,594,1,594,3,594,9278,8,594,1,594,1,594,1,594,
  	1,594,1,594,1,594,1,594,1,594,1,594,1,594,1,594,1,594,1,594,1,594,1,594,
  	1,594,1,594,1,594,1,594,1,594,1,594,3,594,9301,8,594,1,595,1,595,1,596,
  	1,596,1,597,1,597,1,598,1,598,1,598,1,599,1,599,1,599,1,599,1,600,1,600,
  	1,601,1,601,1,601,1,601,3,601,9322,8,601,1,602,1,602,1,603,1,603,1,603,
  	3,603,9329,8,603,1,604,1,604,1,604,1,604,5,604,9335,8,604,10,604,12,604,
  	9338,9,604,1,605,1,605,1,605,1,605,5,605,9344,8,605,10,605,12,605,9347,
  	9,605,1,605,1,605,3,605,9351,8,605,1,605,1,605,1,605,1,605,1,605,3,605,
  	9358,8,605,1,606,1,606,1,606,1,606,5,606,9364,8,606,10,606,12,606,9367,
  	9,606,1,606,1,606,3,606,9371,8,606,1,606,1,606,1,607,1,607,1,607,1,607,
  	5,607,9379,8,607,10,607,12,607,9382,9,607,1,608,1,608,1,608,1,608,5,608,
  	9388,8,608,10,608,12,608,9391,9,608,1,608,1,608,3,608,9395,8,608,1,608,
  	1,608,1,608,1,608,1,608,3,608,9402,8,608,1,609,1,609,1,609,1,609,1,609,
  	3,609,9409,8,609,1,610,1,610,1,610,1,610,1,610,1,610,1,610,1,610,3,610,
  	9419,8,610,1,611,1,611,1,611,1,611,1,611,1,611,1,611,1,611,3,611,9429,
  	8,611,1,612,1,612,1,612,1,612,1,612,1,612,1,612,5,612,9438,8,612,10,612,
  	12,612,9441,9,612,1,612,1,612,1,612,3,612,9446,8,612,1,612,3,612,9449,
  	8,612,1,613,1,613,1,613,1,613,3,613,9455,8,613,1,613,1,613,1,613,1,613,
  	1,613,1,613,1,613,5,613,9464,8,613,10,613,12,613,9467,9,613,1,613,1,613,
  	1,613,3,613,9472,8,613,1,613,1,613,3,613,9476,8,613,1,614,1,614,1,614,
  	1,614,3,614,9482,8,614,1,614,1,614,3,614,9486,8,614,1,614,1,614,1,615,
  	1,615,1,616,1,616,1,616,1,616,1,616,1,616,1,616,1,616,1,616,3,616,9501,
  	8,616,1,617,1,617,1,617,1,617,1,617,1,617,1,617,1,617,1,617,3,617,9512,
  	8,617,1,618,1,618,1,619,1,619,1,619,1,620,1,620,1,620,1,620,5,620,9523,
  	8,620,10,620,12,620,9526,9,620,1,620,1,620,1,621,1,621,1,621,3,621,9533,
  	8,621,1,622,1,622,1,623,3,623,9538,8,623,1,623,1,623,1,623,1,623,1,623,
  	5,623,9545,8,623,10,623,12,623,9548,9,623,1,623,1,623,4,623,9552,8,623,
  	11,623,12,623,9553,1,624,1,624,1,625,3,625,9559,8,625,1,625,1,625,1,625,
  	1,625,1,625,5,625,9566,8,625,10,625,12,625,9569,9,625,1,625,1,625,5,625,
  	9573,8,625,10,625,12,625,9576,9,625,1,626,1,626,1,626,1,627,1,627,1,627,
  	3,627,9584,8,627,1,628,3,628,9587,8,628,1,628,1,628,3,628,9591,8,628,
  	1,629,1,629,1,629,1,629,1,629,3,629,9598,8,629,1,629,3,629,9601,8,629,
  	1,629,1,629,1,629,1,629,1,629,5,629,9608,8,629,10,629,12,629,9611,9,629,
  	1,629,1,629,5,629,9615,8,629,10,629,12,629,9618,9,629,1,630,1,630,1,631,
  	1,631,1,631,3,631,9625,8,631,1,631,1,631,1,632,1,632,1,632,1,632,1,632,
  	3,632,9634,8,632,1,632,3,632,9637,8,632,1,632,1,632,3,632,9641,8,632,
  	1,633,1,633,1,633,1,633,5,633,9647,8,633,10,633,12,633,9650,9,633,1,633,
  	1,633,1,633,1,633,1,633,1,633,1,633,1,633,1,633,1,633,3,633,9662,8,633,
  	1,634,1,634,1,634,1,634,1,634,1,634,1,634,3,634,9671,8,634,1,634,1,634,
  	1,634,1,634,1,634,1,634,1,634,1,634,1,634,1,634,1,634,1,634,1,634,1,634,
  	1,634,1,634,1,634,1,634,1,634,1,634,1,634,1,634,1,634,1,634,1,634,1,634,
  	1,634,1,634,1,634,1,634,1,634,1,634,1,634,3,634,9706,8,634,1,635,1,635,
  	1,635,1,635,1,635,5,635,9713,8,635,10,635,12,635,9716,9,635,3,635,9718,
  	8,635,1,636,1,636,1,636,1,636,1,636,1,636,1,636,3,636,9727,8,636,1,637,
  	1,637,1,637,1,637,5,637,9733,8,637,10,637,12,637,9736,9,637,1,637,1,637,
  	1,637,1,637,1,637,3,637,9743,8,637,1,638,1,638,1,638,1,638,1,638,1,638,
  	1,638,1,639,1,639,1,639,1,640,1,640,1,641,1,641,1,641,1,642,1,642,1,643,
  	1,643,1,643,3,643,9765,8,643,1,644,1,644,1,645,1,645,1,646,1,646,1,647,
  	1,647,1,648,1,648,1,649,1,649,1,650,1,650,1,651,1,651,1,652,1,652,1,653,
  	1,653,1,654,1,654,1,655,1,655,1,656,1,656,1,657,1,657,1,658,1,658,1,659,
  	1,659,1,660,1,660,1,661,1,661,1,662,1,662,1,663,1,663,1,664,1,664,1,665,
  	1,665,1,666,1,666,1,666,1,667,1,667,1,667,3,667,9817,8,667,1,668,1,668,
  	1,669,1,669,1,670,1,670,1,671,1,671,1,672,1,672,1,673,1,673,1,673,1,673,
  	1,673,1,674,1,674,1,674,1,674,1,674,1,674,5,674,9840,8,674,10,674,12,
  	674,9843,9,674,1,674,1,674,5,674,9847,8,674,10,674,12,674,9850,9,674,
  	1,674,1,674,1,674,3,674,9855,8,674,1,675,1,675,1,675,1,675,3,675,9861,
  	8,675,1,675,5,675,9864,8,675,10,675,12,675,9867,9,675,1,675,1,675,1,676,
  	1,676,1,676,1,676,1,676,1,676,1,676,1,676,1,676,1,676,1,676,1,676,1,676,
  	1,676,1,676,1,676,1,676,1,676,1,676,1,676,1,676,1,676,1,676,1,676,1,676,
  	1,676,1,676,1,676,3,676,9899,8,676,1,677,1,677,1,678,1,678,1,678,1,679,
  	1,679,1,679,5,679,9909,8,679,10,679,12,679,9912,9,679,1,680,1,680,1,680,
  	1,680,3,680,9918,8,680,1,680,1,680,1,681,1,681,5,681,9924,8,681,10,681,
  	12,681,9927,9,681,1,682,1,682,1,682,1,682,3,682,9933,8,682,1,682,1,682,
  	1,682,1,682,1,682,1,682,1,682,1,682,5,682,9943,8,682,10,682,12,682,9946,
  	9,682,1,682,1,682,1,682,1,682,1,682,1,682,1,682,3,682,9955,8,682,1,682,
  	1,682,1,682,1,682,5,682,9961,8,682,10,682,12,682,9964,9,682,1,682,1,682,
  	1,682,3,682,9969,8,682,1,683,1,683,1,683,1,683,3,683,9975,8,683,1,683,
  	1,683,1,683,1,683,1,683,5,683,9982,8,683,10,683,12,683,9985,9,683,1,683,
  	1,683,1,683,1,683,3,683,9991,8,683,1,683,1,683,1,683,1,683,5,683,9997,
  	8,683,10,683,12,683,10000,9,683,1,683,1,683,3,683,10004,8,683,1,683,0,
  	8,460,466,528,564,800,1144,1162,1168,684,0,2,4,6,8,10,12,14,16,18,20,
  	22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,54,56,58,60,62,64,66,
  	68,70,72,74,76,78,80,82,84,86,88,90,92,94,96,98,100,102,104,106,108,110,
  	112,114,116,118,120,122,124,126,128,130,132,134,136,138,140,142,144,146,
  	148,150,152,154,156,158,160,162,164,166,168,170,172,174,176,178,180,182,
  	184,186,188,190,192,194,196,198,200,202,204,206,208,210,212,214,216,218,
  	220,222,224,226,228,230,232,234,236,238,240,242,244,246,248,250,252,254,
  	256,258,260,262,264,266,268,270,272,274,276,278,280,282,284,286,288,290,
  	292,294,296,298,300,302,304,306,308,310,312,314,316,318,320,322,324,326,
  	328,330,332,334,336,338,340,342,344,346,348,350,352,354,356,358,360,362,
  	364,366,368,370,372,374,376,378,380,382,384,386,388,390,392,394,396,398,
  	400,402,404,406,408,410,412,414,416,418,420,422,424,426,428,430,432,434,
  	436,438,440,442,444,446,448,450,452,454,456,458,460,462,464,466,468,470,
  	472,474,476,478,480,482,484,486,488,490,492,494,496,498,500,502,504,506,
  	508,510,512,514,516,518,520,522,524,526,528,530,532,534,536,538,540,542,
  	544,546,548,550,552,554,556,558,560,562,564,566,568,570,572,574,576,578,
  	580,582,584,586,588,590,592,594,596,598,600,602,604,606,608,610,612,614,
  	616,618,620,622,624,626,628,630,632,634,636,638,640,642,644,646,648,650,
  	652,654,656,658,660,662,664,666,668,670,672,674,676,678,680,682,684,686,
  	688,690,692,694,696,698,700,702,704,706,708,710,712,714,716,718,720,722,
  	724,726,728,730,732,734,736,738,740,742,744,746,748,750,752,754,756,758,
  	760,762,764,766,768,770,772,774,776,778,780,782,784,786,788,790,792,794,
  	796,798,800,802,804,806,808,810,812,814,816,818,820,822,824,826,828,830,
  	832,834,836,838,840,842,844,846,848,850,852,854,856,858,860,862,864,866,
  	868,870,872,874,876,878,880,882,884,886,888,890,892,894,896,898,900,902,
  	904,906,908,910,912,914,916,918,920,922,924,926,928,930,932,934,936,938,
  	940,942,944,946,948,950,952,954,956,958,960,962,964,966,968,970,972,974,
  	976,978,980,982,984,986,988,990,992,994,996,998,1000,1002,1004,1006,1008,
  	1010,1012,1014,1016,1018,1020,1022,1024,1026,1028,1030,1032,1034,1036,
  	1038,1040,1042,1044,1046,1048,1050,1052,1054,1056,1058,1060,1062,1064,
  	1066,1068,1070,1072,1074,1076,1078,1080,1082,1084,1086,1088,1090,1092,
  	1094,1096,1098,1100,1102,1104,1106,1108,1110,1112,1114,1116,1118,1120,
  	1122,1124,1126,1128,1130,1132,1134,1136,1138,1140,1142,1144,1146,1148,
  	1150,1152,1154,1156,1158,1160,1162,1164,1166,1168,1170,1172,1174,1176,
  	1178,1180,1182,1184,1186,1188,1190,1192,1194,1196,1198,1200,1202,1204,
  	1206,1208,1210,1212,1214,1216,1218,1220,1222,1224,1226,1228,1230,1232,
  	1234,1236,1238,1240,1242,1244,1246,1248,1250,1252,1254,1256,1258,1260,
  	1262,1264,1266,1268,1270,1272,1274,1276,1278,1280,1282,1284,1286,1288,
  	1290,1292,1294,1296,1298,1300,1302,1304,1306,1308,1310,1312,1314,1316,
  	1318,1320,1322,1324,1326,1328,1330,1332,1334,1336,1338,1340,1342,1344,
  	1346,1348,1350,1352,1354,1356,1358,1360,1362,1364,1366,0,43,6,0,1,1,35,
  	35,45,45,178,178,261,261,368,368,2,0,41,41,47,47,1,0,66,69,1,0,66,67,
  	1,0,100,101,6,0,188,188,326,326,328,328,342,342,364,364,368,368,1,0,112,
  	117,1,0,118,120,1,0,121,123,1,0,135,146,1,0,147,148,2,0,135,135,156,158,
  	3,0,136,136,153,153,159,161,3,0,135,135,152,152,156,158,2,0,136,136,159,
  	161,1,0,162,164,2,0,98,98,167,167,1,0,235,236,2,0,18,18,368,368,3,0,1,
  	1,18,18,368,368,2,0,45,45,368,368,1,0,275,278,3,0,279,288,347,348,362,
  	362,1,0,303,305,2,0,264,264,307,308,2,0,296,296,312,312,1,0,16,17,2,0,
  	333,334,343,343,2,0,173,173,175,175,1,0,319,320,5,0,173,173,175,175,230,
  	230,355,359,365,367,2,0,45,45,178,179,2,0,319,320,345,346,3,0,182,184,
  	186,186,324,324,3,0,180,181,349,352,360,361,2,0,357,359,366,367,2,0,89,
  	89,185,185,2,0,172,172,174,174,1,0,322,323,2,0,33,33,322,323,2,0,2,15,
  	18,19,5,0,326,326,328,328,342,342,364,364,368,368,3,0,157,157,160,160,
  	368,368,11049,0,1368,1,0,0,0,2,1372,1,0,0,0,4,1379,1,0,0,0,6,1386,1,0,
  	0,0,8,1388,1,0,0,0,10,1412,1,0,0,0,12,1416,1,0,0,0,14,1421,1,0,0,0,16,
  	1429,1,0,0,0,18,1449,1,0,0,0,20,1454,1,0,0,0,22,1477,1,0,0,0,24,1563,
  	1,0,0,0,26,1565,1,0,0,0,28,1570,1,0,0,0,30,1593,1,0,0,0,32,1673,1,0,0,
  	0,34,1675,1,0,0,0,36,1696,1,0,0,0,38,1718,1,0,0,0,40,1806,1,0,0,0,42,
  	1809,1,0,0,0,44,1852,1,0,0,0,46,1856,1,0,0,0,48,1902,1,0,0,0,50,1904,
  	1,0,0,0,52,1911,1,0,0,0,54,1965,1,0,0,0,56,1994,1,0,0,0,58,2003,1,0,0,
  	0,60,2005,1,0,0,0,62,2016,1,0,0,0,64,2044,1,0,0,0,66,2065,1,0,0,0,68,
  	2079,1,0,0,0,70,2081,1,0,0,0,72,2084,1,0,0,0,74,2087,1,0,0,0,76,2092,
  	1,0,0,0,78,2106,1,0,0,0,80,2149,1,0,0,0,82,2151,1,0,0,0,84,2186,1,0,0,
  	0,86,2192,1,0,0,0,88,2197,1,0,0,0,90,2221,1,0,0,0,92,2241,1,0,0,0,94,
  	2243,1,0,0,0,96,2247,1,0,0,0,98,2269,1,0,0,0,100,2274,1,0,0,0,102,2301,
  	1,0,0,0,104,2307,1,0,0,0,106,2322,1,0,0,0,108,2328,1,0,0,0,110,2347,1,
  	0,0,0,112,2353,1,0,0,0,114,2355,1,0,0,0,116,2366,1,0,0,0,118,2391,1,0,
  	0,0,120,2420,1,0,0,0,122,2426,1,0,0,0,124,2450,1,0,0,0,126,2477,1,0,0,
  	0,128,2479,1,0,0,0,130,2482,1,0,0,0,132,2518,1,0,0,0,134,2520,1,0,0,0,
  	136,2531,1,0,0,0,138,2536,1,0,0,0,140,2541,1,0,0,0,142,2545,1,0,0,0,144,
  	2549,1,0,0,0,146,2551,1,0,0,0,148,2555,1,0,0,0,150,2597,1,0,0,0,152,2603,
  	1,0,0,0,154,2619,1,0,0,0,156,2621,1,0,0,0,158,2633,1,0,0,0,160,2693,1,
  	0,0,0,162,2695,1,0,0,0,164,2709,1,0,0,0,166,2711,1,0,0,0,168,2719,1,0,
  	0,0,170,2728,1,0,0,0,172,2732,1,0,0,0,174,2742,1,0,0,0,176,2749,1,0,0,
  	0,178,2762,1,0,0,0,180,2784,1,0,0,0,182,2786,1,0,0,0,184,2803,1,0,0,0,
  	186,2805,1,0,0,0,188,2812,1,0,0,0,190,2819,1,0,0,0,192,2826,1,0,0,0,194,
  	2830,1,0,0,0,196,2840,1,0,0,0,198,2858,1,0,0,0,200,2860,1,0,0,0,202,2882,
  	1,0,0,0,204,2897,1,0,0,0,206,2915,1,0,0,0,208,2920,1,0,0,0,210,2931,1,
  	0,0,0,212,2948,1,0,0,0,214,2950,1,0,0,0,216,3000,1,0,0,0,218,3002,1,0,
  	0,0,220,3032,1,0,0,0,222,3034,1,0,0,0,224,3036,1,0,0,0,226,3038,1,0,0,
  	0,228,3040,1,0,0,0,230,3043,1,0,0,0,232,3067,1,0,0,0,234,3091,1,0,0,0,
  	236,3186,1,0,0,0,238,3188,1,0,0,0,240,3190,1,0,0,0,242,3192,1,0,0,0,244,
  	3194,1,0,0,0,246,3196,1,0,0,0,248,3198,1,0,0,0,250,3200,1,0,0,0,252,3212,
  	1,0,0,0,254,3215,1,0,0,0,256,3238,1,0,0,0,258,3240,1,0,0,0,260,3254,1,
  	0,0,0,262,3257,1,0,0,0,264,3273,1,0,0,0,266,3275,1,0,0,0,268,3277,1,0,
  	0,0,270,3279,1,0,0,0,272,3281,1,0,0,0,274,3290,1,0,0,0,276,3297,1,0,0,
  	0,278,3303,1,0,0,0,280,3305,1,0,0,0,282,3310,1,0,0,0,284,3314,1,0,0,0,
  	286,3319,1,0,0,0,288,3331,1,0,0,0,290,3338,1,0,0,0,292,3340,1,0,0,0,294,
  	3342,1,0,0,0,296,3370,1,0,0,0,298,3372,1,0,0,0,300,3374,1,0,0,0,302,3376,
  	1,0,0,0,304,3392,1,0,0,0,306,3404,1,0,0,0,308,3416,1,0,0,0,310,3424,1,
  	0,0,0,312,3426,1,0,0,0,314,3434,1,0,0,0,316,3454,1,0,0,0,318,3462,1,0,
  	0,0,320,3470,1,0,0,0,322,3490,1,0,0,0,324,3498,1,0,0,0,326,3526,1,0,0,
  	0,328,3542,1,0,0,0,330,3550,1,0,0,0,332,3570,1,0,0,0,334,3598,1,0,0,0,
  	336,3616,1,0,0,0,338,3621,1,0,0,0,340,3632,1,0,0,0,342,3648,1,0,0,0,344,
  	3677,1,0,0,0,346,3679,1,0,0,0,348,3714,1,0,0,0,350,3724,1,0,0,0,352,3743,
  	1,0,0,0,354,3750,1,0,0,0,356,3757,1,0,0,0,358,3763,1,0,0,0,360,3765,1,
  	0,0,0,362,3773,1,0,0,0,364,3778,1,0,0,0,366,3790,1,0,0,0,368,3792,1,0,
  	0,0,370,3855,1,0,0,0,372,3857,1,0,0,0,374,3904,1,0,0,0,376,3906,1,0,0,
  	0,378,3908,1,0,0,0,380,3911,1,0,0,0,382,3914,1,0,0,0,384,3916,1,0,0,0,
  	386,3977,1,0,0,0,388,3981,1,0,0,0,390,3983,1,0,0,0,392,3994,1,0,0,0,394,
  	4021,1,0,0,0,396,4026,1,0,0,0,398,4037,1,0,0,0,400,4049,1,0,0,0,402,4063,
  	1,0,0,0,404,4088,1,0,0,0,406,4090,1,0,0,0,408,4098,1,0,0,0,410,4106,1,
  	0,0,0,412,4121,1,0,0,0,414,4131,1,0,0,0,416,4152,1,0,0,0,418,4154,1,0,
  	0,0,420,4164,1,0,0,0,422,4175,1,0,0,0,424,4184,1,0,0,0,426,4191,1,0,0,
  	0,428,4193,1,0,0,0,430,4200,1,0,0,0,432,4207,1,0,0,0,434,4214,1,0,0,0,
  	436,4220,1,0,0,0,438,4238,1,0,0,0,440,4245,1,0,0,0,442,4255,1,0,0,0,444,
  	4259,1,0,0,0,446,4264,1,0,0,0,448,4266,1,0,0,0,450,4291,1,0,0,0,452,4302,
  	1,0,0,0,454,4323,1,0,0,0,456,4327,1,0,0,0,458,4330,1,0,0,0,460,4470,1,
  	0,0,0,462,4522,1,0,0,0,464,4524,1,0,0,0,466,4613,1,0,0,0,468,4657,1,0,
  	0,0,470,4659,1,0,0,0,472,4666,1,0,0,0,474,4668,1,0,0,0,476,4679,1,0,0,
  	0,478,4703,1,0,0,0,480,4708,1,0,0,0,482,4710,1,0,0,0,484,4718,1,0,0,0,
  	486,4765,1,0,0,0,488,4769,1,0,0,0,490,4796,1,0,0,0,492,4800,1,0,0,0,494,
  	4805,1,0,0,0,496,4815,1,0,0,0,498,4817,1,0,0,0,500,4821,1,0,0,0,502,4827,
  	1,0,0,0,504,4837,1,0,0,0,506,4839,1,0,0,0,508,4847,1,0,0,0,510,4851,1,
  	0,0,0,512,4864,1,0,0,0,514,4875,1,0,0,0,516,4892,1,0,0,0,518,4894,1,0,
  	0,0,520,4921,1,0,0,0,522,4940,1,0,0,0,524,4944,1,0,0,0,526,4960,1,0,0,
  	0,528,4967,1,0,0,0,530,5003,1,0,0,0,532,5009,1,0,0,0,534,5039,1,0,0,0,
  	536,5168,1,0,0,0,538,5173,1,0,0,0,540,5175,1,0,0,0,542,5183,1,0,0,0,544,
  	5196,1,0,0,0,546,5220,1,0,0,0,548,5227,1,0,0,0,550,5232,1,0,0,0,552,5245,
  	1,0,0,0,554,5255,1,0,0,0,556,5266,1,0,0,0,558,5272,1,0,0,0,560,5277,1,
  	0,0,0,562,5284,1,0,0,0,564,5310,1,0,0,0,566,5330,1,0,0,0,568,5341,1,0,
  	0,0,570,5346,1,0,0,0,572,5486,1,0,0,0,574,5489,1,0,0,0,576,5502,1,0,0,
  	0,578,5513,1,0,0,0,580,5524,1,0,0,0,582,5540,1,0,0,0,584,5556,1,0,0,0,
  	586,5565,1,0,0,0,588,5576,1,0,0,0,590,5598,1,0,0,0,592,5616,1,0,0,0,594,
  	5620,1,0,0,0,596,5626,1,0,0,0,598,5632,1,0,0,0,600,5640,1,0,0,0,602,5644,
  	1,0,0,0,604,5650,1,0,0,0,606,5654,1,0,0,0,608,5656,1,0,0,0,610,5679,1,
  	0,0,0,612,5697,1,0,0,0,614,5699,1,0,0,0,616,5701,1,0,0,0,618,5709,1,0,
  	0,0,620,5714,1,0,0,0,622,5737,1,0,0,0,624,5742,1,0,0,0,626,5751,1,0,0,
  	0,628,5766,1,0,0,0,630,5783,1,0,0,0,632,5788,1,0,0,0,634,5797,1,0,0,0,
  	636,5812,1,0,0,0,638,5831,1,0,0,0,640,5833,1,0,0,0,642,5842,1,0,0,0,644,
  	5871,1,0,0,0,646,5873,1,0,0,0,648,5893,1,0,0,0,650,5896,1,0,0,0,652,5920,
  	1,0,0,0,654,5922,1,0,0,0,656,5938,1,0,0,0,658,5956,1,0,0,0,660,5958,1,
  	0,0,0,662,5967,1,0,0,0,664,5996,1,0,0,0,666,5998,1,0,0,0,668,6026,1,0,
  	0,0,670,6028,1,0,0,0,672,6044,1,0,0,0,674,6053,1,0,0,0,676,6064,1,0,0,
  	0,678,6080,1,0,0,0,680,6084,1,0,0,0,682,6086,1,0,0,0,684,6096,1,0,0,0,
  	686,6123,1,0,0,0,688,6128,1,0,0,0,690,6172,1,0,0,0,692,6177,1,0,0,0,694,
  	6190,1,0,0,0,696,6249,1,0,0,0,698,6251,1,0,0,0,700,6261,1,0,0,0,702,6280,
  	1,0,0,0,704,6285,1,0,0,0,706,6302,1,0,0,0,708,6311,1,0,0,0,710,6319,1,
  	0,0,0,712,6321,1,0,0,0,714,6331,1,0,0,0,716,6337,1,0,0,0,718,6349,1,0,
  	0,0,720,6364,1,0,0,0,722,6366,1,0,0,0,724,6375,1,0,0,0,726,6377,1,0,0,
  	0,728,6387,1,0,0,0,730,6406,1,0,0,0,732,6410,1,0,0,0,734,6412,1,0,0,0,
  	736,6414,1,0,0,0,738,6416,1,0,0,0,740,6418,1,0,0,0,742,6436,1,0,0,0,744,
  	6468,1,0,0,0,746,6470,1,0,0,0,748,6478,1,0,0,0,750,6486,1,0,0,0,752,6496,
  	1,0,0,0,754,6500,1,0,0,0,756,6503,1,0,0,0,758,6506,1,0,0,0,760,6533,1,
  	0,0,0,762,6535,1,0,0,0,764,6539,1,0,0,0,766,6541,1,0,0,0,768,6562,1,0,
  	0,0,770,6564,1,0,0,0,772,6574,1,0,0,0,774,6576,1,0,0,0,776,6598,1,0,0,
  	0,778,6624,1,0,0,0,780,6626,1,0,0,0,782,6628,1,0,0,0,784,6638,1,0,0,0,
  	786,6643,1,0,0,0,788,6684,1,0,0,0,790,6694,1,0,0,0,792,6696,1,0,0,0,794,
  	6707,1,0,0,0,796,6715,1,0,0,0,798,6726,1,0,0,0,800,6746,1,0,0,0,802,6760,
  	1,0,0,0,804,6762,1,0,0,0,806,6767,1,0,0,0,808,6778,1,0,0,0,810,6780,1,
  	0,0,0,812,6812,1,0,0,0,814,6831,1,0,0,0,816,6833,1,0,0,0,818,6842,1,0,
  	0,0,820,6854,1,0,0,0,822,6856,1,0,0,0,824,6864,1,0,0,0,826,6870,1,0,0,
  	0,828,6873,1,0,0,0,830,6906,1,0,0,0,832,6924,1,0,0,0,834,6939,1,0,0,0,
  	836,6950,1,0,0,0,838,6952,1,0,0,0,840,6962,1,0,0,0,842,7004,1,0,0,0,844,
  	7080,1,0,0,0,846,7084,1,0,0,0,848,7088,1,0,0,0,850,7092,1,0,0,0,852,7095,
  	1,0,0,0,854,7103,1,0,0,0,856,7105,1,0,0,0,858,7107,1,0,0,0,860,7119,1,
  	0,0,0,862,7177,1,0,0,0,864,7188,1,0,0,0,866,7191,1,0,0,0,868,7207,1,0,
  	0,0,870,7218,1,0,0,0,872,7220,1,0,0,0,874,7223,1,0,0,0,876,7244,1,0,0,
  	0,878,7248,1,0,0,0,880,7253,1,0,0,0,882,7260,1,0,0,0,884,7264,1,0,0,0,
  	886,7269,1,0,0,0,888,7271,1,0,0,0,890,7277,1,0,0,0,892,7283,1,0,0,0,894,
  	7292,1,0,0,0,896,7306,1,0,0,0,898,7322,1,0,0,0,900,7338,1,0,0,0,902,7372,
  	1,0,0,0,904,7381,1,0,0,0,906,7398,1,0,0,0,908,7409,1,0,0,0,910,7428,1,
  	0,0,0,912,7430,1,0,0,0,914,7438,1,0,0,0,916,7448,1,0,0,0,918,7450,1,0,
  	0,0,920,7464,1,0,0,0,922,7476,1,0,0,0,924,7479,1,0,0,0,926,7498,1,0,0,
  	0,928,7501,1,0,0,0,930,7517,1,0,0,0,932,7537,1,0,0,0,934,7568,1,0,0,0,
  	936,7570,1,0,0,0,938,7590,1,0,0,0,940,7592,1,0,0,0,942,7599,1,0,0,0,944,
  	7608,1,0,0,0,946,7614,1,0,0,0,948,7643,1,0,0,0,950,7645,1,0,0,0,952,7659,
  	1,0,0,0,954,7669,1,0,0,0,956,7679,1,0,0,0,958,7690,1,0,0,0,960,7700,1,
  	0,0,0,962,7702,1,0,0,0,964,7711,1,0,0,0,966,7720,1,0,0,0,968,7728,1,0,
  	0,0,970,7741,1,0,0,0,972,7754,1,0,0,0,974,7767,1,0,0,0,976,7816,1,0,0,
  	0,978,7818,1,0,0,0,980,7820,1,0,0,0,982,7822,1,0,0,0,984,7824,1,0,0,0,
  	986,7826,1,0,0,0,988,7828,1,0,0,0,990,7830,1,0,0,0,992,7832,1,0,0,0,994,
  	7834,1,0,0,0,996,7836,1,0,0,0,998,7838,1,0,0,0,1000,7840,1,0,0,0,1002,
  	7842,1,0,0,0,1004,7844,1,0,0,0,1006,7846,1,0,0,0,1008,7848,1,0,0,0,1010,
  	7850,1,0,0,0,1012,7860,1,0,0,0,1014,7862,1,0,0,0,1016,7875,1,0,0,0,1018,
  	7902,1,0,0,0,1020,7916,1,0,0,0,1022,7918,1,0,0,0,1024,7935,1,0,0,0,1026,
  	7952,1,0,0,0,1028,7995,1,0,0,0,1030,8012,1,0,0,0,1032,8029,1,0,0,0,1034,
  	8072,1,0,0,0,1036,8089,1,0,0,0,1038,8118,1,0,0,0,1040,8149,1,0,0,0,1042,
  	8164,1,0,0,0,1044,8181,1,0,0,0,1046,8200,1,0,0,0,1048,8207,1,0,0,0,1050,
  	8214,1,0,0,0,1052,8216,1,0,0,0,1054,8218,1,0,0,0,1056,8220,1,0,0,0,1058,
  	8222,1,0,0,0,1060,8224,1,0,0,0,1062,8226,1,0,0,0,1064,8228,1,0,0,0,1066,
  	8230,1,0,0,0,1068,8233,1,0,0,0,1070,8240,1,0,0,0,1072,8249,1,0,0,0,1074,
  	8253,1,0,0,0,1076,8255,1,0,0,0,1078,8272,1,0,0,0,1080,8279,1,0,0,0,1082,
  	8300,1,0,0,0,1084,8311,1,0,0,0,1086,8340,1,0,0,0,1088,8369,1,0,0,0,1090,
  	8374,1,0,0,0,1092,8376,1,0,0,0,1094,8381,1,0,0,0,1096,8392,1,0,0,0,1098,
  	8397,1,0,0,0,1100,8402,1,0,0,0,1102,8410,1,0,0,0,1104,8414,1,0,0,0,1106,
  	8416,1,0,0,0,1108,8427,1,0,0,0,1110,8440,1,0,0,0,1112,8442,1,0,0,0,1114,
  	8484,1,0,0,0,1116,8487,1,0,0,0,1118,8534,1,0,0,0,1120,8544,1,0,0,0,1122,
  	8560,1,0,0,0,1124,8564,1,0,0,0,1126,8566,1,0,0,0,1128,8586,1,0,0,0,1130,
  	8639,1,0,0,0,1132,8646,1,0,0,0,1134,8648,1,0,0,0,1136,8650,1,0,0,0,1138,
  	8652,1,0,0,0,1140,8654,1,0,0,0,1142,8674,1,0,0,0,1144,8687,1,0,0,0,1146,
  	8821,1,0,0,0,1148,8823,1,0,0,0,1150,8834,1,0,0,0,1152,8839,1,0,0,0,1154,
  	8843,1,0,0,0,1156,8847,1,0,0,0,1158,8849,1,0,0,0,1160,8853,1,0,0,0,1162,
  	8922,1,0,0,0,1164,9090,1,0,0,0,1166,9092,1,0,0,0,1168,9111,1,0,0,0,1170,
  	9140,1,0,0,0,1172,9150,1,0,0,0,1174,9154,1,0,0,0,1176,9156,1,0,0,0,1178,
  	9158,1,0,0,0,1180,9160,1,0,0,0,1182,9207,1,0,0,0,1184,9218,1,0,0,0,1186,
  	9228,1,0,0,0,1188,9300,1,0,0,0,1190,9302,1,0,0,0,1192,9304,1,0,0,0,1194,
  	9306,1,0,0,0,1196,9308,1,0,0,0,1198,9311,1,0,0,0,1200,9315,1,0,0,0,1202,
  	9321,1,0,0,0,1204,9323,1,0,0,0,1206,9328,1,0,0,0,1208,9336,1,0,0,0,1210,
  	9350,1,0,0,0,1212,9370,1,0,0,0,1214,9380,1,0,0,0,1216,9394,1,0,0,0,1218,
  	9408,1,0,0,0,1220,9410,1,0,0,0,1222,9420,1,0,0,0,1224,9448,1,0,0,0,1226,
  	9475,1,0,0,0,1228,9481,1,0,0,0,1230,9489,1,0,0,0,1232,9500,1,0,0,0,1234,
  	9511,1,0,0,0,1236,9513,1,0,0,0,1238,9515,1,0,0,0,1240,9518,1,0,0,0,1242,
  	9529,1,0,0,0,1244,9534,1,0,0,0,1246,9537,1,0,0,0,1248,9555,1,0,0,0,1250,
  	9558,1,0,0,0,1252,9577,1,0,0,0,1254,9580,1,0,0,0,1256,9590,1,0,0,0,1258,
  	9597,1,0,0,0,1260,9619,1,0,0,0,1262,9624,1,0,0,0,1264,9628,1,0,0,0,1266,
  	9661,1,0,0,0,1268,9705,1,0,0,0,1270,9707,1,0,0,0,1272,9726,1,0,0,0,1274,
  	9742,1,0,0,0,1276,9744,1,0,0,0,1278,9751,1,0,0,0,1280,9754,1,0,0,0,1282,
  	9756,1,0,0,0,1284,9759,1,0,0,0,1286,9761,1,0,0,0,1288,9766,1,0,0,0,1290,
  	9768,1,0,0,0,1292,9770,1,0,0,0,1294,9772,1,0,0,0,1296,9774,1,0,0,0,1298,
  	9776,1,0,0,0,1300,9778,1,0,0,0,1302,9780,1,0,0,0,1304,9782,1,0,0,0,1306,
  	9784,1,0,0,0,1308,9786,1,0,0,0,1310,9788,1,0,0,0,1312,9790,1,0,0,0,1314,
  	9792,1,0,0,0,1316,9794,1,0,0,0,1318,9796,1,0,0,0,1320,9798,1,0,0,0,1322,
  	9800,1,0,0,0,1324,9802,1,0,0,0,1326,9804,1,0,0,0,1328,9806,1,0,0,0,1330,
  	9808,1,0,0,0,1332,9810,1,0,0,0,1334,9813,1,0,0,0,1336,9818,1,0,0,0,1338,
  	9820,1,0,0,0,1340,9822,1,0,0,0,1342,9824,1,0,0,0,1344,9826,1,0,0,0,1346,
  	9828,1,0,0,0,1348,9833,1,0,0,0,1350,9856,1,0,0,0,1352,9898,1,0,0,0,1354,
  	9900,1,0,0,0,1356,9902,1,0,0,0,1358,9905,1,0,0,0,1360,9913,1,0,0,0,1362,
  	9921,1,0,0,0,1364,9968,1,0,0,0,1366,10003,1,0,0,0,1368,1369,3,16,8,0,
  	1369,1370,3,14,7,0,1370,1371,5,0,0,1,1371,1,1,0,0,0,1372,1373,3,16,8,
  	0,1373,1374,3,4,2,0,1374,1375,5,0,0,1,1375,3,1,0,0,0,1376,1378,3,6,3,
  	0,1377,1376,1,0,0,0,1378,1381,1,0,0,0,1379,1377,1,0,0,0,1379,1380,1,0,
  	0,0,1380,5,1,0,0,0,1381,1379,1,0,0,0,1382,1387,3,8,4,0,1383,1387,3,12,
  	6,0,1384,1387,3,1348,674,0,1385,1387,5,31,0,0,1386,1382,1,0,0,0,1386,
  	1383,1,0,0,0,1386,1384,1,0,0,0,1386,1385,1,0,0,0,1387,7,1,0,0,0,1388,
  	1389,5,28,0,0,1389,1390,3,1248,624,0,1390,1395,3,10,5,0,1391,1392,5,30,
  	0,0,1392,1394,3,10,5,0,1393,1391,1,0,0,0,1394,1397,1,0,0,0,1395,1393,
  	1,0,0,0,1395,1396,1,0,0,0,1396,1407,1,0,0,0,1397,1395,1,0,0,0,1398,1399,
  	5,29,0,0,1399,1404,3,10,5,0,1400,1401,5,30,0,0,1401,1403,3,10,5,0,1402,
  	1400,1,0,0,0,1403,1406,1,0,0,0,1404,1402,1,0,0,0,1404,1405,1,0,0,0,1405,
  	1408,1,0,0,0,1406,1404,1,0,0,0,1407,1398,1,0,0,0,1407,1408,1,0,0,0,1408,
  	1409,1,0,0,0,1409,1410,5,31,0,0,1410,9,1,0,0,0,1411,1413,7,0,0,0,1412,
  	1411,1,0,0,0,1413,1414,1,0,0,0,1414,1412,1,0,0,0,1414,1415,1,0,0,0,1415,
  	11,1,0,0,0,1416,1417,5,27,0,0,1417,1418,3,10,5,0,1418,1419,5,31,0,0,1419,
  	13,1,0,0,0,1420,1422,3,54,27,0,1421,1420,1,0,0,0,1421,1422,1,0,0,0,1422,
  	1426,1,0,0,0,1423,1425,3,18,9,0,1424,1423,1,0,0,0,1425,1428,1,0,0,0,1426,
  	1424,1,0,0,0,1426,1427,1,0,0,0,1427,15,1,0,0,0,1428,1426,1,0,0,0,1429,
  	1430,1,0,0,0,1430,17,1,0,0,0,1431,1450,3,24,12,0,1432,1450,3,696,348,
  	0,1433,1450,3,32,16,0,1434,1450,3,40,20,0,1435,1450,3,52,26,0,1436,1450,
  	3,1344,672,0,1437,1439,3,1240,620,0,1438,1437,1,0,0,0,1439,1442,1,0,0,
  	0,1440,1438,1,0,0,0,1440,1441,1,0,0,0,1441,1445,1,0,0,0,1442,1440,1,0,
  	0,0,1443,1446,3,178,89,0,1444,1446,3,96,48,0,1445,1443,1,0,0,0,1445,1444,
  	1,0,0,0,1446,1450,1,0,0,0,1447,1450,3,1348,674,0,1448,1450,3,1268,634,
  	0,1449,1431,1,0,0,0,1449,1432,1,0,0,0,1449,1433,1,0,0,0,1449,1434,1,0,
  	0,0,1449,1435,1,0,0,0,1449,1436,1,0,0,0,1449,1440,1,0,0,0,1449,1447,1,
  	0,0,0,1449,1448,1,0,0,0,1450,19,1,0,0,0,1451,1453,3,1240,620,0,1452,1451,
  	1,0,0,0,1453,1456,1,0,0,0,1454,1452,1,0,0,0,1454,1455,1,0,0,0,1455,1457,
  	1,0,0,0,1456,1454,1,0,0,0,1457,1459,3,26,13,0,1458,1460,3,232,116,0,1459,
  	1458,1,0,0,0,1459,1460,1,0,0,0,1460,1461,1,0,0,0,1461,1465,3,1248,624,
  	0,1462,1464,3,208,104,0,1463,1462,1,0,0,0,1464,1467,1,0,0,0,1465,1463,
  	1,0,0,0,1465,1466,1,0,0,0,1466,1469,1,0,0,0,1467,1465,1,0,0,0,1468,1470,
  	3,56,28,0,1469,1468,1,0,0,0,1469,1470,1,0,0,0,1470,1471,1,0,0,0,1471,
  	1472,3,60,30,0,1472,1473,5,31,0,0,1473,21,1,0,0,0,1474,1476,3,1240,620,
  	0,1475,1474,1,0,0,0,1476,1479,1,0,0,0,1477,1475,1,0,0,0,1477,1478,1,0,
  	0,0,1478,1480,1,0,0,0,1479,1477,1,0,0,0,1480,1482,3,26,13,0,1481,1483,
  	3,232,116,0,1482,1481,1,0,0,0,1482,1483,1,0,0,0,1483,1484,1,0,0,0,1484,
  	1488,3,1248,624,0,1485,1487,3,208,104,0,1486,1485,1,0,0,0,1487,1490,1,
  	0,0,0,1488,1486,1,0,0,0,1488,1489,1,0,0,0,1489,1492,1,0,0,0,1490,1488,
  	1,0,0,0,1491,1493,3,56,28,0,1492,1491,1,0,0,0,1492,1493,1,0,0,0,1493,
  	1495,1,0,0,0,1494,1496,3,62,31,0,1495,1494,1,0,0,0,1495,1496,1,0,0,0,
  	1496,1497,1,0,0,0,1497,1498,5,31,0,0,1498,23,1,0,0,0,1499,1501,3,20,10,
  	0,1500,1502,3,54,27,0,1501,1500,1,0,0,0,1501,1502,1,0,0,0,1502,1506,1,
  	0,0,0,1503,1505,3,86,43,0,1504,1503,1,0,0,0,1505,1508,1,0,0,0,1506,1504,
  	1,0,0,0,1506,1507,1,0,0,0,1507,1509,1,0,0,0,1508,1506,1,0,0,0,1509,1512,
  	5,42,0,0,1510,1511,5,33,0,0,1511,1513,3,1248,624,0,1512,1510,1,0,0,0,
  	1512,1513,1,0,0,0,1513,1564,1,0,0,0,1514,1516,3,22,11,0,1515,1517,3,54,
  	27,0,1516,1515,1,0,0,0,1516,1517,1,0,0,0,1517,1521,1,0,0,0,1518,1520,
  	3,92,46,0,1519,1518,1,0,0,0,1520,1523,1,0,0,0,1521,1519,1,0,0,0,1521,
  	1522,1,0,0,0,1522,1524,1,0,0,0,1523,1521,1,0,0,0,1524,1527,5,42,0,0,1525,
  	1526,5,33,0,0,1526,1528,3,1248,624,0,1527,1525,1,0,0,0,1527,1528,1,0,
  	0,0,1528,1564,1,0,0,0,1529,1531,3,1240,620,0,1530,1529,1,0,0,0,1531,1534,
  	1,0,0,0,1532,1530,1,0,0,0,1532,1533,1,0,0,0,1533,1535,1,0,0,0,1534,1532,
  	1,0,0,0,1535,1537,3,26,13,0,1536,1538,3,232,116,0,1537,1536,1,0,0,0,1537,
  	1538,1,0,0,0,1538,1539,1,0,0,0,1539,1540,3,1248,624,0,1540,1541,5,43,
  	0,0,1541,1542,5,35,0,0,1542,1543,5,45,0,0,1543,1544,5,44,0,0,1544,1546,
  	5,31,0,0,1545,1547,3,54,27,0,1546,1545,1,0,0,0,1546,1547,1,0,0,0,1547,
  	1551,1,0,0,0,1548,1550,3,86,43,0,1549,1548,1,0,0,0,1550,1553,1,0,0,0,
  	1551,1549,1,0,0,0,1551,1552,1,0,0,0,1552,1554,1,0,0,0,1553,1551,1,0,0,
  	0,1554,1557,5,42,0,0,1555,1556,5,33,0,0,1556,1558,3,1248,624,0,1557,1555,
  	1,0,0,0,1557,1558,1,0,0,0,1558,1564,1,0,0,0,1559,1560,5,46,0,0,1560,1564,
  	3,20,10,0,1561,1562,5,46,0,0,1562,1564,3,22,11,0,1563,1499,1,0,0,0,1563,
  	1514,1,0,0,0,1563,1532,1,0,0,0,1563,1559,1,0,0,0,1563,1561,1,0,0,0,1564,
  	25,1,0,0,0,1565,1566,7,1,0,0,1566,27,1,0,0,0,1567,1569,3,1240,620,0,1568,
  	1567,1,0,0,0,1569,1572,1,0,0,0,1570,1568,1,0,0,0,1570,1571,1,0,0,0,1571,
  	1573,1,0,0,0,1572,1570,1,0,0,0,1573,1575,5,48,0,0,1574,1576,3,232,116,
  	0,1575,1574,1,0,0,0,1575,1576,1,0,0,0,1576,1577,1,0,0,0,1577,1581,3,1250,
  	625,0,1578,1580,3,208,104,0,1579,1578,1,0,0,0,1580,1583,1,0,0,0,1581,
  	1579,1,0,0,0,1581,1582,1,0,0,0,1582,1585,1,0,0,0,1583,1581,1,0,0,0,1584,
  	1586,3,56,28,0,1585,1584,1,0,0,0,1585,1586,1,0,0,0,1586,1587,1,0,0,0,
  	1587,1588,3,60,30,0,1588,1589,5,31,0,0,1589,29,1,0,0,0,1590,1592,3,1240,
  	620,0,1591,1590,1,0,0,0,1592,1595,1,0,0,0,1593,1591,1,0,0,0,1593,1594,
  	1,0,0,0,1594,1596,1,0,0,0,1595,1593,1,0,0,0,1596,1598,5,48,0,0,1597,1599,
  	3,232,116,0,1598,1597,1,0,0,0,1598,1599,1,0,0,0,1599,1600,1,0,0,0,1600,
  	1604,3,1250,625,0,1601,1603,3,208,104,0,1602,1601,1,0,0,0,1603,1606,1,
  	0,0,0,1604,1602,1,0,0,0,1604,1605,1,0,0,0,1605,1608,1,0,0,0,1606,1604,
  	1,0,0,0,1607,1609,3,56,28,0,1608,1607,1,0,0,0,1608,1609,1,0,0,0,1609,
  	1611,1,0,0,0,1610,1612,3,62,31,0,1611,1610,1,0,0,0,1611,1612,1,0,0,0,
  	1612,1613,1,0,0,0,1613,1614,5,31,0,0,1614,31,1,0,0,0,1615,1617,3,28,14,
  	0,1616,1618,3,54,27,0,1617,1616,1,0,0,0,1617,1618,1,0,0,0,1618,1622,1,
  	0,0,0,1619,1621,3,104,52,0,1620,1619,1,0,0,0,1621,1624,1,0,0,0,1622,1620,
  	1,0,0,0,1622,1623,1,0,0,0,1623,1625,1,0,0,0,1624,1622,1,0,0,0,1625,1628,
  	5,49,0,0,1626,1627,5,33,0,0,1627,1629,3,1250,625,0,1628,1626,1,0,0,0,
  	1628,1629,1,0,0,0,1629,1674,1,0,0,0,1630,1632,3,30,15,0,1631,1633,3,54,
  	27,0,1632,1631,1,0,0,0,1632,1633,1,0,0,0,1633,1637,1,0,0,0,1634,1636,
  	3,106,53,0,1635,1634,1,0,0,0,1636,1639,1,0,0,0,1637,1635,1,0,0,0,1637,
  	1638,1,0,0,0,1638,1640,1,0,0,0,1639,1637,1,0,0,0,1640,1643,5,49,0,0,1641,
  	1642,5,33,0,0,1642,1644,3,1250,625,0,1643,1641,1,0,0,0,1643,1644,1,0,
  	0,0,1644,1674,1,0,0,0,1645,1647,3,1240,620,0,1646,1645,1,0,0,0,1646,1647,
  	1,0,0,0,1647,1648,1,0,0,0,1648,1649,5,48,0,0,1649,1650,3,1250,625,0,1650,
  	1651,5,43,0,0,1651,1652,5,35,0,0,1652,1653,5,45,0,0,1653,1654,5,44,0,
  	0,1654,1656,5,31,0,0,1655,1657,3,54,27,0,1656,1655,1,0,0,0,1656,1657,
  	1,0,0,0,1657,1661,1,0,0,0,1658,1660,3,104,52,0,1659,1658,1,0,0,0,1660,
  	1663,1,0,0,0,1661,1659,1,0,0,0,1661,1662,1,0,0,0,1662,1664,1,0,0,0,1663,
  	1661,1,0,0,0,1664,1667,5,49,0,0,1665,1666,5,33,0,0,1666,1668,3,1250,625,
  	0,1667,1665,1,0,0,0,1667,1668,1,0,0,0,1668,1674,1,0,0,0,1669,1670,5,46,
  	0,0,1670,1674,3,28,14,0,1671,1672,5,46,0,0,1672,1674,3,30,15,0,1673,1615,
  	1,0,0,0,1673,1630,1,0,0,0,1673,1646,1,0,0,0,1673,1669,1,0,0,0,1673,1671,
  	1,0,0,0,1674,33,1,0,0,0,1675,1676,3,1240,620,0,1676,1678,5,50,0,0,1677,
  	1679,3,232,116,0,1678,1677,1,0,0,0,1678,1679,1,0,0,0,1679,1680,1,0,0,
  	0,1680,1684,3,1248,624,0,1681,1683,3,208,104,0,1682,1681,1,0,0,0,1683,
  	1686,1,0,0,0,1684,1682,1,0,0,0,1684,1685,1,0,0,0,1685,1688,1,0,0,0,1686,
  	1684,1,0,0,0,1687,1689,3,56,28,0,1688,1687,1,0,0,0,1688,1689,1,0,0,0,
  	1689,1690,1,0,0,0,1690,1691,3,60,30,0,1691,1692,5,31,0,0,1692,35,1,0,
  	0,0,1693,1695,3,1240,620,0,1694,1693,1,0,0,0,1695,1698,1,0,0,0,1696,1694,
  	1,0,0,0,1696,1697,1,0,0,0,1697,1699,1,0,0,0,1698,1696,1,0,0,0,1699,1701,
  	5,50,0,0,1700,1702,3,232,116,0,1701,1700,1,0,0,0,1701,1702,1,0,0,0,1702,
  	1703,1,0,0,0,1703,1707,3,1248,624,0,1704,1706,3,208,104,0,1705,1704,1,
  	0,0,0,1706,1709,1,0,0,0,1707,1705,1,0,0,0,1707,1708,1,0,0,0,1708,1711,
  	1,0,0,0,1709,1707,1,0,0,0,1710,1712,3,56,28,0,1711,1710,1,0,0,0,1711,
  	1712,1,0,0,0,1712,1714,1,0,0,0,1713,1715,3,62,31,0,1714,1713,1,0,0,0,
  	1714,1715,1,0,0,0,1715,1716,1,0,0,0,1716,1717,5,31,0,0,1717,37,1,0,0,
  	0,1718,1719,5,60,0,0,1719,1725,3,1248,624,0,1720,1722,5,43,0,0,1721,1723,
  	3,114,57,0,1722,1721,1,0,0,0,1722,1723,1,0,0,0,1723,1724,1,0,0,0,1724,
  	1726,5,44,0,0,1725,1720,1,0,0,0,1725,1726,1,0,0,0,1726,1727,1,0,0,0,1727,
  	1737,5,31,0,0,1728,1730,3,1240,620,0,1729,1728,1,0,0,0,1730,1733,1,0,
  	0,0,1731,1729,1,0,0,0,1731,1732,1,0,0,0,1732,1734,1,0,0,0,1733,1731,1,
  	0,0,0,1734,1736,3,118,59,0,1735,1731,1,0,0,0,1736,1739,1,0,0,0,1737,1735,
  	1,0,0,0,1737,1738,1,0,0,0,1738,1740,1,0,0,0,1739,1737,1,0,0,0,1740,1743,
  	5,61,0,0,1741,1742,5,33,0,0,1742,1744,3,1248,624,0,1743,1741,1,0,0,0,
  	1743,1744,1,0,0,0,1744,39,1,0,0,0,1745,1747,3,34,17,0,1746,1748,3,54,
  	27,0,1747,1746,1,0,0,0,1747,1748,1,0,0,0,1748,1752,1,0,0,0,1749,1751,
  	3,108,54,0,1750,1749,1,0,0,0,1751,1754,1,0,0,0,1752,1750,1,0,0,0,1752,
  	1753,1,0,0,0,1753,1755,1,0,0,0,1754,1752,1,0,0,0,1755,1758,5,51,0,0,1756,
  	1757,5,33,0,0,1757,1759,3,1248,624,0,1758,1756,1,0,0,0,1758,1759,1,0,
  	0,0,1759,1807,1,0,0,0,1760,1762,3,36,18,0,1761,1763,3,54,27,0,1762,1761,
  	1,0,0,0,1762,1763,1,0,0,0,1763,1767,1,0,0,0,1764,1766,3,110,55,0,1765,
  	1764,1,0,0,0,1766,1769,1,0,0,0,1767,1765,1,0,0,0,1767,1768,1,0,0,0,1768,
  	1770,1,0,0,0,1769,1767,1,0,0,0,1770,1773,5,51,0,0,1771,1772,5,33,0,0,
  	1772,1774,3,1248,624,0,1773,1771,1,0,0,0,1773,1774,1,0,0,0,1774,1807,
  	1,0,0,0,1775,1777,3,1240,620,0,1776,1775,1,0,0,0,1777,1780,1,0,0,0,1778,
  	1776,1,0,0,0,1778,1779,1,0,0,0,1779,1781,1,0,0,0,1780,1778,1,0,0,0,1781,
  	1782,5,50,0,0,1782,1783,3,1248,624,0,1783,1784,5,43,0,0,1784,1785,5,35,
  	0,0,1785,1786,5,45,0,0,1786,1787,5,44,0,0,1787,1789,5,31,0,0,1788,1790,
  	3,54,27,0,1789,1788,1,0,0,0,1789,1790,1,0,0,0,1790,1794,1,0,0,0,1791,
  	1793,3,108,54,0,1792,1791,1,0,0,0,1793,1796,1,0,0,0,1794,1792,1,0,0,0,
  	1794,1795,1,0,0,0,1795,1797,1,0,0,0,1796,1794,1,0,0,0,1797,1800,5,51,
  	0,0,1798,1799,5,33,0,0,1799,1801,3,1248,624,0,1800,1798,1,0,0,0,1800,
  	1801,1,0,0,0,1801,1807,1,0,0,0,1802,1803,5,46,0,0,1803,1807,3,34,17,0,
  	1804,1805,5,46,0,0,1805,1807,3,36,18,0,1806,1745,1,0,0,0,1806,1760,1,
  	0,0,0,1806,1778,1,0,0,0,1806,1802,1,0,0,0,1806,1804,1,0,0,0,1807,41,1,
  	0,0,0,1808,1810,5,52,0,0,1809,1808,1,0,0,0,1809,1810,1,0,0,0,1810,1811,
  	1,0,0,0,1811,1813,5,53,0,0,1812,1814,3,232,116,0,1813,1812,1,0,0,0,1813,
  	1814,1,0,0,0,1814,1815,1,0,0,0,1815,1817,3,1248,624,0,1816,1818,3,56,
  	28,0,1817,1816,1,0,0,0,1817,1818,1,0,0,0,1818,1827,1,0,0,0,1819,1820,
  	5,55,0,0,1820,1825,3,262,131,0,1821,1822,5,43,0,0,1822,1823,3,1118,559,
  	0,1823,1824,5,44,0,0,1824,1826,1,0,0,0,1825,1821,1,0,0,0,1825,1826,1,
  	0,0,0,1826,1828,1,0,0,0,1827,1819,1,0,0,0,1827,1828,1,0,0,0,1828,1838,
  	1,0,0,0,1829,1830,5,170,0,0,1830,1835,3,44,22,0,1831,1832,5,30,0,0,1832,
  	1834,3,44,22,0,1833,1831,1,0,0,0,1834,1837,1,0,0,0,1835,1833,1,0,0,0,
  	1835,1836,1,0,0,0,1836,1839,1,0,0,0,1837,1835,1,0,0,0,1838,1829,1,0,0,
  	0,1838,1839,1,0,0,0,1839,1840,1,0,0,0,1840,1844,5,31,0,0,1841,1843,3,
  	124,62,0,1842,1841,1,0,0,0,1843,1846,1,0,0,0,1844,1842,1,0,0,0,1844,1845,
  	1,0,0,0,1845,1847,1,0,0,0,1846,1844,1,0,0,0,1847,1850,5,54,0,0,1848,1849,
  	5,33,0,0,1849,1851,3,1248,624,0,1850,1848,1,0,0,0,1850,1851,1,0,0,0,1851,
  	43,1,0,0,0,1852,1854,3,1254,627,0,1853,1855,3,610,305,0,1854,1853,1,0,
  	0,0,1854,1855,1,0,0,0,1855,45,1,0,0,0,1856,1857,5,48,0,0,1857,1858,5,
  	53,0,0,1858,1860,3,1248,624,0,1859,1861,3,56,28,0,1860,1859,1,0,0,0,1860,
  	1861,1,0,0,0,1861,1871,1,0,0,0,1862,1863,5,55,0,0,1863,1868,3,44,22,0,
  	1864,1865,5,30,0,0,1865,1867,3,44,22,0,1866,1864,1,0,0,0,1867,1870,1,
  	0,0,0,1868,1866,1,0,0,0,1868,1869,1,0,0,0,1869,1872,1,0,0,0,1870,1868,
  	1,0,0,0,1871,1862,1,0,0,0,1871,1872,1,0,0,0,1872,1873,1,0,0,0,1873,1877,
  	5,31,0,0,1874,1876,3,48,24,0,1875,1874,1,0,0,0,1876,1879,1,0,0,0,1877,
  	1875,1,0,0,0,1877,1878,1,0,0,0,1878,1880,1,0,0,0,1879,1877,1,0,0,0,1880,
  	1883,5,54,0,0,1881,1882,5,33,0,0,1882,1884,3,1248,624,0,1883,1881,1,0,
  	0,0,1883,1884,1,0,0,0,1884,47,1,0,0,0,1885,1903,3,218,109,0,1886,1888,
  	3,1240,620,0,1887,1886,1,0,0,0,1888,1891,1,0,0,0,1889,1887,1,0,0,0,1889,
  	1890,1,0,0,0,1890,1892,1,0,0,0,1891,1889,1,0,0,0,1892,1893,3,50,25,0,
  	1893,1894,5,31,0,0,1894,1903,1,0,0,0,1895,1896,3,186,93,0,1896,1897,5,
  	31,0,0,1897,1903,1,0,0,0,1898,1899,3,188,94,0,1899,1900,5,31,0,0,1900,
  	1903,1,0,0,0,1901,1903,5,31,0,0,1902,1885,1,0,0,0,1902,1889,1,0,0,0,1902,
  	1895,1,0,0,0,1902,1898,1,0,0,0,1902,1901,1,0,0,0,1903,49,1,0,0,0,1904,
  	1905,5,169,0,0,1905,1906,5,52,0,0,1906,1907,3,144,72,0,1907,51,1,0,0,
  	0,1908,1910,3,1240,620,0,1909,1908,1,0,0,0,1910,1913,1,0,0,0,1911,1909,
  	1,0,0,0,1911,1912,1,0,0,0,1912,1914,1,0,0,0,1913,1911,1,0,0,0,1914,1915,
  	5,56,0,0,1915,1916,3,1248,624,0,1916,1918,5,31,0,0,1917,1919,3,54,27,
  	0,1918,1917,1,0,0,0,1918,1919,1,0,0,0,1919,1929,1,0,0,0,1920,1922,3,1240,
  	620,0,1921,1920,1,0,0,0,1922,1925,1,0,0,0,1923,1921,1,0,0,0,1923,1924,
  	1,0,0,0,1924,1926,1,0,0,0,1925,1923,1,0,0,0,1926,1928,3,178,89,0,1927,
  	1923,1,0,0,0,1928,1931,1,0,0,0,1929,1927,1,0,0,0,1929,1930,1,0,0,0,1930,
  	1932,1,0,0,0,1931,1929,1,0,0,0,1932,1935,5,57,0,0,1933,1934,5,33,0,0,
  	1934,1936,3,1248,624,0,1935,1933,1,0,0,0,1935,1936,1,0,0,0,1936,53,1,
  	0,0,0,1937,1938,5,58,0,0,1938,1939,3,1202,601,0,1939,1940,5,178,0,0,1940,
  	1941,3,1202,601,0,1941,1942,5,31,0,0,1942,1966,1,0,0,0,1943,1944,5,58,
  	0,0,1944,1945,3,1202,601,0,1945,1946,5,31,0,0,1946,1966,1,0,0,0,1947,
  	1948,5,59,0,0,1948,1949,3,1202,601,0,1949,1950,5,31,0,0,1950,1966,1,0,
  	0,0,1951,1952,5,58,0,0,1952,1953,3,1202,601,0,1953,1954,5,31,0,0,1954,
  	1955,5,59,0,0,1955,1956,3,1202,601,0,1956,1957,5,31,0,0,1957,1966,1,0,
  	0,0,1958,1959,5,59,0,0,1959,1960,3,1202,601,0,1960,1961,5,31,0,0,1961,
  	1962,5,58,0,0,1962,1963,3,1202,601,0,1963,1964,5,31,0,0,1964,1966,1,0,
  	0,0,1965,1937,1,0,0,0,1965,1943,1,0,0,0,1965,1947,1,0,0,0,1965,1951,1,
  	0,0,0,1965,1958,1,0,0,0,1966,55,1,0,0,0,1967,1968,5,213,0,0,1968,1969,
  	5,43,0,0,1969,1974,3,318,159,0,1970,1971,5,30,0,0,1971,1973,3,58,29,0,
  	1972,1970,1,0,0,0,1973,1976,1,0,0,0,1974,1972,1,0,0,0,1974,1975,1,0,0,
  	0,1975,1977,1,0,0,0,1976,1974,1,0,0,0,1977,1978,5,44,0,0,1978,1995,1,
  	0,0,0,1979,1980,5,213,0,0,1980,1981,5,43,0,0,1981,1986,3,58,29,0,1982,
  	1983,5,30,0,0,1983,1985,3,58,29,0,1984,1982,1,0,0,0,1985,1988,1,0,0,0,
  	1986,1984,1,0,0,0,1986,1987,1,0,0,0,1987,1989,1,0,0,0,1988,1986,1,0,0,
  	0,1989,1990,5,44,0,0,1990,1995,1,0,0,0,1991,1992,5,213,0,0,1992,1993,
  	5,43,0,0,1993,1995,5,44,0,0,1994,1967,1,0,0,0,1994,1979,1,0,0,0,1994,
  	1991,1,0,0,0,1995,57,1,0,0,0,1996,2004,3,188,94,0,1997,2004,3,186,93,
  	0,1998,1999,3,236,118,0,1999,2000,3,318,159,0,2000,2004,1,0,0,0,2001,
  	2002,5,64,0,0,2002,2004,3,326,163,0,2003,1996,1,0,0,0,2003,1997,1,0,0,
  	0,2003,1998,1,0,0,0,2003,2001,1,0,0,0,2004,59,1,0,0,0,2005,2006,5,43,
  	0,0,2006,2011,3,66,33,0,2007,2008,5,30,0,0,2008,2010,3,66,33,0,2009,2007,
  	1,0,0,0,2010,2013,1,0,0,0,2011,2009,1,0,0,0,2011,2012,1,0,0,0,2012,2014,
  	1,0,0,0,2013,2011,1,0,0,0,2014,2015,5,44,0,0,2015,61,1,0,0,0,2016,2037,
  	5,43,0,0,2017,2019,3,1240,620,0,2018,2017,1,0,0,0,2019,2022,1,0,0,0,2020,
  	2018,1,0,0,0,2020,2021,1,0,0,0,2021,2023,1,0,0,0,2022,2020,1,0,0,0,2023,
  	2034,3,80,40,0,2024,2028,5,30,0,0,2025,2027,3,1240,620,0,2026,2025,1,
  	0,0,0,2027,2030,1,0,0,0,2028,2026,1,0,0,0,2028,2029,1,0,0,0,2029,2031,
  	1,0,0,0,2030,2028,1,0,0,0,2031,2033,3,80,40,0,2032,2024,1,0,0,0,2033,
  	2036,1,0,0,0,2034,2032,1,0,0,0,2034,2035,1,0,0,0,2035,2038,1,0,0,0,2036,
  	2034,1,0,0,0,2037,2020,1,0,0,0,2037,2038,1,0,0,0,2038,2039,1,0,0,0,2039,
  	2040,5,44,0,0,2040,63,1,0,0,0,2041,2043,3,1240,620,0,2042,2041,1,0,0,
  	0,2043,2046,1,0,0,0,2044,2042,1,0,0,0,2044,2045,1,0,0,0,2045,2052,1,0,
  	0,0,2046,2044,1,0,0,0,2047,2053,3,192,96,0,2048,2053,3,194,97,0,2049,
  	2053,3,196,98,0,2050,2053,3,200,100,0,2051,2053,3,198,99,0,2052,2047,
  	1,0,0,0,2052,2048,1,0,0,0,2052,2049,1,0,0,0,2052,2050,1,0,0,0,2052,2051,
  	1,0,0,0,2053,65,1,0,0,0,2054,2056,3,68,34,0,2055,2054,1,0,0,0,2055,2056,
  	1,0,0,0,2056,2066,1,0,0,0,2057,2058,5,35,0,0,2058,2059,3,1248,624,0,2059,
  	2061,5,43,0,0,2060,2062,3,68,34,0,2061,2060,1,0,0,0,2061,2062,1,0,0,0,
  	2062,2063,1,0,0,0,2063,2064,5,44,0,0,2064,2066,1,0,0,0,2065,2055,1,0,
  	0,0,2065,2057,1,0,0,0,2066,67,1,0,0,0,2067,2080,3,70,35,0,2068,2069,5,
  	85,0,0,2069,2074,3,70,35,0,2070,2071,5,30,0,0,2071,2073,3,70,35,0,2072,
  	2070,1,0,0,0,2073,2076,1,0,0,0,2074,2072,1,0,0,0,2074,2075,1,0,0,0,2075,
  	2077,1,0,0,0,2076,2074,1,0,0,0,2077,2078,5,86,0,0,2078,2080,1,0,0,0,2079,
  	2067,1,0,0,0,2079,2068,1,0,0,0,2080,69,1,0,0,0,2081,2082,3,1248,624,0,
  	2082,2083,3,1216,608,0,2083,71,1,0,0,0,2084,2085,7,2,0,0,2085,73,1,0,
  	0,0,2086,2088,3,72,36,0,2087,2086,1,0,0,0,2087,2088,1,0,0,0,2088,2089,
  	1,0,0,0,2089,2090,3,274,137,0,2090,75,1,0,0,0,2091,2093,3,72,36,0,2092,
  	2091,1,0,0,0,2092,2093,1,0,0,0,2093,2094,1,0,0,0,2094,2095,3,276,138,
  	0,2095,77,1,0,0,0,2096,2099,3,1250,625,0,2097,2098,5,35,0,0,2098,2100,
  	3,1248,624,0,2099,2097,1,0,0,0,2099,2100,1,0,0,0,2100,2107,1,0,0,0,2101,
  	2104,5,48,0,0,2102,2103,5,35,0,0,2103,2105,3,1248,624,0,2104,2102,1,0,
  	0,0,2104,2105,1,0,0,0,2105,2107,1,0,0,0,2106,2096,1,0,0,0,2106,2101,1,
  	0,0,0,2107,79,1,0,0,0,2108,2111,3,74,37,0,2109,2111,3,78,39,0,2110,2108,
  	1,0,0,0,2110,2109,1,0,0,0,2111,2112,1,0,0,0,2112,2116,3,1248,624,0,2113,
  	2115,3,352,176,0,2114,2113,1,0,0,0,2115,2118,1,0,0,0,2116,2114,1,0,0,
  	0,2116,2117,1,0,0,0,2117,2121,1,0,0,0,2118,2116,1,0,0,0,2119,2120,5,362,
  	0,0,2120,2122,3,1144,572,0,2121,2119,1,0,0,0,2121,2122,1,0,0,0,2122,2150,
  	1,0,0,0,2123,2125,3,76,38,0,2124,2123,1,0,0,0,2124,2125,1,0,0,0,2125,
  	2126,1,0,0,0,2126,2130,3,1248,624,0,2127,2129,3,358,179,0,2128,2127,1,
  	0,0,0,2129,2132,1,0,0,0,2130,2128,1,0,0,0,2130,2131,1,0,0,0,2131,2135,
  	1,0,0,0,2132,2130,1,0,0,0,2133,2134,5,362,0,0,2134,2136,3,1144,572,0,
  	2135,2133,1,0,0,0,2135,2136,1,0,0,0,2136,2150,1,0,0,0,2137,2140,3,74,
  	37,0,2138,2140,3,76,38,0,2139,2137,1,0,0,0,2139,2138,1,0,0,0,2140,2141,
  	1,0,0,0,2141,2142,5,35,0,0,2142,2143,3,1248,624,0,2143,2145,5,43,0,0,
  	2144,2146,3,1162,581,0,2145,2144,1,0,0,0,2145,2146,1,0,0,0,2146,2147,
  	1,0,0,0,2147,2148,5,44,0,0,2148,2150,1,0,0,0,2149,2110,1,0,0,0,2149,2124,
  	1,0,0,0,2149,2139,1,0,0,0,2150,81,1,0,0,0,2151,2152,5,166,0,0,2152,2171,
  	5,368,0,0,2153,2154,5,43,0,0,2154,2157,3,1236,618,0,2155,2156,5,30,0,
  	0,2156,2158,3,1118,559,0,2157,2155,1,0,0,0,2157,2158,1,0,0,0,2158,2159,
  	1,0,0,0,2159,2160,5,44,0,0,2160,2162,1,0,0,0,2161,2153,1,0,0,0,2161,2162,
  	1,0,0,0,2162,2163,1,0,0,0,2163,2172,5,31,0,0,2164,2165,5,43,0,0,2165,
  	2166,3,1118,559,0,2166,2167,5,44,0,0,2167,2169,1,0,0,0,2168,2164,1,0,
  	0,0,2168,2169,1,0,0,0,2169,2170,1,0,0,0,2170,2172,5,31,0,0,2171,2161,
  	1,0,0,0,2171,2168,1,0,0,0,2172,83,1,0,0,0,2173,2187,3,90,45,0,2174,2187,
  	3,608,304,0,2175,2187,3,878,439,0,2176,2187,3,96,48,0,2177,2187,3,744,
  	372,0,2178,2187,3,750,375,0,2179,2187,3,754,377,0,2180,2187,3,810,405,
  	0,2181,2187,3,756,378,0,2182,2187,3,674,337,0,2183,2187,3,680,340,0,2184,
  	2187,3,82,41,0,2185,2187,3,1264,632,0,2186,2173,1,0,0,0,2186,2174,1,0,
  	0,0,2186,2175,1,0,0,0,2186,2176,1,0,0,0,2186,2177,1,0,0,0,2186,2178,1,
  	0,0,0,2186,2179,1,0,0,0,2186,2180,1,0,0,0,2186,2181,1,0,0,0,2186,2182,
  	1,0,0,0,2186,2183,1,0,0,0,2186,2184,1,0,0,0,2186,2185,1,0,0,0,2187,85,
  	1,0,0,0,2188,2189,3,64,32,0,2189,2190,5,31,0,0,2190,2193,1,0,0,0,2191,
  	2193,3,92,46,0,2192,2188,1,0,0,0,2192,2191,1,0,0,0,2193,87,1,0,0,0,2194,
  	2196,3,1240,620,0,2195,2194,1,0,0,0,2196,2199,1,0,0,0,2197,2195,1,0,0,
  	0,2197,2198,1,0,0,0,2198,2205,1,0,0,0,2199,2197,1,0,0,0,2200,2206,3,94,
  	47,0,2201,2206,3,572,286,0,2202,2206,3,740,370,0,2203,2206,3,608,304,
  	0,2204,2206,3,84,42,0,2205,2200,1,0,0,0,2205,2201,1,0,0,0,2205,2202,1,
  	0,0,0,2205,2203,1,0,0,0,2205,2204,1,0,0,0,2206,89,1,0,0,0,2207,2222,3,
  	180,90,0,2208,2222,3,214,107,0,2209,2222,3,902,451,0,2210,2211,5,36,0,
  	0,2211,2212,5,70,0,0,2212,2213,3,1248,624,0,2213,2214,5,31,0,0,2214,2222,
  	1,0,0,0,2215,2216,5,36,0,0,2216,2217,5,197,0,0,2217,2218,5,198,0,0,2218,
  	2219,3,506,253,0,2219,2220,5,31,0,0,2220,2222,1,0,0,0,2221,2207,1,0,0,
  	0,2221,2208,1,0,0,0,2221,2209,1,0,0,0,2221,2210,1,0,0,0,2221,2215,1,0,
  	0,0,2222,91,1,0,0,0,2223,2242,3,672,336,0,2224,2242,3,88,44,0,2225,2242,
  	3,950,475,0,2226,2228,3,1240,620,0,2227,2226,1,0,0,0,2228,2231,1,0,0,
  	0,2229,2227,1,0,0,0,2229,2230,1,0,0,0,2230,2232,1,0,0,0,2231,2229,1,0,
  	0,0,2232,2242,3,190,95,0,2233,2242,3,40,20,0,2234,2242,3,24,12,0,2235,
  	2242,3,54,27,0,2236,2237,3,1264,632,0,2237,2238,5,31,0,0,2238,2242,1,
  	0,0,0,2239,2242,3,1344,672,0,2240,2242,3,1270,635,0,2241,2223,1,0,0,0,
  	2241,2224,1,0,0,0,2241,2225,1,0,0,0,2241,2229,1,0,0,0,2241,2233,1,0,0,
  	0,2241,2234,1,0,0,0,2241,2235,1,0,0,0,2241,2236,1,0,0,0,2241,2239,1,0,
  	0,0,2241,2240,1,0,0,0,2242,93,1,0,0,0,2243,2244,5,71,0,0,2244,2245,3,
  	312,156,0,2245,2246,5,31,0,0,2246,95,1,0,0,0,2247,2248,5,72,0,0,2248,
  	2263,3,1248,624,0,2249,2251,5,33,0,0,2250,2249,1,0,0,0,2250,2251,1,0,
  	0,0,2251,2252,1,0,0,0,2252,2253,3,1248,624,0,2253,2260,3,1214,607,0,2254,
  	2255,5,30,0,0,2255,2256,3,1248,624,0,2256,2257,3,1214,607,0,2257,2259,
  	1,0,0,0,2258,2254,1,0,0,0,2259,2262,1,0,0,0,2260,2258,1,0,0,0,2260,2261,
  	1,0,0,0,2261,2264,1,0,0,0,2262,2260,1,0,0,0,2263,2250,1,0,0,0,2263,2264,
  	1,0,0,0,2264,2265,1,0,0,0,2265,2266,3,98,49,0,2266,97,1,0,0,0,2267,2270,
  	3,608,304,0,2268,2270,3,628,314,0,2269,2267,1,0,0,0,2269,2268,1,0,0,0,
  	2270,99,1,0,0,0,2271,2273,3,1240,620,0,2272,2271,1,0,0,0,2273,2276,1,
  	0,0,0,2274,2272,1,0,0,0,2274,2275,1,0,0,0,2275,2290,1,0,0,0,2276,2274,
  	1,0,0,0,2277,2291,3,84,42,0,2278,2279,5,187,0,0,2279,2284,3,410,205,0,
  	2280,2281,5,30,0,0,2281,2283,3,410,205,0,2282,2280,1,0,0,0,2283,2286,
  	1,0,0,0,2284,2282,1,0,0,0,2284,2285,1,0,0,0,2285,2287,1,0,0,0,2286,2284,
  	1,0,0,0,2287,2288,5,31,0,0,2288,2291,1,0,0,0,2289,2291,3,102,51,0,2290,
  	2277,1,0,0,0,2290,2278,1,0,0,0,2290,2289,1,0,0,0,2291,101,1,0,0,0,2292,
  	2293,5,46,0,0,2293,2294,3,144,72,0,2294,2295,5,31,0,0,2295,2302,1,0,0,
  	0,2296,2297,5,46,0,0,2297,2298,5,73,0,0,2298,2299,3,398,199,0,2299,2300,
  	5,31,0,0,2300,2302,1,0,0,0,2301,2292,1,0,0,0,2301,2296,1,0,0,0,2302,103,
  	1,0,0,0,2303,2304,3,64,32,0,2304,2305,5,31,0,0,2305,2308,1,0,0,0,2306,
  	2308,3,106,53,0,2307,2303,1,0,0,0,2307,2306,1,0,0,0,2308,105,1,0,0,0,
  	2309,2323,3,656,328,0,2310,2312,3,1240,620,0,2311,2310,1,0,0,0,2312,2315,
  	1,0,0,0,2313,2311,1,0,0,0,2313,2314,1,0,0,0,2314,2316,1,0,0,0,2315,2313,
  	1,0,0,0,2316,2323,3,190,95,0,2317,2323,3,100,50,0,2318,2323,3,40,20,0,
  	2319,2323,3,32,16,0,2320,2323,3,54,27,0,2321,2323,3,1344,672,0,2322,2309,
  	1,0,0,0,2322,2313,1,0,0,0,2322,2317,1,0,0,0,2322,2318,1,0,0,0,2322,2319,
  	1,0,0,0,2322,2320,1,0,0,0,2322,2321,1,0,0,0,2323,107,1,0,0,0,2324,2325,
  	3,64,32,0,2325,2326,5,31,0,0,2326,2329,1,0,0,0,2327,2329,3,110,55,0,2328,
  	2324,1,0,0,0,2328,2327,1,0,0,0,2329,109,1,0,0,0,2330,2332,3,1240,620,
  	0,2331,2330,1,0,0,0,2332,2335,1,0,0,0,2333,2331,1,0,0,0,2333,2334,1,0,
  	0,0,2334,2342,1,0,0,0,2335,2333,1,0,0,0,2336,2343,3,744,372,0,2337,2343,
  	3,90,45,0,2338,2343,3,190,95,0,2339,2343,3,754,377,0,2340,2343,3,810,
  	405,0,2341,2343,3,424,212,0,2342,2336,1,0,0,0,2342,2337,1,0,0,0,2342,
  	2338,1,0,0,0,2342,2339,1,0,0,0,2342,2340,1,0,0,0,2342,2341,1,0,0,0,2343,
  	2348,1,0,0,0,2344,2348,3,54,27,0,2345,2348,3,112,56,0,2346,2348,3,1344,
  	672,0,2347,2333,1,0,0,0,2347,2344,1,0,0,0,2347,2345,1,0,0,0,2347,2346,
  	1,0,0,0,2348,111,1,0,0,0,2349,2354,3,674,337,0,2350,2354,3,680,340,0,
  	2351,2354,3,672,336,0,2352,2354,3,82,41,0,2353,2349,1,0,0,0,2353,2350,
  	1,0,0,0,2353,2351,1,0,0,0,2353,2352,1,0,0,0,2354,113,1,0,0,0,2355,2360,
  	3,116,58,0,2356,2357,5,30,0,0,2357,2359,3,116,58,0,2358,2356,1,0,0,0,
  	2359,2362,1,0,0,0,2360,2358,1,0,0,0,2360,2361,1,0,0,0,2361,115,1,0,0,
  	0,2362,2360,1,0,0,0,2363,2365,3,1240,620,0,2364,2363,1,0,0,0,2365,2368,
  	1,0,0,0,2366,2364,1,0,0,0,2366,2367,1,0,0,0,2367,2370,1,0,0,0,2368,2366,
  	1,0,0,0,2369,2371,7,3,0,0,2370,2369,1,0,0,0,2370,2371,1,0,0,0,2371,2372,
  	1,0,0,0,2372,2373,3,456,228,0,2373,2377,3,1248,624,0,2374,2376,3,358,
  	179,0,2375,2374,1,0,0,0,2376,2379,1,0,0,0,2377,2375,1,0,0,0,2377,2378,
  	1,0,0,0,2378,2382,1,0,0,0,2379,2377,1,0,0,0,2380,2381,5,362,0,0,2381,
  	2383,3,442,221,0,2382,2380,1,0,0,0,2382,2383,1,0,0,0,2383,117,1,0,0,0,
  	2384,2392,3,120,60,0,2385,2392,3,754,377,0,2386,2392,3,756,378,0,2387,
  	2392,3,810,405,0,2388,2392,3,878,439,0,2389,2392,3,744,372,0,2390,2392,
  	3,122,61,0,2391,2384,1,0,0,0,2391,2385,1,0,0,0,2391,2386,1,0,0,0,2391,
  	2387,1,0,0,0,2391,2388,1,0,0,0,2391,2389,1,0,0,0,2391,2390,1,0,0,0,2392,
  	119,1,0,0,0,2393,2395,5,80,0,0,2394,2393,1,0,0,0,2395,2398,1,0,0,0,2396,
  	2394,1,0,0,0,2396,2397,1,0,0,0,2397,2399,1,0,0,0,2398,2396,1,0,0,0,2399,
  	2421,3,202,101,0,2400,2421,3,368,184,0,2401,2421,3,38,19,0,2402,2421,
  	3,446,223,0,2403,2421,3,518,259,0,2404,2421,3,402,201,0,2405,2421,3,214,
  	107,0,2406,2421,3,902,451,0,2407,2408,5,36,0,0,2408,2409,5,70,0,0,2409,
  	2410,3,1248,624,0,2410,2411,5,31,0,0,2411,2421,1,0,0,0,2412,2413,5,36,
  	0,0,2413,2414,5,197,0,0,2414,2415,5,198,0,0,2415,2416,3,506,253,0,2416,
  	2417,5,31,0,0,2417,2421,1,0,0,0,2418,2421,5,31,0,0,2419,2421,3,1344,672,
  	0,2420,2396,1,0,0,0,2420,2400,1,0,0,0,2420,2401,1,0,0,0,2420,2402,1,0,
  	0,0,2420,2403,1,0,0,0,2420,2404,1,0,0,0,2420,2405,1,0,0,0,2420,2406,1,
  	0,0,0,2420,2407,1,0,0,0,2420,2412,1,0,0,0,2420,2418,1,0,0,0,2420,2419,
  	1,0,0,0,2421,121,1,0,0,0,2422,2427,3,674,337,0,2423,2427,3,680,340,0,
  	2424,2427,3,672,336,0,2425,2427,3,82,41,0,2426,2422,1,0,0,0,2426,2423,
  	1,0,0,0,2426,2424,1,0,0,0,2426,2425,1,0,0,0,2427,123,1,0,0,0,2428,2430,
  	3,1240,620,0,2429,2428,1,0,0,0,2430,2433,1,0,0,0,2431,2429,1,0,0,0,2431,
  	2432,1,0,0,0,2432,2440,1,0,0,0,2433,2431,1,0,0,0,2434,2441,3,126,63,0,
  	2435,2441,3,132,66,0,2436,2441,3,136,68,0,2437,2441,3,218,109,0,2438,
  	2441,3,42,21,0,2439,2441,3,518,259,0,2440,2434,1,0,0,0,2440,2435,1,0,
  	0,0,2440,2436,1,0,0,0,2440,2437,1,0,0,0,2440,2438,1,0,0,0,2440,2439,1,
  	0,0,0,2441,2451,1,0,0,0,2442,2443,3,186,93,0,2443,2444,5,31,0,0,2444,
  	2451,1,0,0,0,2445,2446,3,188,94,0,2446,2447,5,31,0,0,2447,2451,1,0,0,
  	0,2448,2451,3,1344,672,0,2449,2451,5,31,0,0,2450,2431,1,0,0,0,2450,2442,
  	1,0,0,0,2450,2445,1,0,0,0,2450,2448,1,0,0,0,2450,2449,1,0,0,0,2451,125,
  	1,0,0,0,2452,2454,3,248,124,0,2453,2452,1,0,0,0,2453,2454,1,0,0,0,2454,
  	2458,1,0,0,0,2455,2457,3,140,70,0,2456,2455,1,0,0,0,2457,2460,1,0,0,0,
  	2458,2456,1,0,0,0,2458,2459,1,0,0,0,2459,2461,1,0,0,0,2460,2458,1,0,0,
  	0,2461,2478,3,202,101,0,2462,2466,3,248,124,0,2463,2465,3,138,69,0,2464,
  	2463,1,0,0,0,2465,2468,1,0,0,0,2466,2464,1,0,0,0,2466,2467,1,0,0,0,2467,
  	2469,1,0,0,0,2468,2466,1,0,0,0,2469,2470,3,236,118,0,2470,2473,3,1248,
  	624,0,2471,2472,5,362,0,0,2472,2474,3,1144,572,0,2473,2471,1,0,0,0,2473,
  	2474,1,0,0,0,2474,2475,1,0,0,0,2475,2476,5,31,0,0,2476,2478,1,0,0,0,2477,
  	2453,1,0,0,0,2477,2462,1,0,0,0,2478,127,1,0,0,0,2479,2480,5,169,0,0,2480,
  	2481,5,52,0,0,2481,129,1,0,0,0,2482,2483,5,46,0,0,2483,131,1,0,0,0,2484,
  	2486,3,142,71,0,2485,2484,1,0,0,0,2486,2489,1,0,0,0,2487,2485,1,0,0,0,
  	2487,2488,1,0,0,0,2488,2493,1,0,0,0,2489,2487,1,0,0,0,2490,2494,3,384,
  	192,0,2491,2494,3,368,184,0,2492,2494,3,148,74,0,2493,2490,1,0,0,0,2493,
  	2491,1,0,0,0,2493,2492,1,0,0,0,2494,2519,1,0,0,0,2495,2499,3,128,64,0,
  	2496,2498,3,138,69,0,2497,2496,1,0,0,0,2498,2501,1,0,0,0,2499,2497,1,
  	0,0,0,2499,2500,1,0,0,0,2500,2502,1,0,0,0,2501,2499,1,0,0,0,2502,2503,
  	3,144,72,0,2503,2504,5,31,0,0,2504,2519,1,0,0,0,2505,2509,3,130,65,0,
  	2506,2508,3,142,71,0,2507,2506,1,0,0,0,2508,2511,1,0,0,0,2509,2507,1,
  	0,0,0,2509,2510,1,0,0,0,2510,2516,1,0,0,0,2511,2509,1,0,0,0,2512,2513,
  	3,144,72,0,2513,2514,5,31,0,0,2514,2517,1,0,0,0,2515,2517,3,134,67,0,
  	2516,2512,1,0,0,0,2516,2515,1,0,0,0,2517,2519,1,0,0,0,2518,2487,1,0,0,
  	0,2518,2495,1,0,0,0,2518,2505,1,0,0,0,2519,133,1,0,0,0,2520,2521,5,75,
  	0,0,2521,2527,5,76,0,0,2522,2524,5,43,0,0,2523,2525,3,390,195,0,2524,
  	2523,1,0,0,0,2524,2525,1,0,0,0,2525,2526,1,0,0,0,2526,2528,5,44,0,0,2527,
  	2522,1,0,0,0,2527,2528,1,0,0,0,2528,135,1,0,0,0,2529,2532,3,172,86,0,
  	2530,2532,3,150,75,0,2531,2529,1,0,0,0,2531,2530,1,0,0,0,2532,137,1,0,
  	0,0,2533,2537,5,77,0,0,2534,2537,5,78,0,0,2535,2537,5,79,0,0,2536,2533,
  	1,0,0,0,2536,2534,1,0,0,0,2536,2535,1,0,0,0,2537,139,1,0,0,0,2538,2542,
  	5,80,0,0,2539,2542,5,81,0,0,2540,2542,3,138,69,0,2541,2538,1,0,0,0,2541,
  	2539,1,0,0,0,2541,2540,1,0,0,0,2542,141,1,0,0,0,2543,2546,5,52,0,0,2544,
  	2546,3,138,69,0,2545,2543,1,0,0,0,2545,2544,1,0,0,0,2546,143,1,0,0,0,
  	2547,2550,3,398,199,0,2548,2550,3,372,186,0,2549,2547,1,0,0,0,2549,2548,
  	1,0,0,0,2550,145,1,0,0,0,2551,2552,5,82,0,0,2552,2553,5,35,0,0,2553,2554,
  	5,76,0,0,2554,147,1,0,0,0,2555,2557,5,75,0,0,2556,2558,3,260,130,0,2557,
  	2556,1,0,0,0,2557,2558,1,0,0,0,2558,2559,1,0,0,0,2559,2565,5,76,0,0,2560,
  	2562,5,43,0,0,2561,2563,3,390,195,0,2562,2561,1,0,0,0,2562,2563,1,0,0,
  	0,2563,2564,1,0,0,0,2564,2566,5,44,0,0,2565,2560,1,0,0,0,2565,2566,1,
  	0,0,0,2566,2567,1,0,0,0,2567,2571,5,31,0,0,2568,2570,3,400,200,0,2569,
  	2568,1,0,0,0,2570,2573,1,0,0,0,2571,2569,1,0,0,0,2571,2572,1,0,0,0,2572,
  	2583,1,0,0,0,2573,2571,1,0,0,0,2574,2579,3,146,73,0,2575,2576,5,43,0,
  	0,2576,2577,3,1118,559,0,2577,2578,5,44,0,0,2578,2580,1,0,0,0,2579,2575,
  	1,0,0,0,2579,2580,1,0,0,0,2580,2581,1,0,0,0,2581,2582,5,31,0,0,2582,2584,
  	1,0,0,0,2583,2574,1,0,0,0,2583,2584,1,0,0,0,2584,2588,1,0,0,0,2585,2587,
  	3,790,395,0,2586,2585,1,0,0,0,2587,2590,1,0,0,0,2588,2586,1,0,0,0,2588,
  	2589,1,0,0,0,2589,2591,1,0,0,0,2590,2588,1,0,0,0,2591,2594,5,83,0,0,2592,
  	2593,5,33,0,0,2593,2595,5,76,0,0,2594,2592,1,0,0,0,2594,2595,1,0,0,0,
  	2595,149,1,0,0,0,2596,2598,5,77,0,0,2597,2596,1,0,0,0,2597,2598,1,0,0,
  	0,2598,2599,1,0,0,0,2599,2600,5,84,0,0,2600,2601,3,1248,624,0,2601,2602,
  	3,152,76,0,2602,151,1,0,0,0,2603,2607,5,85,0,0,2604,2606,3,154,77,0,2605,
  	2604,1,0,0,0,2606,2609,1,0,0,0,2607,2605,1,0,0,0,2607,2608,1,0,0,0,2608,
  	2610,1,0,0,0,2609,2607,1,0,0,0,2610,2611,5,86,0,0,2611,153,1,0,0,0,2612,
  	2613,5,87,0,0,2613,2614,3,156,78,0,2614,2615,5,88,0,0,2615,2616,3,156,
  	78,0,2616,2617,5,31,0,0,2617,2620,1,0,0,0,2618,2620,3,160,80,0,2619,2612,
  	1,0,0,0,2619,2618,1,0,0,0,2620,155,1,0,0,0,2621,2626,3,158,79,0,2622,
  	2623,5,30,0,0,2623,2625,3,158,79,0,2624,2622,1,0,0,0,2625,2628,1,0,0,
  	0,2626,2624,1,0,0,0,2626,2627,1,0,0,0,2627,157,1,0,0,0,2628,2626,1,0,
  	0,0,2629,2630,3,1206,603,0,2630,2631,5,35,0,0,2631,2634,1,0,0,0,2632,
  	2634,3,260,130,0,2633,2629,1,0,0,0,2633,2632,1,0,0,0,2633,2634,1,0,0,
  	0,2634,2636,1,0,0,0,2635,2637,3,1196,598,0,2636,2635,1,0,0,0,2636,2637,
  	1,0,0,0,2637,2638,1,0,0,0,2638,2652,3,1248,624,0,2639,2640,5,110,0,0,
  	2640,2641,3,1144,572,0,2641,2642,5,111,0,0,2642,2644,1,0,0,0,2643,2639,
  	1,0,0,0,2644,2647,1,0,0,0,2645,2643,1,0,0,0,2645,2646,1,0,0,0,2646,2648,
  	1,0,0,0,2647,2645,1,0,0,0,2648,2649,5,35,0,0,2649,2651,3,1248,624,0,2650,
  	2645,1,0,0,0,2651,2654,1,0,0,0,2652,2650,1,0,0,0,2652,2653,1,0,0,0,2653,
  	2655,1,0,0,0,2654,2652,1,0,0,0,2655,2656,3,1210,605,0,2656,159,1,0,0,
  	0,2657,2659,5,231,0,0,2658,2657,1,0,0,0,2658,2659,1,0,0,0,2659,2660,1,
  	0,0,0,2660,2661,3,506,253,0,2661,2662,5,31,0,0,2662,2694,1,0,0,0,2663,
  	2664,3,162,81,0,2664,2665,5,31,0,0,2665,2694,1,0,0,0,2666,2667,3,1162,
  	581,0,2667,2668,5,89,0,0,2668,2669,3,164,82,0,2669,2694,1,0,0,0,2670,
  	2671,5,90,0,0,2671,2672,5,43,0,0,2672,2673,3,1162,581,0,2673,2674,5,44,
  	0,0,2674,2677,3,164,82,0,2675,2676,5,91,0,0,2676,2678,3,164,82,0,2677,
  	2675,1,0,0,0,2677,2678,1,0,0,0,2678,2694,1,0,0,0,2679,2680,5,92,0,0,2680,
  	2681,5,43,0,0,2681,2682,3,1258,629,0,2682,2683,5,110,0,0,2683,2684,3,
  	874,437,0,2684,2685,5,111,0,0,2685,2686,5,44,0,0,2686,2687,3,164,82,0,
  	2687,2694,1,0,0,0,2688,2689,5,197,0,0,2689,2690,5,231,0,0,2690,2691,3,
  	158,79,0,2691,2692,5,31,0,0,2692,2694,1,0,0,0,2693,2658,1,0,0,0,2693,
  	2663,1,0,0,0,2693,2666,1,0,0,0,2693,2670,1,0,0,0,2693,2679,1,0,0,0,2693,
  	2688,1,0,0,0,2694,161,1,0,0,0,2695,2696,5,303,0,0,2696,2697,5,85,0,0,
  	2697,2698,3,570,285,0,2698,2699,5,86,0,0,2699,163,1,0,0,0,2700,2710,3,
  	160,80,0,2701,2705,5,85,0,0,2702,2704,3,160,80,0,2703,2702,1,0,0,0,2704,
  	2707,1,0,0,0,2705,2703,1,0,0,0,2705,2706,1,0,0,0,2706,2708,1,0,0,0,2707,
  	2705,1,0,0,0,2708,2710,5,86,0,0,2709,2700,1,0,0,0,2709,2701,1,0,0,0,2710,
  	165,1,0,0,0,2711,2716,3,168,84,0,2712,2713,5,30,0,0,2713,2715,3,168,84,
  	0,2714,2712,1,0,0,0,2715,2718,1,0,0,0,2716,2714,1,0,0,0,2716,2717,1,0,
  	0,0,2717,167,1,0,0,0,2718,2716,1,0,0,0,2719,2721,3,1164,582,0,2720,2722,
  	3,170,85,0,2721,2720,1,0,0,0,2721,2722,1,0,0,0,2722,169,1,0,0,0,2723,
  	2724,5,93,0,0,2724,2729,3,1162,581,0,2725,2726,5,33,0,0,2726,2727,5,178,
  	0,0,2727,2729,3,1162,581,0,2728,2723,1,0,0,0,2728,2725,1,0,0,0,2729,171,
  	1,0,0,0,2730,2733,3,130,65,0,2731,2733,3,382,191,0,2732,2730,1,0,0,0,
  	2732,2731,1,0,0,0,2732,2733,1,0,0,0,2733,2735,1,0,0,0,2734,2736,5,77,
  	0,0,2735,2734,1,0,0,0,2735,2736,1,0,0,0,2736,2737,1,0,0,0,2737,2738,5,
  	84,0,0,2738,2739,3,1248,624,0,2739,2740,5,31,0,0,2740,173,1,0,0,0,2741,
  	2743,5,77,0,0,2742,2741,1,0,0,0,2742,2743,1,0,0,0,2743,2744,1,0,0,0,2744,
  	2745,5,84,0,0,2745,2746,3,260,130,0,2746,2747,3,1248,624,0,2747,2748,
  	3,152,76,0,2748,175,1,0,0,0,2749,2754,3,1248,624,0,2750,2751,5,30,0,0,
  	2751,2753,3,1248,624,0,2752,2750,1,0,0,0,2753,2756,1,0,0,0,2754,2752,
  	1,0,0,0,2754,2755,1,0,0,0,2755,177,1,0,0,0,2756,2754,1,0,0,0,2757,2763,
  	3,180,90,0,2758,2763,3,190,95,0,2759,2763,3,182,91,0,2760,2763,3,212,
  	106,0,2761,2763,3,54,27,0,2762,2757,1,0,0,0,2762,2758,1,0,0,0,2762,2759,
  	1,0,0,0,2762,2760,1,0,0,0,2762,2761,1,0,0,0,2763,179,1,0,0,0,2764,2785,
  	3,216,108,0,2765,2785,3,202,101,0,2766,2785,3,384,192,0,2767,2785,3,368,
  	184,0,2768,2785,3,38,19,0,2769,2785,3,374,187,0,2770,2785,3,174,87,0,
  	2771,2785,3,42,21,0,2772,2785,3,46,23,0,2773,2785,3,148,74,0,2774,2775,
  	3,188,94,0,2775,2776,5,31,0,0,2776,2785,1,0,0,0,2777,2778,3,186,93,0,
  	2778,2779,5,31,0,0,2779,2785,1,0,0,0,2780,2785,3,518,259,0,2781,2785,
  	3,402,201,0,2782,2785,3,446,223,0,2783,2785,5,31,0,0,2784,2764,1,0,0,
  	0,2784,2765,1,0,0,0,2784,2766,1,0,0,0,2784,2767,1,0,0,0,2784,2768,1,0,
  	0,0,2784,2769,1,0,0,0,2784,2770,1,0,0,0,2784,2771,1,0,0,0,2784,2772,1,
  	0,0,0,2784,2773,1,0,0,0,2784,2774,1,0,0,0,2784,2777,1,0,0,0,2784,2780,
  	1,0,0,0,2784,2781,1,0,0,0,2784,2782,1,0,0,0,2784,2783,1,0,0,0,2785,181,
  	1,0,0,0,2786,2787,5,50,0,0,2787,2791,5,31,0,0,2788,2790,3,184,92,0,2789,
  	2788,1,0,0,0,2790,2793,1,0,0,0,2791,2789,1,0,0,0,2791,2792,1,0,0,0,2792,
  	2794,1,0,0,0,2793,2791,1,0,0,0,2794,2795,5,51,0,0,2795,183,1,0,0,0,2796,
  	2804,3,384,192,0,2797,2804,3,368,184,0,2798,2804,3,42,21,0,2799,2804,
  	3,518,259,0,2800,2804,3,148,74,0,2801,2804,5,31,0,0,2802,2804,3,1344,
  	672,0,2803,2796,1,0,0,0,2803,2797,1,0,0,0,2803,2798,1,0,0,0,2803,2799,
  	1,0,0,0,2803,2800,1,0,0,0,2803,2801,1,0,0,0,2803,2802,1,0,0,0,2804,185,
  	1,0,0,0,2805,2808,5,95,0,0,2806,2809,3,252,126,0,2807,2809,5,64,0,0,2808,
  	2806,1,0,0,0,2808,2807,1,0,0,0,2809,2810,1,0,0,0,2810,2811,3,318,159,
  	0,2811,187,1,0,0,0,2812,2815,5,96,0,0,2813,2816,3,252,126,0,2814,2816,
  	5,64,0,0,2815,2813,1,0,0,0,2815,2814,1,0,0,0,2816,2817,1,0,0,0,2817,2818,
  	3,318,159,0,2818,189,1,0,0,0,2819,2821,5,97,0,0,2820,2822,3,354,177,0,
  	2821,2820,1,0,0,0,2821,2822,1,0,0,0,2822,2823,1,0,0,0,2823,2824,3,322,
  	161,0,2824,2825,5,31,0,0,2825,191,1,0,0,0,2826,2827,5,68,0,0,2827,2828,
  	3,274,137,0,2828,2829,3,320,160,0,2829,193,1,0,0,0,2830,2838,5,66,0,0,
  	2831,2832,3,274,137,0,2832,2833,3,320,160,0,2833,2839,1,0,0,0,2834,2836,
  	3,276,138,0,2835,2834,1,0,0,0,2835,2836,1,0,0,0,2836,2837,1,0,0,0,2837,
  	2839,3,330,165,0,2838,2831,1,0,0,0,2838,2835,1,0,0,0,2839,195,1,0,0,0,
  	2840,2848,5,67,0,0,2841,2842,3,274,137,0,2842,2843,3,320,160,0,2843,2849,
  	1,0,0,0,2844,2846,3,276,138,0,2845,2844,1,0,0,0,2845,2846,1,0,0,0,2846,
  	2847,1,0,0,0,2847,2849,3,332,166,0,2848,2841,1,0,0,0,2848,2845,1,0,0,
  	0,2849,197,1,0,0,0,2850,2851,3,1250,625,0,2851,2852,3,314,157,0,2852,
  	2859,1,0,0,0,2853,2854,3,1250,625,0,2854,2855,5,35,0,0,2855,2856,3,1248,
  	624,0,2856,2857,3,314,157,0,2857,2859,1,0,0,0,2858,2850,1,0,0,0,2858,
  	2853,1,0,0,0,2859,199,1,0,0,0,2860,2861,5,69,0,0,2861,2862,3,276,138,
  	0,2862,2863,3,330,165,0,2863,201,1,0,0,0,2864,2866,3,248,124,0,2865,2864,
  	1,0,0,0,2865,2866,1,0,0,0,2866,2877,1,0,0,0,2867,2869,3,232,116,0,2868,
  	2867,1,0,0,0,2868,2869,1,0,0,0,2869,2870,1,0,0,0,2870,2878,3,206,103,
  	0,2871,2873,3,250,125,0,2872,2874,3,232,116,0,2873,2872,1,0,0,0,2873,
  	2874,1,0,0,0,2874,2875,1,0,0,0,2875,2876,3,204,102,0,2876,2878,1,0,0,
  	0,2877,2868,1,0,0,0,2877,2871,1,0,0,0,2878,2883,1,0,0,0,2879,2883,3,218,
  	109,0,2880,2883,3,208,104,0,2881,2883,3,230,115,0,2882,2865,1,0,0,0,2882,
  	2879,1,0,0,0,2882,2880,1,0,0,0,2882,2881,1,0,0,0,2883,203,1,0,0,0,2884,
  	2898,3,252,126,0,2885,2889,3,280,140,0,2886,2888,3,354,177,0,2887,2886,
  	1,0,0,0,2888,2891,1,0,0,0,2889,2887,1,0,0,0,2889,2890,1,0,0,0,2890,2898,
  	1,0,0,0,2891,2889,1,0,0,0,2892,2894,3,354,177,0,2893,2892,1,0,0,0,2894,
  	2895,1,0,0,0,2895,2893,1,0,0,0,2895,2896,1,0,0,0,2896,2898,1,0,0,0,2897,
  	2884,1,0,0,0,2897,2885,1,0,0,0,2897,2893,1,0,0,0,2898,2899,1,0,0,0,2899,
  	2900,3,328,164,0,2900,2901,5,31,0,0,2901,205,1,0,0,0,2902,2916,3,236,
  	118,0,2903,2907,3,280,140,0,2904,2906,3,354,177,0,2905,2904,1,0,0,0,2906,
  	2909,1,0,0,0,2907,2905,1,0,0,0,2907,2908,1,0,0,0,2908,2916,1,0,0,0,2909,
  	2907,1,0,0,0,2910,2912,3,354,177,0,2911,2910,1,0,0,0,2912,2913,1,0,0,
  	0,2913,2911,1,0,0,0,2913,2914,1,0,0,0,2914,2916,1,0,0,0,2915,2902,1,0,
  	0,0,2915,2903,1,0,0,0,2915,2911,1,0,0,0,2916,2917,1,0,0,0,2917,2918,3,
  	328,164,0,2918,2919,5,31,0,0,2919,207,1,0,0,0,2920,2921,5,98,0,0,2921,
  	2926,3,210,105,0,2922,2923,5,30,0,0,2923,2925,3,210,105,0,2924,2922,1,
  	0,0,0,2925,2928,1,0,0,0,2926,2924,1,0,0,0,2926,2927,1,0,0,0,2927,2929,
  	1,0,0,0,2928,2926,1,0,0,0,2929,2930,5,31,0,0,2930,209,1,0,0,0,2931,2932,
  	3,1248,624,0,2932,2935,5,32,0,0,2933,2936,3,1248,624,0,2934,2936,5,45,
  	0,0,2935,2933,1,0,0,0,2935,2934,1,0,0,0,2936,211,1,0,0,0,2937,2938,5,
  	167,0,0,2938,2939,5,176,0,0,2939,2949,5,31,0,0,2940,2941,5,167,0,0,2941,
  	2944,3,210,105,0,2942,2943,5,30,0,0,2943,2945,3,210,105,0,2944,2942,1,
  	0,0,0,2944,2945,1,0,0,0,2945,2946,1,0,0,0,2946,2947,5,31,0,0,2947,2949,
  	1,0,0,0,2948,2937,1,0,0,0,2948,2940,1,0,0,0,2949,213,1,0,0,0,2950,2951,
  	5,99,0,0,2951,2952,3,176,88,0,2952,2953,5,31,0,0,2953,215,1,0,0,0,2954,
  	2957,3,272,136,0,2955,2958,3,296,148,0,2956,2958,3,302,151,0,2957,2955,
  	1,0,0,0,2957,2956,1,0,0,0,2957,2958,1,0,0,0,2958,2960,1,0,0,0,2959,2961,
  	7,4,0,0,2960,2959,1,0,0,0,2960,2961,1,0,0,0,2961,2962,1,0,0,0,2962,2964,
  	3,252,126,0,2963,2965,3,304,152,0,2964,2963,1,0,0,0,2964,2965,1,0,0,0,
  	2965,2966,1,0,0,0,2966,2967,3,316,158,0,2967,2968,5,31,0,0,2968,3001,
  	1,0,0,0,2969,2971,3,1248,624,0,2970,2972,3,796,398,0,2971,2970,1,0,0,
  	0,2971,2972,1,0,0,0,2972,2973,1,0,0,0,2973,2974,3,316,158,0,2974,2975,
  	5,31,0,0,2975,3001,1,0,0,0,2976,2977,5,149,0,0,2977,2979,3,254,127,0,
  	2978,2980,3,308,154,0,2979,2978,1,0,0,0,2979,2980,1,0,0,0,2980,2981,1,
  	0,0,0,2981,2985,3,1248,624,0,2982,2984,3,352,176,0,2983,2982,1,0,0,0,
  	2984,2987,1,0,0,0,2985,2983,1,0,0,0,2985,2986,1,0,0,0,2986,2996,1,0,0,
  	0,2987,2985,1,0,0,0,2988,2989,5,30,0,0,2989,2993,3,1248,624,0,2990,2992,
  	3,352,176,0,2991,2990,1,0,0,0,2992,2995,1,0,0,0,2993,2991,1,0,0,0,2993,
  	2994,1,0,0,0,2994,2997,1,0,0,0,2995,2993,1,0,0,0,2996,2988,1,0,0,0,2996,
  	2997,1,0,0,0,2997,2998,1,0,0,0,2998,2999,5,31,0,0,2999,3001,1,0,0,0,3000,
  	2954,1,0,0,0,3000,2969,1,0,0,0,3000,2976,1,0,0,0,3001,217,1,0,0,0,3002,
  	3028,5,102,0,0,3003,3006,3,236,118,0,3004,3006,3,272,136,0,3005,3003,
  	1,0,0,0,3005,3004,1,0,0,0,3006,3007,1,0,0,0,3007,3011,3,1248,624,0,3008,
  	3010,3,358,179,0,3009,3008,1,0,0,0,3010,3013,1,0,0,0,3011,3009,1,0,0,
  	0,3011,3012,1,0,0,0,3012,3029,1,0,0,0,3013,3011,1,0,0,0,3014,3015,3,1248,
  	624,0,3015,3016,3,1214,607,0,3016,3017,5,35,0,0,3017,3018,3,1248,624,
  	0,3018,3019,3,1248,624,0,3019,3029,1,0,0,0,3020,3026,3,220,110,0,3021,
  	3026,3,222,111,0,3022,3026,3,224,112,0,3023,3026,3,226,113,0,3024,3026,
  	3,228,114,0,3025,3020,1,0,0,0,3025,3021,1,0,0,0,3025,3022,1,0,0,0,3025,
  	3023,1,0,0,0,3025,3024,1,0,0,0,3025,3026,1,0,0,0,3026,3027,1,0,0,0,3027,
  	3029,3,1248,624,0,3028,3005,1,0,0,0,3028,3014,1,0,0,0,3028,3025,1,0,0,
  	0,3029,3030,1,0,0,0,3030,3031,5,31,0,0,3031,219,1,0,0,0,3032,3033,5,103,
  	0,0,3033,221,1,0,0,0,3034,3035,5,104,0,0,3035,223,1,0,0,0,3036,3037,5,
  	105,0,0,3037,225,1,0,0,0,3038,3039,5,53,0,0,3039,227,1,0,0,0,3040,3041,
  	5,48,0,0,3041,3042,5,53,0,0,3042,229,1,0,0,0,3043,3061,5,363,0,0,3044,
  	3045,3,236,118,0,3045,3052,3,1248,624,0,3046,3049,5,321,0,0,3047,3050,
  	3,1252,626,0,3048,3050,3,260,130,0,3049,3047,1,0,0,0,3049,3048,1,0,0,
  	0,3049,3050,1,0,0,0,3050,3051,1,0,0,0,3051,3053,3,1248,624,0,3052,3046,
  	1,0,0,0,3052,3053,1,0,0,0,3053,3062,1,0,0,0,3054,3057,3,1252,626,0,3055,
  	3057,3,260,130,0,3056,3054,1,0,0,0,3056,3055,1,0,0,0,3056,3057,1,0,0,
  	0,3057,3058,1,0,0,0,3058,3059,3,1248,624,0,3059,3060,3,1248,624,0,3060,
  	3062,1,0,0,0,3061,3044,1,0,0,0,3061,3056,1,0,0,0,3062,3063,1,0,0,0,3063,
  	3064,5,31,0,0,3064,231,1,0,0,0,3065,3068,5,77,0,0,3066,3068,5,94,0,0,
  	3067,3065,1,0,0,0,3067,3066,1,0,0,0,3068,233,1,0,0,0,3069,3092,3,282,
  	141,0,3070,3092,3,1218,609,0,3071,3074,3,1252,626,0,3072,3074,3,260,130,
  	0,3073,3071,1,0,0,0,3073,3072,1,0,0,0,3073,3074,1,0,0,0,3074,3075,1,0,
  	0,0,3075,3076,3,1248,624,0,3076,3081,3,1216,608,0,3077,3078,5,110,0,0,
  	3078,3079,3,1154,577,0,3079,3080,5,111,0,0,3080,3082,1,0,0,0,3081,3077,
  	1,0,0,0,3081,3082,1,0,0,0,3082,3092,1,0,0,0,3083,3084,5,43,0,0,3084,3085,
  	3,1144,572,0,3085,3086,5,44,0,0,3086,3092,1,0,0,0,3087,3092,3,280,140,
  	0,3088,3092,3,240,120,0,3089,3092,3,248,124,0,3090,3092,3,1264,632,0,
  	3091,3069,1,0,0,0,3091,3070,1,0,0,0,3091,3073,1,0,0,0,3091,3083,1,0,0,
  	0,3091,3087,1,0,0,0,3091,3088,1,0,0,0,3091,3089,1,0,0,0,3091,3090,1,0,
  	0,0,3092,235,1,0,0,0,3093,3095,3,268,134,0,3094,3096,3,280,140,0,3095,
  	3094,1,0,0,0,3095,3096,1,0,0,0,3096,3100,1,0,0,0,3097,3099,3,354,177,
  	0,3098,3097,1,0,0,0,3099,3102,1,0,0,0,3100,3098,1,0,0,0,3100,3101,1,0,
  	0,0,3101,3187,1,0,0,0,3102,3100,1,0,0,0,3103,3105,3,266,133,0,3104,3106,
  	3,280,140,0,3105,3104,1,0,0,0,3105,3106,1,0,0,0,3106,3187,1,0,0,0,3107,
  	3187,3,270,135,0,3108,3113,3,290,145,0,3109,3111,3,238,119,0,3110,3112,
  	3,280,140,0,3111,3110,1,0,0,0,3111,3112,1,0,0,0,3112,3114,1,0,0,0,3113,
  	3109,1,0,0,0,3113,3114,1,0,0,0,3114,3115,1,0,0,0,3115,3116,5,85,0,0,3116,
  	3120,3,286,143,0,3117,3119,3,286,143,0,3118,3117,1,0,0,0,3119,3122,1,
  	0,0,0,3120,3118,1,0,0,0,3120,3121,1,0,0,0,3121,3123,1,0,0,0,3122,3120,
  	1,0,0,0,3123,3127,5,86,0,0,3124,3126,3,354,177,0,3125,3124,1,0,0,0,3126,
  	3129,1,0,0,0,3127,3125,1,0,0,0,3127,3128,1,0,0,0,3128,3187,1,0,0,0,3129,
  	3127,1,0,0,0,3130,3132,5,103,0,0,3131,3133,3,256,128,0,3132,3131,1,0,
  	0,0,3132,3133,1,0,0,0,3133,3134,1,0,0,0,3134,3135,5,85,0,0,3135,3140,
  	3,258,129,0,3136,3137,5,30,0,0,3137,3139,3,258,129,0,3138,3136,1,0,0,
  	0,3139,3142,1,0,0,0,3140,3138,1,0,0,0,3140,3141,1,0,0,0,3141,3143,1,0,
  	0,0,3142,3140,1,0,0,0,3143,3144,5,86,0,0,3144,3187,1,0,0,0,3145,3187,
  	3,240,120,0,3146,3187,3,244,122,0,3147,3149,5,52,0,0,3148,3150,5,48,0,
  	0,3149,3148,1,0,0,0,3149,3150,1,0,0,0,3150,3151,1,0,0,0,3151,3153,3,1250,
  	625,0,3152,3154,3,610,305,0,3153,3152,1,0,0,0,3153,3154,1,0,0,0,3154,
  	3157,1,0,0,0,3155,3156,5,35,0,0,3156,3158,3,1248,624,0,3157,3155,1,0,
  	0,0,3157,3158,1,0,0,0,3158,3187,1,0,0,0,3159,3162,3,260,130,0,3160,3162,
  	3,1252,626,0,3161,3159,1,0,0,0,3161,3160,1,0,0,0,3161,3162,1,0,0,0,3162,
  	3163,1,0,0,0,3163,3182,3,1248,624,0,3164,3166,3,354,177,0,3165,3164,1,
  	0,0,0,3166,3167,1,0,0,0,3167,3165,1,0,0,0,3167,3168,1,0,0,0,3168,3183,
  	1,0,0,0,3169,3171,3,610,305,0,3170,3169,1,0,0,0,3170,3171,1,0,0,0,3171,
  	3179,1,0,0,0,3172,3173,5,32,0,0,3173,3175,3,1248,624,0,3174,3176,3,610,
  	305,0,3175,3174,1,0,0,0,3175,3176,1,0,0,0,3176,3178,1,0,0,0,3177,3172,
  	1,0,0,0,3178,3181,1,0,0,0,3179,3177,1,0,0,0,3179,3180,1,0,0,0,3180,3183,
  	1,0,0,0,3181,3179,1,0,0,0,3182,3165,1,0,0,0,3182,3170,1,0,0,0,3183,3187,
  	1,0,0,0,3184,3187,3,246,123,0,3185,3187,3,294,147,0,3186,3093,1,0,0,0,
  	3186,3103,1,0,0,0,3186,3107,1,0,0,0,3186,3108,1,0,0,0,3186,3130,1,0,0,
  	0,3186,3145,1,0,0,0,3186,3146,1,0,0,0,3186,3147,1,0,0,0,3186,3161,1,0,
  	0,0,3186,3184,1,0,0,0,3186,3185,1,0,0,0,3187,237,1,0,0,0,3188,3189,5,
  	106,0,0,3189,239,1,0,0,0,3190,3191,5,107,0,0,3191,241,1,0,0,0,3192,3193,
  	5,20,0,0,3193,243,1,0,0,0,3194,3195,5,108,0,0,3195,245,1,0,0,0,3196,3197,
  	5,109,0,0,3197,247,1,0,0,0,3198,3199,5,74,0,0,3199,249,1,0,0,0,3200,3201,
  	5,150,0,0,3201,251,1,0,0,0,3202,3213,3,236,118,0,3203,3205,3,280,140,
  	0,3204,3203,1,0,0,0,3204,3205,1,0,0,0,3205,3209,1,0,0,0,3206,3208,3,354,
  	177,0,3207,3206,1,0,0,0,3208,3211,1,0,0,0,3209,3207,1,0,0,0,3209,3210,
  	1,0,0,0,3210,3213,1,0,0,0,3211,3209,1,0,0,0,3212,3202,1,0,0,0,3212,3204,
  	1,0,0,0,3213,253,1,0,0,0,3214,3216,3,280,140,0,3215,3214,1,0,0,0,3215,
  	3216,1,0,0,0,3216,3220,1,0,0,0,3217,3219,3,354,177,0,3218,3217,1,0,0,
  	0,3219,3222,1,0,0,0,3220,3218,1,0,0,0,3220,3221,1,0,0,0,3221,255,1,0,
  	0,0,3222,3220,1,0,0,0,3223,3225,3,266,133,0,3224,3226,3,280,140,0,3225,
  	3224,1,0,0,0,3225,3226,1,0,0,0,3226,3239,1,0,0,0,3227,3229,3,268,134,
  	0,3228,3230,3,280,140,0,3229,3228,1,0,0,0,3229,3230,1,0,0,0,3230,3232,
  	1,0,0,0,3231,3233,3,354,177,0,3232,3231,1,0,0,0,3232,3233,1,0,0,0,3233,
  	3239,1,0,0,0,3234,3236,3,1248,624,0,3235,3237,3,354,177,0,3236,3235,1,
  	0,0,0,3236,3237,1,0,0,0,3237,3239,1,0,0,0,3238,3223,1,0,0,0,3238,3227,
  	1,0,0,0,3238,3234,1,0,0,0,3239,257,1,0,0,0,3240,3248,3,1248,624,0,3241,
  	3242,5,110,0,0,3242,3245,5,18,0,0,3243,3244,5,33,0,0,3244,3246,5,18,0,
  	0,3245,3243,1,0,0,0,3245,3246,1,0,0,0,3246,3247,1,0,0,0,3247,3249,5,111,
  	0,0,3248,3241,1,0,0,0,3248,3249,1,0,0,0,3249,3252,1,0,0,0,3250,3251,5,
  	362,0,0,3251,3253,3,1144,572,0,3252,3250,1,0,0,0,3252,3253,1,0,0,0,3253,
  	259,1,0,0,0,3254,3255,3,262,131,0,3255,3256,5,32,0,0,3256,261,1,0,0,0,
  	3257,3259,7,5,0,0,3258,3260,3,610,305,0,3259,3258,1,0,0,0,3259,3260,1,
  	0,0,0,3260,3268,1,0,0,0,3261,3262,5,32,0,0,3262,3264,3,1248,624,0,3263,
  	3265,3,610,305,0,3264,3263,1,0,0,0,3264,3265,1,0,0,0,3265,3267,1,0,0,
  	0,3266,3261,1,0,0,0,3267,3270,1,0,0,0,3268,3266,1,0,0,0,3268,3269,1,0,
  	0,0,3269,263,1,0,0,0,3270,3268,1,0,0,0,3271,3274,3,268,134,0,3272,3274,
  	3,266,133,0,3273,3271,1,0,0,0,3273,3272,1,0,0,0,3274,265,1,0,0,0,3275,
  	3276,7,6,0,0,3276,267,1,0,0,0,3277,3278,7,7,0,0,3278,269,1,0,0,0,3279,
  	3280,7,8,0,0,3280,271,1,0,0,0,3281,3282,7,9,0,0,3282,273,1,0,0,0,3283,
  	3285,3,272,136,0,3284,3283,1,0,0,0,3284,3285,1,0,0,0,3285,3286,1,0,0,
  	0,3286,3291,3,252,126,0,3287,3291,3,1248,624,0,3288,3289,5,149,0,0,3289,
  	3291,3,254,127,0,3290,3284,1,0,0,0,3290,3287,1,0,0,0,3290,3288,1,0,0,
  	0,3291,275,1,0,0,0,3292,3298,3,278,139,0,3293,3294,5,110,0,0,3294,3295,
  	3,1158,579,0,3295,3296,5,111,0,0,3296,3298,1,0,0,0,3297,3292,1,0,0,0,
  	3297,3293,1,0,0,0,3298,277,1,0,0,0,3299,3304,3,236,118,0,3300,3301,3,
  	250,125,0,3301,3302,3,252,126,0,3302,3304,1,0,0,0,3303,3299,1,0,0,0,3303,
  	3300,1,0,0,0,3304,279,1,0,0,0,3305,3306,7,10,0,0,3306,281,1,0,0,0,3307,
  	3311,3,264,132,0,3308,3311,3,270,135,0,3309,3311,3,1262,631,0,3310,3307,
  	1,0,0,0,3310,3308,1,0,0,0,3310,3309,1,0,0,0,3311,283,1,0,0,0,3312,3315,
  	5,80,0,0,3313,3315,5,81,0,0,3314,3312,1,0,0,0,3314,3313,1,0,0,0,3315,
  	285,1,0,0,0,3316,3318,3,1240,620,0,3317,3316,1,0,0,0,3318,3321,1,0,0,
  	0,3319,3317,1,0,0,0,3319,3320,1,0,0,0,3320,3323,1,0,0,0,3321,3319,1,0,
  	0,0,3322,3324,3,284,142,0,3323,3322,1,0,0,0,3323,3324,1,0,0,0,3324,3325,
  	1,0,0,0,3325,3326,3,288,144,0,3326,3327,3,328,164,0,3327,3328,5,31,0,
  	0,3328,287,1,0,0,0,3329,3332,3,236,118,0,3330,3332,5,151,0,0,3331,3329,
  	1,0,0,0,3331,3330,1,0,0,0,3332,289,1,0,0,0,3333,3339,3,222,111,0,3334,
  	3336,3,224,112,0,3335,3337,3,292,146,0,3336,3335,1,0,0,0,3336,3337,1,
  	0,0,0,3337,3339,1,0,0,0,3338,3333,1,0,0,0,3338,3334,1,0,0,0,3339,291,
  	1,0,0,0,3340,3341,5,310,0,0,3341,293,1,0,0,0,3342,3343,5,64,0,0,3343,
  	3346,5,43,0,0,3344,3347,3,1162,581,0,3345,3347,3,236,118,0,3346,3344,
  	1,0,0,0,3346,3345,1,0,0,0,3347,3348,1,0,0,0,3348,3349,5,44,0,0,3349,295,
  	1,0,0,0,3350,3351,5,43,0,0,3351,3352,7,11,0,0,3352,3353,5,30,0,0,3353,
  	3354,7,12,0,0,3354,3371,5,44,0,0,3355,3356,5,43,0,0,3356,3357,7,12,0,
  	0,3357,3358,5,30,0,0,3358,3359,7,13,0,0,3359,3371,5,44,0,0,3360,3361,
  	5,43,0,0,3361,3362,5,152,0,0,3362,3363,5,30,0,0,3363,3364,7,14,0,0,3364,
  	3371,5,44,0,0,3365,3366,5,43,0,0,3366,3367,5,153,0,0,3367,3368,5,30,0,
  	0,3368,3369,7,11,0,0,3369,3371,5,44,0,0,3370,3350,1,0,0,0,3370,3355,1,
  	0,0,0,3370,3360,1,0,0,0,3370,3365,1,0,0,0,3371,297,1,0,0,0,3372,3373,
  	7,11,0,0,3373,299,1,0,0,0,3374,3375,7,14,0,0,3375,301,1,0,0,0,3376,3377,
  	7,15,0,0,3377,303,1,0,0,0,3378,3393,3,308,154,0,3379,3380,5,213,0,0,3380,
  	3381,5,43,0,0,3381,3388,3,1166,583,0,3382,3383,5,30,0,0,3383,3386,3,1166,
  	583,0,3384,3385,5,30,0,0,3385,3387,3,1166,583,0,3386,3384,1,0,0,0,3386,
  	3387,1,0,0,0,3387,3389,1,0,0,0,3388,3382,1,0,0,0,3388,3389,1,0,0,0,3389,
  	3390,1,0,0,0,3390,3391,5,44,0,0,3391,3393,1,0,0,0,3392,3378,1,0,0,0,3392,
  	3379,1,0,0,0,3393,305,1,0,0,0,3394,3405,3,308,154,0,3395,3396,5,213,0,
  	0,3396,3397,5,43,0,0,3397,3400,3,1166,583,0,3398,3399,5,30,0,0,3399,3401,
  	3,1166,583,0,3400,3398,1,0,0,0,3400,3401,1,0,0,0,3401,3402,1,0,0,0,3402,
  	3403,5,44,0,0,3403,3405,1,0,0,0,3404,3394,1,0,0,0,3404,3395,1,0,0,0,3405,
  	307,1,0,0,0,3406,3408,5,16,0,0,3407,3409,3,1204,602,0,3408,3407,1,0,0,
  	0,3408,3409,1,0,0,0,3409,3417,1,0,0,0,3410,3412,5,17,0,0,3411,3413,3,
  	1204,602,0,3412,3411,1,0,0,0,3412,3413,1,0,0,0,3413,3417,1,0,0,0,3414,
  	3415,5,213,0,0,3415,3417,3,310,155,0,3416,3406,1,0,0,0,3416,3410,1,0,
  	0,0,3416,3414,1,0,0,0,3417,309,1,0,0,0,3418,3425,5,18,0,0,3419,3425,5,
  	19,0,0,3420,3425,3,1254,627,0,3421,3425,3,1202,601,0,3422,3425,5,403,
  	0,0,3423,3425,3,1256,628,0,3424,3418,1,0,0,0,3424,3419,1,0,0,0,3424,3420,
  	1,0,0,0,3424,3421,1,0,0,0,3424,3422,1,0,0,0,3424,3423,1,0,0,0,3425,311,
  	1,0,0,0,3426,3431,3,336,168,0,3427,3428,5,30,0,0,3428,3430,3,336,168,
  	0,3429,3427,1,0,0,0,3430,3433,1,0,0,0,3431,3429,1,0,0,0,3431,3432,1,0,
  	0,0,3432,313,1,0,0,0,3433,3431,1,0,0,0,3434,3438,3,1250,625,0,3435,3437,
  	3,352,176,0,3436,3435,1,0,0,0,3437,3440,1,0,0,0,3438,3436,1,0,0,0,3438,
  	3439,1,0,0,0,3439,3451,1,0,0,0,3440,3438,1,0,0,0,3441,3442,5,30,0,0,3442,
  	3446,3,1250,625,0,3443,3445,3,352,176,0,3444,3443,1,0,0,0,3445,3448,1,
  	0,0,0,3446,3444,1,0,0,0,3446,3447,1,0,0,0,3447,3450,1,0,0,0,3448,3446,
  	1,0,0,0,3449,3441,1,0,0,0,3450,3453,1,0,0,0,3451,3449,1,0,0,0,3451,3452,
  	1,0,0,0,3452,315,1,0,0,0,3453,3451,1,0,0,0,3454,3459,3,338,169,0,3455,
  	3456,5,30,0,0,3456,3458,3,338,169,0,3457,3455,1,0,0,0,3458,3461,1,0,0,
  	0,3459,3457,1,0,0,0,3459,3460,1,0,0,0,3460,317,1,0,0,0,3461,3459,1,0,
  	0,0,3462,3467,3,340,170,0,3463,3464,5,30,0,0,3464,3466,3,340,170,0,3465,
  	3463,1,0,0,0,3466,3469,1,0,0,0,3467,3465,1,0,0,0,3467,3468,1,0,0,0,3468,
  	319,1,0,0,0,3469,3467,1,0,0,0,3470,3474,3,1248,624,0,3471,3473,3,352,
  	176,0,3472,3471,1,0,0,0,3473,3476,1,0,0,0,3474,3472,1,0,0,0,3474,3475,
  	1,0,0,0,3475,3487,1,0,0,0,3476,3474,1,0,0,0,3477,3478,5,30,0,0,3478,3482,
  	3,1248,624,0,3479,3481,3,352,176,0,3480,3479,1,0,0,0,3481,3484,1,0,0,
  	0,3482,3480,1,0,0,0,3482,3483,1,0,0,0,3483,3486,1,0,0,0,3484,3482,1,0,
  	0,0,3485,3477,1,0,0,0,3486,3489,1,0,0,0,3487,3485,1,0,0,0,3487,3488,1,
  	0,0,0,3488,321,1,0,0,0,3489,3487,1,0,0,0,3490,3495,3,342,171,0,3491,3492,
  	5,30,0,0,3492,3494,3,342,171,0,3493,3491,1,0,0,0,3494,3497,1,0,0,0,3495,
  	3493,1,0,0,0,3495,3496,1,0,0,0,3496,323,1,0,0,0,3497,3495,1,0,0,0,3498,
  	3502,3,1248,624,0,3499,3501,3,358,179,0,3500,3499,1,0,0,0,3501,3504,1,
  	0,0,0,3502,3500,1,0,0,0,3502,3503,1,0,0,0,3503,3507,1,0,0,0,3504,3502,
  	1,0,0,0,3505,3506,5,362,0,0,3506,3508,3,1162,581,0,3507,3505,1,0,0,0,
  	3507,3508,1,0,0,0,3508,3523,1,0,0,0,3509,3510,5,30,0,0,3510,3514,3,1248,
  	624,0,3511,3513,3,358,179,0,3512,3511,1,0,0,0,3513,3516,1,0,0,0,3514,
  	3512,1,0,0,0,3514,3515,1,0,0,0,3515,3519,1,0,0,0,3516,3514,1,0,0,0,3517,
  	3518,5,362,0,0,3518,3520,3,1162,581,0,3519,3517,1,0,0,0,3519,3520,1,0,
  	0,0,3520,3522,1,0,0,0,3521,3509,1,0,0,0,3522,3525,1,0,0,0,3523,3521,1,
  	0,0,0,3523,3524,1,0,0,0,3524,325,1,0,0,0,3525,3523,1,0,0,0,3526,3529,
  	3,1248,624,0,3527,3528,5,362,0,0,3528,3530,3,236,118,0,3529,3527,1,0,
  	0,0,3529,3530,1,0,0,0,3530,3539,1,0,0,0,3531,3532,5,30,0,0,3532,3535,
  	3,1248,624,0,3533,3534,5,362,0,0,3534,3536,3,236,118,0,3535,3533,1,0,
  	0,0,3535,3536,1,0,0,0,3536,3538,1,0,0,0,3537,3531,1,0,0,0,3538,3541,1,
  	0,0,0,3539,3537,1,0,0,0,3539,3540,1,0,0,0,3540,327,1,0,0,0,3541,3539,
  	1,0,0,0,3542,3547,3,346,173,0,3543,3544,5,30,0,0,3544,3546,3,346,173,
  	0,3545,3543,1,0,0,0,3546,3549,1,0,0,0,3547,3545,1,0,0,0,3547,3548,1,0,
  	0,0,3548,329,1,0,0,0,3549,3547,1,0,0,0,3550,3554,3,1248,624,0,3551,3553,
  	3,358,179,0,3552,3551,1,0,0,0,3553,3556,1,0,0,0,3554,3552,1,0,0,0,3554,
  	3555,1,0,0,0,3555,3567,1,0,0,0,3556,3554,1,0,0,0,3557,3558,5,30,0,0,3558,
  	3562,3,1248,624,0,3559,3561,3,358,179,0,3560,3559,1,0,0,0,3561,3564,1,
  	0,0,0,3562,3560,1,0,0,0,3562,3563,1,0,0,0,3563,3566,1,0,0,0,3564,3562,
  	1,0,0,0,3565,3557,1,0,0,0,3566,3569,1,0,0,0,3567,3565,1,0,0,0,3567,3568,
  	1,0,0,0,3568,331,1,0,0,0,3569,3567,1,0,0,0,3570,3574,3,1248,624,0,3571,
  	3573,3,358,179,0,3572,3571,1,0,0,0,3573,3576,1,0,0,0,3574,3572,1,0,0,
  	0,3574,3575,1,0,0,0,3575,3579,1,0,0,0,3576,3574,1,0,0,0,3577,3578,5,362,
  	0,0,3578,3580,3,1144,572,0,3579,3577,1,0,0,0,3579,3580,1,0,0,0,3580,3595,
  	1,0,0,0,3581,3582,5,30,0,0,3582,3586,3,1248,624,0,3583,3585,3,358,179,
  	0,3584,3583,1,0,0,0,3585,3588,1,0,0,0,3586,3584,1,0,0,0,3586,3587,1,0,
  	0,0,3587,3591,1,0,0,0,3588,3586,1,0,0,0,3589,3590,5,362,0,0,3590,3592,
  	3,1144,572,0,3591,3589,1,0,0,0,3591,3592,1,0,0,0,3592,3594,1,0,0,0,3593,
  	3581,1,0,0,0,3594,3597,1,0,0,0,3595,3593,1,0,0,0,3595,3596,1,0,0,0,3596,
  	333,1,0,0,0,3597,3595,1,0,0,0,3598,3601,3,1248,624,0,3599,3600,5,362,
  	0,0,3600,3602,3,1248,624,0,3601,3599,1,0,0,0,3601,3602,1,0,0,0,3602,3611,
  	1,0,0,0,3603,3604,5,30,0,0,3604,3607,3,1248,624,0,3605,3606,5,362,0,0,
  	3606,3608,3,1248,624,0,3607,3605,1,0,0,0,3607,3608,1,0,0,0,3608,3610,
  	1,0,0,0,3609,3603,1,0,0,0,3610,3613,1,0,0,0,3611,3609,1,0,0,0,3611,3612,
  	1,0,0,0,3612,335,1,0,0,0,3613,3611,1,0,0,0,3614,3617,3,1248,624,0,3615,
  	3617,3,1246,623,0,3616,3614,1,0,0,0,3616,3615,1,0,0,0,3617,3618,1,0,0,
  	0,3618,3619,5,362,0,0,3619,3620,3,1148,574,0,3620,337,1,0,0,0,3621,3625,
  	3,1248,624,0,3622,3624,3,352,176,0,3623,3622,1,0,0,0,3624,3627,1,0,0,
  	0,3625,3623,1,0,0,0,3625,3626,1,0,0,0,3626,3630,1,0,0,0,3627,3625,1,0,
  	0,0,3628,3629,5,362,0,0,3629,3631,3,1162,581,0,3630,3628,1,0,0,0,3630,
  	3631,1,0,0,0,3631,339,1,0,0,0,3632,3636,3,1248,624,0,3633,3635,3,352,
  	176,0,3634,3633,1,0,0,0,3635,3638,1,0,0,0,3636,3634,1,0,0,0,3636,3637,
  	1,0,0,0,3637,3641,1,0,0,0,3638,3636,1,0,0,0,3639,3640,5,362,0,0,3640,
  	3642,3,1150,575,0,3641,3639,1,0,0,0,3641,3642,1,0,0,0,3642,341,1,0,0,
  	0,3643,3644,3,1248,624,0,3644,3645,5,362,0,0,3645,3646,3,1148,574,0,3646,
  	3649,1,0,0,0,3647,3649,3,344,172,0,3648,3643,1,0,0,0,3648,3647,1,0,0,
  	0,3649,343,1,0,0,0,3650,3651,5,165,0,0,3651,3652,5,166,0,0,3652,3653,
  	5,362,0,0,3653,3654,5,43,0,0,3654,3657,3,1148,574,0,3655,3656,5,30,0,
  	0,3656,3658,3,1148,574,0,3657,3655,1,0,0,0,3657,3658,1,0,0,0,3658,3659,
  	1,0,0,0,3659,3660,5,44,0,0,3660,3661,5,31,0,0,3661,3678,1,0,0,0,3662,
  	3663,5,165,0,0,3663,3664,5,166,0,0,3664,3665,3,970,485,0,3665,3666,5,
  	166,0,0,3666,3667,3,972,486,0,3667,3668,5,362,0,0,3668,3669,5,43,0,0,
  	3669,3672,3,1148,574,0,3670,3671,5,30,0,0,3671,3673,3,1148,574,0,3672,
  	3670,1,0,0,0,3672,3673,1,0,0,0,3673,3674,1,0,0,0,3674,3675,5,44,0,0,3675,
  	3676,5,31,0,0,3676,3678,1,0,0,0,3677,3650,1,0,0,0,3677,3662,1,0,0,0,3678,
  	345,1,0,0,0,3679,3711,3,1248,624,0,3680,3681,5,362,0,0,3681,3712,3,348,
  	174,0,3682,3686,3,362,181,0,3683,3685,3,358,179,0,3684,3683,1,0,0,0,3685,
  	3688,1,0,0,0,3686,3684,1,0,0,0,3686,3687,1,0,0,0,3687,3691,1,0,0,0,3688,
  	3686,1,0,0,0,3689,3690,5,362,0,0,3690,3692,3,350,175,0,3691,3689,1,0,
  	0,0,3691,3692,1,0,0,0,3692,3712,1,0,0,0,3693,3694,5,362,0,0,3694,3699,
  	5,76,0,0,3695,3696,5,43,0,0,3696,3697,3,1118,559,0,3697,3698,5,44,0,0,
  	3698,3700,1,0,0,0,3699,3695,1,0,0,0,3699,3700,1,0,0,0,3700,3712,1,0,0,
  	0,3701,3703,3,358,179,0,3702,3701,1,0,0,0,3703,3706,1,0,0,0,3704,3702,
  	1,0,0,0,3704,3705,1,0,0,0,3705,3709,1,0,0,0,3706,3704,1,0,0,0,3707,3708,
  	5,362,0,0,3708,3710,3,1162,581,0,3709,3707,1,0,0,0,3709,3710,1,0,0,0,
  	3710,3712,1,0,0,0,3711,3680,1,0,0,0,3711,3682,1,0,0,0,3711,3693,1,0,0,
  	0,3711,3704,1,0,0,0,3712,347,1,0,0,0,3713,3715,3,260,130,0,3714,3713,
  	1,0,0,0,3714,3715,1,0,0,0,3715,3716,1,0,0,0,3716,3722,5,76,0,0,3717,3718,
  	5,43,0,0,3718,3719,3,1118,559,0,3719,3720,5,44,0,0,3720,3723,1,0,0,0,
  	3721,3723,3,1162,581,0,3722,3717,1,0,0,0,3722,3721,1,0,0,0,3722,3723,
  	1,0,0,0,3723,349,1,0,0,0,3724,3725,5,76,0,0,3725,3726,5,110,0,0,3726,
  	3727,3,1162,581,0,3727,3732,5,111,0,0,3728,3729,5,43,0,0,3729,3730,3,
  	1162,581,0,3730,3731,5,44,0,0,3731,3733,1,0,0,0,3732,3728,1,0,0,0,3732,
  	3733,1,0,0,0,3733,351,1,0,0,0,3734,3735,5,110,0,0,3735,3736,3,1158,579,
  	0,3736,3737,5,111,0,0,3737,3744,1,0,0,0,3738,3739,5,110,0,0,3739,3740,
  	3,1144,572,0,3740,3741,5,111,0,0,3741,3744,1,0,0,0,3742,3744,3,362,181,
  	0,3743,3734,1,0,0,0,3743,3738,1,0,0,0,3743,3742,1,0,0,0,3744,353,1,0,
  	0,0,3745,3746,5,110,0,0,3746,3747,3,1158,579,0,3747,3748,5,111,0,0,3748,
  	3751,1,0,0,0,3749,3751,3,362,181,0,3750,3745,1,0,0,0,3750,3749,1,0,0,
  	0,3751,355,1,0,0,0,3752,3753,5,110,0,0,3753,3754,3,236,118,0,3754,3755,
  	5,111,0,0,3755,3758,1,0,0,0,3756,3758,5,23,0,0,3757,3752,1,0,0,0,3757,
  	3756,1,0,0,0,3758,357,1,0,0,0,3759,3764,3,362,181,0,3760,3764,3,352,176,
  	0,3761,3764,3,356,178,0,3762,3764,3,360,180,0,3763,3759,1,0,0,0,3763,
  	3760,1,0,0,0,3763,3761,1,0,0,0,3763,3762,1,0,0,0,3764,359,1,0,0,0,3765,
  	3766,5,110,0,0,3766,3769,5,166,0,0,3767,3768,5,33,0,0,3768,3770,3,1144,
  	572,0,3769,3767,1,0,0,0,3769,3770,1,0,0,0,3770,3771,1,0,0,0,3771,3772,
  	5,111,0,0,3772,361,1,0,0,0,3773,3774,5,110,0,0,3774,3775,5,111,0,0,3775,
  	363,1,0,0,0,3776,3779,3,236,118,0,3777,3779,5,151,0,0,3778,3776,1,0,0,
  	0,3778,3777,1,0,0,0,3779,365,1,0,0,0,3780,3791,3,364,182,0,3781,3783,
  	3,280,140,0,3782,3781,1,0,0,0,3782,3783,1,0,0,0,3783,3787,1,0,0,0,3784,
  	3786,3,354,177,0,3785,3784,1,0,0,0,3786,3789,1,0,0,0,3787,3785,1,0,0,
  	0,3787,3788,1,0,0,0,3788,3791,1,0,0,0,3789,3787,1,0,0,0,3790,3780,1,0,
  	0,0,3790,3782,1,0,0,0,3791,367,1,0,0,0,3792,3794,5,75,0,0,3793,3795,3,
  	232,116,0,3794,3793,1,0,0,0,3794,3795,1,0,0,0,3795,3796,1,0,0,0,3796,
  	3797,3,370,185,0,3797,369,1,0,0,0,3798,3803,3,366,183,0,3799,3800,3,1250,
  	625,0,3800,3801,5,35,0,0,3801,3804,1,0,0,0,3802,3804,3,260,130,0,3803,
  	3799,1,0,0,0,3803,3802,1,0,0,0,3803,3804,1,0,0,0,3804,3805,1,0,0,0,3805,
  	3806,3,1248,624,0,3806,3810,5,31,0,0,3807,3809,3,388,194,0,3808,3807,
  	1,0,0,0,3809,3812,1,0,0,0,3810,3808,1,0,0,0,3810,3811,1,0,0,0,3811,3816,
  	1,0,0,0,3812,3810,1,0,0,0,3813,3815,3,790,395,0,3814,3813,1,0,0,0,3815,
  	3818,1,0,0,0,3816,3814,1,0,0,0,3816,3817,1,0,0,0,3817,3819,1,0,0,0,3818,
  	3816,1,0,0,0,3819,3822,5,83,0,0,3820,3821,5,33,0,0,3821,3823,3,1248,624,
  	0,3822,3820,1,0,0,0,3822,3823,1,0,0,0,3823,3856,1,0,0,0,3824,3829,3,366,
  	183,0,3825,3826,3,1250,625,0,3826,3827,5,35,0,0,3827,3830,1,0,0,0,3828,
  	3830,3,260,130,0,3829,3825,1,0,0,0,3829,3828,1,0,0,0,3829,3830,1,0,0,
  	0,3830,3831,1,0,0,0,3831,3832,3,1248,624,0,3832,3834,5,43,0,0,3833,3835,
  	3,390,195,0,3834,3833,1,0,0,0,3834,3835,1,0,0,0,3835,3836,1,0,0,0,3836,
  	3837,5,44,0,0,3837,3841,5,31,0,0,3838,3840,3,400,200,0,3839,3838,1,0,
  	0,0,3840,3843,1,0,0,0,3841,3839,1,0,0,0,3841,3842,1,0,0,0,3842,3847,1,
  	0,0,0,3843,3841,1,0,0,0,3844,3846,3,790,395,0,3845,3844,1,0,0,0,3846,
  	3849,1,0,0,0,3847,3845,1,0,0,0,3847,3848,1,0,0,0,3848,3850,1,0,0,0,3849,
  	3847,1,0,0,0,3850,3853,5,83,0,0,3851,3852,5,33,0,0,3852,3854,3,1248,624,
  	0,3853,3851,1,0,0,0,3853,3854,1,0,0,0,3854,3856,1,0,0,0,3855,3798,1,0,
  	0,0,3855,3824,1,0,0,0,3856,371,1,0,0,0,3857,3858,5,75,0,0,3858,3859,3,
  	366,183,0,3859,3865,3,1248,624,0,3860,3862,5,43,0,0,3861,3863,3,390,195,
  	0,3862,3861,1,0,0,0,3862,3863,1,0,0,0,3863,3864,1,0,0,0,3864,3866,5,44,
  	0,0,3865,3860,1,0,0,0,3865,3866,1,0,0,0,3866,373,1,0,0,0,3867,3868,5,
  	98,0,0,3868,3871,3,242,121,0,3869,3872,3,376,188,0,3870,3872,3,382,191,
  	0,3871,3869,1,0,0,0,3871,3870,1,0,0,0,3871,3872,1,0,0,0,3872,3875,1,0,
  	0,0,3873,3874,5,368,0,0,3874,3876,5,362,0,0,3875,3873,1,0,0,0,3875,3876,
  	1,0,0,0,3876,3877,1,0,0,0,3877,3878,3,372,186,0,3878,3879,5,31,0,0,3879,
  	3905,1,0,0,0,3880,3881,5,98,0,0,3881,3883,3,242,121,0,3882,3884,3,376,
  	188,0,3883,3882,1,0,0,0,3883,3884,1,0,0,0,3884,3887,1,0,0,0,3885,3886,
  	5,368,0,0,3886,3888,5,362,0,0,3887,3885,1,0,0,0,3887,3888,1,0,0,0,3888,
  	3889,1,0,0,0,3889,3890,3,398,199,0,3890,3891,5,31,0,0,3891,3905,1,0,0,
  	0,3892,3893,5,167,0,0,3893,3896,3,242,121,0,3894,3895,5,368,0,0,3895,
  	3897,5,362,0,0,3896,3894,1,0,0,0,3896,3897,1,0,0,0,3897,3900,1,0,0,0,
  	3898,3901,3,378,189,0,3899,3901,3,380,190,0,3900,3898,1,0,0,0,3900,3899,
  	1,0,0,0,3901,3902,1,0,0,0,3902,3903,5,31,0,0,3903,3905,1,0,0,0,3904,3867,
  	1,0,0,0,3904,3880,1,0,0,0,3904,3892,1,0,0,0,3905,375,1,0,0,0,3906,3907,
  	5,168,0,0,3907,377,1,0,0,0,3908,3909,5,75,0,0,3909,3910,3,1248,624,0,
  	3910,379,1,0,0,0,3911,3912,5,330,0,0,3912,3913,3,1248,624,0,3913,381,
  	1,0,0,0,3914,3915,5,169,0,0,3915,383,1,0,0,0,3916,3918,5,330,0,0,3917,
  	3919,3,232,116,0,3918,3917,1,0,0,0,3918,3919,1,0,0,0,3919,3920,1,0,0,
  	0,3920,3921,3,386,193,0,3921,385,1,0,0,0,3922,3923,3,1250,625,0,3923,
  	3924,5,35,0,0,3924,3927,1,0,0,0,3925,3927,3,260,130,0,3926,3922,1,0,0,
  	0,3926,3925,1,0,0,0,3926,3927,1,0,0,0,3927,3928,1,0,0,0,3928,3929,3,1248,
  	624,0,3929,3933,5,31,0,0,3930,3932,3,388,194,0,3931,3930,1,0,0,0,3932,
  	3935,1,0,0,0,3933,3931,1,0,0,0,3933,3934,1,0,0,0,3934,3939,1,0,0,0,3935,
  	3933,1,0,0,0,3936,3938,3,784,392,0,3937,3936,1,0,0,0,3938,3941,1,0,0,
  	0,3939,3937,1,0,0,0,3939,3940,1,0,0,0,3940,3942,1,0,0,0,3941,3939,1,0,
  	0,0,3942,3945,5,171,0,0,3943,3944,5,33,0,0,3944,3946,3,1248,624,0,3945,
  	3943,1,0,0,0,3945,3946,1,0,0,0,3946,3978,1,0,0,0,3947,3948,3,1250,625,
  	0,3948,3949,5,35,0,0,3949,3952,1,0,0,0,3950,3952,3,260,130,0,3951,3947,
  	1,0,0,0,3951,3950,1,0,0,0,3951,3952,1,0,0,0,3952,3953,1,0,0,0,3953,3954,
  	3,1248,624,0,3954,3956,5,43,0,0,3955,3957,3,390,195,0,3956,3955,1,0,0,
  	0,3956,3957,1,0,0,0,3957,3958,1,0,0,0,3958,3959,5,44,0,0,3959,3963,5,
  	31,0,0,3960,3962,3,400,200,0,3961,3960,1,0,0,0,3962,3965,1,0,0,0,3963,
  	3961,1,0,0,0,3963,3964,1,0,0,0,3964,3969,1,0,0,0,3965,3963,1,0,0,0,3966,
  	3968,3,784,392,0,3967,3966,1,0,0,0,3968,3971,1,0,0,0,3969,3967,1,0,0,
  	0,3969,3970,1,0,0,0,3970,3972,1,0,0,0,3971,3969,1,0,0,0,3972,3975,5,171,
  	0,0,3973,3974,5,33,0,0,3974,3976,3,1248,624,0,3975,3973,1,0,0,0,3975,
  	3976,1,0,0,0,3976,3978,1,0,0,0,3977,3926,1,0,0,0,3977,3951,1,0,0,0,3978,
  	387,1,0,0,0,3979,3982,3,400,200,0,3980,3982,3,396,198,0,3981,3979,1,0,
  	0,0,3981,3980,1,0,0,0,3982,389,1,0,0,0,3983,3988,3,392,196,0,3984,3985,
  	5,30,0,0,3985,3987,3,392,196,0,3986,3984,1,0,0,0,3987,3990,1,0,0,0,3988,
  	3986,1,0,0,0,3988,3989,1,0,0,0,3989,391,1,0,0,0,3990,3988,1,0,0,0,3991,
  	3993,3,1240,620,0,3992,3991,1,0,0,0,3993,3996,1,0,0,0,3994,3992,1,0,0,
  	0,3994,3995,1,0,0,0,3995,3998,1,0,0,0,3996,3994,1,0,0,0,3997,3999,3,394,
  	197,0,3998,3997,1,0,0,0,3998,3999,1,0,0,0,3999,4001,1,0,0,0,4000,4002,
  	3,250,125,0,4001,4000,1,0,0,0,4001,4002,1,0,0,0,4002,4003,1,0,0,0,4003,
  	4004,3,252,126,0,4004,4008,3,1248,624,0,4005,4007,3,358,179,0,4006,4005,
  	1,0,0,0,4007,4010,1,0,0,0,4008,4006,1,0,0,0,4008,4009,1,0,0,0,4009,4013,
  	1,0,0,0,4010,4008,1,0,0,0,4011,4012,5,362,0,0,4012,4014,3,1162,581,0,
  	4013,4011,1,0,0,0,4013,4014,1,0,0,0,4014,393,1,0,0,0,4015,4022,5,66,0,
  	0,4016,4022,5,67,0,0,4017,4022,5,68,0,0,4018,4022,5,69,0,0,4019,4020,
  	5,74,0,0,4020,4022,5,69,0,0,4021,4015,1,0,0,0,4021,4016,1,0,0,0,4021,
  	4017,1,0,0,0,4021,4018,1,0,0,0,4021,4019,1,0,0,0,4022,395,1,0,0,0,4023,
  	4025,3,1240,620,0,4024,4023,1,0,0,0,4025,4028,1,0,0,0,4026,4024,1,0,0,
  	0,4026,4027,1,0,0,0,4027,4029,1,0,0,0,4028,4026,1,0,0,0,4029,4031,3,394,
  	197,0,4030,4032,3,250,125,0,4031,4030,1,0,0,0,4031,4032,1,0,0,0,4032,
  	4033,1,0,0,0,4033,4034,3,252,126,0,4034,4035,3,324,162,0,4035,4036,5,
  	31,0,0,4036,397,1,0,0,0,4037,4038,5,330,0,0,4038,4044,3,1248,624,0,4039,
  	4041,5,43,0,0,4040,4042,3,390,195,0,4041,4040,1,0,0,0,4041,4042,1,0,0,
  	0,4042,4043,1,0,0,0,4043,4045,5,44,0,0,4044,4039,1,0,0,0,4044,4045,1,
  	0,0,0,4045,399,1,0,0,0,4046,4048,3,1240,620,0,4047,4046,1,0,0,0,4048,
  	4051,1,0,0,0,4049,4047,1,0,0,0,4049,4050,1,0,0,0,4050,4061,1,0,0,0,4051,
  	4049,1,0,0,0,4052,4062,3,202,101,0,4053,4054,3,186,93,0,4054,4055,5,31,
  	0,0,4055,4062,1,0,0,0,4056,4057,3,188,94,0,4057,4058,5,31,0,0,4058,4062,
  	1,0,0,0,4059,4062,3,402,201,0,4060,4062,3,510,255,0,4061,4052,1,0,0,0,
  	4061,4053,1,0,0,0,4061,4056,1,0,0,0,4061,4059,1,0,0,0,4061,4060,1,0,0,
  	0,4062,401,1,0,0,0,4063,4064,5,72,0,0,4064,4065,3,404,202,0,4065,4066,
  	5,75,0,0,4066,4067,3,236,118,0,4067,4068,3,1248,624,0,4068,4069,5,43,
  	0,0,4069,4070,3,406,203,0,4070,4071,5,44,0,0,4071,4072,5,31,0,0,4072,
  	403,1,0,0,0,4073,4089,5,173,0,0,4074,4089,5,172,0,0,4075,4089,5,175,0,
  	0,4076,4089,5,174,0,0,4077,4089,5,45,0,0,4078,4089,5,177,0,0,4079,4089,
  	5,178,0,0,4080,4089,5,179,0,0,4081,4089,5,180,0,0,4082,4089,5,181,0,0,
  	4083,4089,5,182,0,0,4084,4089,5,183,0,0,4085,4089,5,184,0,0,4086,4089,
  	5,186,0,0,4087,4089,5,362,0,0,4088,4073,1,0,0,0,4088,4074,1,0,0,0,4088,
  	4075,1,0,0,0,4088,4076,1,0,0,0,4088,4077,1,0,0,0,4088,4078,1,0,0,0,4088,
  	4079,1,0,0,0,4088,4080,1,0,0,0,4088,4081,1,0,0,0,4088,4082,1,0,0,0,4088,
  	4083,1,0,0,0,4088,4084,1,0,0,0,4088,4085,1,0,0,0,4088,4086,1,0,0,0,4088,
  	4087,1,0,0,0,4089,405,1,0,0,0,4090,4095,3,236,118,0,4091,4092,5,30,0,
  	0,4092,4094,3,236,118,0,4093,4091,1,0,0,0,4094,4097,1,0,0,0,4095,4093,
  	1,0,0,0,4095,4096,1,0,0,0,4096,407,1,0,0,0,4097,4095,1,0,0,0,4098,4100,
  	5,52,0,0,4099,4101,5,48,0,0,4100,4099,1,0,0,0,4100,4101,1,0,0,0,4101,
  	4102,1,0,0,0,4102,4103,3,1250,625,0,4103,4104,3,334,167,0,4104,4105,5,
  	31,0,0,4105,409,1,0,0,0,4106,4107,3,1248,624,0,4107,4108,5,43,0,0,4108,
  	4113,3,412,206,0,4109,4110,5,30,0,0,4110,4112,3,412,206,0,4111,4109,1,
  	0,0,0,4112,4115,1,0,0,0,4113,4111,1,0,0,0,4113,4114,1,0,0,0,4114,4116,
  	1,0,0,0,4115,4113,1,0,0,0,4116,4117,5,44,0,0,4117,411,1,0,0,0,4118,4120,
  	3,1240,620,0,4119,4118,1,0,0,0,4120,4123,1,0,0,0,4121,4119,1,0,0,0,4121,
  	4122,1,0,0,0,4122,4129,1,0,0,0,4123,4121,1,0,0,0,4124,4130,3,414,207,
  	0,4125,4130,3,418,209,0,4126,4130,3,420,210,0,4127,4128,5,70,0,0,4128,
  	4130,3,1248,624,0,4129,4124,1,0,0,0,4129,4125,1,0,0,0,4129,4126,1,0,0,
  	0,4129,4127,1,0,0,0,4130,413,1,0,0,0,4131,4132,3,72,36,0,4132,4137,3,
  	416,208,0,4133,4134,5,30,0,0,4134,4136,3,416,208,0,4135,4133,1,0,0,0,
  	4136,4139,1,0,0,0,4137,4135,1,0,0,0,4137,4138,1,0,0,0,4138,415,1,0,0,
  	0,4139,4137,1,0,0,0,4140,4153,3,1248,624,0,4141,4142,5,35,0,0,4142,4143,
  	3,1248,624,0,4143,4147,5,43,0,0,4144,4146,3,1162,581,0,4145,4144,1,0,
  	0,0,4146,4149,1,0,0,0,4147,4145,1,0,0,0,4147,4148,1,0,0,0,4148,4150,1,
  	0,0,0,4149,4147,1,0,0,0,4150,4151,5,44,0,0,4151,4153,1,0,0,0,4152,4140,
  	1,0,0,0,4152,4141,1,0,0,0,4153,417,1,0,0,0,4154,4159,3,1248,624,0,4155,
  	4156,5,110,0,0,4156,4157,3,1144,572,0,4157,4158,5,111,0,0,4158,4160,1,
  	0,0,0,4159,4155,1,0,0,0,4159,4160,1,0,0,0,4160,4161,1,0,0,0,4161,4162,
  	5,35,0,0,4162,4163,3,1248,624,0,4163,419,1,0,0,0,4164,4165,7,16,0,0,4165,
  	4170,3,422,211,0,4166,4167,5,30,0,0,4167,4169,3,422,211,0,4168,4166,1,
  	0,0,0,4169,4172,1,0,0,0,4170,4168,1,0,0,0,4170,4171,1,0,0,0,4171,421,
  	1,0,0,0,4172,4170,1,0,0,0,4173,4176,3,144,72,0,4174,4176,3,1248,624,0,
  	4175,4173,1,0,0,0,4175,4174,1,0,0,0,4176,423,1,0,0,0,4177,4178,3,1248,
  	624,0,4178,4179,5,33,0,0,4179,4181,1,0,0,0,4180,4177,1,0,0,0,4180,4181,
  	1,0,0,0,4181,4182,1,0,0,0,4182,4185,3,426,213,0,4183,4185,3,628,314,0,
  	4184,4180,1,0,0,0,4184,4183,1,0,0,0,4185,425,1,0,0,0,4186,4192,3,428,
  	214,0,4187,4192,3,430,215,0,4188,4192,3,432,216,0,4189,4192,3,436,218,
  	0,4190,4192,3,438,219,0,4191,4186,1,0,0,0,4191,4187,1,0,0,0,4191,4188,
  	1,0,0,0,4191,4189,1,0,0,0,4191,4190,1,0,0,0,4192,427,1,0,0,0,4193,4194,
  	5,191,0,0,4194,4195,5,192,0,0,4195,4196,5,43,0,0,4196,4197,3,458,229,
  	0,4197,4198,5,44,0,0,4198,4199,3,772,386,0,4199,429,1,0,0,0,4200,4201,
  	5,193,0,0,4201,4202,5,192,0,0,4202,4203,5,43,0,0,4203,4204,3,458,229,
  	0,4204,4205,5,44,0,0,4205,4206,3,772,386,0,4206,431,1,0,0,0,4207,4208,
  	5,194,0,0,4208,4209,5,192,0,0,4209,4210,5,43,0,0,4210,4211,3,458,229,
  	0,4211,4212,5,44,0,0,4212,4213,3,784,392,0,4213,433,1,0,0,0,4214,4215,
  	5,195,0,0,4215,4216,5,43,0,0,4216,4217,3,458,229,0,4217,4218,5,44,0,0,
  	4218,4219,3,772,386,0,4219,435,1,0,0,0,4220,4221,5,194,0,0,4221,4222,
  	5,204,0,0,4222,4224,5,43,0,0,4223,4225,3,904,452,0,4224,4223,1,0,0,0,
  	4224,4225,1,0,0,0,4225,4232,1,0,0,0,4226,4227,5,197,0,0,4227,4228,5,198,
  	0,0,4228,4229,5,43,0,0,4229,4230,3,506,253,0,4230,4231,5,44,0,0,4231,
  	4233,1,0,0,0,4232,4226,1,0,0,0,4232,4233,1,0,0,0,4233,4234,1,0,0,0,4234,
  	4235,3,466,233,0,4235,4236,5,44,0,0,4236,4237,3,784,392,0,4237,437,1,
  	0,0,0,4238,4239,5,314,0,0,4239,4240,5,192,0,0,4240,4241,5,43,0,0,4241,
  	4242,3,458,229,0,4242,4243,5,44,0,0,4243,4244,5,31,0,0,4244,439,1,0,0,
  	0,4245,4251,3,1260,630,0,4246,4248,5,43,0,0,4247,4249,3,490,245,0,4248,
  	4247,1,0,0,0,4248,4249,1,0,0,0,4249,4250,1,0,0,0,4250,4252,5,44,0,0,4251,
  	4246,1,0,0,0,4251,4252,1,0,0,0,4252,441,1,0,0,0,4253,4256,3,460,230,0,
  	4254,4256,3,488,244,0,4255,4253,1,0,0,0,4255,4254,1,0,0,0,4256,443,1,
  	0,0,0,4257,4260,3,448,224,0,4258,4260,3,464,232,0,4259,4257,1,0,0,0,4259,
  	4258,1,0,0,0,4260,445,1,0,0,0,4261,4265,3,448,224,0,4262,4265,3,464,232,
  	0,4263,4265,3,510,255,0,4264,4261,1,0,0,0,4264,4262,1,0,0,0,4264,4263,
  	1,0,0,0,4265,447,1,0,0,0,4266,4267,5,192,0,0,4267,4273,3,1248,624,0,4268,
  	4270,5,43,0,0,4269,4271,3,450,225,0,4270,4269,1,0,0,0,4270,4271,1,0,0,
  	0,4271,4272,1,0,0,0,4272,4274,5,44,0,0,4273,4268,1,0,0,0,4273,4274,1,
  	0,0,0,4274,4275,1,0,0,0,4275,4279,5,31,0,0,4276,4278,3,508,254,0,4277,
  	4276,1,0,0,0,4278,4281,1,0,0,0,4279,4277,1,0,0,0,4279,4280,1,0,0,0,4280,
  	4282,1,0,0,0,4281,4279,1,0,0,0,4282,4284,3,458,229,0,4283,4285,5,31,0,
  	0,4284,4283,1,0,0,0,4284,4285,1,0,0,0,4285,4286,1,0,0,0,4286,4289,5,196,
  	0,0,4287,4288,5,33,0,0,4288,4290,3,1248,624,0,4289,4287,1,0,0,0,4289,
  	4290,1,0,0,0,4290,449,1,0,0,0,4291,4296,3,452,226,0,4292,4293,5,30,0,
  	0,4293,4295,3,452,226,0,4294,4292,1,0,0,0,4295,4298,1,0,0,0,4296,4294,
  	1,0,0,0,4296,4297,1,0,0,0,4297,451,1,0,0,0,4298,4296,1,0,0,0,4299,4301,
  	3,1240,620,0,4300,4299,1,0,0,0,4301,4304,1,0,0,0,4302,4300,1,0,0,0,4302,
  	4303,1,0,0,0,4303,4309,1,0,0,0,4304,4302,1,0,0,0,4305,4307,5,79,0,0,4306,
  	4308,3,454,227,0,4307,4306,1,0,0,0,4307,4308,1,0,0,0,4308,4310,1,0,0,
  	0,4309,4305,1,0,0,0,4309,4310,1,0,0,0,4310,4311,1,0,0,0,4311,4312,3,456,
  	228,0,4312,4316,3,1248,624,0,4313,4315,3,358,179,0,4314,4313,1,0,0,0,
  	4315,4318,1,0,0,0,4316,4314,1,0,0,0,4316,4317,1,0,0,0,4317,4321,1,0,0,
  	0,4318,4316,1,0,0,0,4319,4320,5,362,0,0,4320,4322,3,442,221,0,4321,4319,
  	1,0,0,0,4321,4322,1,0,0,0,4322,453,1,0,0,0,4323,4324,5,66,0,0,4324,455,
  	1,0,0,0,4325,4328,3,480,240,0,4326,4328,5,192,0,0,4327,4325,1,0,0,0,4327,
  	4326,1,0,0,0,4328,457,1,0,0,0,4329,4331,3,904,452,0,4330,4329,1,0,0,0,
  	4330,4331,1,0,0,0,4331,4338,1,0,0,0,4332,4333,5,197,0,0,4333,4334,5,198,
  	0,0,4334,4335,5,43,0,0,4335,4336,3,506,253,0,4336,4337,5,44,0,0,4337,
  	4339,1,0,0,0,4338,4332,1,0,0,0,4338,4339,1,0,0,0,4339,4340,1,0,0,0,4340,
  	4341,3,460,230,0,4341,459,1,0,0,0,4342,4343,6,230,-1,0,4343,4471,3,466,
  	233,0,4344,4345,5,154,0,0,4345,4346,5,43,0,0,4346,4347,3,466,233,0,4347,
  	4348,5,44,0,0,4348,4471,1,0,0,0,4349,4350,5,155,0,0,4350,4351,5,43,0,
  	0,4351,4352,3,466,233,0,4352,4353,5,44,0,0,4353,4471,1,0,0,0,4354,4355,
  	5,43,0,0,4355,4356,3,460,230,0,4356,4357,5,44,0,0,4357,4471,1,0,0,0,4358,
  	4359,5,201,0,0,4359,4471,3,460,230,31,4360,4361,3,466,233,0,4361,4362,
  	5,199,0,0,4362,4363,3,460,230,28,4363,4471,1,0,0,0,4364,4365,3,466,233,
  	0,4365,4366,5,200,0,0,4366,4367,3,460,230,27,4367,4471,1,0,0,0,4368,4369,
  	5,90,0,0,4369,4370,5,43,0,0,4370,4371,3,506,253,0,4371,4372,5,44,0,0,
  	4372,4375,3,460,230,0,4373,4374,5,91,0,0,4374,4376,3,460,230,0,4375,4373,
  	1,0,0,0,4375,4376,1,0,0,0,4376,4471,1,0,0,0,4377,4378,5,264,0,0,4378,
  	4379,5,43,0,0,4379,4380,3,506,253,0,4380,4381,5,44,0,0,4381,4385,3,462,
  	231,0,4382,4384,3,462,231,0,4383,4382,1,0,0,0,4384,4387,1,0,0,0,4385,
  	4383,1,0,0,0,4385,4386,1,0,0,0,4386,4388,1,0,0,0,4387,4385,1,0,0,0,4388,
  	4389,5,265,0,0,4389,4471,1,0,0,0,4390,4391,3,466,233,0,4391,4392,5,211,
  	0,0,4392,4393,3,460,230,24,4393,4471,1,0,0,0,4394,4395,3,466,233,0,4395,
  	4396,5,212,0,0,4396,4397,3,460,230,23,4397,4471,1,0,0,0,4398,4399,5,124,
  	0,0,4399,4471,3,460,230,22,4400,4401,5,124,0,0,4401,4402,5,110,0,0,4402,
  	4403,3,1144,572,0,4403,4404,5,111,0,0,4404,4405,3,460,230,21,4405,4471,
  	1,0,0,0,4406,4407,5,125,0,0,4407,4471,3,460,230,20,4408,4409,5,125,0,
  	0,4409,4410,5,110,0,0,4410,4411,3,1144,572,0,4411,4412,5,111,0,0,4412,
  	4413,3,460,230,19,4413,4471,1,0,0,0,4414,4415,5,275,0,0,4415,4471,3,460,
  	230,18,4416,4417,5,275,0,0,4417,4418,5,110,0,0,4418,4419,3,504,252,0,
  	4419,4420,5,111,0,0,4420,4421,3,460,230,17,4421,4471,1,0,0,0,4422,4423,
  	5,126,0,0,4423,4424,5,110,0,0,4424,4425,3,1158,579,0,4425,4426,5,111,
  	0,0,4426,4427,3,460,230,16,4427,4471,1,0,0,0,4428,4429,5,134,0,0,4429,
  	4471,3,460,230,15,4430,4431,5,133,0,0,4431,4432,5,110,0,0,4432,4433,3,
  	1158,579,0,4433,4434,5,111,0,0,4434,4435,3,460,230,14,4435,4471,1,0,0,
  	0,4436,4437,5,134,0,0,4437,4438,5,110,0,0,4438,4439,3,504,252,0,4439,
  	4440,5,111,0,0,4440,4441,3,460,230,13,4441,4471,1,0,0,0,4442,4443,5,129,
  	0,0,4443,4444,5,43,0,0,4444,4445,3,506,253,0,4445,4446,5,44,0,0,4446,
  	4447,3,460,230,6,4447,4471,1,0,0,0,4448,4449,5,130,0,0,4449,4450,5,43,
  	0,0,4450,4451,3,506,253,0,4451,4452,5,44,0,0,4452,4453,3,460,230,5,4453,
  	4471,1,0,0,0,4454,4455,5,131,0,0,4455,4456,5,43,0,0,4456,4457,3,506,253,
  	0,4457,4458,5,44,0,0,4458,4459,3,460,230,4,4459,4471,1,0,0,0,4460,4461,
  	5,132,0,0,4461,4462,5,43,0,0,4462,4463,3,506,253,0,4463,4464,5,44,0,0,
  	4464,4465,3,460,230,3,4465,4471,1,0,0,0,4466,4471,3,440,220,0,4467,4468,
  	3,904,452,0,4468,4469,3,460,230,1,4469,4471,1,0,0,0,4470,4342,1,0,0,0,
  	4470,4344,1,0,0,0,4470,4349,1,0,0,0,4470,4354,1,0,0,0,4470,4358,1,0,0,
  	0,4470,4360,1,0,0,0,4470,4364,1,0,0,0,4470,4368,1,0,0,0,4470,4377,1,0,
  	0,0,4470,4390,1,0,0,0,4470,4394,1,0,0,0,4470,4398,1,0,0,0,4470,4400,1,
  	0,0,0,4470,4406,1,0,0,0,4470,4408,1,0,0,0,4470,4414,1,0,0,0,4470,4416,
  	1,0,0,0,4470,4422,1,0,0,0,4470,4428,1,0,0,0,4470,4430,1,0,0,0,4470,4436,
  	1,0,0,0,4470,4442,1,0,0,0,4470,4448,1,0,0,0,4470,4454,1,0,0,0,4470,4460,
  	1,0,0,0,4470,4466,1,0,0,0,4470,4467,1,0,0,0,4471,4498,1,0,0,0,4472,4473,
  	10,30,0,0,4473,4474,5,202,0,0,4474,4497,3,460,230,31,4475,4476,10,29,
  	0,0,4476,4477,5,203,0,0,4477,4497,3,460,230,30,4478,4479,10,12,0,0,4479,
  	4480,5,232,0,0,4480,4497,3,460,230,13,4481,4482,10,11,0,0,4482,4483,5,
  	233,0,0,4483,4497,3,460,230,12,4484,4485,10,10,0,0,4485,4486,5,127,0,
  	0,4486,4497,3,460,230,11,4487,4488,10,9,0,0,4488,4489,5,128,0,0,4489,
  	4497,3,460,230,10,4490,4491,10,8,0,0,4491,4492,5,234,0,0,4492,4497,3,
  	460,230,9,4493,4494,10,7,0,0,4494,4495,5,198,0,0,4495,4497,3,460,230,
  	8,4496,4472,1,0,0,0,4496,4475,1,0,0,0,4496,4478,1,0,0,0,4496,4481,1,0,
  	0,0,4496,4484,1,0,0,0,4496,4487,1,0,0,0,4496,4490,1,0,0,0,4496,4493,1,
  	0,0,0,4497,4500,1,0,0,0,4498,4496,1,0,0,0,4498,4499,1,0,0,0,4499,461,
  	1,0,0,0,4500,4498,1,0,0,0,4501,4506,3,506,253,0,4502,4503,5,30,0,0,4503,
  	4505,3,506,253,0,4504,4502,1,0,0,0,4505,4508,1,0,0,0,4506,4504,1,0,0,
  	0,4506,4507,1,0,0,0,4507,4509,1,0,0,0,4508,4506,1,0,0,0,4509,4510,5,33,
  	0,0,4510,4512,3,460,230,0,4511,4513,5,31,0,0,4512,4511,1,0,0,0,4512,4513,
  	1,0,0,0,4513,4523,1,0,0,0,4514,4516,5,36,0,0,4515,4517,5,33,0,0,4516,
  	4515,1,0,0,0,4516,4517,1,0,0,0,4517,4518,1,0,0,0,4518,4520,3,460,230,
  	0,4519,4521,5,31,0,0,4520,4519,1,0,0,0,4520,4521,1,0,0,0,4521,4523,1,
  	0,0,0,4522,4501,1,0,0,0,4522,4514,1,0,0,0,4523,463,1,0,0,0,4524,4525,
  	5,204,0,0,4525,4531,3,1248,624,0,4526,4528,5,43,0,0,4527,4529,3,474,237,
  	0,4528,4527,1,0,0,0,4528,4529,1,0,0,0,4529,4530,1,0,0,0,4530,4532,5,44,
  	0,0,4531,4526,1,0,0,0,4531,4532,1,0,0,0,4532,4533,1,0,0,0,4533,4537,5,
  	31,0,0,4534,4536,3,508,254,0,4535,4534,1,0,0,0,4536,4539,1,0,0,0,4537,
  	4535,1,0,0,0,4537,4538,1,0,0,0,4538,4540,1,0,0,0,4539,4537,1,0,0,0,4540,
  	4542,3,466,233,0,4541,4543,5,31,0,0,4542,4541,1,0,0,0,4542,4543,1,0,0,
  	0,4543,4544,1,0,0,0,4544,4547,5,205,0,0,4545,4546,5,33,0,0,4546,4548,
  	3,1248,624,0,4547,4545,1,0,0,0,4547,4548,1,0,0,0,4548,465,1,0,0,0,4549,
  	4550,6,233,-1,0,4550,4551,3,468,234,0,4551,4557,3,466,233,0,4552,4553,
  	3,468,234,0,4553,4554,3,466,233,0,4554,4556,1,0,0,0,4555,4552,1,0,0,0,
  	4556,4559,1,0,0,0,4557,4555,1,0,0,0,4557,4558,1,0,0,0,4558,4614,1,0,0,
  	0,4559,4557,1,0,0,0,4560,4562,3,506,253,0,4561,4563,3,494,247,0,4562,
  	4561,1,0,0,0,4562,4563,1,0,0,0,4563,4614,1,0,0,0,4564,4565,5,43,0,0,4565,
  	4570,3,506,253,0,4566,4567,5,30,0,0,4567,4569,3,472,236,0,4568,4566,1,
  	0,0,0,4569,4572,1,0,0,0,4570,4568,1,0,0,0,4570,4571,1,0,0,0,4571,4573,
  	1,0,0,0,4572,4570,1,0,0,0,4573,4575,5,44,0,0,4574,4576,3,494,247,0,4575,
  	4574,1,0,0,0,4575,4576,1,0,0,0,4576,4614,1,0,0,0,4577,4579,3,482,241,
  	0,4578,4580,3,496,248,0,4579,4578,1,0,0,0,4579,4580,1,0,0,0,4580,4614,
  	1,0,0,0,4581,4582,5,43,0,0,4582,4587,3,466,233,0,4583,4584,5,30,0,0,4584,
  	4586,3,472,236,0,4585,4583,1,0,0,0,4586,4589,1,0,0,0,4587,4585,1,0,0,
  	0,4587,4588,1,0,0,0,4588,4590,1,0,0,0,4589,4587,1,0,0,0,4590,4592,5,44,
  	0,0,4591,4593,3,496,248,0,4592,4591,1,0,0,0,4592,4593,1,0,0,0,4593,4614,
  	1,0,0,0,4594,4595,5,207,0,0,4595,4596,5,43,0,0,4596,4601,3,466,233,0,
  	4597,4598,5,30,0,0,4598,4600,3,472,236,0,4599,4597,1,0,0,0,4600,4603,
  	1,0,0,0,4601,4599,1,0,0,0,4601,4602,1,0,0,0,4602,4604,1,0,0,0,4603,4601,
  	1,0,0,0,4604,4605,5,44,0,0,4605,4614,1,0,0,0,4606,4607,3,506,253,0,4607,
  	4608,5,208,0,0,4608,4609,3,466,233,3,4609,4614,1,0,0,0,4610,4611,3,904,
  	452,0,4611,4612,3,466,233,1,4612,4614,1,0,0,0,4613,4549,1,0,0,0,4613,
  	4560,1,0,0,0,4613,4564,1,0,0,0,4613,4577,1,0,0,0,4613,4581,1,0,0,0,4613,
  	4594,1,0,0,0,4613,4606,1,0,0,0,4613,4610,1,0,0,0,4614,4640,1,0,0,0,4615,
  	4616,10,7,0,0,4616,4617,5,203,0,0,4617,4639,3,466,233,8,4618,4619,10,
  	6,0,0,4619,4620,5,206,0,0,4620,4639,3,466,233,7,4621,4622,10,5,0,0,4622,
  	4623,5,202,0,0,4623,4639,3,466,233,6,4624,4625,10,2,0,0,4625,4626,5,209,
  	0,0,4626,4639,3,466,233,3,4627,4628,10,12,0,0,4628,4629,3,468,234,0,4629,
  	4635,3,466,233,0,4630,4631,3,468,234,0,4631,4632,3,466,233,0,4632,4634,
  	1,0,0,0,4633,4630,1,0,0,0,4634,4637,1,0,0,0,4635,4633,1,0,0,0,4635,4636,
  	1,0,0,0,4636,4639,1,0,0,0,4637,4635,1,0,0,0,4638,4615,1,0,0,0,4638,4618,
  	1,0,0,0,4638,4621,1,0,0,0,4638,4624,1,0,0,0,4638,4627,1,0,0,0,4639,4642,
  	1,0,0,0,4640,4638,1,0,0,0,4640,4641,1,0,0,0,4641,467,1,0,0,0,4642,4640,
  	1,0,0,0,4643,4644,5,210,0,0,4644,4658,3,1182,591,0,4645,4658,5,16,0,0,
  	4646,4647,5,210,0,0,4647,4648,5,110,0,0,4648,4649,3,504,252,0,4649,4650,
  	5,111,0,0,4650,4658,1,0,0,0,4651,4652,5,210,0,0,4652,4658,5,23,0,0,4653,
  	4654,5,210,0,0,4654,4655,5,110,0,0,4655,4656,5,173,0,0,4656,4658,5,111,
  	0,0,4657,4643,1,0,0,0,4657,4645,1,0,0,0,4657,4646,1,0,0,0,4657,4651,1,
  	0,0,0,4657,4653,1,0,0,0,4658,469,1,0,0,0,4659,4660,3,482,241,0,4660,4661,
  	5,35,0,0,4661,4662,3,1248,624,0,4662,471,1,0,0,0,4663,4667,3,762,381,
  	0,4664,4667,3,1142,571,0,4665,4667,3,1114,557,0,4666,4663,1,0,0,0,4666,
  	4664,1,0,0,0,4666,4665,1,0,0,0,4667,473,1,0,0,0,4668,4673,3,476,238,0,
  	4669,4670,5,30,0,0,4670,4672,3,476,238,0,4671,4669,1,0,0,0,4672,4675,
  	1,0,0,0,4673,4671,1,0,0,0,4673,4674,1,0,0,0,4674,475,1,0,0,0,4675,4673,
  	1,0,0,0,4676,4678,3,1240,620,0,4677,4676,1,0,0,0,4678,4681,1,0,0,0,4679,
  	4677,1,0,0,0,4679,4680,1,0,0,0,4680,4686,1,0,0,0,4681,4679,1,0,0,0,4682,
  	4684,5,79,0,0,4683,4685,3,478,239,0,4684,4683,1,0,0,0,4684,4685,1,0,0,
  	0,4685,4687,1,0,0,0,4686,4682,1,0,0,0,4686,4687,1,0,0,0,4687,4688,1,0,
  	0,0,4688,4689,3,480,240,0,4689,4693,3,1248,624,0,4690,4692,3,358,179,
  	0,4691,4690,1,0,0,0,4692,4695,1,0,0,0,4693,4691,1,0,0,0,4693,4694,1,0,
  	0,0,4694,4698,1,0,0,0,4695,4693,1,0,0,0,4696,4697,5,362,0,0,4697,4699,
  	3,488,244,0,4698,4696,1,0,0,0,4698,4699,1,0,0,0,4699,477,1,0,0,0,4700,
  	4704,5,66,0,0,4701,4704,5,68,0,0,4702,4704,5,67,0,0,4703,4700,1,0,0,0,
  	4703,4701,1,0,0,0,4703,4702,1,0,0,0,4704,479,1,0,0,0,4705,4709,3,252,
  	126,0,4706,4709,5,204,0,0,4707,4709,5,65,0,0,4708,4705,1,0,0,0,4708,4706,
  	1,0,0,0,4708,4707,1,0,0,0,4709,481,1,0,0,0,4710,4715,3,1260,630,0,4711,
  	4712,5,43,0,0,4712,4713,3,486,243,0,4713,4714,5,44,0,0,4714,4716,1,0,
  	0,0,4715,4711,1,0,0,0,4715,4716,1,0,0,0,4716,483,1,0,0,0,4717,4719,3,
  	488,244,0,4718,4717,1,0,0,0,4718,4719,1,0,0,0,4719,485,1,0,0,0,4720,4722,
  	3,488,244,0,4721,4720,1,0,0,0,4721,4722,1,0,0,0,4722,4727,1,0,0,0,4723,
  	4724,5,30,0,0,4724,4726,3,484,242,0,4725,4723,1,0,0,0,4726,4729,1,0,0,
  	0,4727,4725,1,0,0,0,4727,4728,1,0,0,0,4728,4741,1,0,0,0,4729,4727,1,0,
  	0,0,4730,4731,5,30,0,0,4731,4732,5,35,0,0,4732,4733,3,1248,624,0,4733,
  	4735,5,43,0,0,4734,4736,3,488,244,0,4735,4734,1,0,0,0,4735,4736,1,0,0,
  	0,4736,4737,1,0,0,0,4737,4738,5,44,0,0,4738,4740,1,0,0,0,4739,4730,1,
  	0,0,0,4740,4743,1,0,0,0,4741,4739,1,0,0,0,4741,4742,1,0,0,0,4742,4766,
  	1,0,0,0,4743,4741,1,0,0,0,4744,4745,5,35,0,0,4745,4746,3,1248,624,0,4746,
  	4748,5,43,0,0,4747,4749,3,488,244,0,4748,4747,1,0,0,0,4748,4749,1,0,0,
  	0,4749,4750,1,0,0,0,4750,4762,5,44,0,0,4751,4752,5,30,0,0,4752,4753,5,
  	35,0,0,4753,4754,3,1248,624,0,4754,4756,5,43,0,0,4755,4757,3,488,244,
  	0,4756,4755,1,0,0,0,4756,4757,1,0,0,0,4757,4758,1,0,0,0,4758,4759,5,44,
  	0,0,4759,4761,1,0,0,0,4760,4751,1,0,0,0,4761,4764,1,0,0,0,4762,4760,1,
  	0,0,0,4762,4763,1,0,0,0,4763,4766,1,0,0,0,4764,4762,1,0,0,0,4765,4721,
  	1,0,0,0,4765,4744,1,0,0,0,4766,487,1,0,0,0,4767,4770,3,800,400,0,4768,
  	4770,3,466,233,0,4769,4767,1,0,0,0,4769,4768,1,0,0,0,4770,489,1,0,0,0,
  	4771,4776,3,492,246,0,4772,4773,5,30,0,0,4773,4775,3,492,246,0,4774,4772,
  	1,0,0,0,4775,4778,1,0,0,0,4776,4774,1,0,0,0,4776,4777,1,0,0,0,4777,4797,
  	1,0,0,0,4778,4776,1,0,0,0,4779,4780,5,35,0,0,4780,4781,3,1248,624,0,4781,
  	4782,5,43,0,0,4782,4783,3,492,246,0,4783,4793,5,44,0,0,4784,4785,5,30,
  	0,0,4785,4786,5,35,0,0,4786,4787,3,1248,624,0,4787,4788,5,43,0,0,4788,
  	4789,3,492,246,0,4789,4790,5,44,0,0,4790,4792,1,0,0,0,4791,4784,1,0,0,
  	0,4792,4795,1,0,0,0,4793,4791,1,0,0,0,4793,4794,1,0,0,0,4794,4797,1,0,
  	0,0,4795,4793,1,0,0,0,4796,4771,1,0,0,0,4796,4779,1,0,0,0,4797,491,1,
  	0,0,0,4798,4801,3,800,400,0,4799,4801,3,1194,597,0,4800,4798,1,0,0,0,
  	4800,4799,1,0,0,0,4801,493,1,0,0,0,4802,4806,3,496,248,0,4803,4806,3,
  	498,249,0,4804,4806,3,500,250,0,4805,4802,1,0,0,0,4805,4803,1,0,0,0,4805,
  	4804,1,0,0,0,4806,495,1,0,0,0,4807,4808,5,214,0,0,4808,4809,3,502,251,
  	0,4809,4810,5,111,0,0,4810,4816,1,0,0,0,4811,4816,5,23,0,0,4812,4813,
  	5,110,0,0,4813,4814,5,173,0,0,4814,4816,5,111,0,0,4815,4807,1,0,0,0,4815,
  	4811,1,0,0,0,4815,4812,1,0,0,0,4816,497,1,0,0,0,4817,4818,5,215,0,0,4818,
  	4819,3,502,251,0,4819,4820,5,111,0,0,4820,499,1,0,0,0,4821,4822,5,216,
  	0,0,4822,4823,3,502,251,0,4823,4824,5,111,0,0,4824,501,1,0,0,0,4825,4828,
  	3,1144,572,0,4826,4828,3,504,252,0,4827,4825,1,0,0,0,4827,4826,1,0,0,
  	0,4828,503,1,0,0,0,4829,4830,3,1144,572,0,4830,4831,5,33,0,0,4831,4832,
  	3,1144,572,0,4832,4838,1,0,0,0,4833,4834,3,1144,572,0,4834,4835,5,33,
  	0,0,4835,4836,5,166,0,0,4836,4838,1,0,0,0,4837,4829,1,0,0,0,4837,4833,
  	1,0,0,0,4838,505,1,0,0,0,4839,4845,3,1162,581,0,4840,4841,5,217,0,0,4841,
  	4842,5,85,0,0,4842,4843,3,166,83,0,4843,4844,5,86,0,0,4844,4846,1,0,0,
  	0,4845,4840,1,0,0,0,4845,4846,1,0,0,0,4846,507,1,0,0,0,4847,4848,3,236,
  	118,0,4848,4849,3,330,165,0,4849,4850,5,31,0,0,4850,509,1,0,0,0,4851,
  	4852,5,315,0,0,4852,4858,3,1248,624,0,4853,4855,5,43,0,0,4854,4856,3,
  	512,256,0,4855,4854,1,0,0,0,4855,4856,1,0,0,0,4856,4857,1,0,0,0,4857,
  	4859,5,44,0,0,4858,4853,1,0,0,0,4858,4859,1,0,0,0,4859,4860,1,0,0,0,4860,
  	4861,5,362,0,0,4861,4862,3,1162,581,0,4862,4863,5,31,0,0,4863,511,1,0,
  	0,0,4864,4869,3,514,257,0,4865,4866,5,30,0,0,4866,4868,3,514,257,0,4867,
  	4865,1,0,0,0,4868,4871,1,0,0,0,4869,4867,1,0,0,0,4869,4870,1,0,0,0,4870,
  	513,1,0,0,0,4871,4869,1,0,0,0,4872,4874,3,1240,620,0,4873,4872,1,0,0,
  	0,4874,4877,1,0,0,0,4875,4873,1,0,0,0,4875,4876,1,0,0,0,4876,4878,1,0,
  	0,0,4877,4875,1,0,0,0,4878,4879,3,516,258,0,4879,4883,3,1248,624,0,4880,
  	4882,3,358,179,0,4881,4880,1,0,0,0,4882,4885,1,0,0,0,4883,4881,1,0,0,
  	0,4883,4884,1,0,0,0,4884,4888,1,0,0,0,4885,4883,1,0,0,0,4886,4887,5,362,
  	0,0,4887,4889,3,1162,581,0,4888,4886,1,0,0,0,4888,4889,1,0,0,0,4889,515,
  	1,0,0,0,4890,4893,3,252,126,0,4891,4893,5,65,0,0,4892,4890,1,0,0,0,4892,
  	4891,1,0,0,0,4893,517,1,0,0,0,4894,4895,5,218,0,0,4895,4901,3,1248,624,
  	0,4896,4898,5,43,0,0,4897,4899,3,390,195,0,4898,4897,1,0,0,0,4898,4899,
  	1,0,0,0,4899,4900,1,0,0,0,4900,4902,5,44,0,0,4901,4896,1,0,0,0,4901,4902,
  	1,0,0,0,4902,4904,1,0,0,0,4903,4905,3,526,263,0,4904,4903,1,0,0,0,4904,
  	4905,1,0,0,0,4905,4906,1,0,0,0,4906,4910,5,31,0,0,4907,4909,3,520,260,
  	0,4908,4907,1,0,0,0,4909,4912,1,0,0,0,4910,4908,1,0,0,0,4910,4911,1,0,
  	0,0,4911,4913,1,0,0,0,4912,4910,1,0,0,0,4913,4916,5,219,0,0,4914,4915,
  	5,33,0,0,4915,4917,3,1248,624,0,4916,4914,1,0,0,0,4916,4917,1,0,0,0,4917,
  	519,1,0,0,0,4918,4920,3,1240,620,0,4919,4918,1,0,0,0,4920,4923,1,0,0,
  	0,4921,4919,1,0,0,0,4921,4922,1,0,0,0,4922,4928,1,0,0,0,4923,4921,1,0,
  	0,0,4924,4929,3,524,262,0,4925,4926,3,522,261,0,4926,4927,5,31,0,0,4927,
  	4929,1,0,0,0,4928,4924,1,0,0,0,4928,4925,1,0,0,0,4929,521,1,0,0,0,4930,
  	4931,5,220,0,0,4931,4932,3,1248,624,0,4932,4933,5,362,0,0,4933,4934,3,
  	1162,581,0,4934,4941,1,0,0,0,4935,4936,5,221,0,0,4936,4937,3,1248,624,
  	0,4937,4938,5,362,0,0,4938,4939,3,1162,581,0,4939,4941,1,0,0,0,4940,4930,
  	1,0,0,0,4940,4935,1,0,0,0,4941,523,1,0,0,0,4942,4945,3,532,266,0,4943,
  	4945,3,550,275,0,4944,4942,1,0,0,0,4944,4943,1,0,0,0,4945,525,1,0,0,0,
  	4946,4961,3,904,452,0,4947,4948,5,321,0,0,4948,4949,5,75,0,0,4949,4950,
  	5,342,0,0,4950,4952,5,43,0,0,4951,4953,3,390,195,0,4952,4951,1,0,0,0,
  	4952,4953,1,0,0,0,4953,4954,1,0,0,0,4954,4961,5,44,0,0,4955,4956,5,222,
  	0,0,4956,4957,5,43,0,0,4957,4958,3,528,264,0,4958,4959,5,44,0,0,4959,
  	4961,1,0,0,0,4960,4946,1,0,0,0,4960,4947,1,0,0,0,4960,4955,1,0,0,0,4961,
  	527,1,0,0,0,4962,4963,6,264,-1,0,4963,4964,5,223,0,0,4964,4968,3,530,
  	265,0,4965,4966,5,224,0,0,4966,4968,3,530,265,0,4967,4962,1,0,0,0,4967,
  	4965,1,0,0,0,4968,4974,1,0,0,0,4969,4970,10,3,0,0,4970,4971,5,202,0,0,
  	4971,4973,3,528,264,4,4972,4969,1,0,0,0,4973,4976,1,0,0,0,4974,4972,1,
  	0,0,0,4974,4975,1,0,0,0,4975,529,1,0,0,0,4976,4974,1,0,0,0,4977,5004,
  	3,1246,623,0,4978,4980,3,1196,598,0,4979,4978,1,0,0,0,4979,4980,1,0,0,
  	0,4980,4981,1,0,0,0,4981,4995,3,1248,624,0,4982,4983,5,110,0,0,4983,4984,
  	3,1144,572,0,4984,4985,5,111,0,0,4985,4987,1,0,0,0,4986,4982,1,0,0,0,
  	4987,4990,1,0,0,0,4988,4986,1,0,0,0,4988,4989,1,0,0,0,4989,4991,1,0,0,
  	0,4990,4988,1,0,0,0,4991,4992,5,35,0,0,4992,4994,3,1248,624,0,4993,4988,
  	1,0,0,0,4994,4997,1,0,0,0,4995,4993,1,0,0,0,4995,4996,1,0,0,0,4996,4999,
  	1,0,0,0,4997,4995,1,0,0,0,4998,5000,3,260,130,0,4999,4998,1,0,0,0,4999,
  	5000,1,0,0,0,5000,5001,1,0,0,0,5001,5002,3,1248,624,0,5002,5004,1,0,0,
  	0,5003,4977,1,0,0,0,5003,4979,1,0,0,0,5004,531,1,0,0,0,5005,5006,3,252,
  	126,0,5006,5007,3,1248,624,0,5007,5008,5,33,0,0,5008,5010,1,0,0,0,5009,
  	5005,1,0,0,0,5009,5010,1,0,0,0,5010,5011,1,0,0,0,5011,5012,5,331,0,0,
  	5012,5018,3,1162,581,0,5013,5014,5,198,0,0,5014,5015,5,43,0,0,5015,5016,
  	3,1162,581,0,5016,5017,5,44,0,0,5017,5019,1,0,0,0,5018,5013,1,0,0,0,5018,
  	5019,1,0,0,0,5019,5020,1,0,0,0,5020,5021,3,534,267,0,5021,533,1,0,0,0,
  	5022,5026,5,85,0,0,5023,5025,3,1240,620,0,5024,5023,1,0,0,0,5025,5028,
  	1,0,0,0,5026,5024,1,0,0,0,5026,5027,1,0,0,0,5027,5034,1,0,0,0,5028,5026,
  	1,0,0,0,5029,5030,3,536,268,0,5030,5031,5,31,0,0,5031,5033,1,0,0,0,5032,
  	5029,1,0,0,0,5033,5036,1,0,0,0,5034,5032,1,0,0,0,5034,5035,1,0,0,0,5035,
  	5037,1,0,0,0,5036,5034,1,0,0,0,5037,5040,5,86,0,0,5038,5040,5,31,0,0,
  	5039,5022,1,0,0,0,5039,5038,1,0,0,0,5040,535,1,0,0,0,5041,5169,3,522,
  	261,0,5042,5044,5,225,0,0,5043,5042,1,0,0,0,5043,5044,1,0,0,0,5044,5045,
  	1,0,0,0,5045,5046,3,538,269,0,5046,5052,3,1248,624,0,5047,5049,5,110,
  	0,0,5048,5050,3,1162,581,0,5049,5048,1,0,0,0,5049,5050,1,0,0,0,5050,5051,
  	1,0,0,0,5051,5053,5,111,0,0,5052,5047,1,0,0,0,5052,5053,1,0,0,0,5053,
  	5054,1,0,0,0,5054,5055,5,362,0,0,5055,5056,5,85,0,0,5056,5057,3,540,270,
  	0,5057,5063,5,86,0,0,5058,5059,5,321,0,0,5059,5060,5,43,0,0,5060,5061,
  	3,1162,581,0,5061,5062,5,44,0,0,5062,5064,1,0,0,0,5063,5058,1,0,0,0,5063,
  	5064,1,0,0,0,5064,5070,1,0,0,0,5065,5066,5,198,0,0,5066,5067,5,43,0,0,
  	5067,5068,3,1162,581,0,5068,5069,5,44,0,0,5069,5071,1,0,0,0,5070,5065,
  	1,0,0,0,5070,5071,1,0,0,0,5071,5169,1,0,0,0,5072,5074,5,225,0,0,5073,
  	5072,1,0,0,0,5073,5074,1,0,0,0,5074,5075,1,0,0,0,5075,5076,3,538,269,
  	0,5076,5082,3,1248,624,0,5077,5079,5,110,0,0,5078,5080,3,1162,581,0,5079,
  	5078,1,0,0,0,5079,5080,1,0,0,0,5080,5081,1,0,0,0,5081,5083,5,111,0,0,
  	5082,5077,1,0,0,0,5082,5083,1,0,0,0,5083,5084,1,0,0,0,5084,5085,5,362,
  	0,0,5085,5091,3,1248,624,0,5086,5087,5,321,0,0,5087,5088,5,43,0,0,5088,
  	5089,3,1162,581,0,5089,5090,5,44,0,0,5090,5092,1,0,0,0,5091,5086,1,0,
  	0,0,5091,5092,1,0,0,0,5092,5098,1,0,0,0,5093,5094,5,198,0,0,5094,5095,
  	5,43,0,0,5095,5096,3,1162,581,0,5096,5097,5,44,0,0,5097,5099,1,0,0,0,
  	5098,5093,1,0,0,0,5098,5099,1,0,0,0,5099,5169,1,0,0,0,5100,5102,5,225,
  	0,0,5101,5100,1,0,0,0,5101,5102,1,0,0,0,5102,5103,1,0,0,0,5103,5104,3,
  	538,269,0,5104,5110,3,1248,624,0,5105,5107,5,110,0,0,5106,5108,3,1162,
  	581,0,5107,5106,1,0,0,0,5107,5108,1,0,0,0,5108,5109,1,0,0,0,5109,5111,
  	5,111,0,0,5110,5105,1,0,0,0,5110,5111,1,0,0,0,5111,5112,1,0,0,0,5112,
  	5113,5,362,0,0,5113,5119,3,1162,581,0,5114,5115,5,198,0,0,5115,5116,5,
  	43,0,0,5116,5117,3,1162,581,0,5117,5118,5,44,0,0,5118,5120,1,0,0,0,5119,
  	5114,1,0,0,0,5119,5120,1,0,0,0,5120,5169,1,0,0,0,5121,5123,5,225,0,0,
  	5122,5121,1,0,0,0,5122,5123,1,0,0,0,5123,5124,1,0,0,0,5124,5125,3,538,
  	269,0,5125,5127,3,1248,624,0,5126,5128,3,362,181,0,5127,5126,1,0,0,0,
  	5127,5128,1,0,0,0,5128,5129,1,0,0,0,5129,5130,5,362,0,0,5130,5136,3,542,
  	271,0,5131,5132,5,198,0,0,5132,5133,5,43,0,0,5133,5134,3,1162,581,0,5134,
  	5135,5,44,0,0,5135,5137,1,0,0,0,5136,5131,1,0,0,0,5136,5137,1,0,0,0,5137,
  	5169,1,0,0,0,5138,5139,3,538,269,0,5139,5145,3,1248,624,0,5140,5142,5,
  	110,0,0,5141,5143,3,1162,581,0,5142,5141,1,0,0,0,5142,5143,1,0,0,0,5143,
  	5144,1,0,0,0,5144,5146,5,111,0,0,5145,5140,1,0,0,0,5145,5146,1,0,0,0,
  	5146,5147,1,0,0,0,5147,5148,5,362,0,0,5148,5154,5,36,0,0,5149,5150,5,
  	198,0,0,5150,5151,5,43,0,0,5151,5152,3,1162,581,0,5152,5153,5,44,0,0,
  	5153,5155,1,0,0,0,5154,5149,1,0,0,0,5154,5155,1,0,0,0,5155,5169,1,0,0,
  	0,5156,5157,3,538,269,0,5157,5158,3,1248,624,0,5158,5159,5,362,0,0,5159,
  	5160,5,36,0,0,5160,5166,5,204,0,0,5161,5162,5,198,0,0,5162,5163,5,43,
  	0,0,5163,5164,3,1162,581,0,5164,5165,5,44,0,0,5165,5167,1,0,0,0,5166,
  	5161,1,0,0,0,5166,5167,1,0,0,0,5167,5169,1,0,0,0,5168,5041,1,0,0,0,5168,
  	5043,1,0,0,0,5168,5073,1,0,0,0,5168,5101,1,0,0,0,5168,5122,1,0,0,0,5168,
  	5138,1,0,0,0,5168,5156,1,0,0,0,5169,537,1,0,0,0,5170,5174,5,226,0,0,5171,
  	5174,5,227,0,0,5172,5174,5,228,0,0,5173,5170,1,0,0,0,5173,5171,1,0,0,
  	0,5173,5172,1,0,0,0,5174,539,1,0,0,0,5175,5180,3,1164,582,0,5176,5177,
  	5,30,0,0,5177,5179,3,1164,582,0,5178,5176,1,0,0,0,5179,5182,1,0,0,0,5180,
  	5178,1,0,0,0,5180,5181,1,0,0,0,5181,541,1,0,0,0,5182,5180,1,0,0,0,5183,
  	5184,5,43,0,0,5184,5185,3,544,272,0,5185,5193,5,44,0,0,5186,5187,5,30,
  	0,0,5187,5188,5,43,0,0,5188,5189,3,544,272,0,5189,5190,5,44,0,0,5190,
  	5192,1,0,0,0,5191,5186,1,0,0,0,5192,5195,1,0,0,0,5193,5191,1,0,0,0,5193,
  	5194,1,0,0,0,5194,543,1,0,0,0,5195,5193,1,0,0,0,5196,5201,3,546,273,0,
  	5197,5198,5,229,0,0,5198,5200,3,546,273,0,5199,5197,1,0,0,0,5200,5203,
  	1,0,0,0,5201,5199,1,0,0,0,5201,5202,1,0,0,0,5202,545,1,0,0,0,5203,5201,
  	1,0,0,0,5204,5221,3,540,270,0,5205,5206,3,540,270,0,5206,5207,5,214,0,
  	0,5207,5208,3,548,274,0,5208,5209,5,111,0,0,5209,5221,1,0,0,0,5210,5211,
  	3,540,270,0,5211,5212,5,216,0,0,5212,5213,3,548,274,0,5213,5214,5,111,
  	0,0,5214,5221,1,0,0,0,5215,5216,3,540,270,0,5216,5217,5,215,0,0,5217,
  	5218,3,548,274,0,5218,5219,5,111,0,0,5219,5221,1,0,0,0,5220,5204,1,0,
  	0,0,5220,5205,1,0,0,0,5220,5210,1,0,0,0,5220,5215,1,0,0,0,5221,547,1,
  	0,0,0,5222,5228,3,1162,581,0,5223,5224,3,1162,581,0,5224,5225,5,33,0,
  	0,5225,5226,3,1162,581,0,5226,5228,1,0,0,0,5227,5222,1,0,0,0,5227,5223,
  	1,0,0,0,5228,549,1,0,0,0,5229,5230,3,1248,624,0,5230,5231,5,33,0,0,5231,
  	5233,1,0,0,0,5232,5229,1,0,0,0,5232,5233,1,0,0,0,5233,5234,1,0,0,0,5234,
  	5235,5,332,0,0,5235,5241,3,552,276,0,5236,5237,5,198,0,0,5237,5238,5,
  	43,0,0,5238,5239,3,1162,581,0,5239,5240,5,44,0,0,5240,5242,1,0,0,0,5241,
  	5236,1,0,0,0,5241,5242,1,0,0,0,5242,5243,1,0,0,0,5243,5244,3,556,278,
  	0,5244,551,1,0,0,0,5245,5246,3,554,277,0,5246,5247,5,30,0,0,5247,5252,
  	3,554,277,0,5248,5249,5,30,0,0,5249,5251,3,554,277,0,5250,5248,1,0,0,
  	0,5251,5254,1,0,0,0,5252,5250,1,0,0,0,5252,5253,1,0,0,0,5253,553,1,0,
  	0,0,5254,5252,1,0,0,0,5255,5256,3,1248,624,0,5256,555,1,0,0,0,5257,5261,
  	5,85,0,0,5258,5260,3,558,279,0,5259,5258,1,0,0,0,5260,5263,1,0,0,0,5261,
  	5259,1,0,0,0,5261,5262,1,0,0,0,5262,5264,1,0,0,0,5263,5261,1,0,0,0,5264,
  	5267,5,86,0,0,5265,5267,5,31,0,0,5266,5257,1,0,0,0,5266,5265,1,0,0,0,
  	5267,557,1,0,0,0,5268,5273,3,368,184,0,5269,5270,3,560,280,0,5270,5271,
  	5,31,0,0,5271,5273,1,0,0,0,5272,5268,1,0,0,0,5272,5269,1,0,0,0,5273,559,
  	1,0,0,0,5274,5276,3,1240,620,0,5275,5274,1,0,0,0,5276,5279,1,0,0,0,5277,
  	5275,1,0,0,0,5277,5278,1,0,0,0,5278,5282,1,0,0,0,5279,5277,1,0,0,0,5280,
  	5283,3,522,261,0,5281,5283,3,562,281,0,5282,5280,1,0,0,0,5282,5281,1,
  	0,0,0,5283,561,1,0,0,0,5284,5285,3,538,269,0,5285,5286,3,1248,624,0,5286,
  	5287,5,362,0,0,5287,5293,3,564,282,0,5288,5289,5,198,0,0,5289,5290,5,
  	43,0,0,5290,5291,3,1162,581,0,5291,5292,5,44,0,0,5292,5294,1,0,0,0,5293,
  	5288,1,0,0,0,5293,5294,1,0,0,0,5294,563,1,0,0,0,5295,5296,6,282,-1,0,
  	5296,5311,3,566,283,0,5297,5298,5,230,0,0,5298,5311,3,566,283,0,5299,
  	5300,5,43,0,0,5300,5301,3,564,282,0,5301,5302,5,44,0,0,5302,5311,1,0,
  	0,0,5303,5311,3,1248,624,0,5304,5308,3,1162,581,0,5305,5306,3,826,413,
  	0,5306,5307,3,1162,581,0,5307,5309,1,0,0,0,5308,5305,1,0,0,0,5308,5309,
  	1,0,0,0,5309,5311,1,0,0,0,5310,5295,1,0,0,0,5310,5297,1,0,0,0,5310,5299,
  	1,0,0,0,5310,5303,1,0,0,0,5310,5304,1,0,0,0,5311,5327,1,0,0,0,5312,5313,
  	10,5,0,0,5313,5314,7,17,0,0,5314,5326,3,564,282,6,5315,5316,10,3,0,0,
  	5316,5317,5,321,0,0,5317,5318,5,43,0,0,5318,5319,3,1162,581,0,5319,5323,
  	5,44,0,0,5320,5321,3,826,413,0,5321,5322,3,1162,581,0,5322,5324,1,0,0,
  	0,5323,5320,1,0,0,0,5323,5324,1,0,0,0,5324,5326,1,0,0,0,5325,5312,1,0,
  	0,0,5325,5315,1,0,0,0,5326,5329,1,0,0,0,5327,5325,1,0,0,0,5327,5328,1,
  	0,0,0,5328,565,1,0,0,0,5329,5327,1,0,0,0,5330,5331,5,237,0,0,5331,5332,
  	5,43,0,0,5332,5333,3,568,284,0,5333,5339,5,44,0,0,5334,5335,5,206,0,0,
  	5335,5336,5,85,0,0,5336,5337,3,570,285,0,5337,5338,5,86,0,0,5338,5340,
  	1,0,0,0,5339,5334,1,0,0,0,5339,5340,1,0,0,0,5340,567,1,0,0,0,5341,5344,
  	3,1248,624,0,5342,5343,5,35,0,0,5343,5345,3,1248,624,0,5344,5342,1,0,
  	0,0,5344,5345,1,0,0,0,5345,569,1,0,0,0,5346,5351,3,1164,582,0,5347,5348,
  	5,30,0,0,5348,5350,3,1164,582,0,5349,5347,1,0,0,0,5350,5353,1,0,0,0,5351,
  	5349,1,0,0,0,5351,5352,1,0,0,0,5352,571,1,0,0,0,5353,5351,1,0,0,0,5354,
  	5356,3,594,297,0,5355,5357,3,304,152,0,5356,5355,1,0,0,0,5356,5357,1,
  	0,0,0,5357,5358,1,0,0,0,5358,5363,3,574,287,0,5359,5360,5,30,0,0,5360,
  	5362,3,574,287,0,5361,5359,1,0,0,0,5362,5365,1,0,0,0,5363,5361,1,0,0,
  	0,5363,5364,1,0,0,0,5364,5366,1,0,0,0,5365,5363,1,0,0,0,5366,5367,5,31,
  	0,0,5367,5487,1,0,0,0,5368,5370,3,596,298,0,5369,5371,3,296,148,0,5370,
  	5369,1,0,0,0,5370,5371,1,0,0,0,5371,5373,1,0,0,0,5372,5374,3,304,152,
  	0,5373,5372,1,0,0,0,5373,5374,1,0,0,0,5374,5375,1,0,0,0,5375,5380,3,576,
  	288,0,5376,5377,5,30,0,0,5377,5379,3,576,288,0,5378,5376,1,0,0,0,5379,
  	5382,1,0,0,0,5380,5378,1,0,0,0,5380,5381,1,0,0,0,5381,5383,1,0,0,0,5382,
  	5380,1,0,0,0,5383,5384,5,31,0,0,5384,5487,1,0,0,0,5385,5387,3,598,299,
  	0,5386,5388,3,304,152,0,5387,5386,1,0,0,0,5387,5388,1,0,0,0,5388,5389,
  	1,0,0,0,5389,5394,3,578,289,0,5390,5391,5,30,0,0,5391,5393,3,578,289,
  	0,5392,5390,1,0,0,0,5393,5396,1,0,0,0,5394,5392,1,0,0,0,5394,5395,1,0,
  	0,0,5395,5397,1,0,0,0,5396,5394,1,0,0,0,5397,5398,5,31,0,0,5398,5487,
  	1,0,0,0,5399,5401,3,600,300,0,5400,5402,3,296,148,0,5401,5400,1,0,0,0,
  	5401,5402,1,0,0,0,5402,5404,1,0,0,0,5403,5405,3,306,153,0,5404,5403,1,
  	0,0,0,5404,5405,1,0,0,0,5405,5406,1,0,0,0,5406,5411,3,580,290,0,5407,
  	5408,5,30,0,0,5408,5410,3,580,290,0,5409,5407,1,0,0,0,5410,5413,1,0,0,
  	0,5411,5409,1,0,0,0,5411,5412,1,0,0,0,5412,5414,1,0,0,0,5413,5411,1,0,
  	0,0,5414,5415,5,31,0,0,5415,5487,1,0,0,0,5416,5418,3,602,301,0,5417,5419,
  	3,296,148,0,5418,5417,1,0,0,0,5418,5419,1,0,0,0,5419,5421,1,0,0,0,5420,
  	5422,3,306,153,0,5421,5420,1,0,0,0,5421,5422,1,0,0,0,5422,5423,1,0,0,
  	0,5423,5428,3,582,291,0,5424,5425,5,30,0,0,5425,5427,3,582,291,0,5426,
  	5424,1,0,0,0,5427,5430,1,0,0,0,5428,5426,1,0,0,0,5428,5429,1,0,0,0,5429,
  	5431,1,0,0,0,5430,5428,1,0,0,0,5431,5432,5,31,0,0,5432,5487,1,0,0,0,5433,
  	5435,3,604,302,0,5434,5436,3,306,153,0,5435,5434,1,0,0,0,5435,5436,1,
  	0,0,0,5436,5437,1,0,0,0,5437,5442,3,586,293,0,5438,5439,5,30,0,0,5439,
  	5441,3,586,293,0,5440,5438,1,0,0,0,5441,5444,1,0,0,0,5442,5440,1,0,0,
  	0,5442,5443,1,0,0,0,5443,5445,1,0,0,0,5444,5442,1,0,0,0,5445,5446,5,31,
  	0,0,5446,5487,1,0,0,0,5447,5448,3,606,303,0,5448,5453,3,584,292,0,5449,
  	5450,5,30,0,0,5450,5452,3,584,292,0,5451,5449,1,0,0,0,5452,5455,1,0,0,
  	0,5453,5451,1,0,0,0,5453,5454,1,0,0,0,5454,5456,1,0,0,0,5455,5453,1,0,
  	0,0,5456,5457,5,31,0,0,5457,5487,1,0,0,0,5458,5460,5,238,0,0,5459,5461,
  	3,590,295,0,5460,5459,1,0,0,0,5460,5461,1,0,0,0,5461,5462,1,0,0,0,5462,
  	5467,3,588,294,0,5463,5464,5,30,0,0,5464,5466,3,588,294,0,5465,5463,1,
  	0,0,0,5466,5469,1,0,0,0,5467,5465,1,0,0,0,5467,5468,1,0,0,0,5468,5470,
  	1,0,0,0,5469,5467,1,0,0,0,5470,5471,5,31,0,0,5471,5487,1,0,0,0,5472,5474,
  	5,239,0,0,5473,5475,3,592,296,0,5474,5473,1,0,0,0,5474,5475,1,0,0,0,5475,
  	5476,1,0,0,0,5476,5481,3,588,294,0,5477,5478,5,30,0,0,5478,5480,3,588,
  	294,0,5479,5477,1,0,0,0,5480,5483,1,0,0,0,5481,5479,1,0,0,0,5481,5482,
  	1,0,0,0,5482,5484,1,0,0,0,5483,5481,1,0,0,0,5484,5485,5,31,0,0,5485,5487,
  	1,0,0,0,5486,5354,1,0,0,0,5486,5368,1,0,0,0,5486,5385,1,0,0,0,5486,5399,
  	1,0,0,0,5486,5416,1,0,0,0,5486,5433,1,0,0,0,5486,5447,1,0,0,0,5486,5458,
  	1,0,0,0,5486,5472,1,0,0,0,5487,573,1,0,0,0,5488,5490,3,620,310,0,5489,
  	5488,1,0,0,0,5489,5490,1,0,0,0,5490,5491,1,0,0,0,5491,5492,5,43,0,0,5492,
  	5493,3,1224,612,0,5493,5494,5,30,0,0,5494,5495,3,1162,581,0,5495,5496,
  	5,30,0,0,5496,5497,3,1162,581,0,5497,5498,5,30,0,0,5498,5499,3,1162,581,
  	0,5499,5500,5,44,0,0,5500,575,1,0,0,0,5501,5503,3,620,310,0,5502,5501,
  	1,0,0,0,5502,5503,1,0,0,0,5503,5504,1,0,0,0,5504,5505,5,43,0,0,5505,5506,
  	3,1224,612,0,5506,5507,5,30,0,0,5507,5508,3,1162,581,0,5508,5509,5,30,
  	0,0,5509,5510,3,1162,581,0,5510,5511,5,44,0,0,5511,577,1,0,0,0,5512,5514,
  	3,620,310,0,5513,5512,1,0,0,0,5513,5514,1,0,0,0,5514,5515,1,0,0,0,5515,
  	5516,5,43,0,0,5516,5517,3,1224,612,0,5517,5518,5,30,0,0,5518,5519,3,1162,
  	581,0,5519,5520,5,30,0,0,5520,5521,3,1162,581,0,5521,5522,5,44,0,0,5522,
  	579,1,0,0,0,5523,5525,3,620,310,0,5524,5523,1,0,0,0,5524,5525,1,0,0,0,
  	5525,5526,1,0,0,0,5526,5527,5,43,0,0,5527,5528,3,1224,612,0,5528,5529,
  	5,30,0,0,5529,5534,3,1162,581,0,5530,5531,5,30,0,0,5531,5533,3,1162,581,
  	0,5532,5530,1,0,0,0,5533,5536,1,0,0,0,5534,5532,1,0,0,0,5534,5535,1,0,
  	0,0,5535,5537,1,0,0,0,5536,5534,1,0,0,0,5537,5538,5,44,0,0,5538,581,1,
  	0,0,0,5539,5541,3,620,310,0,5540,5539,1,0,0,0,5540,5541,1,0,0,0,5541,
  	5542,1,0,0,0,5542,5543,5,43,0,0,5543,5548,3,1224,612,0,5544,5545,5,30,
  	0,0,5545,5547,3,1224,612,0,5546,5544,1,0,0,0,5547,5550,1,0,0,0,5548,5546,
  	1,0,0,0,5548,5549,1,0,0,0,5549,5551,1,0,0,0,5550,5548,1,0,0,0,5551,5552,
  	5,30,0,0,5552,5553,3,1162,581,0,5553,5554,5,44,0,0,5554,583,1,0,0,0,5555,
  	5557,3,620,310,0,5556,5555,1,0,0,0,5556,5557,1,0,0,0,5557,5558,1,0,0,
  	0,5558,5559,5,43,0,0,5559,5560,3,1224,612,0,5560,5561,5,30,0,0,5561,5562,
  	3,1224,612,0,5562,5563,5,44,0,0,5563,585,1,0,0,0,5564,5566,3,620,310,
  	0,5565,5564,1,0,0,0,5565,5566,1,0,0,0,5566,5567,1,0,0,0,5567,5568,5,43,
  	0,0,5568,5569,3,1224,612,0,5569,5570,5,30,0,0,5570,5571,3,1224,612,0,
  	5571,5572,5,30,0,0,5572,5573,3,1162,581,0,5573,5574,5,44,0,0,5574,587,
  	1,0,0,0,5575,5577,3,620,310,0,5576,5575,1,0,0,0,5576,5577,1,0,0,0,5577,
  	5578,1,0,0,0,5578,5579,5,43,0,0,5579,5580,3,1224,612,0,5580,5581,5,44,
  	0,0,5581,589,1,0,0,0,5582,5583,5,43,0,0,5583,5584,3,298,149,0,5584,5585,
  	5,30,0,0,5585,5586,3,300,150,0,5586,5587,5,44,0,0,5587,5599,1,0,0,0,5588,
  	5589,5,43,0,0,5589,5590,3,300,150,0,5590,5591,5,30,0,0,5591,5592,3,298,
  	149,0,5592,5593,5,44,0,0,5593,5599,1,0,0,0,5594,5595,5,43,0,0,5595,5596,
  	3,298,149,0,5596,5597,5,44,0,0,5597,5599,1,0,0,0,5598,5582,1,0,0,0,5598,
  	5588,1,0,0,0,5598,5594,1,0,0,0,5599,591,1,0,0,0,5600,5601,5,43,0,0,5601,
  	5602,3,298,149,0,5602,5603,5,30,0,0,5603,5604,3,300,150,0,5604,5605,5,
  	44,0,0,5605,5617,1,0,0,0,5606,5607,5,43,0,0,5607,5608,3,300,150,0,5608,
  	5609,5,30,0,0,5609,5610,3,298,149,0,5610,5611,5,44,0,0,5611,5617,1,0,
  	0,0,5612,5613,5,43,0,0,5613,5614,3,300,150,0,5614,5615,5,44,0,0,5615,
  	5617,1,0,0,0,5616,5600,1,0,0,0,5616,5606,1,0,0,0,5616,5612,1,0,0,0,5617,
  	593,1,0,0,0,5618,5621,5,240,0,0,5619,5621,5,241,0,0,5620,5618,1,0,0,0,
  	5620,5619,1,0,0,0,5621,595,1,0,0,0,5622,5627,5,242,0,0,5623,5627,5,243,
  	0,0,5624,5627,5,244,0,0,5625,5627,5,245,0,0,5626,5622,1,0,0,0,5626,5623,
  	1,0,0,0,5626,5624,1,0,0,0,5626,5625,1,0,0,0,5627,597,1,0,0,0,5628,5633,
  	5,246,0,0,5629,5633,5,247,0,0,5630,5633,5,248,0,0,5631,5633,5,249,0,0,
  	5632,5628,1,0,0,0,5632,5629,1,0,0,0,5632,5630,1,0,0,0,5632,5631,1,0,0,
  	0,5633,599,1,0,0,0,5634,5641,5,203,0,0,5635,5641,5,250,0,0,5636,5641,
  	5,202,0,0,5637,5641,5,251,0,0,5638,5641,5,252,0,0,5639,5641,5,253,0,0,
  	5640,5634,1,0,0,0,5640,5635,1,0,0,0,5640,5636,1,0,0,0,5640,5637,1,0,0,
  	0,5640,5638,1,0,0,0,5640,5639,1,0,0,0,5641,601,1,0,0,0,5642,5645,5,254,
  	0,0,5643,5645,5,201,0,0,5644,5642,1,0,0,0,5644,5643,1,0,0,0,5645,603,
  	1,0,0,0,5646,5651,5,255,0,0,5647,5651,5,256,0,0,5648,5651,5,257,0,0,5649,
  	5651,5,258,0,0,5650,5646,1,0,0,0,5650,5647,1,0,0,0,5650,5648,1,0,0,0,
  	5650,5649,1,0,0,0,5651,605,1,0,0,0,5652,5655,5,259,0,0,5653,5655,5,260,
  	0,0,5654,5652,1,0,0,0,5654,5653,1,0,0,0,5655,607,1,0,0,0,5656,5658,3,
  	1248,624,0,5657,5659,3,610,305,0,5658,5657,1,0,0,0,5658,5659,1,0,0,0,
  	5659,5660,1,0,0,0,5660,5665,3,618,309,0,5661,5662,5,30,0,0,5662,5664,
  	3,618,309,0,5663,5661,1,0,0,0,5664,5667,1,0,0,0,5665,5663,1,0,0,0,5665,
  	5666,1,0,0,0,5666,5668,1,0,0,0,5667,5665,1,0,0,0,5668,5669,5,31,0,0,5669,
  	609,1,0,0,0,5670,5671,5,213,0,0,5671,5673,5,43,0,0,5672,5674,3,612,306,
  	0,5673,5672,1,0,0,0,5673,5674,1,0,0,0,5674,5675,1,0,0,0,5675,5680,5,44,
  	0,0,5676,5680,5,17,0,0,5677,5678,5,213,0,0,5678,5680,5,368,0,0,5679,5670,
  	1,0,0,0,5679,5676,1,0,0,0,5679,5677,1,0,0,0,5680,611,1,0,0,0,5681,5686,
  	3,614,307,0,5682,5683,5,30,0,0,5683,5685,3,614,307,0,5684,5682,1,0,0,
  	0,5685,5688,1,0,0,0,5686,5684,1,0,0,0,5686,5687,1,0,0,0,5687,5698,1,0,
  	0,0,5688,5686,1,0,0,0,5689,5694,3,616,308,0,5690,5691,5,30,0,0,5691,5693,
  	3,616,308,0,5692,5690,1,0,0,0,5693,5696,1,0,0,0,5694,5692,1,0,0,0,5694,
  	5695,1,0,0,0,5695,5698,1,0,0,0,5696,5694,1,0,0,0,5697,5681,1,0,0,0,5697,
  	5689,1,0,0,0,5698,613,1,0,0,0,5699,5700,3,1152,576,0,5700,615,1,0,0,0,
  	5701,5702,5,35,0,0,5702,5703,3,1248,624,0,5703,5705,5,43,0,0,5704,5706,
  	3,1152,576,0,5705,5704,1,0,0,0,5705,5706,1,0,0,0,5706,5707,1,0,0,0,5707,
  	5708,5,44,0,0,5708,617,1,0,0,0,5709,5710,3,620,310,0,5710,5711,5,43,0,
  	0,5711,5712,3,622,311,0,5712,5713,5,44,0,0,5713,619,1,0,0,0,5714,5718,
  	3,1248,624,0,5715,5717,3,352,176,0,5716,5715,1,0,0,0,5717,5720,1,0,0,
  	0,5718,5716,1,0,0,0,5718,5719,1,0,0,0,5719,621,1,0,0,0,5720,5718,1,0,
  	0,0,5721,5726,3,624,312,0,5722,5723,5,30,0,0,5723,5725,3,624,312,0,5724,
  	5722,1,0,0,0,5725,5728,1,0,0,0,5726,5724,1,0,0,0,5726,5727,1,0,0,0,5727,
  	5738,1,0,0,0,5728,5726,1,0,0,0,5729,5734,3,626,313,0,5730,5731,5,30,0,
  	0,5731,5733,3,626,313,0,5732,5730,1,0,0,0,5733,5736,1,0,0,0,5734,5732,
  	1,0,0,0,5734,5735,1,0,0,0,5735,5738,1,0,0,0,5736,5734,1,0,0,0,5737,5721,
  	1,0,0,0,5737,5729,1,0,0,0,5738,623,1,0,0,0,5739,5741,3,1240,620,0,5740,
  	5739,1,0,0,0,5741,5744,1,0,0,0,5742,5740,1,0,0,0,5742,5743,1,0,0,0,5743,
  	5746,1,0,0,0,5744,5742,1,0,0,0,5745,5747,3,1162,581,0,5746,5745,1,0,0,
  	0,5746,5747,1,0,0,0,5747,625,1,0,0,0,5748,5750,3,1240,620,0,5749,5748,
  	1,0,0,0,5750,5753,1,0,0,0,5751,5749,1,0,0,0,5751,5752,1,0,0,0,5752,5764,
  	1,0,0,0,5753,5751,1,0,0,0,5754,5755,5,35,0,0,5755,5761,3,1248,624,0,5756,
  	5758,5,43,0,0,5757,5759,3,1162,581,0,5758,5757,1,0,0,0,5758,5759,1,0,
  	0,0,5759,5760,1,0,0,0,5760,5762,5,44,0,0,5761,5756,1,0,0,0,5761,5762,
  	1,0,0,0,5762,5765,1,0,0,0,5763,5765,5,261,0,0,5764,5754,1,0,0,0,5764,
  	5763,1,0,0,0,5765,627,1,0,0,0,5766,5767,3,1254,627,0,5767,5768,3,620,
  	310,0,5768,5769,5,43,0,0,5769,5770,3,630,315,0,5770,5771,5,44,0,0,5771,
  	5772,5,31,0,0,5772,629,1,0,0,0,5773,5776,3,632,316,0,5774,5775,5,30,0,
  	0,5775,5777,3,632,316,0,5776,5774,1,0,0,0,5776,5777,1,0,0,0,5777,5784,
  	1,0,0,0,5778,5781,3,634,317,0,5779,5780,5,30,0,0,5780,5782,3,634,317,
  	0,5781,5779,1,0,0,0,5781,5782,1,0,0,0,5782,5784,1,0,0,0,5783,5773,1,0,
  	0,0,5783,5778,1,0,0,0,5784,631,1,0,0,0,5785,5787,3,1240,620,0,5786,5785,
  	1,0,0,0,5787,5790,1,0,0,0,5788,5786,1,0,0,0,5788,5789,1,0,0,0,5789,5792,
  	1,0,0,0,5790,5788,1,0,0,0,5791,5793,3,442,221,0,5792,5791,1,0,0,0,5792,
  	5793,1,0,0,0,5793,633,1,0,0,0,5794,5796,3,1240,620,0,5795,5794,1,0,0,
  	0,5796,5799,1,0,0,0,5797,5795,1,0,0,0,5797,5798,1,0,0,0,5798,5810,1,0,
  	0,0,5799,5797,1,0,0,0,5800,5801,5,35,0,0,5801,5807,3,1248,624,0,5802,
  	5804,5,43,0,0,5803,5805,3,442,221,0,5804,5803,1,0,0,0,5804,5805,1,0,0,
  	0,5805,5806,1,0,0,0,5806,5808,5,44,0,0,5807,5802,1,0,0,0,5807,5808,1,
  	0,0,0,5808,5811,1,0,0,0,5809,5811,5,261,0,0,5810,5800,1,0,0,0,5810,5809,
  	1,0,0,0,5811,635,1,0,0,0,5812,5816,5,262,0,0,5813,5815,3,638,319,0,5814,
  	5813,1,0,0,0,5815,5818,1,0,0,0,5816,5814,1,0,0,0,5816,5817,1,0,0,0,5817,
  	5819,1,0,0,0,5818,5816,1,0,0,0,5819,5820,5,263,0,0,5820,637,1,0,0,0,5821,
  	5832,3,640,320,0,5822,5832,3,642,321,0,5823,5832,3,646,323,0,5824,5825,
  	3,1248,624,0,5825,5826,5,33,0,0,5826,5828,1,0,0,0,5827,5824,1,0,0,0,5827,
  	5828,1,0,0,0,5828,5829,1,0,0,0,5829,5832,3,654,327,0,5830,5832,3,88,44,
  	0,5831,5821,1,0,0,0,5831,5822,1,0,0,0,5831,5823,1,0,0,0,5831,5827,1,0,
  	0,0,5831,5830,1,0,0,0,5832,639,1,0,0,0,5833,5834,5,90,0,0,5834,5835,5,
  	43,0,0,5835,5836,3,1144,572,0,5836,5837,5,44,0,0,5837,5840,3,638,319,
  	0,5838,5839,5,91,0,0,5839,5841,3,638,319,0,5840,5838,1,0,0,0,5840,5841,
  	1,0,0,0,5841,641,1,0,0,0,5842,5843,5,264,0,0,5843,5844,5,43,0,0,5844,
  	5845,3,1144,572,0,5845,5846,5,44,0,0,5846,5850,3,644,322,0,5847,5849,
  	3,644,322,0,5848,5847,1,0,0,0,5849,5852,1,0,0,0,5850,5848,1,0,0,0,5850,
  	5851,1,0,0,0,5851,5853,1,0,0,0,5852,5850,1,0,0,0,5853,5854,5,265,0,0,
  	5854,643,1,0,0,0,5855,5860,3,1144,572,0,5856,5857,5,30,0,0,5857,5859,
  	3,1144,572,0,5858,5856,1,0,0,0,5859,5862,1,0,0,0,5860,5858,1,0,0,0,5860,
  	5861,1,0,0,0,5861,5863,1,0,0,0,5862,5860,1,0,0,0,5863,5864,5,33,0,0,5864,
  	5865,3,638,319,0,5865,5872,1,0,0,0,5866,5868,5,36,0,0,5867,5869,5,33,
  	0,0,5868,5867,1,0,0,0,5868,5869,1,0,0,0,5869,5870,1,0,0,0,5870,5872,3,
  	638,319,0,5871,5855,1,0,0,0,5871,5866,1,0,0,0,5872,645,1,0,0,0,5873,5874,
  	5,266,0,0,5874,5875,5,43,0,0,5875,5876,3,650,325,0,5876,5877,5,31,0,0,
  	5877,5878,3,1144,572,0,5878,5879,5,31,0,0,5879,5880,3,648,324,0,5880,
  	5881,5,44,0,0,5881,5882,3,652,326,0,5882,647,1,0,0,0,5883,5884,3,1248,
  	624,0,5884,5885,3,764,382,0,5885,5886,3,1144,572,0,5886,5894,1,0,0,0,
  	5887,5888,3,1230,615,0,5888,5889,3,1248,624,0,5889,5894,1,0,0,0,5890,
  	5891,3,1248,624,0,5891,5892,3,1230,615,0,5892,5894,1,0,0,0,5893,5883,
  	1,0,0,0,5893,5887,1,0,0,0,5893,5890,1,0,0,0,5894,649,1,0,0,0,5895,5897,
  	5,99,0,0,5896,5895,1,0,0,0,5896,5897,1,0,0,0,5897,5898,1,0,0,0,5898,5899,
  	3,1248,624,0,5899,5900,5,362,0,0,5900,5901,3,1144,572,0,5901,651,1,0,
  	0,0,5902,5903,5,223,0,0,5903,5904,5,33,0,0,5904,5908,3,1248,624,0,5905,
  	5907,3,638,319,0,5906,5905,1,0,0,0,5907,5910,1,0,0,0,5908,5906,1,0,0,
  	0,5908,5909,1,0,0,0,5909,5911,1,0,0,0,5910,5908,1,0,0,0,5911,5914,5,224,
  	0,0,5912,5913,5,33,0,0,5913,5915,3,1248,624,0,5914,5912,1,0,0,0,5914,
  	5915,1,0,0,0,5915,5921,1,0,0,0,5916,5917,3,1248,624,0,5917,5918,5,33,
  	0,0,5918,5919,3,654,327,0,5919,5921,1,0,0,0,5920,5902,1,0,0,0,5920,5916,
  	1,0,0,0,5921,653,1,0,0,0,5922,5925,5,223,0,0,5923,5924,5,33,0,0,5924,
  	5926,3,1248,624,0,5925,5923,1,0,0,0,5925,5926,1,0,0,0,5926,5930,1,0,0,
  	0,5927,5929,3,638,319,0,5928,5927,1,0,0,0,5929,5932,1,0,0,0,5930,5928,
  	1,0,0,0,5930,5931,1,0,0,0,5931,5933,1,0,0,0,5932,5930,1,0,0,0,5933,5936,
  	5,224,0,0,5934,5935,5,33,0,0,5935,5937,3,1248,624,0,5936,5934,1,0,0,0,
  	5936,5937,1,0,0,0,5937,655,1,0,0,0,5938,5942,5,262,0,0,5939,5941,3,658,
  	329,0,5940,5939,1,0,0,0,5941,5944,1,0,0,0,5942,5940,1,0,0,0,5942,5943,
  	1,0,0,0,5943,5945,1,0,0,0,5944,5942,1,0,0,0,5945,5946,5,263,0,0,5946,
  	657,1,0,0,0,5947,5957,3,660,330,0,5948,5957,3,662,331,0,5949,5957,3,666,
  	333,0,5950,5951,3,1248,624,0,5951,5952,5,33,0,0,5952,5953,1,0,0,0,5953,
  	5954,3,670,335,0,5954,5957,1,0,0,0,5955,5957,3,100,50,0,5956,5947,1,0,
  	0,0,5956,5948,1,0,0,0,5956,5949,1,0,0,0,5956,5950,1,0,0,0,5956,5955,1,
  	0,0,0,5957,659,1,0,0,0,5958,5959,5,90,0,0,5959,5960,5,43,0,0,5960,5961,
  	3,1144,572,0,5961,5962,5,44,0,0,5962,5965,3,658,329,0,5963,5964,5,91,
  	0,0,5964,5966,3,658,329,0,5965,5963,1,0,0,0,5965,5966,1,0,0,0,5966,661,
  	1,0,0,0,5967,5968,5,264,0,0,5968,5969,5,43,0,0,5969,5970,3,1144,572,0,
  	5970,5971,5,44,0,0,5971,5975,3,664,332,0,5972,5974,3,664,332,0,5973,5972,
  	1,0,0,0,5974,5977,1,0,0,0,5975,5973,1,0,0,0,5975,5976,1,0,0,0,5976,5978,
  	1,0,0,0,5977,5975,1,0,0,0,5978,5979,5,265,0,0,5979,663,1,0,0,0,5980,5985,
  	3,1144,572,0,5981,5982,5,30,0,0,5982,5984,3,1144,572,0,5983,5981,1,0,
  	0,0,5984,5987,1,0,0,0,5985,5983,1,0,0,0,5985,5986,1,0,0,0,5986,5988,1,
  	0,0,0,5987,5985,1,0,0,0,5988,5989,5,33,0,0,5989,5990,3,658,329,0,5990,
  	5997,1,0,0,0,5991,5993,5,36,0,0,5992,5994,5,33,0,0,5993,5992,1,0,0,0,
  	5993,5994,1,0,0,0,5994,5995,1,0,0,0,5995,5997,3,658,329,0,5996,5980,1,
  	0,0,0,5996,5991,1,0,0,0,5997,665,1,0,0,0,5998,5999,5,266,0,0,5999,6000,
  	5,43,0,0,6000,6001,3,650,325,0,6001,6002,5,31,0,0,6002,6003,3,1144,572,
  	0,6003,6004,5,31,0,0,6004,6005,3,648,324,0,6005,6006,5,44,0,0,6006,6007,
  	3,668,334,0,6007,667,1,0,0,0,6008,6009,5,223,0,0,6009,6010,5,33,0,0,6010,
  	6014,3,1248,624,0,6011,6013,3,658,329,0,6012,6011,1,0,0,0,6013,6016,1,
  	0,0,0,6014,6012,1,0,0,0,6014,6015,1,0,0,0,6015,6017,1,0,0,0,6016,6014,
  	1,0,0,0,6017,6020,5,224,0,0,6018,6019,5,33,0,0,6019,6021,3,1248,624,0,
  	6020,6018,1,0,0,0,6020,6021,1,0,0,0,6021,6027,1,0,0,0,6022,6023,3,1248,
  	624,0,6023,6024,5,33,0,0,6024,6025,3,670,335,0,6025,6027,1,0,0,0,6026,
  	6008,1,0,0,0,6026,6022,1,0,0,0,6027,669,1,0,0,0,6028,6031,5,223,0,0,6029,
  	6030,5,33,0,0,6030,6032,3,1248,624,0,6031,6029,1,0,0,0,6031,6032,1,0,
  	0,0,6032,6036,1,0,0,0,6033,6035,3,658,329,0,6034,6033,1,0,0,0,6035,6038,
  	1,0,0,0,6036,6034,1,0,0,0,6036,6037,1,0,0,0,6037,6039,1,0,0,0,6038,6036,
  	1,0,0,0,6039,6042,5,224,0,0,6040,6041,5,33,0,0,6041,6043,3,1248,624,0,
  	6042,6040,1,0,0,0,6042,6043,1,0,0,0,6043,671,1,0,0,0,6044,6048,5,262,
  	0,0,6045,6047,3,690,345,0,6046,6045,1,0,0,0,6047,6050,1,0,0,0,6048,6046,
  	1,0,0,0,6048,6049,1,0,0,0,6049,6051,1,0,0,0,6050,6048,1,0,0,0,6051,6052,
  	5,263,0,0,6052,673,1,0,0,0,6053,6054,5,266,0,0,6054,6055,5,43,0,0,6055,
  	6056,3,676,338,0,6056,6057,5,31,0,0,6057,6058,3,1144,572,0,6058,6059,
  	5,31,0,0,6059,6060,3,678,339,0,6060,6061,5,44,0,0,6061,6062,3,690,345,
  	0,6062,675,1,0,0,0,6063,6065,5,99,0,0,6064,6063,1,0,0,0,6064,6065,1,0,
  	0,0,6065,6066,1,0,0,0,6066,6067,3,1248,624,0,6067,6068,5,362,0,0,6068,
  	6069,3,1144,572,0,6069,677,1,0,0,0,6070,6071,3,1248,624,0,6071,6072,3,
  	764,382,0,6072,6073,3,1144,572,0,6073,6081,1,0,0,0,6074,6075,3,1230,615,
  	0,6075,6076,3,1248,624,0,6076,6081,1,0,0,0,6077,6078,3,1248,624,0,6078,
  	6079,3,1230,615,0,6079,6081,1,0,0,0,6080,6070,1,0,0,0,6080,6074,1,0,0,
  	0,6080,6077,1,0,0,0,6081,679,1,0,0,0,6082,6085,3,682,341,0,6083,6085,
  	3,684,342,0,6084,6082,1,0,0,0,6084,6083,1,0,0,0,6085,681,1,0,0,0,6086,
  	6087,5,90,0,0,6087,6088,5,43,0,0,6088,6089,3,1144,572,0,6089,6090,5,44,
  	0,0,6090,6094,3,690,345,0,6091,6092,5,91,0,0,6092,6095,3,690,345,0,6093,
  	6095,4,341,16,0,6094,6091,1,0,0,0,6094,6093,1,0,0,0,6095,683,1,0,0,0,
  	6096,6097,5,264,0,0,6097,6098,5,43,0,0,6098,6099,3,1144,572,0,6099,6101,
  	5,44,0,0,6100,6102,3,686,343,0,6101,6100,1,0,0,0,6102,6103,1,0,0,0,6103,
  	6101,1,0,0,0,6103,6104,1,0,0,0,6104,6105,1,0,0,0,6105,6106,5,265,0,0,
  	6106,685,1,0,0,0,6107,6112,3,1144,572,0,6108,6109,5,30,0,0,6109,6111,
  	3,1144,572,0,6110,6108,1,0,0,0,6111,6114,1,0,0,0,6112,6110,1,0,0,0,6112,
  	6113,1,0,0,0,6113,6115,1,0,0,0,6114,6112,1,0,0,0,6115,6116,5,33,0,0,6116,
  	6117,3,690,345,0,6117,6124,1,0,0,0,6118,6120,5,36,0,0,6119,6121,5,33,
  	0,0,6120,6119,1,0,0,0,6120,6121,1,0,0,0,6121,6122,1,0,0,0,6122,6124,3,
  	690,345,0,6123,6107,1,0,0,0,6123,6118,1,0,0,0,6124,687,1,0,0,0,6125,6126,
  	3,1248,624,0,6126,6127,5,33,0,0,6127,6129,1,0,0,0,6128,6125,1,0,0,0,6128,
  	6129,1,0,0,0,6129,6130,1,0,0,0,6130,6134,5,223,0,0,6131,6132,5,33,0,0,
  	6132,6135,3,1248,624,0,6133,6135,4,344,17,0,6134,6131,1,0,0,0,6134,6133,
  	1,0,0,0,6135,6139,1,0,0,0,6136,6138,3,690,345,0,6137,6136,1,0,0,0,6138,
  	6141,1,0,0,0,6139,6137,1,0,0,0,6139,6140,1,0,0,0,6140,6142,1,0,0,0,6141,
  	6139,1,0,0,0,6142,6146,5,224,0,0,6143,6144,5,33,0,0,6144,6147,3,1248,
  	624,0,6145,6147,4,344,18,0,6146,6143,1,0,0,0,6146,6145,1,0,0,0,6147,689,
  	1,0,0,0,6148,6173,3,88,44,0,6149,6151,3,1240,620,0,6150,6149,1,0,0,0,
  	6151,6154,1,0,0,0,6152,6150,1,0,0,0,6152,6153,1,0,0,0,6153,6167,1,0,0,
  	0,6154,6152,1,0,0,0,6155,6156,5,187,0,0,6156,6161,3,410,205,0,6157,6158,
  	5,30,0,0,6158,6160,3,410,205,0,6159,6157,1,0,0,0,6160,6163,1,0,0,0,6161,
  	6159,1,0,0,0,6161,6162,1,0,0,0,6162,6164,1,0,0,0,6163,6161,1,0,0,0,6164,
  	6165,5,31,0,0,6165,6168,1,0,0,0,6166,6168,3,102,51,0,6167,6155,1,0,0,
  	0,6167,6166,1,0,0,0,6168,6173,1,0,0,0,6169,6173,3,120,60,0,6170,6173,
  	3,672,336,0,6171,6173,3,688,344,0,6172,6148,1,0,0,0,6172,6152,1,0,0,0,
  	6172,6169,1,0,0,0,6172,6170,1,0,0,0,6172,6171,1,0,0,0,6173,691,1,0,0,
  	0,6174,6176,3,1240,620,0,6175,6174,1,0,0,0,6176,6179,1,0,0,0,6177,6175,
  	1,0,0,0,6177,6178,1,0,0,0,6178,6180,1,0,0,0,6179,6177,1,0,0,0,6180,6181,
  	5,268,0,0,6181,6182,3,1248,624,0,6182,6183,5,43,0,0,6183,6184,3,698,349,
  	0,6184,6185,5,44,0,0,6185,6186,5,31,0,0,6186,693,1,0,0,0,6187,6189,3,
  	1240,620,0,6188,6187,1,0,0,0,6189,6192,1,0,0,0,6190,6188,1,0,0,0,6190,
  	6191,1,0,0,0,6191,6193,1,0,0,0,6192,6190,1,0,0,0,6193,6194,5,268,0,0,
  	6194,6195,3,1248,624,0,6195,6196,5,43,0,0,6196,6197,3,700,350,0,6197,
  	6198,5,44,0,0,6198,6199,5,31,0,0,6199,695,1,0,0,0,6200,6201,3,692,346,
  	0,6201,6205,3,702,351,0,6202,6204,3,702,351,0,6203,6202,1,0,0,0,6204,
  	6207,1,0,0,0,6205,6203,1,0,0,0,6205,6206,1,0,0,0,6206,6208,1,0,0,0,6207,
  	6205,1,0,0,0,6208,6209,3,710,355,0,6209,6212,5,269,0,0,6210,6211,5,33,
  	0,0,6211,6213,3,1248,624,0,6212,6210,1,0,0,0,6212,6213,1,0,0,0,6213,6250,
  	1,0,0,0,6214,6215,3,694,347,0,6215,6216,3,710,355,0,6216,6219,5,269,0,
  	0,6217,6218,5,33,0,0,6218,6220,3,1248,624,0,6219,6217,1,0,0,0,6219,6220,
  	1,0,0,0,6220,6250,1,0,0,0,6221,6222,5,46,0,0,6222,6250,3,692,346,0,6223,
  	6224,5,46,0,0,6224,6250,3,694,347,0,6225,6227,3,1240,620,0,6226,6225,
  	1,0,0,0,6227,6230,1,0,0,0,6228,6226,1,0,0,0,6228,6229,1,0,0,0,6229,6231,
  	1,0,0,0,6230,6228,1,0,0,0,6231,6232,5,268,0,0,6232,6233,3,1248,624,0,
  	6233,6234,5,43,0,0,6234,6235,5,261,0,0,6235,6236,5,44,0,0,6236,6240,5,
  	31,0,0,6237,6239,3,702,351,0,6238,6237,1,0,0,0,6239,6242,1,0,0,0,6240,
  	6238,1,0,0,0,6240,6241,1,0,0,0,6241,6243,1,0,0,0,6242,6240,1,0,0,0,6243,
  	6244,3,710,355,0,6244,6247,5,269,0,0,6245,6246,5,33,0,0,6246,6248,3,1248,
  	624,0,6247,6245,1,0,0,0,6247,6248,1,0,0,0,6248,6250,1,0,0,0,6249,6200,
  	1,0,0,0,6249,6214,1,0,0,0,6249,6221,1,0,0,0,6249,6223,1,0,0,0,6249,6228,
  	1,0,0,0,6250,697,1,0,0,0,6251,6252,3,1248,624,0,6252,6253,5,30,0,0,6253,
  	6258,3,1248,624,0,6254,6255,5,30,0,0,6255,6257,3,1248,624,0,6256,6254,
  	1,0,0,0,6257,6260,1,0,0,0,6258,6256,1,0,0,0,6258,6259,1,0,0,0,6259,699,
  	1,0,0,0,6260,6258,1,0,0,0,6261,6262,3,704,352,0,6262,6263,5,30,0,0,6263,
  	6268,3,706,353,0,6264,6265,5,30,0,0,6265,6267,3,706,353,0,6266,6264,1,
  	0,0,0,6267,6270,1,0,0,0,6268,6266,1,0,0,0,6268,6269,1,0,0,0,6269,701,
  	1,0,0,0,6270,6268,1,0,0,0,6271,6272,3,704,352,0,6272,6273,5,31,0,0,6273,
  	6281,1,0,0,0,6274,6275,3,706,353,0,6275,6276,5,31,0,0,6276,6281,1,0,0,
  	0,6277,6278,3,708,354,0,6278,6279,5,31,0,0,6279,6281,1,0,0,0,6280,6271,
  	1,0,0,0,6280,6274,1,0,0,0,6280,6277,1,0,0,0,6281,703,1,0,0,0,6282,6284,
  	3,1240,620,0,6283,6282,1,0,0,0,6284,6287,1,0,0,0,6285,6283,1,0,0,0,6285,
  	6286,1,0,0,0,6286,6297,1,0,0,0,6287,6285,1,0,0,0,6288,6289,5,67,0,0,6289,
  	6298,3,1248,624,0,6290,6291,5,67,0,0,6291,6292,5,120,0,0,6292,6295,3,
  	1248,624,0,6293,6294,5,362,0,0,6294,6296,3,1144,572,0,6295,6293,1,0,0,
  	0,6295,6296,1,0,0,0,6296,6298,1,0,0,0,6297,6288,1,0,0,0,6297,6290,1,0,
  	0,0,6298,705,1,0,0,0,6299,6301,3,1240,620,0,6300,6299,1,0,0,0,6301,6304,
  	1,0,0,0,6302,6300,1,0,0,0,6302,6303,1,0,0,0,6303,6305,1,0,0,0,6304,6302,
  	1,0,0,0,6305,6306,5,66,0,0,6306,6307,3,176,88,0,6307,707,1,0,0,0,6308,
  	6310,3,1240,620,0,6309,6308,1,0,0,0,6310,6313,1,0,0,0,6311,6309,1,0,0,
  	0,6311,6312,1,0,0,0,6312,6314,1,0,0,0,6313,6311,1,0,0,0,6314,6315,5,120,
  	0,0,6315,6316,3,1248,624,0,6316,709,1,0,0,0,6317,6320,3,712,356,0,6318,
  	6320,3,716,358,0,6319,6317,1,0,0,0,6319,6318,1,0,0,0,6320,711,1,0,0,0,
  	6321,6322,5,270,0,0,6322,6326,3,714,357,0,6323,6325,3,714,357,0,6324,
  	6323,1,0,0,0,6325,6328,1,0,0,0,6326,6324,1,0,0,0,6326,6327,1,0,0,0,6327,
  	6329,1,0,0,0,6328,6326,1,0,0,0,6329,6330,5,271,0,0,6330,713,1,0,0,0,6331,
  	6332,3,726,363,0,6332,6333,5,33,0,0,6333,6334,3,734,367,0,6334,6335,5,
  	31,0,0,6335,715,1,0,0,0,6336,6338,3,718,359,0,6337,6336,1,0,0,0,6337,
  	6338,1,0,0,0,6338,6339,1,0,0,0,6339,6340,5,270,0,0,6340,6344,3,722,361,
  	0,6341,6343,3,722,361,0,6342,6341,1,0,0,0,6343,6346,1,0,0,0,6344,6342,
  	1,0,0,0,6344,6345,1,0,0,0,6345,6347,1,0,0,0,6346,6344,1,0,0,0,6347,6348,
  	5,271,0,0,6348,717,1,0,0,0,6349,6350,5,272,0,0,6350,6351,3,1248,624,0,
  	6351,6352,5,362,0,0,6352,6353,3,720,360,0,6353,6354,5,31,0,0,6354,719,
  	1,0,0,0,6355,6365,5,8,0,0,6356,6365,5,9,0,0,6357,6365,5,12,0,0,6358,6365,
  	5,13,0,0,6359,6365,5,10,0,0,6360,6365,5,11,0,0,6361,6365,5,14,0,0,6362,
  	6365,5,15,0,0,6363,6365,5,18,0,0,6364,6355,1,0,0,0,6364,6356,1,0,0,0,
  	6364,6357,1,0,0,0,6364,6358,1,0,0,0,6364,6359,1,0,0,0,6364,6360,1,0,0,
  	0,6364,6361,1,0,0,0,6364,6362,1,0,0,0,6364,6363,1,0,0,0,6365,721,1,0,
  	0,0,6366,6367,3,724,362,0,6367,6368,5,33,0,0,6368,6369,3,736,368,0,6369,
  	6370,5,33,0,0,6370,6371,3,732,366,0,6371,6372,5,31,0,0,6372,723,1,0,0,
  	0,6373,6376,3,726,363,0,6374,6376,3,728,364,0,6375,6373,1,0,0,0,6375,
  	6374,1,0,0,0,6376,725,1,0,0,0,6377,6381,3,736,368,0,6378,6380,3,736,368,
  	0,6379,6378,1,0,0,0,6380,6383,1,0,0,0,6381,6379,1,0,0,0,6381,6382,1,0,
  	0,0,6382,727,1,0,0,0,6383,6381,1,0,0,0,6384,6386,3,736,368,0,6385,6384,
  	1,0,0,0,6386,6389,1,0,0,0,6387,6385,1,0,0,0,6387,6388,1,0,0,0,6388,6390,
  	1,0,0,0,6389,6387,1,0,0,0,6390,6394,3,730,365,0,6391,6393,3,736,368,0,
  	6392,6391,1,0,0,0,6393,6396,1,0,0,0,6394,6392,1,0,0,0,6394,6395,1,0,0,
  	0,6395,729,1,0,0,0,6396,6394,1,0,0,0,6397,6399,5,43,0,0,6398,6400,3,736,
  	368,0,6399,6398,1,0,0,0,6400,6401,1,0,0,0,6401,6399,1,0,0,0,6401,6402,
  	1,0,0,0,6402,6403,1,0,0,0,6403,6404,5,44,0,0,6404,6407,1,0,0,0,6405,6407,
  	3,738,369,0,6406,6397,1,0,0,0,6406,6405,1,0,0,0,6407,731,1,0,0,0,6408,
  	6411,3,734,367,0,6409,6411,5,175,0,0,6410,6408,1,0,0,0,6410,6409,1,0,
  	0,0,6411,733,1,0,0,0,6412,6413,7,18,0,0,6413,735,1,0,0,0,6414,6415,7,
  	19,0,0,6415,737,1,0,0,0,6416,6417,7,20,0,0,6417,739,1,0,0,0,6418,6420,
  	3,1248,624,0,6419,6421,3,296,148,0,6420,6419,1,0,0,0,6420,6421,1,0,0,
  	0,6421,6423,1,0,0,0,6422,6424,3,306,153,0,6423,6422,1,0,0,0,6423,6424,
  	1,0,0,0,6424,6425,1,0,0,0,6425,6430,3,742,371,0,6426,6427,5,30,0,0,6427,
  	6429,3,742,371,0,6428,6426,1,0,0,0,6429,6432,1,0,0,0,6430,6428,1,0,0,
  	0,6430,6431,1,0,0,0,6431,6433,1,0,0,0,6432,6430,1,0,0,0,6433,6434,5,31,
  	0,0,6434,741,1,0,0,0,6435,6437,3,620,310,0,6436,6435,1,0,0,0,6436,6437,
  	1,0,0,0,6437,6438,1,0,0,0,6438,6439,5,43,0,0,6439,6440,3,1224,612,0,6440,
  	6441,5,30,0,0,6441,6446,3,1162,581,0,6442,6443,5,30,0,0,6443,6445,3,1162,
  	581,0,6444,6442,1,0,0,0,6445,6448,1,0,0,0,6446,6444,1,0,0,0,6446,6447,
  	1,0,0,0,6447,6449,1,0,0,0,6448,6446,1,0,0,0,6449,6450,5,44,0,0,6450,743,
  	1,0,0,0,6451,6453,5,273,0,0,6452,6454,3,296,148,0,6453,6452,1,0,0,0,6453,
  	6454,1,0,0,0,6454,6456,1,0,0,0,6455,6457,3,304,152,0,6456,6455,1,0,0,
  	0,6456,6457,1,0,0,0,6457,6458,1,0,0,0,6458,6459,3,746,373,0,6459,6460,
  	5,31,0,0,6460,6469,1,0,0,0,6461,6463,5,362,0,0,6462,6464,3,796,398,0,
  	6463,6462,1,0,0,0,6463,6464,1,0,0,0,6464,6465,1,0,0,0,6465,6466,3,748,
  	374,0,6466,6467,5,31,0,0,6467,6469,1,0,0,0,6468,6451,1,0,0,0,6468,6461,
  	1,0,0,0,6469,745,1,0,0,0,6470,6475,3,752,376,0,6471,6472,5,30,0,0,6472,
  	6474,3,752,376,0,6473,6471,1,0,0,0,6474,6477,1,0,0,0,6475,6473,1,0,0,
  	0,6475,6476,1,0,0,0,6476,747,1,0,0,0,6477,6475,1,0,0,0,6478,6483,3,770,
  	385,0,6479,6480,5,30,0,0,6480,6482,3,770,385,0,6481,6479,1,0,0,0,6482,
  	6485,1,0,0,0,6483,6481,1,0,0,0,6483,6484,1,0,0,0,6484,749,1,0,0,0,6485,
  	6483,1,0,0,0,6486,6487,5,274,0,0,6487,6490,3,1224,612,0,6488,6489,5,362,
  	0,0,6489,6491,3,1224,612,0,6490,6488,1,0,0,0,6491,6492,1,0,0,0,6492,6490,
  	1,0,0,0,6492,6493,1,0,0,0,6493,6494,1,0,0,0,6494,6495,5,31,0,0,6495,751,
  	1,0,0,0,6496,6497,3,1224,612,0,6497,6498,5,362,0,0,6498,6499,3,1162,581,
  	0,6499,753,1,0,0,0,6500,6501,5,272,0,0,6501,6502,3,784,392,0,6502,755,
  	1,0,0,0,6503,6504,3,758,379,0,6504,6505,3,786,393,0,6505,757,1,0,0,0,
  	6506,6507,7,21,0,0,6507,759,1,0,0,0,6508,6509,3,1226,613,0,6509,6510,
  	5,362,0,0,6510,6511,3,794,397,0,6511,6512,3,1162,581,0,6512,6534,1,0,
  	0,0,6513,6514,3,1228,614,0,6514,6515,5,362,0,0,6515,6516,3,350,175,0,
  	6516,6534,1,0,0,0,6517,6518,3,1206,603,0,6518,6519,5,35,0,0,6519,6523,
  	1,0,0,0,6520,6523,3,260,130,0,6521,6523,3,1252,626,0,6522,6517,1,0,0,
  	0,6522,6520,1,0,0,0,6522,6521,1,0,0,0,6522,6523,1,0,0,0,6523,6526,1,0,
  	0,0,6524,6527,3,1248,624,0,6525,6527,3,1246,623,0,6526,6524,1,0,0,0,6526,
  	6525,1,0,0,0,6527,6528,1,0,0,0,6528,6529,3,1210,605,0,6529,6530,5,362,
  	0,0,6530,6531,3,348,174,0,6531,6534,1,0,0,0,6532,6534,3,762,381,0,6533,
  	6508,1,0,0,0,6533,6513,1,0,0,0,6533,6522,1,0,0,0,6533,6532,1,0,0,0,6534,
  	761,1,0,0,0,6535,6536,3,1226,613,0,6536,6537,3,764,382,0,6537,6538,3,
  	1162,581,0,6538,763,1,0,0,0,6539,6540,7,22,0,0,6540,765,1,0,0,0,6541,
  	6542,3,1226,613,0,6542,6544,5,183,0,0,6543,6545,3,794,397,0,6544,6543,
  	1,0,0,0,6544,6545,1,0,0,0,6545,6546,1,0,0,0,6546,6547,3,1162,581,0,6547,
  	767,1,0,0,0,6548,6549,5,273,0,0,6549,6563,3,770,385,0,6550,6551,5,289,
  	0,0,6551,6563,3,1226,613,0,6552,6555,5,290,0,0,6553,6556,3,770,385,0,
  	6554,6556,3,752,376,0,6555,6553,1,0,0,0,6555,6554,1,0,0,0,6556,6563,1,
  	0,0,0,6557,6560,5,291,0,0,6558,6561,3,1226,613,0,6559,6561,3,1224,612,
  	0,6560,6558,1,0,0,0,6560,6559,1,0,0,0,6561,6563,1,0,0,0,6562,6548,1,0,
  	0,0,6562,6550,1,0,0,0,6562,6552,1,0,0,0,6562,6557,1,0,0,0,6563,769,1,
  	0,0,0,6564,6565,3,1226,613,0,6565,6566,5,362,0,0,6566,6567,3,1162,581,
  	0,6567,771,1,0,0,0,6568,6575,3,784,392,0,6569,6571,3,786,393,0,6570,6569,
  	1,0,0,0,6570,6571,1,0,0,0,6571,6572,1,0,0,0,6572,6573,5,91,0,0,6573,6575,
  	3,784,392,0,6574,6568,1,0,0,0,6574,6570,1,0,0,0,6575,773,1,0,0,0,6576,
  	6579,5,223,0,0,6577,6578,5,33,0,0,6578,6580,3,1248,624,0,6579,6577,1,
  	0,0,0,6579,6580,1,0,0,0,6580,6584,1,0,0,0,6581,6583,3,400,200,0,6582,
  	6581,1,0,0,0,6583,6586,1,0,0,0,6584,6582,1,0,0,0,6584,6585,1,0,0,0,6585,
  	6590,1,0,0,0,6586,6584,1,0,0,0,6587,6589,3,784,392,0,6588,6587,1,0,0,
  	0,6589,6592,1,0,0,0,6590,6588,1,0,0,0,6590,6591,1,0,0,0,6591,6593,1,0,
  	0,0,6592,6590,1,0,0,0,6593,6596,5,224,0,0,6594,6595,5,33,0,0,6595,6597,
  	3,1248,624,0,6596,6594,1,0,0,0,6596,6597,1,0,0,0,6597,775,1,0,0,0,6598,
  	6601,5,292,0,0,6599,6600,5,33,0,0,6600,6602,3,1248,624,0,6601,6599,1,
  	0,0,0,6601,6602,1,0,0,0,6602,6606,1,0,0,0,6603,6605,3,400,200,0,6604,
  	6603,1,0,0,0,6605,6608,1,0,0,0,6606,6604,1,0,0,0,6606,6607,1,0,0,0,6607,
  	6612,1,0,0,0,6608,6606,1,0,0,0,6609,6611,3,784,392,0,6610,6609,1,0,0,
  	0,6611,6614,1,0,0,0,6612,6610,1,0,0,0,6612,6613,1,0,0,0,6613,6618,1,0,
  	0,0,6614,6612,1,0,0,0,6615,6619,3,778,389,0,6616,6619,3,780,390,0,6617,
  	6619,3,782,391,0,6618,6615,1,0,0,0,6618,6616,1,0,0,0,6618,6617,1,0,0,
  	0,6619,6622,1,0,0,0,6620,6621,5,33,0,0,6621,6623,3,1248,624,0,6622,6620,
  	1,0,0,0,6622,6623,1,0,0,0,6623,777,1,0,0,0,6624,6625,5,293,0,0,6625,779,
  	1,0,0,0,6626,6627,5,294,0,0,6627,781,1,0,0,0,6628,6629,5,295,0,0,6629,
  	783,1,0,0,0,6630,6639,3,786,393,0,6631,6633,3,1240,620,0,6632,6631,1,
  	0,0,0,6633,6636,1,0,0,0,6634,6632,1,0,0,0,6634,6635,1,0,0,0,6635,6637,
  	1,0,0,0,6636,6634,1,0,0,0,6637,6639,5,31,0,0,6638,6630,1,0,0,0,6638,6634,
  	1,0,0,0,6639,785,1,0,0,0,6640,6641,3,1248,624,0,6641,6642,5,33,0,0,6642,
  	6644,1,0,0,0,6643,6640,1,0,0,0,6643,6644,1,0,0,0,6644,6648,1,0,0,0,6645,
  	6647,3,1240,620,0,6646,6645,1,0,0,0,6647,6650,1,0,0,0,6648,6646,1,0,0,
  	0,6648,6649,1,0,0,0,6649,6651,1,0,0,0,6650,6648,1,0,0,0,6651,6652,3,788,
  	394,0,6652,787,1,0,0,0,6653,6654,3,760,380,0,6654,6655,5,31,0,0,6655,
  	6685,1,0,0,0,6656,6657,3,766,383,0,6657,6658,5,31,0,0,6658,6685,1,0,0,
  	0,6659,6660,3,768,384,0,6660,6661,5,31,0,0,6661,6685,1,0,0,0,6662,6685,
  	3,828,414,0,6663,6685,3,818,409,0,6664,6665,3,1142,571,0,6665,6666,5,
  	31,0,0,6666,6685,1,0,0,0,6667,6685,3,876,438,0,6668,6685,3,816,408,0,
  	6669,6685,3,814,407,0,6670,6685,3,862,431,0,6671,6685,3,808,404,0,6672,
  	6685,3,776,388,0,6673,6685,3,792,396,0,6674,6685,3,774,387,0,6675,6685,
  	3,812,406,0,6676,6685,3,882,441,0,6677,6685,3,928,464,0,6678,6685,3,838,
  	419,0,6679,6685,3,434,217,0,6680,6681,3,1264,632,0,6681,6682,5,31,0,0,
  	6682,6685,1,0,0,0,6683,6685,3,1344,672,0,6684,6653,1,0,0,0,6684,6656,
  	1,0,0,0,6684,6659,1,0,0,0,6684,6662,1,0,0,0,6684,6663,1,0,0,0,6684,6664,
  	1,0,0,0,6684,6667,1,0,0,0,6684,6668,1,0,0,0,6684,6669,1,0,0,0,6684,6670,
  	1,0,0,0,6684,6671,1,0,0,0,6684,6672,1,0,0,0,6684,6673,1,0,0,0,6684,6674,
  	1,0,0,0,6684,6675,1,0,0,0,6684,6676,1,0,0,0,6684,6677,1,0,0,0,6684,6678,
  	1,0,0,0,6684,6679,1,0,0,0,6684,6680,1,0,0,0,6684,6683,1,0,0,0,6685,789,
  	1,0,0,0,6686,6695,3,786,393,0,6687,6689,3,1240,620,0,6688,6687,1,0,0,
  	0,6689,6692,1,0,0,0,6690,6688,1,0,0,0,6690,6691,1,0,0,0,6691,6693,1,0,
  	0,0,6692,6690,1,0,0,0,6693,6695,5,31,0,0,6694,6686,1,0,0,0,6694,6690,
  	1,0,0,0,6695,791,1,0,0,0,6696,6697,3,806,403,0,6697,6698,3,784,392,0,
  	6698,793,1,0,0,0,6699,6708,3,796,398,0,6700,6708,3,798,399,0,6701,6702,
  	5,296,0,0,6702,6703,5,43,0,0,6703,6704,3,1162,581,0,6704,6705,5,44,0,
  	0,6705,6706,3,798,399,0,6706,6708,1,0,0,0,6707,6699,1,0,0,0,6707,6700,
  	1,0,0,0,6707,6701,1,0,0,0,6708,795,1,0,0,0,6709,6716,3,308,154,0,6710,
  	6711,5,213,0,0,6711,6712,5,43,0,0,6712,6713,3,1166,583,0,6713,6714,5,
  	44,0,0,6714,6716,1,0,0,0,6715,6709,1,0,0,0,6715,6710,1,0,0,0,6716,797,
  	1,0,0,0,6717,6718,5,297,0,0,6718,6719,5,43,0,0,6719,6720,3,800,400,0,
  	6720,6721,5,44,0,0,6721,6727,1,0,0,0,6722,6727,5,24,0,0,6723,6727,5,25,
  	0,0,6724,6725,5,297,0,0,6725,6727,3,1256,628,0,6726,6717,1,0,0,0,6726,
  	6722,1,0,0,0,6726,6723,1,0,0,0,6726,6724,1,0,0,0,6727,799,1,0,0,0,6728,
  	6730,6,400,-1,0,6729,6731,3,918,459,0,6730,6729,1,0,0,0,6730,6731,1,0,
  	0,0,6731,6732,1,0,0,0,6732,6735,3,1162,581,0,6733,6734,5,198,0,0,6734,
  	6736,3,1162,581,0,6735,6733,1,0,0,0,6735,6736,1,0,0,0,6736,6747,1,0,0,
  	0,6737,6740,3,482,241,0,6738,6739,5,198,0,0,6739,6741,3,1162,581,0,6740,
  	6738,1,0,0,0,6740,6741,1,0,0,0,6741,6747,1,0,0,0,6742,6743,5,43,0,0,6743,
  	6744,3,800,400,0,6744,6745,5,44,0,0,6745,6747,1,0,0,0,6746,6728,1,0,0,
  	0,6746,6737,1,0,0,0,6746,6742,1,0,0,0,6747,6757,1,0,0,0,6748,6751,10,
  	2,0,0,6749,6752,3,802,401,0,6750,6752,3,804,402,0,6751,6749,1,0,0,0,6751,
  	6750,1,0,0,0,6752,6753,1,0,0,0,6753,6754,3,800,400,3,6754,6756,1,0,0,
  	0,6755,6748,1,0,0,0,6756,6759,1,0,0,0,6757,6755,1,0,0,0,6757,6758,1,0,
  	0,0,6758,801,1,0,0,0,6759,6757,1,0,0,0,6760,6761,5,202,0,0,6761,803,1,
  	0,0,0,6762,6763,5,30,0,0,6763,805,1,0,0,0,6764,6768,3,796,398,0,6765,
  	6768,3,798,399,0,6766,6768,3,922,461,0,6767,6764,1,0,0,0,6767,6765,1,
  	0,0,0,6767,6766,1,0,0,0,6768,807,1,0,0,0,6769,6771,5,298,0,0,6770,6772,
  	3,1162,581,0,6771,6770,1,0,0,0,6771,6772,1,0,0,0,6772,6773,1,0,0,0,6773,
  	6779,5,31,0,0,6774,6775,5,299,0,0,6775,6779,5,31,0,0,6776,6777,5,300,
  	0,0,6777,6779,5,31,0,0,6778,6769,1,0,0,0,6778,6774,1,0,0,0,6778,6776,
  	1,0,0,0,6779,809,1,0,0,0,6780,6781,5,329,0,0,6781,6782,3,786,393,0,6782,
  	811,1,0,0,0,6783,6791,5,301,0,0,6784,6785,5,43,0,0,6785,6786,3,1162,581,
  	0,6786,6787,5,44,0,0,6787,6788,3,784,392,0,6788,6792,1,0,0,0,6789,6790,
  	5,292,0,0,6790,6792,5,31,0,0,6791,6784,1,0,0,0,6791,6789,1,0,0,0,6792,
  	6813,1,0,0,0,6793,6794,5,302,0,0,6794,6797,5,43,0,0,6795,6798,3,1248,
  	624,0,6796,6798,3,1246,623,0,6797,6795,1,0,0,0,6797,6796,1,0,0,0,6798,
  	6806,1,0,0,0,6799,6802,5,30,0,0,6800,6803,3,1248,624,0,6801,6803,3,1246,
  	623,0,6802,6800,1,0,0,0,6802,6801,1,0,0,0,6803,6805,1,0,0,0,6804,6799,
  	1,0,0,0,6805,6808,1,0,0,0,6806,6804,1,0,0,0,6806,6807,1,0,0,0,6807,6809,
  	1,0,0,0,6808,6806,1,0,0,0,6809,6810,5,44,0,0,6810,6811,3,772,386,0,6811,
  	6813,1,0,0,0,6812,6783,1,0,0,0,6812,6793,1,0,0,0,6813,813,1,0,0,0,6814,
  	6817,5,89,0,0,6815,6818,3,1248,624,0,6816,6818,3,1246,623,0,6817,6815,
  	1,0,0,0,6817,6816,1,0,0,0,6818,6819,1,0,0,0,6819,6820,5,31,0,0,6820,6832,
  	1,0,0,0,6821,6823,5,344,0,0,6822,6824,3,794,397,0,6823,6822,1,0,0,0,6823,
  	6824,1,0,0,0,6824,6827,1,0,0,0,6825,6828,3,1248,624,0,6826,6828,3,1246,
  	623,0,6827,6825,1,0,0,0,6827,6826,1,0,0,0,6828,6829,1,0,0,0,6829,6830,
  	5,31,0,0,6830,6832,1,0,0,0,6831,6814,1,0,0,0,6831,6821,1,0,0,0,6832,815,
  	1,0,0,0,6833,6837,5,197,0,0,6834,6838,3,1248,624,0,6835,6838,3,1246,623,
  	0,6836,6838,5,292,0,0,6837,6834,1,0,0,0,6837,6835,1,0,0,0,6837,6836,1,
  	0,0,0,6838,6839,1,0,0,0,6839,6840,5,31,0,0,6840,817,1,0,0,0,6841,6843,
  	3,820,410,0,6842,6841,1,0,0,0,6842,6843,1,0,0,0,6843,6844,1,0,0,0,6844,
  	6845,5,90,0,0,6845,6846,5,43,0,0,6846,6847,3,822,411,0,6847,6848,5,44,
  	0,0,6848,6852,3,784,392,0,6849,6850,5,91,0,0,6850,6853,3,784,392,0,6851,
  	6853,4,409,20,0,6852,6849,1,0,0,0,6852,6851,1,0,0,0,6853,819,1,0,0,0,
  	6854,6855,7,23,0,0,6855,821,1,0,0,0,6856,6861,3,824,412,0,6857,6858,5,
  	354,0,0,6858,6860,3,824,412,0,6859,6857,1,0,0,0,6860,6863,1,0,0,0,6861,
  	6859,1,0,0,0,6861,6862,1,0,0,0,6862,823,1,0,0,0,6863,6861,1,0,0,0,6864,
  	6868,3,1162,581,0,6865,6866,3,826,413,0,6866,6867,3,842,421,0,6867,6869,
  	1,0,0,0,6868,6865,1,0,0,0,6868,6869,1,0,0,0,6869,825,1,0,0,0,6870,6871,
  	5,306,0,0,6871,827,1,0,0,0,6872,6874,3,820,410,0,6873,6872,1,0,0,0,6873,
  	6874,1,0,0,0,6874,6875,1,0,0,0,6875,6876,3,830,415,0,6876,6877,5,43,0,
  	0,6877,6878,3,1162,581,0,6878,6902,5,44,0,0,6879,6883,3,832,416,0,6880,
  	6882,3,832,416,0,6881,6880,1,0,0,0,6882,6885,1,0,0,0,6883,6881,1,0,0,
  	0,6883,6884,1,0,0,0,6884,6903,1,0,0,0,6885,6883,1,0,0,0,6886,6887,5,306,
  	0,0,6887,6891,3,834,417,0,6888,6890,3,834,417,0,6889,6888,1,0,0,0,6890,
  	6893,1,0,0,0,6891,6889,1,0,0,0,6891,6892,1,0,0,0,6892,6903,1,0,0,0,6893,
  	6891,1,0,0,0,6894,6895,5,324,0,0,6895,6899,3,836,418,0,6896,6898,3,836,
  	418,0,6897,6896,1,0,0,0,6898,6901,1,0,0,0,6899,6897,1,0,0,0,6899,6900,
  	1,0,0,0,6900,6903,1,0,0,0,6901,6899,1,0,0,0,6902,6879,1,0,0,0,6902,6886,
  	1,0,0,0,6902,6894,1,0,0,0,6903,6904,1,0,0,0,6904,6905,5,265,0,0,6905,
  	829,1,0,0,0,6906,6907,7,24,0,0,6907,831,1,0,0,0,6908,6913,3,1162,581,
  	0,6909,6910,5,30,0,0,6910,6912,3,1162,581,0,6911,6909,1,0,0,0,6912,6915,
  	1,0,0,0,6913,6911,1,0,0,0,6913,6914,1,0,0,0,6914,6916,1,0,0,0,6915,6913,
  	1,0,0,0,6916,6917,5,33,0,0,6917,6918,3,784,392,0,6918,6925,1,0,0,0,6919,
  	6921,5,36,0,0,6920,6922,5,33,0,0,6921,6920,1,0,0,0,6921,6922,1,0,0,0,
  	6922,6923,1,0,0,0,6923,6925,3,784,392,0,6924,6908,1,0,0,0,6924,6919,1,
  	0,0,0,6925,833,1,0,0,0,6926,6929,3,842,421,0,6927,6928,5,354,0,0,6928,
  	6930,3,1162,581,0,6929,6927,1,0,0,0,6929,6930,1,0,0,0,6930,6931,1,0,0,
  	0,6931,6932,5,33,0,0,6932,6933,3,784,392,0,6933,6940,1,0,0,0,6934,6936,
  	5,36,0,0,6935,6937,5,33,0,0,6936,6935,1,0,0,0,6936,6937,1,0,0,0,6937,
  	6938,1,0,0,0,6938,6940,3,784,392,0,6939,6926,1,0,0,0,6939,6934,1,0,0,
  	0,6940,835,1,0,0,0,6941,6942,3,570,285,0,6942,6943,5,33,0,0,6943,6944,
  	3,784,392,0,6944,6951,1,0,0,0,6945,6947,5,36,0,0,6946,6948,5,33,0,0,6947,
  	6946,1,0,0,0,6947,6948,1,0,0,0,6948,6949,1,0,0,0,6949,6951,3,784,392,
  	0,6950,6941,1,0,0,0,6950,6945,1,0,0,0,6951,837,1,0,0,0,6952,6953,5,309,
  	0,0,6953,6957,3,840,420,0,6954,6956,3,840,420,0,6955,6954,1,0,0,0,6956,
  	6959,1,0,0,0,6957,6955,1,0,0,0,6957,6958,1,0,0,0,6958,6960,1,0,0,0,6959,
  	6957,1,0,0,0,6960,6961,5,265,0,0,6961,839,1,0,0,0,6962,6963,3,1162,581,
  	0,6963,6964,5,33,0,0,6964,6965,3,784,392,0,6965,841,1,0,0,0,6966,6967,
  	5,35,0,0,6967,7005,3,1248,624,0,6968,7005,5,261,0,0,6969,7005,3,1144,
  	572,0,6970,6971,5,310,0,0,6971,6973,3,1248,624,0,6972,6974,3,842,421,
  	0,6973,6972,1,0,0,0,6973,6974,1,0,0,0,6974,7005,1,0,0,0,6975,6976,5,316,
  	0,0,6976,6977,5,85,0,0,6977,6982,3,842,421,0,6978,6979,5,30,0,0,6979,
  	6981,3,842,421,0,6980,6978,1,0,0,0,6981,6984,1,0,0,0,6982,6980,1,0,0,
  	0,6982,6983,1,0,0,0,6983,6985,1,0,0,0,6984,6982,1,0,0,0,6985,6986,5,86,
  	0,0,6986,7005,1,0,0,0,6987,6988,5,316,0,0,6988,6989,5,85,0,0,6989,6990,
  	3,1248,624,0,6990,6991,5,33,0,0,6991,6999,3,842,421,0,6992,6993,5,30,
  	0,0,6993,6994,3,1248,624,0,6994,6995,5,33,0,0,6995,6996,3,842,421,0,6996,
  	6998,1,0,0,0,6997,6992,1,0,0,0,6998,7001,1,0,0,0,6999,6997,1,0,0,0,6999,
  	7000,1,0,0,0,7000,7002,1,0,0,0,7001,6999,1,0,0,0,7002,7003,5,86,0,0,7003,
  	7005,1,0,0,0,7004,6966,1,0,0,0,7004,6968,1,0,0,0,7004,6969,1,0,0,0,7004,
  	6970,1,0,0,0,7004,6975,1,0,0,0,7004,6987,1,0,0,0,7005,843,1,0,0,0,7006,
  	7007,5,316,0,0,7007,7008,5,85,0,0,7008,7013,3,1162,581,0,7009,7010,5,
  	30,0,0,7010,7012,3,1162,581,0,7011,7009,1,0,0,0,7012,7015,1,0,0,0,7013,
  	7011,1,0,0,0,7013,7014,1,0,0,0,7014,7016,1,0,0,0,7015,7013,1,0,0,0,7016,
  	7017,5,86,0,0,7017,7081,1,0,0,0,7018,7019,5,316,0,0,7019,7020,5,85,0,
  	0,7020,7021,3,846,423,0,7021,7022,5,33,0,0,7022,7030,3,1162,581,0,7023,
  	7024,5,30,0,0,7024,7025,3,846,423,0,7025,7026,5,33,0,0,7026,7027,3,1162,
  	581,0,7027,7029,1,0,0,0,7028,7023,1,0,0,0,7029,7032,1,0,0,0,7030,7028,
  	1,0,0,0,7030,7031,1,0,0,0,7031,7033,1,0,0,0,7032,7030,1,0,0,0,7033,7034,
  	5,86,0,0,7034,7081,1,0,0,0,7035,7036,5,316,0,0,7036,7037,5,85,0,0,7037,
  	7038,3,848,424,0,7038,7039,5,33,0,0,7039,7047,3,1162,581,0,7040,7041,
  	5,30,0,0,7041,7042,3,848,424,0,7042,7043,5,33,0,0,7043,7044,3,1162,581,
  	0,7044,7046,1,0,0,0,7045,7040,1,0,0,0,7046,7049,1,0,0,0,7047,7045,1,0,
  	0,0,7047,7048,1,0,0,0,7048,7050,1,0,0,0,7049,7047,1,0,0,0,7050,7051,5,
  	86,0,0,7051,7081,1,0,0,0,7052,7053,5,316,0,0,7053,7054,5,85,0,0,7054,
  	7055,3,1144,572,0,7055,7056,5,85,0,0,7056,7073,3,1162,581,0,7057,7062,
  	5,86,0,0,7058,7059,5,30,0,0,7059,7061,3,1162,581,0,7060,7058,1,0,0,0,
  	7061,7064,1,0,0,0,7062,7060,1,0,0,0,7062,7063,1,0,0,0,7063,7074,1,0,0,
  	0,7064,7062,1,0,0,0,7065,7066,5,30,0,0,7066,7068,3,1162,581,0,7067,7065,
  	1,0,0,0,7068,7071,1,0,0,0,7069,7067,1,0,0,0,7069,7070,1,0,0,0,7070,7072,
  	1,0,0,0,7071,7069,1,0,0,0,7072,7074,5,86,0,0,7073,7057,1,0,0,0,7073,7069,
  	1,0,0,0,7074,7075,1,0,0,0,7075,7076,5,86,0,0,7076,7081,1,0,0,0,7077,7078,
  	5,316,0,0,7078,7079,5,85,0,0,7079,7081,5,86,0,0,7080,7006,1,0,0,0,7080,
  	7018,1,0,0,0,7080,7035,1,0,0,0,7080,7052,1,0,0,0,7080,7077,1,0,0,0,7081,
  	845,1,0,0,0,7082,7085,3,1248,624,0,7083,7085,3,850,425,0,7084,7082,1,
  	0,0,0,7084,7083,1,0,0,0,7085,847,1,0,0,0,7086,7089,3,1144,572,0,7087,
  	7089,3,850,425,0,7088,7086,1,0,0,0,7088,7087,1,0,0,0,7089,849,1,0,0,0,
  	7090,7093,3,282,141,0,7091,7093,5,36,0,0,7092,7090,1,0,0,0,7092,7091,
  	1,0,0,0,7093,851,1,0,0,0,7094,7096,3,854,427,0,7095,7094,1,0,0,0,7095,
  	7096,1,0,0,0,7096,7097,1,0,0,0,7097,7098,3,844,422,0,7098,853,1,0,0,0,
  	7099,7104,3,1262,631,0,7100,7104,3,1254,627,0,7101,7104,3,266,133,0,7102,
  	7104,3,294,147,0,7103,7099,1,0,0,0,7103,7100,1,0,0,0,7103,7101,1,0,0,
  	0,7103,7102,1,0,0,0,7104,855,1,0,0,0,7105,7106,3,852,426,0,7106,857,1,
  	0,0,0,7107,7108,5,316,0,0,7108,7109,5,85,0,0,7109,7114,3,1224,612,0,7110,
  	7111,5,30,0,0,7111,7113,3,1224,612,0,7112,7110,1,0,0,0,7113,7116,1,0,
  	0,0,7114,7112,1,0,0,0,7114,7115,1,0,0,0,7115,7117,1,0,0,0,7116,7114,1,
  	0,0,0,7117,7118,5,86,0,0,7118,859,1,0,0,0,7119,7120,5,316,0,0,7120,7121,
  	5,85,0,0,7121,7126,3,1226,613,0,7122,7123,5,30,0,0,7123,7125,3,1226,613,
  	0,7124,7122,1,0,0,0,7125,7128,1,0,0,0,7126,7124,1,0,0,0,7126,7127,1,0,
  	0,0,7127,7129,1,0,0,0,7128,7126,1,0,0,0,7129,7130,5,86,0,0,7130,861,1,
  	0,0,0,7131,7132,5,311,0,0,7132,7178,3,784,392,0,7133,7134,7,25,0,0,7134,
  	7135,5,43,0,0,7135,7136,3,1162,581,0,7136,7137,5,44,0,0,7137,7138,3,784,
  	392,0,7138,7178,1,0,0,0,7139,7140,5,266,0,0,7140,7142,5,43,0,0,7141,7143,
  	3,864,432,0,7142,7141,1,0,0,0,7142,7143,1,0,0,0,7143,7144,1,0,0,0,7144,
  	7146,5,31,0,0,7145,7147,3,1162,581,0,7146,7145,1,0,0,0,7146,7147,1,0,
  	0,0,7147,7148,1,0,0,0,7148,7150,5,31,0,0,7149,7151,3,868,434,0,7150,7149,
  	1,0,0,0,7150,7151,1,0,0,0,7151,7152,1,0,0,0,7152,7153,5,44,0,0,7153,7178,
  	3,784,392,0,7154,7155,5,313,0,0,7155,7156,3,784,392,0,7156,7157,5,312,
  	0,0,7157,7158,5,43,0,0,7158,7159,3,1162,581,0,7159,7160,5,44,0,0,7160,
  	7161,5,31,0,0,7161,7178,1,0,0,0,7162,7163,5,92,0,0,7163,7164,5,43,0,0,
  	7164,7165,3,1258,629,0,7165,7166,5,110,0,0,7166,7167,3,874,437,0,7167,
  	7172,5,111,0,0,7168,7169,5,110,0,0,7169,7170,3,1248,624,0,7170,7171,5,
  	111,0,0,7171,7173,1,0,0,0,7172,7168,1,0,0,0,7172,7173,1,0,0,0,7173,7174,
  	1,0,0,0,7174,7175,5,44,0,0,7175,7176,3,786,393,0,7176,7178,1,0,0,0,7177,
  	7131,1,0,0,0,7177,7133,1,0,0,0,7177,7139,1,0,0,0,7177,7154,1,0,0,0,7177,
  	7162,1,0,0,0,7178,863,1,0,0,0,7179,7189,3,748,374,0,7180,7185,3,866,433,
  	0,7181,7182,5,30,0,0,7182,7184,3,866,433,0,7183,7181,1,0,0,0,7184,7187,
  	1,0,0,0,7185,7183,1,0,0,0,7185,7186,1,0,0,0,7186,7189,1,0,0,0,7187,7185,
  	1,0,0,0,7188,7179,1,0,0,0,7188,7180,1,0,0,0,7189,865,1,0,0,0,7190,7192,
  	5,150,0,0,7191,7190,1,0,0,0,7191,7192,1,0,0,0,7192,7193,1,0,0,0,7193,
  	7194,3,236,118,0,7194,7195,3,1248,624,0,7195,7196,5,362,0,0,7196,7204,
  	3,1162,581,0,7197,7198,5,30,0,0,7198,7199,3,1248,624,0,7199,7200,5,362,
  	0,0,7200,7201,3,1162,581,0,7201,7203,1,0,0,0,7202,7197,1,0,0,0,7203,7206,
  	1,0,0,0,7204,7202,1,0,0,0,7204,7205,1,0,0,0,7205,867,1,0,0,0,7206,7204,
  	1,0,0,0,7207,7212,3,870,435,0,7208,7209,5,30,0,0,7209,7211,3,870,435,
  	0,7210,7208,1,0,0,0,7211,7214,1,0,0,0,7212,7210,1,0,0,0,7212,7213,1,0,
  	0,0,7213,869,1,0,0,0,7214,7212,1,0,0,0,7215,7219,3,762,381,0,7216,7219,
  	3,1142,571,0,7217,7219,3,1114,557,0,7218,7215,1,0,0,0,7218,7216,1,0,0,
  	0,7218,7217,1,0,0,0,7219,871,1,0,0,0,7220,7221,5,30,0,0,7221,873,1,0,
  	0,0,7222,7224,3,1248,624,0,7223,7222,1,0,0,0,7223,7224,1,0,0,0,7224,7231,
  	1,0,0,0,7225,7227,3,872,436,0,7226,7228,3,1248,624,0,7227,7226,1,0,0,
  	0,7227,7228,1,0,0,0,7228,7230,1,0,0,0,7229,7225,1,0,0,0,7230,7233,1,0,
  	0,0,7231,7229,1,0,0,0,7231,7232,1,0,0,0,7232,875,1,0,0,0,7233,7231,1,
  	0,0,0,7234,7235,3,1114,557,0,7235,7236,5,31,0,0,7236,7245,1,0,0,0,7237,
  	7238,5,151,0,0,7238,7239,5,316,0,0,7239,7240,5,43,0,0,7240,7241,3,1114,
  	557,0,7241,7242,5,44,0,0,7242,7243,5,31,0,0,7243,7245,1,0,0,0,7244,7234,
  	1,0,0,0,7244,7237,1,0,0,0,7245,877,1,0,0,0,7246,7249,3,424,212,0,7247,
  	7249,3,880,440,0,7248,7246,1,0,0,0,7248,7247,1,0,0,0,7249,879,1,0,0,0,
  	7250,7251,3,1248,624,0,7251,7252,5,33,0,0,7252,7254,1,0,0,0,7253,7250,
  	1,0,0,0,7253,7254,1,0,0,0,7254,7255,1,0,0,0,7255,7256,3,894,447,0,7256,
  	881,1,0,0,0,7257,7261,3,426,213,0,7258,7261,3,884,442,0,7259,7261,3,628,
  	314,0,7260,7257,1,0,0,0,7260,7258,1,0,0,0,7260,7259,1,0,0,0,7261,883,
  	1,0,0,0,7262,7265,3,886,443,0,7263,7265,3,894,447,0,7264,7262,1,0,0,0,
  	7264,7263,1,0,0,0,7265,885,1,0,0,0,7266,7270,3,888,444,0,7267,7270,3,
  	890,445,0,7268,7270,3,892,446,0,7269,7266,1,0,0,0,7269,7267,1,0,0,0,7269,
  	7268,1,0,0,0,7270,887,1,0,0,0,7271,7272,5,191,0,0,7272,7273,5,43,0,0,
  	7273,7274,3,1162,581,0,7274,7275,5,44,0,0,7275,7276,3,772,386,0,7276,
  	889,1,0,0,0,7277,7278,5,193,0,0,7278,7279,5,43,0,0,7279,7280,3,1162,581,
  	0,7280,7281,5,44,0,0,7281,7282,3,772,386,0,7282,891,1,0,0,0,7283,7284,
  	5,194,0,0,7284,7285,5,43,0,0,7285,7286,3,1162,581,0,7286,7287,5,44,0,
  	0,7287,7288,3,784,392,0,7288,893,1,0,0,0,7289,7293,3,896,448,0,7290,7293,
  	3,898,449,0,7291,7293,3,900,450,0,7292,7289,1,0,0,0,7292,7290,1,0,0,0,
  	7292,7291,1,0,0,0,7293,895,1,0,0,0,7294,7295,5,191,0,0,7295,7296,7,26,
  	0,0,7296,7297,5,43,0,0,7297,7298,3,1162,581,0,7298,7299,5,44,0,0,7299,
  	7300,3,772,386,0,7300,7307,1,0,0,0,7301,7302,5,191,0,0,7302,7303,5,329,
  	0,0,7303,7304,3,1162,581,0,7304,7305,3,772,386,0,7305,7307,1,0,0,0,7306,
  	7294,1,0,0,0,7306,7301,1,0,0,0,7307,897,1,0,0,0,7308,7309,5,193,0,0,7309,
  	7310,7,26,0,0,7310,7311,5,43,0,0,7311,7312,3,1162,581,0,7312,7313,5,44,
  	0,0,7313,7314,3,772,386,0,7314,7323,1,0,0,0,7315,7316,5,193,0,0,7316,
  	7317,5,329,0,0,7317,7318,5,43,0,0,7318,7319,3,1162,581,0,7319,7320,5,
  	44,0,0,7320,7321,3,772,386,0,7321,7323,1,0,0,0,7322,7308,1,0,0,0,7322,
  	7315,1,0,0,0,7323,899,1,0,0,0,7324,7325,5,194,0,0,7325,7326,7,26,0,0,
  	7326,7327,5,43,0,0,7327,7328,3,1162,581,0,7328,7329,5,44,0,0,7329,7330,
  	3,784,392,0,7330,7339,1,0,0,0,7331,7332,5,194,0,0,7332,7333,5,329,0,0,
  	7333,7334,5,43,0,0,7334,7335,3,1162,581,0,7335,7336,5,44,0,0,7336,7337,
  	3,784,392,0,7337,7339,1,0,0,0,7338,7324,1,0,0,0,7338,7331,1,0,0,0,7339,
  	901,1,0,0,0,7340,7342,5,36,0,0,7341,7340,1,0,0,0,7341,7342,1,0,0,0,7342,
  	7343,1,0,0,0,7343,7345,5,70,0,0,7344,7346,3,1248,624,0,7345,7344,1,0,
  	0,0,7345,7346,1,0,0,0,7346,7347,1,0,0,0,7347,7348,3,904,452,0,7348,7352,
  	5,31,0,0,7349,7351,3,906,453,0,7350,7349,1,0,0,0,7351,7354,1,0,0,0,7352,
  	7350,1,0,0,0,7352,7353,1,0,0,0,7353,7355,1,0,0,0,7354,7352,1,0,0,0,7355,
  	7358,5,317,0,0,7356,7357,5,33,0,0,7357,7359,3,1248,624,0,7358,7356,1,
  	0,0,0,7358,7359,1,0,0,0,7359,7373,1,0,0,0,7360,7361,5,267,0,0,7361,7363,
  	5,70,0,0,7362,7364,3,1248,624,0,7363,7362,1,0,0,0,7363,7364,1,0,0,0,7364,
  	7365,1,0,0,0,7365,7366,3,904,452,0,7366,7367,5,31,0,0,7367,7370,5,317,
  	0,0,7368,7369,5,33,0,0,7369,7371,3,1248,624,0,7370,7368,1,0,0,0,7370,
  	7371,1,0,0,0,7371,7373,1,0,0,0,7372,7341,1,0,0,0,7372,7360,1,0,0,0,7373,
  	903,1,0,0,0,7374,7375,5,297,0,0,7375,7382,3,1248,624,0,7376,7377,5,297,
  	0,0,7377,7378,5,43,0,0,7378,7379,3,800,400,0,7379,7380,5,44,0,0,7380,
  	7382,1,0,0,0,7381,7374,1,0,0,0,7381,7376,1,0,0,0,7382,905,1,0,0,0,7383,
  	7384,5,36,0,0,7384,7385,3,908,454,0,7385,7386,5,31,0,0,7386,7399,1,0,
  	0,0,7387,7388,3,910,455,0,7388,7389,3,912,456,0,7389,7390,5,31,0,0,7390,
  	7399,1,0,0,0,7391,7393,3,1240,620,0,7392,7391,1,0,0,0,7393,7396,1,0,0,
  	0,7394,7392,1,0,0,0,7394,7395,1,0,0,0,7395,7397,1,0,0,0,7396,7394,1,0,
  	0,0,7397,7399,3,444,222,0,7398,7383,1,0,0,0,7398,7387,1,0,0,0,7398,7394,
  	1,0,0,0,7399,907,1,0,0,0,7400,7401,5,66,0,0,7401,7410,3,916,458,0,7402,
  	7403,5,67,0,0,7403,7410,3,916,458,0,7404,7405,5,66,0,0,7405,7406,3,916,
  	458,0,7406,7407,5,67,0,0,7407,7408,3,916,458,0,7408,7410,1,0,0,0,7409,
  	7400,1,0,0,0,7409,7402,1,0,0,0,7409,7404,1,0,0,0,7410,909,1,0,0,0,7411,
  	7413,5,66,0,0,7412,7414,3,916,458,0,7413,7412,1,0,0,0,7413,7414,1,0,0,
  	0,7414,7429,1,0,0,0,7415,7417,5,67,0,0,7416,7418,3,916,458,0,7417,7416,
  	1,0,0,0,7417,7418,1,0,0,0,7418,7429,1,0,0,0,7419,7421,5,66,0,0,7420,7422,
  	3,916,458,0,7421,7420,1,0,0,0,7421,7422,1,0,0,0,7422,7423,1,0,0,0,7423,
  	7425,5,67,0,0,7424,7426,3,916,458,0,7425,7424,1,0,0,0,7425,7426,1,0,0,
  	0,7426,7429,1,0,0,0,7427,7429,5,68,0,0,7428,7411,1,0,0,0,7428,7415,1,
  	0,0,0,7428,7419,1,0,0,0,7428,7427,1,0,0,0,7429,911,1,0,0,0,7430,7435,
  	3,914,457,0,7431,7432,5,30,0,0,7432,7434,3,914,457,0,7433,7431,1,0,0,
  	0,7434,7437,1,0,0,0,7435,7433,1,0,0,0,7435,7436,1,0,0,0,7436,913,1,0,
  	0,0,7437,7435,1,0,0,0,7438,7441,3,1248,624,0,7439,7440,5,362,0,0,7440,
  	7442,3,1162,581,0,7441,7439,1,0,0,0,7441,7442,1,0,0,0,7442,915,1,0,0,
  	0,7443,7445,3,918,459,0,7444,7446,3,796,398,0,7445,7444,1,0,0,0,7445,
  	7446,1,0,0,0,7446,7449,1,0,0,0,7447,7449,3,796,398,0,7448,7443,1,0,0,
  	0,7448,7447,1,0,0,0,7449,917,1,0,0,0,7450,7451,7,27,0,0,7451,919,1,0,
  	0,0,7452,7453,3,926,463,0,7453,7455,5,183,0,0,7454,7456,3,922,461,0,7455,
  	7454,1,0,0,0,7455,7456,1,0,0,0,7456,7457,1,0,0,0,7457,7458,3,1162,581,
  	0,7458,7465,1,0,0,0,7459,7460,3,922,461,0,7460,7461,3,926,463,0,7461,
  	7462,5,183,0,0,7462,7463,3,1162,581,0,7463,7465,1,0,0,0,7464,7452,1,0,
  	0,0,7464,7459,1,0,0,0,7465,921,1,0,0,0,7466,7467,5,210,0,0,7467,7477,
  	5,18,0,0,7468,7477,5,16,0,0,7469,7470,5,210,0,0,7470,7477,3,1248,624,
  	0,7471,7472,5,210,0,0,7472,7473,5,43,0,0,7473,7474,3,1162,581,0,7474,
  	7475,5,44,0,0,7475,7477,1,0,0,0,7476,7466,1,0,0,0,7476,7468,1,0,0,0,7476,
  	7469,1,0,0,0,7476,7471,1,0,0,0,7477,923,1,0,0,0,7478,7480,3,1196,598,
  	0,7479,7478,1,0,0,0,7479,7480,1,0,0,0,7480,7481,1,0,0,0,7481,7495,3,1248,
  	624,0,7482,7483,5,110,0,0,7483,7484,3,1144,572,0,7484,7485,5,111,0,0,
  	7485,7487,1,0,0,0,7486,7482,1,0,0,0,7487,7490,1,0,0,0,7488,7486,1,0,0,
  	0,7488,7489,1,0,0,0,7489,7491,1,0,0,0,7490,7488,1,0,0,0,7491,7492,5,35,
  	0,0,7492,7494,3,1248,624,0,7493,7488,1,0,0,0,7494,7497,1,0,0,0,7495,7493,
  	1,0,0,0,7495,7496,1,0,0,0,7496,925,1,0,0,0,7497,7495,1,0,0,0,7498,7499,
  	3,924,462,0,7499,7500,3,1210,605,0,7500,927,1,0,0,0,7501,7502,5,318,0,
  	0,7502,7504,5,43,0,0,7503,7505,3,1248,624,0,7504,7503,1,0,0,0,7504,7505,
  	1,0,0,0,7505,7506,1,0,0,0,7506,7507,5,44,0,0,7507,7511,3,930,465,0,7508,
  	7510,3,930,465,0,7509,7508,1,0,0,0,7510,7513,1,0,0,0,7511,7509,1,0,0,
  	0,7511,7512,1,0,0,0,7512,7514,1,0,0,0,7513,7511,1,0,0,0,7514,7515,5,205,
  	0,0,7515,929,1,0,0,0,7516,7518,3,364,182,0,7517,7516,1,0,0,0,7517,7518,
  	1,0,0,0,7518,7519,1,0,0,0,7519,7524,3,1248,624,0,7520,7521,5,43,0,0,7521,
  	7522,3,390,195,0,7522,7523,5,44,0,0,7523,7525,1,0,0,0,7524,7520,1,0,0,
  	0,7524,7525,1,0,0,0,7525,7526,1,0,0,0,7526,7527,5,33,0,0,7527,7532,3,
  	932,466,0,7528,7529,5,356,0,0,7529,7531,3,932,466,0,7530,7528,1,0,0,0,
  	7531,7534,1,0,0,0,7532,7530,1,0,0,0,7532,7533,1,0,0,0,7533,7535,1,0,0,
  	0,7534,7532,1,0,0,0,7535,7536,5,31,0,0,7536,931,1,0,0,0,7537,7543,3,934,
  	467,0,7538,7539,5,93,0,0,7539,7541,3,1162,581,0,7540,7542,3,936,468,0,
  	7541,7540,1,0,0,0,7541,7542,1,0,0,0,7542,7544,1,0,0,0,7543,7538,1,0,0,
  	0,7543,7544,1,0,0,0,7544,933,1,0,0,0,7545,7549,3,938,469,0,7546,7548,
  	3,938,469,0,7547,7546,1,0,0,0,7548,7551,1,0,0,0,7549,7547,1,0,0,0,7549,
  	7550,1,0,0,0,7550,7569,1,0,0,0,7551,7549,1,0,0,0,7552,7553,5,80,0,0,7553,
  	7558,5,293,0,0,7554,7555,5,43,0,0,7555,7556,3,1162,581,0,7556,7557,5,
  	44,0,0,7557,7559,1,0,0,0,7558,7554,1,0,0,0,7558,7559,1,0,0,0,7559,7560,
  	1,0,0,0,7560,7561,3,940,470,0,7561,7565,3,940,470,0,7562,7564,3,940,470,
  	0,7563,7562,1,0,0,0,7564,7567,1,0,0,0,7565,7563,1,0,0,0,7565,7566,1,0,
  	0,0,7566,7569,1,0,0,0,7567,7565,1,0,0,0,7568,7545,1,0,0,0,7568,7552,1,
  	0,0,0,7569,935,1,0,0,0,7570,7574,5,85,0,0,7571,7573,3,202,101,0,7572,
  	7571,1,0,0,0,7573,7576,1,0,0,0,7574,7572,1,0,0,0,7574,7575,1,0,0,0,7575,
  	7580,1,0,0,0,7576,7574,1,0,0,0,7577,7579,3,784,392,0,7578,7577,1,0,0,
  	0,7579,7582,1,0,0,0,7580,7578,1,0,0,0,7580,7581,1,0,0,0,7581,7583,1,0,
  	0,0,7582,7580,1,0,0,0,7583,7584,5,86,0,0,7584,937,1,0,0,0,7585,7591,3,
  	940,470,0,7586,7591,3,936,468,0,7587,7591,3,942,471,0,7588,7591,3,944,
  	472,0,7589,7591,3,946,473,0,7590,7585,1,0,0,0,7590,7586,1,0,0,0,7590,
  	7587,1,0,0,0,7590,7588,1,0,0,0,7590,7589,1,0,0,0,7591,939,1,0,0,0,7592,
  	7597,3,1248,624,0,7593,7594,5,43,0,0,7594,7595,3,1118,559,0,7595,7596,
  	5,44,0,0,7596,7598,1,0,0,0,7597,7593,1,0,0,0,7597,7598,1,0,0,0,7598,941,
  	1,0,0,0,7599,7600,5,90,0,0,7600,7601,5,43,0,0,7601,7602,3,1162,581,0,
  	7602,7603,5,44,0,0,7603,7606,3,940,470,0,7604,7605,5,91,0,0,7605,7607,
  	3,940,470,0,7606,7604,1,0,0,0,7606,7607,1,0,0,0,7607,943,1,0,0,0,7608,
  	7609,5,296,0,0,7609,7610,5,43,0,0,7610,7611,3,1162,581,0,7611,7612,5,
  	44,0,0,7612,7613,3,940,470,0,7613,945,1,0,0,0,7614,7615,5,264,0,0,7615,
  	7616,5,43,0,0,7616,7617,3,1162,581,0,7617,7618,5,44,0,0,7618,7622,3,948,
  	474,0,7619,7621,3,948,474,0,7620,7619,1,0,0,0,7621,7624,1,0,0,0,7622,
  	7620,1,0,0,0,7622,7623,1,0,0,0,7623,7625,1,0,0,0,7624,7622,1,0,0,0,7625,
  	7626,5,265,0,0,7626,947,1,0,0,0,7627,7632,3,1162,581,0,7628,7629,5,30,
  	0,0,7629,7631,3,1162,581,0,7630,7628,1,0,0,0,7631,7634,1,0,0,0,7632,7630,
  	1,0,0,0,7632,7633,1,0,0,0,7633,7635,1,0,0,0,7634,7632,1,0,0,0,7635,7636,
  	5,33,0,0,7636,7637,3,940,470,0,7637,7644,1,0,0,0,7638,7640,5,36,0,0,7639,
  	7641,5,33,0,0,7640,7639,1,0,0,0,7640,7641,1,0,0,0,7641,7642,1,0,0,0,7642,
  	7644,3,940,470,0,7643,7627,1,0,0,0,7643,7638,1,0,0,0,7644,949,1,0,0,0,
  	7645,7649,5,335,0,0,7646,7648,3,952,476,0,7647,7646,1,0,0,0,7648,7651,
  	1,0,0,0,7649,7647,1,0,0,0,7649,7650,1,0,0,0,7650,7652,1,0,0,0,7651,7649,
  	1,0,0,0,7652,7653,5,336,0,0,7653,951,1,0,0,0,7654,7660,3,190,95,0,7655,
  	7660,3,954,477,0,7656,7660,3,956,478,0,7657,7660,3,958,479,0,7658,7660,
  	3,1020,510,0,7659,7654,1,0,0,0,7659,7655,1,0,0,0,7659,7656,1,0,0,0,7659,
  	7657,1,0,0,0,7659,7658,1,0,0,0,7660,953,1,0,0,0,7661,7662,5,337,0,0,7662,
  	7663,3,968,484,0,7663,7664,5,31,0,0,7664,7670,1,0,0,0,7665,7666,5,338,
  	0,0,7666,7667,3,968,484,0,7667,7668,5,31,0,0,7668,7670,1,0,0,0,7669,7661,
  	1,0,0,0,7669,7665,1,0,0,0,7670,955,1,0,0,0,7671,7672,5,339,0,0,7672,7673,
  	3,968,484,0,7673,7674,5,31,0,0,7674,7680,1,0,0,0,7675,7676,5,340,0,0,
  	7676,7677,3,968,484,0,7677,7678,5,31,0,0,7678,7680,1,0,0,0,7679,7671,
  	1,0,0,0,7679,7675,1,0,0,0,7680,957,1,0,0,0,7681,7682,3,960,480,0,7682,
  	7683,5,31,0,0,7683,7691,1,0,0,0,7684,7685,3,1012,506,0,7685,7686,5,31,
  	0,0,7686,7691,1,0,0,0,7687,7688,3,1018,509,0,7688,7689,5,31,0,0,7689,
  	7691,1,0,0,0,7690,7681,1,0,0,0,7690,7684,1,0,0,0,7690,7687,1,0,0,0,7691,
  	959,1,0,0,0,7692,7693,3,962,481,0,7693,7694,5,362,0,0,7694,7695,3,974,
  	487,0,7695,7701,1,0,0,0,7696,7697,3,964,482,0,7697,7698,5,362,0,0,7698,
  	7699,3,974,487,0,7699,7701,1,0,0,0,7700,7692,1,0,0,0,7700,7696,1,0,0,
  	0,7701,961,1,0,0,0,7702,7703,5,43,0,0,7703,7705,3,970,485,0,7704,7706,
  	7,28,0,0,7705,7704,1,0,0,0,7705,7706,1,0,0,0,7706,7707,1,0,0,0,7707,7708,
  	5,229,0,0,7708,7709,3,972,486,0,7709,7710,5,44,0,0,7710,963,1,0,0,0,7711,
  	7712,5,43,0,0,7712,7714,3,966,483,0,7713,7715,7,28,0,0,7714,7713,1,0,
  	0,0,7714,7715,1,0,0,0,7715,7716,1,0,0,0,7716,7717,5,353,0,0,7717,7718,
  	3,968,484,0,7718,7719,5,44,0,0,7719,965,1,0,0,0,7720,7725,3,970,485,0,
  	7721,7722,5,30,0,0,7722,7724,3,970,485,0,7723,7721,1,0,0,0,7724,7727,
  	1,0,0,0,7725,7723,1,0,0,0,7725,7726,1,0,0,0,7726,967,1,0,0,0,7727,7725,
  	1,0,0,0,7728,7733,3,972,486,0,7729,7730,5,30,0,0,7730,7732,3,972,486,
  	0,7731,7729,1,0,0,0,7732,7735,1,0,0,0,7733,7731,1,0,0,0,7733,7734,1,0,
  	0,0,7734,969,1,0,0,0,7735,7733,1,0,0,0,7736,7742,3,1248,624,0,7737,7738,
  	3,1250,625,0,7738,7739,5,35,0,0,7739,7740,3,1248,624,0,7740,7742,1,0,
  	0,0,7741,7736,1,0,0,0,7741,7737,1,0,0,0,7742,7747,1,0,0,0,7743,7744,5,
  	110,0,0,7744,7745,3,1154,577,0,7745,7746,5,111,0,0,7746,7748,1,0,0,0,
  	7747,7743,1,0,0,0,7747,7748,1,0,0,0,7748,971,1,0,0,0,7749,7755,3,1248,
  	624,0,7750,7751,3,1250,625,0,7751,7752,5,35,0,0,7752,7753,3,1248,624,
  	0,7753,7755,1,0,0,0,7754,7749,1,0,0,0,7754,7750,1,0,0,0,7755,7760,1,0,
  	0,0,7756,7757,5,110,0,0,7757,7758,3,1154,577,0,7758,7759,5,111,0,0,7759,
  	7761,1,0,0,0,7760,7756,1,0,0,0,7760,7761,1,0,0,0,7761,973,1,0,0,0,7762,
  	7768,3,976,488,0,7763,7764,5,43,0,0,7764,7765,3,976,488,0,7765,7766,5,
  	44,0,0,7766,7768,1,0,0,0,7767,7762,1,0,0,0,7767,7763,1,0,0,0,7768,975,
  	1,0,0,0,7769,7817,3,978,489,0,7770,7771,3,980,490,0,7771,7772,5,30,0,
  	0,7772,7773,3,982,491,0,7773,7817,1,0,0,0,7774,7775,3,980,490,0,7775,
  	7776,5,30,0,0,7776,7777,3,982,491,0,7777,7778,5,30,0,0,7778,7779,3,984,
  	492,0,7779,7817,1,0,0,0,7780,7781,3,986,493,0,7781,7782,5,30,0,0,7782,
  	7783,3,988,494,0,7783,7784,5,30,0,0,7784,7785,3,990,495,0,7785,7786,5,
  	30,0,0,7786,7787,3,992,496,0,7787,7788,5,30,0,0,7788,7789,3,994,497,0,
  	7789,7790,5,30,0,0,7790,7791,3,996,498,0,7791,7817,1,0,0,0,7792,7793,
  	3,986,493,0,7793,7794,5,30,0,0,7794,7795,3,988,494,0,7795,7796,5,30,0,
  	0,7796,7797,3,990,495,0,7797,7798,5,30,0,0,7798,7799,3,992,496,0,7799,
  	7800,5,30,0,0,7800,7801,3,994,497,0,7801,7802,5,30,0,0,7802,7803,3,996,
  	498,0,7803,7804,5,30,0,0,7804,7805,3,998,499,0,7805,7806,5,30,0,0,7806,
  	7807,3,1000,500,0,7807,7808,5,30,0,0,7808,7809,3,1002,501,0,7809,7810,
  	5,30,0,0,7810,7811,3,1004,502,0,7811,7812,5,30,0,0,7812,7813,3,1006,503,
  	0,7813,7814,5,30,0,0,7814,7815,3,1008,504,0,7815,7817,1,0,0,0,7816,7769,
  	1,0,0,0,7816,7770,1,0,0,0,7816,7774,1,0,0,0,7816,7780,1,0,0,0,7816,7792,
  	1,0,0,0,7817,977,1,0,0,0,7818,7819,3,1010,505,0,7819,979,1,0,0,0,7820,
  	7821,3,1010,505,0,7821,981,1,0,0,0,7822,7823,3,1010,505,0,7823,983,1,
  	0,0,0,7824,7825,3,1010,505,0,7825,985,1,0,0,0,7826,7827,3,1010,505,0,
  	7827,987,1,0,0,0,7828,7829,3,1010,505,0,7829,989,1,0,0,0,7830,7831,3,
  	1010,505,0,7831,991,1,0,0,0,7832,7833,3,1010,505,0,7833,993,1,0,0,0,7834,
  	7835,3,1010,505,0,7835,995,1,0,0,0,7836,7837,3,1010,505,0,7837,997,1,
  	0,0,0,7838,7839,3,1010,505,0,7839,999,1,0,0,0,7840,7841,3,1010,505,0,
  	7841,1001,1,0,0,0,7842,7843,3,1010,505,0,7843,1003,1,0,0,0,7844,7845,
  	3,1010,505,0,7845,1005,1,0,0,0,7846,7847,3,1010,505,0,7847,1007,1,0,0,
  	0,7848,7849,3,1010,505,0,7849,1009,1,0,0,0,7850,7851,3,1148,574,0,7851,
  	1011,1,0,0,0,7852,7853,3,1014,507,0,7853,7854,5,362,0,0,7854,7855,3,974,
  	487,0,7855,7861,1,0,0,0,7856,7857,3,1016,508,0,7857,7858,5,362,0,0,7858,
  	7859,3,974,487,0,7859,7861,1,0,0,0,7860,7852,1,0,0,0,7860,7856,1,0,0,
  	0,7861,1013,1,0,0,0,7862,7864,5,43,0,0,7863,7865,3,918,459,0,7864,7863,
  	1,0,0,0,7864,7865,1,0,0,0,7865,7866,1,0,0,0,7866,7867,3,970,485,0,7867,
  	7868,5,229,0,0,7868,7869,5,43,0,0,7869,7870,3,972,486,0,7870,7871,3,1178,
  	589,0,7871,7872,3,1162,581,0,7872,7873,5,44,0,0,7873,7874,5,44,0,0,7874,
  	1015,1,0,0,0,7875,7877,5,43,0,0,7876,7878,3,918,459,0,7877,7876,1,0,0,
  	0,7877,7878,1,0,0,0,7878,7879,1,0,0,0,7879,7880,3,966,483,0,7880,7881,
  	5,353,0,0,7881,7882,5,43,0,0,7882,7883,3,968,484,0,7883,7884,3,1178,589,
  	0,7884,7885,3,1162,581,0,7885,7886,5,44,0,0,7886,7887,5,44,0,0,7887,1017,
  	1,0,0,0,7888,7889,5,90,0,0,7889,7890,5,43,0,0,7890,7891,3,1168,584,0,
  	7891,7892,5,44,0,0,7892,7893,3,960,480,0,7893,7903,1,0,0,0,7894,7895,
  	5,90,0,0,7895,7896,5,43,0,0,7896,7897,3,1168,584,0,7897,7898,5,44,0,0,
  	7898,7899,3,1012,506,0,7899,7903,1,0,0,0,7900,7901,5,341,0,0,7901,7903,
  	3,960,480,0,7902,7888,1,0,0,0,7902,7894,1,0,0,0,7902,7900,1,0,0,0,7903,
  	1019,1,0,0,0,7904,7917,3,1022,511,0,7905,7917,3,1024,512,0,7906,7917,
  	3,1026,513,0,7907,7917,3,1028,514,0,7908,7917,3,1030,515,0,7909,7917,
  	3,1032,516,0,7910,7917,3,1034,517,0,7911,7917,3,1036,518,0,7912,7917,
  	3,1038,519,0,7913,7917,3,1040,520,0,7914,7917,3,1042,521,0,7915,7917,
  	3,1044,522,0,7916,7904,1,0,0,0,7916,7905,1,0,0,0,7916,7906,1,0,0,0,7916,
  	7907,1,0,0,0,7916,7908,1,0,0,0,7916,7909,1,0,0,0,7916,7910,1,0,0,0,7916,
  	7911,1,0,0,0,7916,7912,1,0,0,0,7916,7913,1,0,0,0,7916,7914,1,0,0,0,7916,
  	7915,1,0,0,0,7917,1021,1,0,0,0,7918,7919,5,166,0,0,7919,7920,5,368,0,
  	0,7920,7921,5,43,0,0,7921,7922,3,1068,534,0,7922,7923,5,30,0,0,7923,7924,
  	3,1056,528,0,7924,7925,5,30,0,0,7925,7930,3,1066,533,0,7926,7928,5,30,
  	0,0,7927,7929,3,1054,527,0,7928,7927,1,0,0,0,7928,7929,1,0,0,0,7929,7931,
  	1,0,0,0,7930,7926,1,0,0,0,7930,7931,1,0,0,0,7931,7932,1,0,0,0,7932,7933,
  	5,44,0,0,7933,7934,5,31,0,0,7934,1023,1,0,0,0,7935,7936,5,166,0,0,7936,
  	7937,5,368,0,0,7937,7938,5,43,0,0,7938,7939,3,1056,528,0,7939,7940,5,
  	30,0,0,7940,7941,3,1068,534,0,7941,7942,5,30,0,0,7942,7947,3,1066,533,
  	0,7943,7945,5,30,0,0,7944,7946,3,1054,527,0,7945,7944,1,0,0,0,7945,7946,
  	1,0,0,0,7946,7948,1,0,0,0,7947,7943,1,0,0,0,7947,7948,1,0,0,0,7948,7949,
  	1,0,0,0,7949,7950,5,44,0,0,7950,7951,5,31,0,0,7951,1025,1,0,0,0,7952,
  	7953,5,166,0,0,7953,7954,5,368,0,0,7954,7955,5,43,0,0,7955,7956,3,1056,
  	528,0,7956,7957,5,30,0,0,7957,7958,3,1068,534,0,7958,7959,5,30,0,0,7959,
  	7960,3,1066,533,0,7960,7961,5,30,0,0,7961,7990,3,1066,533,0,7962,7964,
  	5,30,0,0,7963,7965,3,1054,527,0,7964,7963,1,0,0,0,7964,7965,1,0,0,0,7965,
  	7988,1,0,0,0,7966,7968,5,30,0,0,7967,7969,3,1060,530,0,7968,7967,1,0,
  	0,0,7968,7969,1,0,0,0,7969,7986,1,0,0,0,7970,7972,5,30,0,0,7971,7973,
  	3,1166,583,0,7972,7971,1,0,0,0,7972,7973,1,0,0,0,7973,7984,1,0,0,0,7974,
  	7976,5,30,0,0,7975,7977,3,1048,524,0,7976,7975,1,0,0,0,7976,7977,1,0,
  	0,0,7977,7982,1,0,0,0,7978,7980,5,30,0,0,7979,7981,3,1046,523,0,7980,
  	7979,1,0,0,0,7980,7981,1,0,0,0,7981,7983,1,0,0,0,7982,7978,1,0,0,0,7982,
  	7983,1,0,0,0,7983,7985,1,0,0,0,7984,7974,1,0,0,0,7984,7985,1,0,0,0,7985,
  	7987,1,0,0,0,7986,7970,1,0,0,0,7986,7987,1,0,0,0,7987,7989,1,0,0,0,7988,
  	7966,1,0,0,0,7988,7989,1,0,0,0,7989,7991,1,0,0,0,7990,7962,1,0,0,0,7990,
  	7991,1,0,0,0,7991,7992,1,0,0,0,7992,7993,5,44,0,0,7993,7994,5,31,0,0,
  	7994,1027,1,0,0,0,7995,7996,5,166,0,0,7996,7997,5,368,0,0,7997,7998,5,
  	43,0,0,7998,7999,3,1056,528,0,7999,8000,5,30,0,0,8000,8001,3,1068,534,
  	0,8001,8002,5,30,0,0,8002,8007,3,1066,533,0,8003,8005,5,30,0,0,8004,8006,
  	3,1054,527,0,8005,8004,1,0,0,0,8005,8006,1,0,0,0,8006,8008,1,0,0,0,8007,
  	8003,1,0,0,0,8007,8008,1,0,0,0,8008,8009,1,0,0,0,8009,8010,5,44,0,0,8010,
  	8011,5,31,0,0,8011,1029,1,0,0,0,8012,8013,5,166,0,0,8013,8014,5,368,0,
  	0,8014,8015,5,43,0,0,8015,8016,3,1056,528,0,8016,8017,5,30,0,0,8017,8018,
  	3,1068,534,0,8018,8019,5,30,0,0,8019,8024,3,1066,533,0,8020,8022,5,30,
  	0,0,8021,8023,3,1054,527,0,8022,8021,1,0,0,0,8022,8023,1,0,0,0,8023,8025,
  	1,0,0,0,8024,8020,1,0,0,0,8024,8025,1,0,0,0,8025,8026,1,0,0,0,8026,8027,
  	5,44,0,0,8027,8028,5,31,0,0,8028,1031,1,0,0,0,8029,8030,5,166,0,0,8030,
  	8031,5,368,0,0,8031,8032,5,43,0,0,8032,8033,3,1056,528,0,8033,8034,5,
  	30,0,0,8034,8035,3,1068,534,0,8035,8036,5,30,0,0,8036,8037,3,1066,533,
  	0,8037,8038,5,30,0,0,8038,8067,3,1066,533,0,8039,8041,5,30,0,0,8040,8042,
  	3,1054,527,0,8041,8040,1,0,0,0,8041,8042,1,0,0,0,8042,8065,1,0,0,0,8043,
  	8045,5,30,0,0,8044,8046,3,1060,530,0,8045,8044,1,0,0,0,8045,8046,1,0,
  	0,0,8046,8063,1,0,0,0,8047,8049,5,30,0,0,8048,8050,3,1166,583,0,8049,
  	8048,1,0,0,0,8049,8050,1,0,0,0,8050,8061,1,0,0,0,8051,8053,5,30,0,0,8052,
  	8054,3,1048,524,0,8053,8052,1,0,0,0,8053,8054,1,0,0,0,8054,8059,1,0,0,
  	0,8055,8057,5,30,0,0,8056,8058,3,1046,523,0,8057,8056,1,0,0,0,8057,8058,
  	1,0,0,0,8058,8060,1,0,0,0,8059,8055,1,0,0,0,8059,8060,1,0,0,0,8060,8062,
  	1,0,0,0,8061,8051,1,0,0,0,8061,8062,1,0,0,0,8062,8064,1,0,0,0,8063,8047,
  	1,0,0,0,8063,8064,1,0,0,0,8064,8066,1,0,0,0,8065,8043,1,0,0,0,8065,8066,
  	1,0,0,0,8066,8068,1,0,0,0,8067,8039,1,0,0,0,8067,8068,1,0,0,0,8068,8069,
  	1,0,0,0,8069,8070,5,44,0,0,8070,8071,5,31,0,0,8071,1033,1,0,0,0,8072,
  	8073,5,166,0,0,8073,8074,5,368,0,0,8074,8075,5,43,0,0,8075,8076,3,1056,
  	528,0,8076,8077,5,30,0,0,8077,8078,3,1068,534,0,8078,8079,5,30,0,0,8079,
  	8084,3,1066,533,0,8080,8082,5,30,0,0,8081,8083,3,1054,527,0,8082,8081,
  	1,0,0,0,8082,8083,1,0,0,0,8083,8085,1,0,0,0,8084,8080,1,0,0,0,8084,8085,
  	1,0,0,0,8085,8086,1,0,0,0,8086,8087,5,44,0,0,8087,8088,5,31,0,0,8088,
  	1035,1,0,0,0,8089,8090,5,166,0,0,8090,8091,5,368,0,0,8091,8092,5,43,0,
  	0,8092,8093,3,1056,528,0,8093,8094,5,30,0,0,8094,8095,3,1068,534,0,8095,
  	8096,5,30,0,0,8096,8113,3,1066,533,0,8097,8099,5,30,0,0,8098,8100,3,1054,
  	527,0,8099,8098,1,0,0,0,8099,8100,1,0,0,0,8100,8111,1,0,0,0,8101,8103,
  	5,30,0,0,8102,8104,3,1052,526,0,8103,8102,1,0,0,0,8103,8104,1,0,0,0,8104,
  	8109,1,0,0,0,8105,8107,5,30,0,0,8106,8108,3,1058,529,0,8107,8106,1,0,
  	0,0,8107,8108,1,0,0,0,8108,8110,1,0,0,0,8109,8105,1,0,0,0,8109,8110,1,
  	0,0,0,8110,8112,1,0,0,0,8111,8101,1,0,0,0,8111,8112,1,0,0,0,8112,8114,
  	1,0,0,0,8113,8097,1,0,0,0,8113,8114,1,0,0,0,8114,8115,1,0,0,0,8115,8116,
  	5,44,0,0,8116,8117,5,31,0,0,8117,1037,1,0,0,0,8118,8119,5,166,0,0,8119,
  	8120,5,368,0,0,8120,8121,5,43,0,0,8121,8122,3,1056,528,0,8122,8123,5,
  	30,0,0,8123,8124,3,1068,534,0,8124,8125,5,30,0,0,8125,8126,3,1066,533,
  	0,8126,8127,5,30,0,0,8127,8144,3,1066,533,0,8128,8130,5,30,0,0,8129,8131,
  	3,1054,527,0,8130,8129,1,0,0,0,8130,8131,1,0,0,0,8131,8142,1,0,0,0,8132,
  	8134,5,30,0,0,8133,8135,3,1052,526,0,8134,8133,1,0,0,0,8134,8135,1,0,
  	0,0,8135,8140,1,0,0,0,8136,8138,5,30,0,0,8137,8139,3,1058,529,0,8138,
  	8137,1,0,0,0,8138,8139,1,0,0,0,8139,8141,1,0,0,0,8140,8136,1,0,0,0,8140,
  	8141,1,0,0,0,8141,8143,1,0,0,0,8142,8132,1,0,0,0,8142,8143,1,0,0,0,8143,
  	8145,1,0,0,0,8144,8128,1,0,0,0,8144,8145,1,0,0,0,8145,8146,1,0,0,0,8146,
  	8147,5,44,0,0,8147,8148,5,31,0,0,8148,1039,1,0,0,0,8149,8150,5,166,0,
  	0,8150,8151,5,368,0,0,8151,8152,5,43,0,0,8152,8153,3,1070,535,0,8153,
  	8154,5,30,0,0,8154,8159,3,1066,533,0,8155,8157,5,30,0,0,8156,8158,3,1054,
  	527,0,8157,8156,1,0,0,0,8157,8158,1,0,0,0,8158,8160,1,0,0,0,8159,8155,
  	1,0,0,0,8159,8160,1,0,0,0,8160,8161,1,0,0,0,8161,8162,5,44,0,0,8162,8163,
  	5,31,0,0,8163,1041,1,0,0,0,8164,8165,5,166,0,0,8165,8166,5,368,0,0,8166,
  	8167,5,43,0,0,8167,8168,3,1070,535,0,8168,8169,5,30,0,0,8169,8170,3,1066,
  	533,0,8170,8171,5,30,0,0,8171,8176,3,1064,532,0,8172,8174,5,30,0,0,8173,
  	8175,3,1054,527,0,8174,8173,1,0,0,0,8174,8175,1,0,0,0,8175,8177,1,0,0,
  	0,8176,8172,1,0,0,0,8176,8177,1,0,0,0,8177,8178,1,0,0,0,8178,8179,5,44,
  	0,0,8179,8180,5,31,0,0,8180,1043,1,0,0,0,8181,8182,5,166,0,0,8182,8183,
  	5,368,0,0,8183,8184,5,43,0,0,8184,8185,3,1056,528,0,8185,8186,5,30,0,
  	0,8186,8187,3,1068,534,0,8187,8188,5,30,0,0,8188,8189,3,1062,531,0,8189,
  	8190,5,30,0,0,8190,8195,3,1050,525,0,8191,8193,5,30,0,0,8192,8194,3,1054,
  	527,0,8193,8192,1,0,0,0,8193,8194,1,0,0,0,8194,8196,1,0,0,0,8195,8191,
  	1,0,0,0,8195,8196,1,0,0,0,8196,8197,1,0,0,0,8197,8198,5,44,0,0,8198,8199,
  	5,31,0,0,8199,1045,1,0,0,0,8200,8205,3,1248,624,0,8201,8202,5,110,0,0,
  	8202,8203,3,1148,574,0,8203,8204,5,111,0,0,8204,8206,1,0,0,0,8205,8201,
  	1,0,0,0,8205,8206,1,0,0,0,8206,1047,1,0,0,0,8207,8212,3,1248,624,0,8208,
  	8209,5,110,0,0,8209,8210,3,1148,574,0,8210,8211,5,111,0,0,8211,8213,1,
  	0,0,0,8212,8208,1,0,0,0,8212,8213,1,0,0,0,8213,1049,1,0,0,0,8214,8215,
  	3,1166,583,0,8215,1051,1,0,0,0,8216,8217,3,1144,572,0,8217,1053,1,0,0,
  	0,8218,8219,3,1248,624,0,8219,1055,1,0,0,0,8220,8221,3,1068,534,0,8221,
  	1057,1,0,0,0,8222,8223,3,1148,574,0,8223,1059,1,0,0,0,8224,8225,3,1166,
  	583,0,8225,1061,1,0,0,0,8226,8227,3,1166,583,0,8227,1063,1,0,0,0,8228,
  	8229,3,1144,572,0,8229,1065,1,0,0,0,8230,8231,3,1166,583,0,8231,1067,
  	1,0,0,0,8232,8234,3,1072,536,0,8233,8232,1,0,0,0,8233,8234,1,0,0,0,8234,
  	8235,1,0,0,0,8235,8238,3,1074,537,0,8236,8237,5,354,0,0,8237,8239,3,1080,
  	540,0,8238,8236,1,0,0,0,8238,8239,1,0,0,0,8239,1069,1,0,0,0,8240,8241,
  	3,1072,536,0,8241,8244,3,1074,537,0,8242,8243,5,354,0,0,8243,8245,3,1080,
  	540,0,8244,8242,1,0,0,0,8244,8245,1,0,0,0,8245,1071,1,0,0,0,8246,8250,
  	5,333,0,0,8247,8250,5,334,0,0,8248,8250,3,1076,538,0,8249,8246,1,0,0,
  	0,8249,8247,1,0,0,0,8249,8248,1,0,0,0,8250,1073,1,0,0,0,8251,8254,3,970,
  	485,0,8252,8254,3,972,486,0,8253,8251,1,0,0,0,8253,8252,1,0,0,0,8254,
  	1075,1,0,0,0,8255,8256,5,343,0,0,8256,8257,5,110,0,0,8257,8262,3,1078,
  	539,0,8258,8259,5,30,0,0,8259,8261,3,1078,539,0,8260,8258,1,0,0,0,8261,
  	8264,1,0,0,0,8262,8260,1,0,0,0,8262,8263,1,0,0,0,8263,8265,1,0,0,0,8264,
  	8262,1,0,0,0,8265,8266,5,111,0,0,8266,1077,1,0,0,0,8267,8273,5,18,0,0,
  	8268,8269,5,368,0,0,8269,8273,5,18,0,0,8270,8271,5,18,0,0,8271,8273,5,
  	368,0,0,8272,8267,1,0,0,0,8272,8268,1,0,0,0,8272,8270,1,0,0,0,8273,1079,
  	1,0,0,0,8274,8280,3,1082,541,0,8275,8276,5,43,0,0,8276,8277,3,1082,541,
  	0,8277,8278,5,44,0,0,8278,8280,1,0,0,0,8279,8274,1,0,0,0,8279,8275,1,
  	0,0,0,8280,1081,1,0,0,0,8281,8301,3,1162,581,0,8282,8283,5,365,0,0,8283,
  	8301,3,1162,581,0,8284,8285,3,1162,581,0,8285,8286,5,180,0,0,8286,8287,
  	3,1084,542,0,8287,8301,1,0,0,0,8288,8289,3,1162,581,0,8289,8290,5,349,
  	0,0,8290,8291,3,1084,542,0,8291,8301,1,0,0,0,8292,8293,3,1162,581,0,8293,
  	8294,5,181,0,0,8294,8295,3,1084,542,0,8295,8301,1,0,0,0,8296,8297,3,1162,
  	581,0,8297,8298,5,350,0,0,8298,8299,3,1084,542,0,8299,8301,1,0,0,0,8300,
  	8281,1,0,0,0,8300,8282,1,0,0,0,8300,8284,1,0,0,0,8300,8288,1,0,0,0,8300,
  	8292,1,0,0,0,8300,8296,1,0,0,0,8301,1083,1,0,0,0,8302,8312,5,8,0,0,8303,
  	8312,5,9,0,0,8304,8312,5,12,0,0,8305,8312,5,13,0,0,8306,8312,5,2,0,0,
  	8307,8312,5,3,0,0,8308,8312,5,4,0,0,8309,8312,5,5,0,0,8310,8312,5,18,
  	0,0,8311,8302,1,0,0,0,8311,8303,1,0,0,0,8311,8304,1,0,0,0,8311,8305,1,
  	0,0,0,8311,8306,1,0,0,0,8311,8307,1,0,0,0,8311,8308,1,0,0,0,8311,8309,
  	1,0,0,0,8311,8310,1,0,0,0,8312,1085,1,0,0,0,8313,8314,5,85,0,0,8314,8319,
  	3,1162,581,0,8315,8316,5,30,0,0,8316,8318,3,1162,581,0,8317,8315,1,0,
  	0,0,8318,8321,1,0,0,0,8319,8317,1,0,0,0,8319,8320,1,0,0,0,8320,8322,1,
  	0,0,0,8321,8319,1,0,0,0,8322,8323,5,86,0,0,8323,8341,1,0,0,0,8324,8325,
  	5,85,0,0,8325,8326,3,1090,545,0,8326,8327,5,33,0,0,8327,8335,3,1162,581,
  	0,8328,8329,5,30,0,0,8329,8330,3,1090,545,0,8330,8331,5,33,0,0,8331,8332,
  	3,1162,581,0,8332,8334,1,0,0,0,8333,8328,1,0,0,0,8334,8337,1,0,0,0,8335,
  	8333,1,0,0,0,8335,8336,1,0,0,0,8336,8338,1,0,0,0,8337,8335,1,0,0,0,8338,
  	8339,5,86,0,0,8339,8341,1,0,0,0,8340,8313,1,0,0,0,8340,8324,1,0,0,0,8341,
  	1087,1,0,0,0,8342,8343,5,85,0,0,8343,8348,3,1144,572,0,8344,8345,5,30,
  	0,0,8345,8347,3,1144,572,0,8346,8344,1,0,0,0,8347,8350,1,0,0,0,8348,8346,
  	1,0,0,0,8348,8349,1,0,0,0,8349,8351,1,0,0,0,8350,8348,1,0,0,0,8351,8352,
  	5,86,0,0,8352,8370,1,0,0,0,8353,8354,5,85,0,0,8354,8355,3,1090,545,0,
  	8355,8356,5,33,0,0,8356,8364,3,1144,572,0,8357,8358,5,30,0,0,8358,8359,
  	3,1090,545,0,8359,8360,5,33,0,0,8360,8361,3,1144,572,0,8361,8363,1,0,
  	0,0,8362,8357,1,0,0,0,8363,8366,1,0,0,0,8364,8362,1,0,0,0,8364,8365,1,
  	0,0,0,8365,8367,1,0,0,0,8366,8364,1,0,0,0,8367,8368,5,86,0,0,8368,8370,
  	1,0,0,0,8369,8342,1,0,0,0,8369,8353,1,0,0,0,8370,1089,1,0,0,0,8371,8375,
  	5,36,0,0,8372,8375,3,1248,624,0,8373,8375,3,1144,572,0,8374,8371,1,0,
  	0,0,8374,8372,1,0,0,0,8374,8373,1,0,0,0,8375,1091,1,0,0,0,8376,8377,5,
  	85,0,0,8377,8378,3,1144,572,0,8378,8379,3,1088,544,0,8379,8380,5,86,0,
  	0,8380,1093,1,0,0,0,8381,8382,5,85,0,0,8382,8387,3,1168,584,0,8383,8384,
  	5,30,0,0,8384,8386,3,1168,584,0,8385,8383,1,0,0,0,8386,8389,1,0,0,0,8387,
  	8385,1,0,0,0,8387,8388,1,0,0,0,8388,8390,1,0,0,0,8389,8387,1,0,0,0,8390,
  	8391,5,86,0,0,8391,1095,1,0,0,0,8392,8393,5,85,0,0,8393,8394,3,1144,572,
  	0,8394,8395,3,1094,547,0,8395,8396,5,86,0,0,8396,1097,1,0,0,0,8397,8398,
  	5,85,0,0,8398,8399,3,1162,581,0,8399,8400,3,1086,543,0,8400,8401,5,86,
  	0,0,8401,1099,1,0,0,0,8402,8403,5,85,0,0,8403,8405,3,1102,551,0,8404,
  	8406,3,1104,552,0,8405,8404,1,0,0,0,8405,8406,1,0,0,0,8406,8407,1,0,0,
  	0,8407,8408,3,1106,553,0,8408,8409,5,86,0,0,8409,1101,1,0,0,0,8410,8411,
  	7,29,0,0,8411,1103,1,0,0,0,8412,8415,3,282,141,0,8413,8415,3,1144,572,
  	0,8414,8412,1,0,0,0,8414,8413,1,0,0,0,8415,1105,1,0,0,0,8416,8417,5,85,
  	0,0,8417,8422,3,1108,554,0,8418,8419,5,30,0,0,8419,8421,3,1108,554,0,
  	8420,8418,1,0,0,0,8421,8424,1,0,0,0,8422,8420,1,0,0,0,8422,8423,1,0,0,
  	0,8423,8425,1,0,0,0,8424,8422,1,0,0,0,8425,8426,5,86,0,0,8426,1107,1,
  	0,0,0,8427,8433,3,1162,581,0,8428,8429,5,321,0,0,8429,8430,5,110,0,0,
  	8430,8431,3,1110,555,0,8431,8432,5,111,0,0,8432,8434,1,0,0,0,8433,8428,
  	1,0,0,0,8433,8434,1,0,0,0,8434,1109,1,0,0,0,8435,8441,3,1162,581,0,8436,
  	8437,3,1162,581,0,8437,8438,3,1178,589,0,8438,8439,3,1162,581,0,8439,
  	8441,1,0,0,0,8440,8435,1,0,0,0,8440,8436,1,0,0,0,8441,1111,1,0,0,0,8442,
  	8443,5,85,0,0,8443,8444,5,86,0,0,8444,1113,1,0,0,0,8445,8446,3,1206,603,
  	0,8446,8447,5,35,0,0,8447,8452,1,0,0,0,8448,8452,3,260,130,0,8449,8452,
  	3,1252,626,0,8450,8452,3,1194,597,0,8451,8445,1,0,0,0,8451,8448,1,0,0,
  	0,8451,8449,1,0,0,0,8451,8450,1,0,0,0,8451,8452,1,0,0,0,8452,8454,1,0,
  	0,0,8453,8455,3,1196,598,0,8454,8453,1,0,0,0,8454,8455,1,0,0,0,8455,8456,
  	1,0,0,0,8456,8463,3,1248,624,0,8457,8458,3,1214,607,0,8458,8459,5,35,
  	0,0,8459,8460,3,1248,624,0,8460,8462,1,0,0,0,8461,8457,1,0,0,0,8462,8465,
  	1,0,0,0,8463,8461,1,0,0,0,8463,8464,1,0,0,0,8464,8469,1,0,0,0,8465,8463,
  	1,0,0,0,8466,8468,3,1240,620,0,8467,8466,1,0,0,0,8468,8471,1,0,0,0,8469,
  	8467,1,0,0,0,8469,8470,1,0,0,0,8470,8477,1,0,0,0,8471,8469,1,0,0,0,8472,
  	8473,5,43,0,0,8473,8474,3,1118,559,0,8474,8475,5,44,0,0,8475,8478,1,0,
  	0,0,8476,8478,3,1210,605,0,8477,8472,1,0,0,0,8477,8476,1,0,0,0,8478,8481,
  	1,0,0,0,8479,8480,5,35,0,0,8480,8482,3,1122,561,0,8481,8479,1,0,0,0,8481,
  	8482,1,0,0,0,8482,8485,1,0,0,0,8483,8485,3,1128,564,0,8484,8451,1,0,0,
  	0,8484,8483,1,0,0,0,8485,1115,1,0,0,0,8486,8488,3,1162,581,0,8487,8486,
  	1,0,0,0,8487,8488,1,0,0,0,8488,1117,1,0,0,0,8489,8491,3,1162,581,0,8490,
  	8489,1,0,0,0,8490,8491,1,0,0,0,8491,8496,1,0,0,0,8492,8493,5,30,0,0,8493,
  	8495,3,1116,558,0,8494,8492,1,0,0,0,8495,8498,1,0,0,0,8496,8494,1,0,0,
  	0,8496,8497,1,0,0,0,8497,8510,1,0,0,0,8498,8496,1,0,0,0,8499,8500,5,30,
  	0,0,8500,8501,5,35,0,0,8501,8502,3,1248,624,0,8502,8504,5,43,0,0,8503,
  	8505,3,1162,581,0,8504,8503,1,0,0,0,8504,8505,1,0,0,0,8505,8506,1,0,0,
  	0,8506,8507,5,44,0,0,8507,8509,1,0,0,0,8508,8499,1,0,0,0,8509,8512,1,
  	0,0,0,8510,8508,1,0,0,0,8510,8511,1,0,0,0,8511,8535,1,0,0,0,8512,8510,
  	1,0,0,0,8513,8514,5,35,0,0,8514,8515,3,1248,624,0,8515,8517,5,43,0,0,
  	8516,8518,3,1162,581,0,8517,8516,1,0,0,0,8517,8518,1,0,0,0,8518,8519,
  	1,0,0,0,8519,8531,5,44,0,0,8520,8521,5,30,0,0,8521,8522,5,35,0,0,8522,
  	8523,3,1248,624,0,8523,8525,5,43,0,0,8524,8526,3,1162,581,0,8525,8524,
  	1,0,0,0,8525,8526,1,0,0,0,8526,8527,1,0,0,0,8527,8528,5,44,0,0,8528,8530,
  	1,0,0,0,8529,8520,1,0,0,0,8530,8533,1,0,0,0,8531,8529,1,0,0,0,8531,8532,
  	1,0,0,0,8532,8535,1,0,0,0,8533,8531,1,0,0,0,8534,8490,1,0,0,0,8534,8513,
  	1,0,0,0,8535,1119,1,0,0,0,8536,8537,3,1130,565,0,8537,8538,5,35,0,0,8538,
  	8539,3,1122,561,0,8539,8545,1,0,0,0,8540,8541,3,262,131,0,8541,8542,5,
  	32,0,0,8542,8543,3,1122,561,0,8543,8545,1,0,0,0,8544,8536,1,0,0,0,8544,
  	8540,1,0,0,0,8545,1121,1,0,0,0,8546,8550,3,1248,624,0,8547,8549,3,1240,
  	620,0,8548,8547,1,0,0,0,8549,8552,1,0,0,0,8550,8548,1,0,0,0,8550,8551,
  	1,0,0,0,8551,8557,1,0,0,0,8552,8550,1,0,0,0,8553,8554,5,43,0,0,8554,8555,
  	3,1118,559,0,8555,8556,5,44,0,0,8556,8558,1,0,0,0,8557,8553,1,0,0,0,8557,
  	8558,1,0,0,0,8558,8561,1,0,0,0,8559,8561,3,1124,562,0,8560,8546,1,0,0,
  	0,8560,8559,1,0,0,0,8561,1123,1,0,0,0,8562,8565,3,1126,563,0,8563,8565,
  	3,1128,564,0,8564,8562,1,0,0,0,8564,8563,1,0,0,0,8565,1125,1,0,0,0,8566,
  	8570,3,1132,566,0,8567,8569,3,1240,620,0,8568,8567,1,0,0,0,8569,8572,
  	1,0,0,0,8570,8568,1,0,0,0,8570,8571,1,0,0,0,8571,8577,1,0,0,0,8572,8570,
  	1,0,0,0,8573,8574,5,43,0,0,8574,8575,3,1118,559,0,8575,8576,5,44,0,0,
  	8576,8578,1,0,0,0,8577,8573,1,0,0,0,8577,8578,1,0,0,0,8578,8584,1,0,0,
  	0,8579,8580,5,321,0,0,8580,8581,5,43,0,0,8581,8582,3,1162,581,0,8582,
  	8583,5,44,0,0,8583,8585,1,0,0,0,8584,8579,1,0,0,0,8584,8585,1,0,0,0,8585,
  	1127,1,0,0,0,8586,8590,5,328,0,0,8587,8589,3,1240,620,0,8588,8587,1,0,
  	0,0,8589,8592,1,0,0,0,8590,8588,1,0,0,0,8590,8591,1,0,0,0,8591,8599,1,
  	0,0,0,8592,8590,1,0,0,0,8593,8596,5,43,0,0,8594,8597,3,176,88,0,8595,
  	8597,5,325,0,0,8596,8594,1,0,0,0,8596,8595,1,0,0,0,8596,8597,1,0,0,0,
  	8597,8598,1,0,0,0,8598,8600,5,44,0,0,8599,8593,1,0,0,0,8599,8600,1,0,
  	0,0,8600,8610,1,0,0,0,8601,8607,5,321,0,0,8602,8604,5,43,0,0,8603,8605,
  	3,176,88,0,8604,8603,1,0,0,0,8604,8605,1,0,0,0,8605,8606,1,0,0,0,8606,
  	8608,5,44,0,0,8607,8602,1,0,0,0,8607,8608,1,0,0,0,8608,8609,1,0,0,0,8609,
  	8611,3,152,76,0,8610,8601,1,0,0,0,8610,8611,1,0,0,0,8611,1129,1,0,0,0,
  	8612,8640,3,1206,603,0,8613,8616,3,260,130,0,8614,8616,3,1252,626,0,8615,
  	8613,1,0,0,0,8615,8614,1,0,0,0,8615,8616,1,0,0,0,8616,8618,1,0,0,0,8617,
  	8619,3,1196,598,0,8618,8617,1,0,0,0,8618,8619,1,0,0,0,8619,8620,1,0,0,
  	0,8620,8634,3,1248,624,0,8621,8622,5,110,0,0,8622,8623,3,1144,572,0,8623,
  	8624,5,111,0,0,8624,8626,1,0,0,0,8625,8621,1,0,0,0,8626,8629,1,0,0,0,
  	8627,8625,1,0,0,0,8627,8628,1,0,0,0,8628,8630,1,0,0,0,8629,8627,1,0,0,
  	0,8630,8631,5,35,0,0,8631,8633,3,1248,624,0,8632,8627,1,0,0,0,8633,8636,
  	1,0,0,0,8634,8632,1,0,0,0,8634,8635,1,0,0,0,8635,8637,1,0,0,0,8636,8634,
  	1,0,0,0,8637,8638,3,1210,605,0,8638,8640,1,0,0,0,8639,8612,1,0,0,0,8639,
  	8615,1,0,0,0,8640,1131,1,0,0,0,8641,8647,3,1248,624,0,8642,8647,3,1134,
  	567,0,8643,8647,3,1136,568,0,8644,8647,3,1138,569,0,8645,8647,3,1140,
  	570,0,8646,8641,1,0,0,0,8646,8642,1,0,0,0,8646,8643,1,0,0,0,8646,8644,
  	1,0,0,0,8646,8645,1,0,0,0,8647,1133,1,0,0,0,8648,8649,5,303,0,0,8649,
  	1135,1,0,0,0,8650,8651,5,203,0,0,8651,1137,1,0,0,0,8652,8653,5,202,0,
  	0,8653,1139,1,0,0,0,8654,8655,5,252,0,0,8655,1141,1,0,0,0,8656,8660,3,
  	1230,615,0,8657,8659,3,1240,620,0,8658,8657,1,0,0,0,8659,8662,1,0,0,0,
  	8660,8658,1,0,0,0,8660,8661,1,0,0,0,8661,8663,1,0,0,0,8662,8660,1,0,0,
  	0,8663,8664,3,1226,613,0,8664,8675,1,0,0,0,8665,8669,3,1226,613,0,8666,
  	8668,3,1240,620,0,8667,8666,1,0,0,0,8668,8671,1,0,0,0,8669,8667,1,0,0,
  	0,8669,8670,1,0,0,0,8670,8672,1,0,0,0,8671,8669,1,0,0,0,8672,8673,3,1230,
  	615,0,8673,8675,1,0,0,0,8674,8656,1,0,0,0,8674,8665,1,0,0,0,8675,1143,
  	1,0,0,0,8676,8677,6,572,-1,0,8677,8688,3,1182,591,0,8678,8682,7,30,0,
  	0,8679,8681,3,1240,620,0,8680,8679,1,0,0,0,8681,8684,1,0,0,0,8682,8680,
  	1,0,0,0,8682,8683,1,0,0,0,8683,8685,1,0,0,0,8684,8682,1,0,0,0,8685,8688,
  	3,1182,591,0,8686,8688,3,1264,632,0,8687,8676,1,0,0,0,8687,8678,1,0,0,
  	0,8687,8686,1,0,0,0,8688,8818,1,0,0,0,8689,8690,10,14,0,0,8690,8694,5,
  	177,0,0,8691,8693,3,1240,620,0,8692,8691,1,0,0,0,8693,8696,1,0,0,0,8694,
  	8692,1,0,0,0,8694,8695,1,0,0,0,8695,8697,1,0,0,0,8696,8694,1,0,0,0,8697,
  	8817,3,1144,572,15,8698,8699,10,13,0,0,8699,8703,7,31,0,0,8700,8702,3,
  	1240,620,0,8701,8700,1,0,0,0,8702,8705,1,0,0,0,8703,8701,1,0,0,0,8703,
  	8704,1,0,0,0,8704,8706,1,0,0,0,8705,8703,1,0,0,0,8706,8817,3,1144,572,
  	14,8707,8708,10,12,0,0,8708,8712,7,28,0,0,8709,8711,3,1240,620,0,8710,
  	8709,1,0,0,0,8711,8714,1,0,0,0,8712,8710,1,0,0,0,8712,8713,1,0,0,0,8713,
  	8715,1,0,0,0,8714,8712,1,0,0,0,8715,8817,3,1144,572,13,8716,8717,10,11,
  	0,0,8717,8721,7,32,0,0,8718,8720,3,1240,620,0,8719,8718,1,0,0,0,8720,
  	8723,1,0,0,0,8721,8719,1,0,0,0,8721,8722,1,0,0,0,8722,8724,1,0,0,0,8723,
  	8721,1,0,0,0,8724,8817,3,1144,572,12,8725,8726,10,10,0,0,8726,8730,7,
  	33,0,0,8727,8729,3,1240,620,0,8728,8727,1,0,0,0,8729,8732,1,0,0,0,8730,
  	8728,1,0,0,0,8730,8731,1,0,0,0,8731,8733,1,0,0,0,8732,8730,1,0,0,0,8733,
  	8817,3,1144,572,11,8734,8735,10,9,0,0,8735,8739,7,34,0,0,8736,8738,3,
  	1240,620,0,8737,8736,1,0,0,0,8738,8741,1,0,0,0,8739,8737,1,0,0,0,8739,
  	8740,1,0,0,0,8740,8742,1,0,0,0,8741,8739,1,0,0,0,8742,8817,3,1144,572,
  	10,8743,8744,10,8,0,0,8744,8748,5,355,0,0,8745,8747,3,1240,620,0,8746,
  	8745,1,0,0,0,8747,8750,1,0,0,0,8748,8746,1,0,0,0,8748,8749,1,0,0,0,8749,
  	8751,1,0,0,0,8750,8748,1,0,0,0,8751,8817,3,1144,572,9,8752,8753,10,7,
  	0,0,8753,8757,7,35,0,0,8754,8756,3,1240,620,0,8755,8754,1,0,0,0,8756,
  	8759,1,0,0,0,8757,8755,1,0,0,0,8757,8758,1,0,0,0,8758,8760,1,0,0,0,8759,
  	8757,1,0,0,0,8760,8817,3,1144,572,8,8761,8762,10,6,0,0,8762,8766,5,356,
  	0,0,8763,8765,3,1240,620,0,8764,8763,1,0,0,0,8765,8768,1,0,0,0,8766,8764,
  	1,0,0,0,8766,8767,1,0,0,0,8767,8769,1,0,0,0,8768,8766,1,0,0,0,8769,8817,
  	3,1144,572,7,8770,8771,10,5,0,0,8771,8775,5,235,0,0,8772,8774,3,1240,
  	620,0,8773,8772,1,0,0,0,8774,8777,1,0,0,0,8775,8773,1,0,0,0,8775,8776,
  	1,0,0,0,8776,8778,1,0,0,0,8777,8775,1,0,0,0,8778,8817,3,1144,572,6,8779,
  	8780,10,4,0,0,8780,8784,5,236,0,0,8781,8783,3,1240,620,0,8782,8781,1,
  	0,0,0,8783,8786,1,0,0,0,8784,8782,1,0,0,0,8784,8785,1,0,0,0,8785,8787,
  	1,0,0,0,8786,8784,1,0,0,0,8787,8817,3,1144,572,5,8788,8793,10,3,0,0,8789,
  	8790,5,235,0,0,8790,8792,3,1162,581,0,8791,8789,1,0,0,0,8792,8795,1,0,
  	0,0,8793,8791,1,0,0,0,8793,8794,1,0,0,0,8794,8796,1,0,0,0,8795,8793,1,
  	0,0,0,8796,8800,3,1146,573,0,8797,8799,3,1240,620,0,8798,8797,1,0,0,0,
  	8799,8802,1,0,0,0,8800,8798,1,0,0,0,8800,8801,1,0,0,0,8801,8803,1,0,0,
  	0,8802,8800,1,0,0,0,8803,8804,3,1162,581,0,8804,8805,5,33,0,0,8805,8806,
  	3,1144,572,3,8806,8817,1,0,0,0,8807,8808,10,2,0,0,8808,8812,7,36,0,0,
  	8809,8811,3,1240,620,0,8810,8809,1,0,0,0,8811,8814,1,0,0,0,8812,8810,
  	1,0,0,0,8812,8813,1,0,0,0,8813,8815,1,0,0,0,8814,8812,1,0,0,0,8815,8817,
  	3,1144,572,2,8816,8689,1,0,0,0,8816,8698,1,0,0,0,8816,8707,1,0,0,0,8816,
  	8716,1,0,0,0,8816,8725,1,0,0,0,8816,8734,1,0,0,0,8816,8743,1,0,0,0,8816,
  	8752,1,0,0,0,8816,8761,1,0,0,0,8816,8770,1,0,0,0,8816,8779,1,0,0,0,8816,
  	8788,1,0,0,0,8816,8807,1,0,0,0,8817,8820,1,0,0,0,8818,8816,1,0,0,0,8818,
  	8819,1,0,0,0,8819,1145,1,0,0,0,8820,8818,1,0,0,0,8821,8822,5,1,0,0,8822,
  	1147,1,0,0,0,8823,8829,3,1144,572,0,8824,8825,5,33,0,0,8825,8826,3,1144,
  	572,0,8826,8827,5,33,0,0,8827,8828,3,1144,572,0,8828,8830,1,0,0,0,8829,
  	8824,1,0,0,0,8829,8830,1,0,0,0,8830,1149,1,0,0,0,8831,8835,3,1148,574,
  	0,8832,8835,3,236,118,0,8833,8835,5,166,0,0,8834,8831,1,0,0,0,8834,8832,
  	1,0,0,0,8834,8833,1,0,0,0,8835,1151,1,0,0,0,8836,8840,3,1166,583,0,8837,
  	8840,3,236,118,0,8838,8840,5,166,0,0,8839,8836,1,0,0,0,8839,8837,1,0,
  	0,0,8839,8838,1,0,0,0,8840,1153,1,0,0,0,8841,8844,3,1144,572,0,8842,8844,
  	3,1156,578,0,8843,8841,1,0,0,0,8843,8842,1,0,0,0,8844,1155,1,0,0,0,8845,
  	8848,3,1158,579,0,8846,8848,3,1160,580,0,8847,8845,1,0,0,0,8847,8846,
  	1,0,0,0,8848,1157,1,0,0,0,8849,8850,3,1144,572,0,8850,8851,5,33,0,0,8851,
  	8852,3,1144,572,0,8852,1159,1,0,0,0,8853,8854,3,1144,572,0,8854,8855,
  	3,1176,588,0,8855,8856,3,1144,572,0,8856,1161,1,0,0,0,8857,8858,6,581,
  	-1,0,8858,8923,3,1188,594,0,8859,8860,5,43,0,0,8860,8861,3,1162,581,0,
  	8861,8862,5,44,0,0,8862,8923,1,0,0,0,8863,8867,7,30,0,0,8864,8866,3,1240,
  	620,0,8865,8864,1,0,0,0,8866,8869,1,0,0,0,8867,8865,1,0,0,0,8867,8868,
  	1,0,0,0,8868,8870,1,0,0,0,8869,8867,1,0,0,0,8870,8923,3,1162,581,21,8871,
  	8875,7,37,0,0,8872,8874,3,1240,620,0,8873,8872,1,0,0,0,8874,8877,1,0,
  	0,0,8875,8873,1,0,0,0,8875,8876,1,0,0,0,8876,8878,1,0,0,0,8877,8875,1,
  	0,0,0,8878,8923,3,1226,613,0,8879,8883,3,1226,613,0,8880,8882,3,1240,
  	620,0,8881,8880,1,0,0,0,8882,8885,1,0,0,0,8883,8881,1,0,0,0,8883,8884,
  	1,0,0,0,8884,8886,1,0,0,0,8885,8883,1,0,0,0,8886,8887,7,37,0,0,8887,8923,
  	1,0,0,0,8888,8889,5,43,0,0,8889,8890,3,1226,613,0,8890,8891,7,22,0,0,
  	8891,8892,3,1162,581,0,8892,8893,5,44,0,0,8893,8923,1,0,0,0,8894,8895,
  	5,43,0,0,8895,8896,3,1162,581,0,8896,8897,5,306,0,0,8897,8902,3,842,421,
  	0,8898,8899,5,235,0,0,8899,8901,3,1162,581,0,8900,8898,1,0,0,0,8901,8904,
  	1,0,0,0,8902,8900,1,0,0,0,8902,8903,1,0,0,0,8903,8905,1,0,0,0,8904,8902,
  	1,0,0,0,8905,8906,5,44,0,0,8906,8910,5,1,0,0,8907,8909,3,1240,620,0,8908,
  	8907,1,0,0,0,8909,8912,1,0,0,0,8910,8908,1,0,0,0,8910,8911,1,0,0,0,8911,
  	8913,1,0,0,0,8912,8910,1,0,0,0,8913,8914,3,1162,581,0,8914,8915,5,33,
  	0,0,8915,8916,3,1162,581,17,8916,8923,1,0,0,0,8917,8918,5,310,0,0,8918,
  	8920,3,1248,624,0,8919,8921,3,1162,581,0,8920,8919,1,0,0,0,8920,8921,
  	1,0,0,0,8921,8923,1,0,0,0,8922,8857,1,0,0,0,8922,8859,1,0,0,0,8922,8863,
  	1,0,0,0,8922,8871,1,0,0,0,8922,8879,1,0,0,0,8922,8888,1,0,0,0,8922,8894,
  	1,0,0,0,8922,8917,1,0,0,0,8923,9080,1,0,0,0,8924,8925,10,15,0,0,8925,
  	8929,5,177,0,0,8926,8928,3,1240,620,0,8927,8926,1,0,0,0,8928,8931,1,0,
  	0,0,8929,8927,1,0,0,0,8929,8930,1,0,0,0,8930,8932,1,0,0,0,8931,8929,1,
  	0,0,0,8932,9079,3,1162,581,16,8933,8934,10,14,0,0,8934,8938,7,31,0,0,
  	8935,8937,3,1240,620,0,8936,8935,1,0,0,0,8937,8940,1,0,0,0,8938,8936,
  	1,0,0,0,8938,8939,1,0,0,0,8939,8941,1,0,0,0,8940,8938,1,0,0,0,8941,9079,
  	3,1162,581,15,8942,8943,10,13,0,0,8943,8947,7,28,0,0,8944,8946,3,1240,
  	620,0,8945,8944,1,0,0,0,8946,8949,1,0,0,0,8947,8945,1,0,0,0,8947,8948,
  	1,0,0,0,8948,8950,1,0,0,0,8949,8947,1,0,0,0,8950,9079,3,1162,581,14,8951,
  	8952,10,12,0,0,8952,8956,7,32,0,0,8953,8955,3,1240,620,0,8954,8953,1,
  	0,0,0,8955,8958,1,0,0,0,8956,8954,1,0,0,0,8956,8957,1,0,0,0,8957,8959,
  	1,0,0,0,8958,8956,1,0,0,0,8959,9079,3,1162,581,13,8960,8961,10,11,0,0,
  	8961,8965,7,33,0,0,8962,8964,3,1240,620,0,8963,8962,1,0,0,0,8964,8967,
  	1,0,0,0,8965,8963,1,0,0,0,8965,8966,1,0,0,0,8966,8968,1,0,0,0,8967,8965,
  	1,0,0,0,8968,9079,3,1162,581,12,8969,8970,10,10,0,0,8970,8974,7,34,0,
  	0,8971,8973,3,1240,620,0,8972,8971,1,0,0,0,8973,8976,1,0,0,0,8974,8972,
  	1,0,0,0,8974,8975,1,0,0,0,8975,8977,1,0,0,0,8976,8974,1,0,0,0,8977,9079,
  	3,1162,581,11,8978,8979,10,9,0,0,8979,8983,5,355,0,0,8980,8982,3,1240,
  	620,0,8981,8980,1,0,0,0,8982,8985,1,0,0,0,8983,8981,1,0,0,0,8983,8984,
  	1,0,0,0,8984,8986,1,0,0,0,8985,8983,1,0,0,0,8986,9079,3,1162,581,10,8987,
  	8988,10,8,0,0,8988,8992,7,35,0,0,8989,8991,3,1240,620,0,8990,8989,1,0,
  	0,0,8991,8994,1,0,0,0,8992,8990,1,0,0,0,8992,8993,1,0,0,0,8993,8995,1,
  	0,0,0,8994,8992,1,0,0,0,8995,9079,3,1162,581,9,8996,8997,10,7,0,0,8997,
  	9001,5,356,0,0,8998,9000,3,1240,620,0,8999,8998,1,0,0,0,9000,9003,1,0,
  	0,0,9001,8999,1,0,0,0,9001,9002,1,0,0,0,9002,9004,1,0,0,0,9003,9001,1,
  	0,0,0,9004,9079,3,1162,581,8,9005,9006,10,6,0,0,9006,9010,5,235,0,0,9007,
  	9009,3,1240,620,0,9008,9007,1,0,0,0,9009,9012,1,0,0,0,9010,9008,1,0,0,
  	0,9010,9011,1,0,0,0,9011,9013,1,0,0,0,9012,9010,1,0,0,0,9013,9079,3,1162,
  	581,7,9014,9015,10,5,0,0,9015,9019,5,236,0,0,9016,9018,3,1240,620,0,9017,
  	9016,1,0,0,0,9018,9021,1,0,0,0,9019,9017,1,0,0,0,9019,9020,1,0,0,0,9020,
  	9022,1,0,0,0,9021,9019,1,0,0,0,9022,9079,3,1162,581,6,9023,9028,10,4,
  	0,0,9024,9025,5,235,0,0,9025,9027,3,1162,581,0,9026,9024,1,0,0,0,9027,
  	9030,1,0,0,0,9028,9026,1,0,0,0,9028,9029,1,0,0,0,9029,9031,1,0,0,0,9030,
  	9028,1,0,0,0,9031,9035,5,1,0,0,9032,9034,3,1240,620,0,9033,9032,1,0,0,
  	0,9034,9037,1,0,0,0,9035,9033,1,0,0,0,9035,9036,1,0,0,0,9036,9038,1,0,
  	0,0,9037,9035,1,0,0,0,9038,9039,3,1162,581,0,9039,9040,5,33,0,0,9040,
  	9041,3,1162,581,4,9041,9079,1,0,0,0,9042,9043,10,3,0,0,9043,9047,7,36,
  	0,0,9044,9046,3,1240,620,0,9045,9044,1,0,0,0,9046,9049,1,0,0,0,9047,9045,
  	1,0,0,0,9047,9048,1,0,0,0,9048,9050,1,0,0,0,9049,9047,1,0,0,0,9050,9079,
  	3,1162,581,3,9051,9052,10,2,0,0,9052,9053,5,306,0,0,9053,9058,3,842,421,
  	0,9054,9055,5,235,0,0,9055,9057,3,1162,581,0,9056,9054,1,0,0,0,9057,9060,
  	1,0,0,0,9058,9056,1,0,0,0,9058,9059,1,0,0,0,9059,9061,1,0,0,0,9060,9058,
  	1,0,0,0,9061,9065,5,1,0,0,9062,9064,3,1240,620,0,9063,9062,1,0,0,0,9064,
  	9067,1,0,0,0,9065,9063,1,0,0,0,9065,9066,1,0,0,0,9066,9068,1,0,0,0,9067,
  	9065,1,0,0,0,9068,9069,3,1162,581,0,9069,9070,5,33,0,0,9070,9071,3,1162,
  	581,3,9071,9079,1,0,0,0,9072,9073,10,1,0,0,9073,9074,5,324,0,0,9074,9075,
  	5,85,0,0,9075,9076,3,570,285,0,9076,9077,5,86,0,0,9077,9079,1,0,0,0,9078,
  	8924,1,0,0,0,9078,8933,1,0,0,0,9078,8942,1,0,0,0,9078,8951,1,0,0,0,9078,
  	8960,1,0,0,0,9078,8969,1,0,0,0,9078,8978,1,0,0,0,9078,8987,1,0,0,0,9078,
  	8996,1,0,0,0,9078,9005,1,0,0,0,9078,9014,1,0,0,0,9078,9023,1,0,0,0,9078,
  	9042,1,0,0,0,9078,9051,1,0,0,0,9078,9072,1,0,0,0,9079,9082,1,0,0,0,9080,
  	9078,1,0,0,0,9080,9081,1,0,0,0,9081,1163,1,0,0,0,9082,9080,1,0,0,0,9083,
  	9091,3,1162,581,0,9084,9085,5,110,0,0,9085,9086,3,1162,581,0,9086,9087,
  	5,33,0,0,9087,9088,3,1162,581,0,9088,9089,5,111,0,0,9089,9091,1,0,0,0,
  	9090,9083,1,0,0,0,9090,9084,1,0,0,0,9091,1165,1,0,0,0,9092,9098,3,1162,
  	581,0,9093,9094,5,33,0,0,9094,9095,3,1162,581,0,9095,9096,5,33,0,0,9096,
  	9097,3,1162,581,0,9097,9099,1,0,0,0,9098,9093,1,0,0,0,9098,9099,1,0,0,
  	0,9099,1167,1,0,0,0,9100,9101,6,584,-1,0,9101,9112,3,1184,592,0,9102,
  	9106,3,1232,616,0,9103,9105,3,1240,620,0,9104,9103,1,0,0,0,9105,9108,
  	1,0,0,0,9106,9104,1,0,0,0,9106,9107,1,0,0,0,9107,9109,1,0,0,0,9108,9106,
  	1,0,0,0,9109,9110,3,1184,592,0,9110,9112,1,0,0,0,9111,9100,1,0,0,0,9111,
  	9102,1,0,0,0,9112,9137,1,0,0,0,9113,9114,10,2,0,0,9114,9118,3,1234,617,
  	0,9115,9117,3,1240,620,0,9116,9115,1,0,0,0,9117,9120,1,0,0,0,9118,9116,
  	1,0,0,0,9118,9119,1,0,0,0,9119,9121,1,0,0,0,9120,9118,1,0,0,0,9121,9122,
  	3,1168,584,3,9122,9136,1,0,0,0,9123,9124,10,1,0,0,9124,9128,3,1146,573,
  	0,9125,9127,3,1240,620,0,9126,9125,1,0,0,0,9127,9130,1,0,0,0,9128,9126,
  	1,0,0,0,9128,9129,1,0,0,0,9129,9131,1,0,0,0,9130,9128,1,0,0,0,9131,9132,
  	3,1168,584,0,9132,9133,5,33,0,0,9133,9134,3,1168,584,2,9134,9136,1,0,
  	0,0,9135,9113,1,0,0,0,9135,9123,1,0,0,0,9136,9139,1,0,0,0,9137,9135,1,
  	0,0,0,9137,9138,1,0,0,0,9138,1169,1,0,0,0,9139,9137,1,0,0,0,9140,9146,
  	3,1168,584,0,9141,9142,5,33,0,0,9142,9143,3,1168,584,0,9143,9144,5,33,
  	0,0,9144,9145,3,1168,584,0,9145,9147,1,0,0,0,9146,9141,1,0,0,0,9146,9147,
  	1,0,0,0,9147,1171,1,0,0,0,9148,9151,3,1162,581,0,9149,9151,3,1174,587,
  	0,9150,9148,1,0,0,0,9150,9149,1,0,0,0,9151,1173,1,0,0,0,9152,9155,3,1158,
  	579,0,9153,9155,3,1180,590,0,9154,9152,1,0,0,0,9154,9153,1,0,0,0,9155,
  	1175,1,0,0,0,9156,9157,7,38,0,0,9157,1177,1,0,0,0,9158,9159,7,39,0,0,
  	9159,1179,1,0,0,0,9160,9161,3,1162,581,0,9161,9162,3,1176,588,0,9162,
  	9163,3,1144,572,0,9163,1181,1,0,0,0,9164,9208,3,1218,609,0,9165,9168,
  	3,1252,626,0,9166,9168,3,260,130,0,9167,9165,1,0,0,0,9167,9166,1,0,0,
  	0,9167,9168,1,0,0,0,9168,9169,1,0,0,0,9169,9170,3,1248,624,0,9170,9175,
  	3,1216,608,0,9171,9172,5,110,0,0,9172,9173,3,1154,577,0,9173,9174,5,111,
  	0,0,9174,9176,1,0,0,0,9175,9171,1,0,0,0,9175,9176,1,0,0,0,9176,9208,1,
  	0,0,0,9177,9182,3,1088,544,0,9178,9179,5,110,0,0,9179,9180,3,1154,577,
  	0,9180,9181,5,111,0,0,9181,9183,1,0,0,0,9182,9178,1,0,0,0,9182,9183,1,
  	0,0,0,9183,9208,1,0,0,0,9184,9189,3,1092,546,0,9185,9186,5,110,0,0,9186,
  	9187,3,1154,577,0,9187,9188,5,111,0,0,9188,9190,1,0,0,0,9189,9185,1,0,
  	0,0,9189,9190,1,0,0,0,9190,9208,1,0,0,0,9191,9208,3,1114,557,0,9192,9208,
  	3,1220,610,0,9193,9208,3,856,428,0,9194,9208,3,294,147,0,9195,9208,3,
  	1194,597,0,9196,9197,5,43,0,0,9197,9203,3,1144,572,0,9198,9199,5,33,0,
  	0,9199,9200,3,1144,572,0,9200,9201,5,33,0,0,9201,9202,3,1144,572,0,9202,
  	9204,1,0,0,0,9203,9198,1,0,0,0,9203,9204,1,0,0,0,9204,9205,1,0,0,0,9205,
  	9206,5,44,0,0,9206,9208,1,0,0,0,9207,9164,1,0,0,0,9207,9167,1,0,0,0,9207,
  	9177,1,0,0,0,9207,9184,1,0,0,0,9207,9191,1,0,0,0,9207,9192,1,0,0,0,9207,
  	9193,1,0,0,0,9207,9194,1,0,0,0,9207,9195,1,0,0,0,9207,9196,1,0,0,0,9208,
  	1183,1,0,0,0,9209,9219,3,1236,618,0,9210,9219,3,1248,624,0,9211,9219,
  	3,1094,547,0,9212,9219,3,1096,548,0,9213,9219,3,1114,557,0,9214,9215,
  	5,43,0,0,9215,9216,3,1170,585,0,9216,9217,5,44,0,0,9217,9219,1,0,0,0,
  	9218,9209,1,0,0,0,9218,9210,1,0,0,0,9218,9211,1,0,0,0,9218,9212,1,0,0,
  	0,9218,9213,1,0,0,0,9218,9214,1,0,0,0,9219,1185,1,0,0,0,9220,9221,3,1206,
  	603,0,9221,9222,5,35,0,0,9222,9229,1,0,0,0,9223,9229,3,260,130,0,9224,
  	9229,3,1252,626,0,9225,9229,3,1194,597,0,9226,9227,5,79,0,0,9227,9229,
  	5,32,0,0,9228,9220,1,0,0,0,9228,9223,1,0,0,0,9228,9224,1,0,0,0,9228,9225,
  	1,0,0,0,9228,9226,1,0,0,0,9228,9229,1,0,0,0,9229,9231,1,0,0,0,9230,9232,
  	3,1196,598,0,9231,9230,1,0,0,0,9231,9232,1,0,0,0,9232,9233,1,0,0,0,9233,
  	9247,3,1248,624,0,9234,9235,5,110,0,0,9235,9236,3,1144,572,0,9236,9237,
  	5,111,0,0,9237,9239,1,0,0,0,9238,9234,1,0,0,0,9239,9242,1,0,0,0,9240,
  	9238,1,0,0,0,9240,9241,1,0,0,0,9241,9243,1,0,0,0,9242,9240,1,0,0,0,9243,
  	9244,5,35,0,0,9244,9246,3,1248,624,0,9245,9240,1,0,0,0,9246,9249,1,0,
  	0,0,9247,9245,1,0,0,0,9247,9248,1,0,0,0,9248,9253,1,0,0,0,9249,9247,1,
  	0,0,0,9250,9252,3,1240,620,0,9251,9250,1,0,0,0,9252,9255,1,0,0,0,9253,
  	9251,1,0,0,0,9253,9254,1,0,0,0,9254,9261,1,0,0,0,9255,9253,1,0,0,0,9256,
  	9257,5,43,0,0,9257,9258,3,1118,559,0,9258,9259,5,44,0,0,9259,9262,1,0,
  	0,0,9260,9262,3,1210,605,0,9261,9256,1,0,0,0,9261,9260,1,0,0,0,9262,9265,
  	1,0,0,0,9263,9264,5,35,0,0,9264,9266,3,1122,561,0,9265,9263,1,0,0,0,9265,
  	9266,1,0,0,0,9266,1187,1,0,0,0,9267,9301,3,1218,609,0,9268,9301,3,1186,
  	593,0,9269,9272,3,1086,543,0,9270,9272,3,1098,549,0,9271,9269,1,0,0,0,
  	9271,9270,1,0,0,0,9272,9277,1,0,0,0,9273,9274,5,110,0,0,9274,9275,3,1172,
  	586,0,9275,9276,5,111,0,0,9276,9278,1,0,0,0,9277,9273,1,0,0,0,9277,9278,
  	1,0,0,0,9278,9301,1,0,0,0,9279,9301,3,1222,611,0,9280,9301,3,852,426,
  	0,9281,9301,3,1100,550,0,9282,9301,3,1264,632,0,9283,9284,3,262,131,0,
  	9284,9285,5,32,0,0,9285,9286,3,1122,561,0,9286,9301,1,0,0,0,9287,9301,
  	3,1190,595,0,9288,9301,3,1194,597,0,9289,9301,3,1200,600,0,9290,9301,
  	3,1112,556,0,9291,9301,3,1128,564,0,9292,9293,5,43,0,0,9293,9294,3,1162,
  	581,0,9294,9295,5,33,0,0,9295,9296,3,1162,581,0,9296,9297,5,33,0,0,9297,
  	9298,3,1162,581,0,9298,9299,5,44,0,0,9299,9301,1,0,0,0,9300,9267,1,0,
  	0,0,9300,9268,1,0,0,0,9300,9271,1,0,0,0,9300,9279,1,0,0,0,9300,9280,1,
  	0,0,0,9300,9281,1,0,0,0,9300,9282,1,0,0,0,9300,9283,1,0,0,0,9300,9287,
  	1,0,0,0,9300,9288,1,0,0,0,9300,9289,1,0,0,0,9300,9290,1,0,0,0,9300,9291,
  	1,0,0,0,9300,9292,1,0,0,0,9301,1189,1,0,0,0,9302,9303,5,326,0,0,9303,
  	1191,1,0,0,0,9304,9305,5,82,0,0,9305,1193,1,0,0,0,9306,9307,5,166,0,0,
  	9307,1195,1,0,0,0,9308,9309,5,327,0,0,9309,9310,5,35,0,0,9310,1197,1,
  	0,0,0,9311,9312,5,326,0,0,9312,9313,5,35,0,0,9313,9314,5,82,0,0,9314,
  	1199,1,0,0,0,9315,9316,5,325,0,0,9316,1201,1,0,0,0,9317,9318,5,18,0,0,
  	9318,9322,3,1204,602,0,9319,9320,5,19,0,0,9320,9322,3,1204,602,0,9321,
  	9317,1,0,0,0,9321,9319,1,0,0,0,9322,1203,1,0,0,0,9323,9324,5,368,0,0,
  	9324,1205,1,0,0,0,9325,9329,3,1190,595,0,9326,9329,3,1192,596,0,9327,
  	9329,3,1198,599,0,9328,9325,1,0,0,0,9328,9326,1,0,0,0,9328,9327,1,0,0,
  	0,9329,1207,1,0,0,0,9330,9331,5,110,0,0,9331,9332,3,1162,581,0,9332,9333,
  	5,111,0,0,9333,9335,1,0,0,0,9334,9330,1,0,0,0,9335,9338,1,0,0,0,9336,
  	9334,1,0,0,0,9336,9337,1,0,0,0,9337,1209,1,0,0,0,9338,9336,1,0,0,0,9339,
  	9340,5,35,0,0,9340,9341,3,1248,624,0,9341,9342,3,1208,604,0,9342,9344,
  	1,0,0,0,9343,9339,1,0,0,0,9344,9347,1,0,0,0,9345,9343,1,0,0,0,9345,9346,
  	1,0,0,0,9346,9348,1,0,0,0,9347,9345,1,0,0,0,9348,9349,5,35,0,0,9349,9351,
  	3,1248,624,0,9350,9345,1,0,0,0,9350,9351,1,0,0,0,9351,9352,1,0,0,0,9352,
  	9357,3,1208,604,0,9353,9354,5,110,0,0,9354,9355,3,1174,587,0,9355,9356,
  	5,111,0,0,9356,9358,1,0,0,0,9357,9353,1,0,0,0,9357,9358,1,0,0,0,9358,
  	1211,1,0,0,0,9359,9360,5,35,0,0,9360,9361,3,1248,624,0,9361,9362,3,1208,
  	604,0,9362,9364,1,0,0,0,9363,9359,1,0,0,0,9364,9367,1,0,0,0,9365,9363,
  	1,0,0,0,9365,9366,1,0,0,0,9366,9368,1,0,0,0,9367,9365,1,0,0,0,9368,9369,
  	5,35,0,0,9369,9371,3,1248,624,0,9370,9365,1,0,0,0,9370,9371,1,0,0,0,9371,
  	9372,1,0,0,0,9372,9373,3,1208,604,0,9373,1213,1,0,0,0,9374,9375,5,110,
  	0,0,9375,9376,3,1144,572,0,9376,9377,5,111,0,0,9377,9379,1,0,0,0,9378,
  	9374,1,0,0,0,9379,9382,1,0,0,0,9380,9378,1,0,0,0,9380,9381,1,0,0,0,9381,
  	1215,1,0,0,0,9382,9380,1,0,0,0,9383,9384,5,35,0,0,9384,9385,3,1248,624,
  	0,9385,9386,3,1214,607,0,9386,9388,1,0,0,0,9387,9383,1,0,0,0,9388,9391,
  	1,0,0,0,9389,9387,1,0,0,0,9389,9390,1,0,0,0,9390,9392,1,0,0,0,9391,9389,
  	1,0,0,0,9392,9393,5,35,0,0,9393,9395,3,1248,624,0,9394,9389,1,0,0,0,9394,
  	9395,1,0,0,0,9395,9396,1,0,0,0,9396,9401,3,1214,607,0,9397,9398,5,110,
  	0,0,9398,9399,3,1156,578,0,9399,9400,5,111,0,0,9400,9402,1,0,0,0,9401,
  	9397,1,0,0,0,9401,9402,1,0,0,0,9402,1217,1,0,0,0,9403,9409,3,1236,618,
  	0,9404,9409,3,1202,601,0,9405,9409,3,1238,619,0,9406,9409,3,242,121,0,
  	9407,9409,3,1248,624,0,9408,9403,1,0,0,0,9408,9404,1,0,0,0,9408,9405,
  	1,0,0,0,9408,9406,1,0,0,0,9408,9407,1,0,0,0,9409,1219,1,0,0,0,9410,9411,
  	3,234,117,0,9411,9418,5,316,0,0,9412,9413,5,43,0,0,9413,9414,3,1144,572,
  	0,9414,9415,5,44,0,0,9415,9419,1,0,0,0,9416,9419,3,1088,544,0,9417,9419,
  	3,1092,546,0,9418,9412,1,0,0,0,9418,9416,1,0,0,0,9418,9417,1,0,0,0,9419,
  	1221,1,0,0,0,9420,9421,3,234,117,0,9421,9428,5,316,0,0,9422,9423,5,43,
  	0,0,9423,9424,3,1162,581,0,9424,9425,5,44,0,0,9425,9429,1,0,0,0,9426,
  	9429,3,1086,543,0,9427,9429,3,1098,549,0,9428,9422,1,0,0,0,9428,9426,
  	1,0,0,0,9428,9427,1,0,0,0,9429,1223,1,0,0,0,9430,9431,3,1256,628,0,9431,
  	9432,3,1216,608,0,9432,9449,1,0,0,0,9433,9434,5,85,0,0,9434,9439,3,1224,
  	612,0,9435,9436,5,30,0,0,9436,9438,3,1224,612,0,9437,9435,1,0,0,0,9438,
  	9441,1,0,0,0,9439,9437,1,0,0,0,9439,9440,1,0,0,0,9440,9442,1,0,0,0,9441,
  	9439,1,0,0,0,9442,9443,5,86,0,0,9443,9449,1,0,0,0,9444,9446,3,854,427,
  	0,9445,9444,1,0,0,0,9445,9446,1,0,0,0,9446,9447,1,0,0,0,9447,9449,3,858,
  	429,0,9448,9430,1,0,0,0,9448,9433,1,0,0,0,9448,9445,1,0,0,0,9449,1225,
  	1,0,0,0,9450,9451,3,1206,603,0,9451,9452,5,35,0,0,9452,9455,1,0,0,0,9453,
  	9455,3,1252,626,0,9454,9450,1,0,0,0,9454,9453,1,0,0,0,9454,9455,1,0,0,
  	0,9455,9456,1,0,0,0,9456,9457,3,1256,628,0,9457,9458,3,1210,605,0,9458,
  	9476,1,0,0,0,9459,9460,5,85,0,0,9460,9465,3,1226,613,0,9461,9462,5,30,
  	0,0,9462,9464,3,1226,613,0,9463,9461,1,0,0,0,9464,9467,1,0,0,0,9465,9463,
  	1,0,0,0,9465,9466,1,0,0,0,9466,9468,1,0,0,0,9467,9465,1,0,0,0,9468,9469,
  	5,86,0,0,9469,9476,1,0,0,0,9470,9472,3,854,427,0,9471,9470,1,0,0,0,9471,
  	9472,1,0,0,0,9472,9473,1,0,0,0,9473,9476,3,860,430,0,9474,9476,3,1100,
  	550,0,9475,9454,1,0,0,0,9475,9459,1,0,0,0,9475,9471,1,0,0,0,9475,9474,
  	1,0,0,0,9476,1227,1,0,0,0,9477,9478,3,1206,603,0,9478,9479,5,35,0,0,9479,
  	9482,1,0,0,0,9480,9482,3,1252,626,0,9481,9477,1,0,0,0,9481,9480,1,0,0,
  	0,9481,9482,1,0,0,0,9482,9485,1,0,0,0,9483,9486,3,1248,624,0,9484,9486,
  	3,1246,623,0,9485,9483,1,0,0,0,9485,9484,1,0,0,0,9486,9487,1,0,0,0,9487,
  	9488,3,1212,606,0,9488,1229,1,0,0,0,9489,9490,7,37,0,0,9490,1231,1,0,
  	0,0,9491,9501,5,230,0,0,9492,9501,5,365,0,0,9493,9501,5,355,0,0,9494,
  	9501,5,358,0,0,9495,9501,5,356,0,0,9496,9501,5,357,0,0,9497,9501,5,366,
  	0,0,9498,9501,5,359,0,0,9499,9501,5,367,0,0,9500,9491,1,0,0,0,9500,9492,
  	1,0,0,0,9500,9493,1,0,0,0,9500,9494,1,0,0,0,9500,9495,1,0,0,0,9500,9496,
  	1,0,0,0,9500,9497,1,0,0,0,9500,9498,1,0,0,0,9500,9499,1,0,0,0,9501,1233,
  	1,0,0,0,9502,9512,5,180,0,0,9503,9512,5,181,0,0,9504,9512,5,235,0,0,9505,
  	9512,5,236,0,0,9506,9512,5,355,0,0,9507,9512,5,356,0,0,9508,9512,5,366,
  	0,0,9509,9512,5,359,0,0,9510,9512,5,367,0,0,9511,9502,1,0,0,0,9511,9503,
  	1,0,0,0,9511,9504,1,0,0,0,9511,9505,1,0,0,0,9511,9506,1,0,0,0,9511,9507,
  	1,0,0,0,9511,9508,1,0,0,0,9511,9509,1,0,0,0,9511,9510,1,0,0,0,9512,1235,
  	1,0,0,0,9513,9514,7,40,0,0,9514,1237,1,0,0,0,9515,9516,5,316,0,0,9516,
  	9517,5,368,0,0,9517,1239,1,0,0,0,9518,9519,5,189,0,0,9519,9524,3,1242,
  	621,0,9520,9521,5,30,0,0,9521,9523,3,1242,621,0,9522,9520,1,0,0,0,9523,
  	9526,1,0,0,0,9524,9522,1,0,0,0,9524,9525,1,0,0,0,9525,9527,1,0,0,0,9526,
  	9524,1,0,0,0,9527,9528,5,190,0,0,9528,1241,1,0,0,0,9529,9532,3,1244,622,
  	0,9530,9531,5,362,0,0,9531,9533,3,1144,572,0,9532,9530,1,0,0,0,9532,9533,
  	1,0,0,0,9533,1243,1,0,0,0,9534,9535,3,1248,624,0,9535,1245,1,0,0,0,9536,
  	9538,3,1196,598,0,9537,9536,1,0,0,0,9537,9538,1,0,0,0,9538,9539,1,0,0,
  	0,9539,9551,3,1248,624,0,9540,9541,5,110,0,0,9541,9542,3,1144,572,0,9542,
  	9543,5,111,0,0,9543,9545,1,0,0,0,9544,9540,1,0,0,0,9545,9548,1,0,0,0,
  	9546,9544,1,0,0,0,9546,9547,1,0,0,0,9547,9549,1,0,0,0,9548,9546,1,0,0,
  	0,9549,9550,5,35,0,0,9550,9552,3,1248,624,0,9551,9546,1,0,0,0,9552,9553,
  	1,0,0,0,9553,9551,1,0,0,0,9553,9554,1,0,0,0,9554,1247,1,0,0,0,9555,9556,
  	7,41,0,0,9556,1249,1,0,0,0,9557,9559,3,1196,598,0,9558,9557,1,0,0,0,9558,
  	9559,1,0,0,0,9559,9560,1,0,0,0,9560,9574,3,1248,624,0,9561,9562,5,110,
  	0,0,9562,9563,3,1144,572,0,9563,9564,5,111,0,0,9564,9566,1,0,0,0,9565,
  	9561,1,0,0,0,9566,9569,1,0,0,0,9567,9565,1,0,0,0,9567,9568,1,0,0,0,9568,
  	9570,1,0,0,0,9569,9567,1,0,0,0,9570,9571,5,35,0,0,9571,9573,3,1248,624,
  	0,9572,9567,1,0,0,0,9573,9576,1,0,0,0,9574,9572,1,0,0,0,9574,9575,1,0,
  	0,0,9575,1251,1,0,0,0,9576,9574,1,0,0,0,9577,9578,7,5,0,0,9578,9579,5,
  	32,0,0,9579,1253,1,0,0,0,9580,9583,7,5,0,0,9581,9582,5,32,0,0,9582,9584,
  	7,41,0,0,9583,9581,1,0,0,0,9583,9584,1,0,0,0,9584,1255,1,0,0,0,9585,9587,
  	3,1252,626,0,9586,9585,1,0,0,0,9586,9587,1,0,0,0,9587,9588,1,0,0,0,9588,
  	9591,3,1248,624,0,9589,9591,3,1246,623,0,9590,9586,1,0,0,0,9590,9589,
  	1,0,0,0,9591,1257,1,0,0,0,9592,9593,3,1206,603,0,9593,9594,5,35,0,0,9594,
  	9598,1,0,0,0,9595,9598,3,260,130,0,9596,9598,3,1252,626,0,9597,9592,1,
  	0,0,0,9597,9595,1,0,0,0,9597,9596,1,0,0,0,9597,9598,1,0,0,0,9598,9600,
  	1,0,0,0,9599,9601,3,1196,598,0,9600,9599,1,0,0,0,9600,9601,1,0,0,0,9601,
  	9602,1,0,0,0,9602,9616,3,1248,624,0,9603,9604,5,110,0,0,9604,9605,3,1144,
  	572,0,9605,9606,5,111,0,0,9606,9608,1,0,0,0,9607,9603,1,0,0,0,9608,9611,
  	1,0,0,0,9609,9607,1,0,0,0,9609,9610,1,0,0,0,9610,9612,1,0,0,0,9611,9609,
  	1,0,0,0,9612,9613,5,35,0,0,9613,9615,3,1248,624,0,9614,9609,1,0,0,0,9615,
  	9618,1,0,0,0,9616,9614,1,0,0,0,9616,9617,1,0,0,0,9617,1259,1,0,0,0,9618,
  	9616,1,0,0,0,9619,9620,3,1258,629,0,9620,1261,1,0,0,0,9621,9622,5,79,
  	0,0,9622,9625,5,32,0,0,9623,9625,3,1252,626,0,9624,9621,1,0,0,0,9624,
  	9623,1,0,0,0,9624,9625,1,0,0,0,9625,9626,1,0,0,0,9626,9627,3,1248,624,
  	0,9627,1263,1,0,0,0,9628,9640,3,1266,633,0,9629,9636,5,43,0,0,9630,9633,
  	3,1118,559,0,9631,9632,5,30,0,0,9632,9634,3,904,452,0,9633,9631,1,0,0,
  	0,9633,9634,1,0,0,0,9634,9637,1,0,0,0,9635,9637,3,236,118,0,9636,9630,
  	1,0,0,0,9636,9635,1,0,0,0,9637,9638,1,0,0,0,9638,9639,5,44,0,0,9639,9641,
  	1,0,0,0,9640,9629,1,0,0,0,9640,9641,1,0,0,0,9641,1265,1,0,0,0,9642,9643,
  	5,166,0,0,9643,9648,5,368,0,0,9644,9645,5,166,0,0,9645,9647,5,368,0,0,
  	9646,9644,1,0,0,0,9647,9650,1,0,0,0,9648,9646,1,0,0,0,9648,9649,1,0,0,
  	0,9649,9662,1,0,0,0,9650,9648,1,0,0,0,9651,9652,5,166,0,0,9652,9662,5,
  	117,0,0,9653,9654,5,166,0,0,9654,9662,5,123,0,0,9655,9656,5,166,0,0,9656,
  	9662,5,147,0,0,9657,9658,5,166,0,0,9658,9662,5,148,0,0,9659,9660,5,166,
  	0,0,9660,9662,5,191,0,0,9661,9642,1,0,0,0,9661,9651,1,0,0,0,9661,9653,
  	1,0,0,0,9661,9655,1,0,0,0,9661,9657,1,0,0,0,9661,9659,1,0,0,0,9662,1267,
  	1,0,0,0,9663,9706,3,1276,638,0,9664,9706,3,1288,644,0,9665,9666,5,406,
  	0,0,9666,9670,5,368,0,0,9667,9671,3,1236,618,0,9668,9671,5,368,0,0,9669,
  	9671,5,19,0,0,9670,9667,1,0,0,0,9670,9668,1,0,0,0,9670,9669,1,0,0,0,9670,
  	9671,1,0,0,0,9671,9706,1,0,0,0,9672,9706,3,1278,639,0,9673,9706,3,1280,
  	640,0,9674,9706,3,1282,641,0,9675,9706,3,1284,642,0,9676,9706,3,1286,
  	643,0,9677,9706,3,1334,667,0,9678,9706,3,1332,666,0,9679,9706,3,1336,
  	668,0,9680,9706,3,1338,669,0,9681,9706,3,1340,670,0,9682,9706,3,1342,
  	671,0,9683,9706,3,1294,647,0,9684,9706,3,1296,648,0,9685,9706,3,1298,
  	649,0,9686,9706,3,1300,650,0,9687,9706,3,1302,651,0,9688,9706,3,1304,
  	652,0,9689,9706,3,1306,653,0,9690,9706,3,1320,660,0,9691,9706,3,1322,
  	661,0,9692,9706,3,1324,662,0,9693,9706,3,1326,663,0,9694,9706,3,1328,
  	664,0,9695,9706,3,1330,665,0,9696,9706,3,1308,654,0,9697,9706,3,1310,
  	655,0,9698,9706,3,1312,656,0,9699,9706,3,1314,657,0,9700,9706,3,1316,
  	658,0,9701,9706,3,1318,659,0,9702,9706,3,1290,645,0,9703,9706,3,1292,
  	646,0,9704,9706,3,1270,635,0,9705,9663,1,0,0,0,9705,9664,1,0,0,0,9705,
  	9665,1,0,0,0,9705,9672,1,0,0,0,9705,9673,1,0,0,0,9705,9674,1,0,0,0,9705,
  	9675,1,0,0,0,9705,9676,1,0,0,0,9705,9677,1,0,0,0,9705,9678,1,0,0,0,9705,
  	9679,1,0,0,0,9705,9680,1,0,0,0,9705,9681,1,0,0,0,9705,9682,1,0,0,0,9705,
  	9683,1,0,0,0,9705,9684,1,0,0,0,9705,9685,1,0,0,0,9705,9686,1,0,0,0,9705,
  	9687,1,0,0,0,9705,9688,1,0,0,0,9705,9689,1,0,0,0,9705,9690,1,0,0,0,9705,
  	9691,1,0,0,0,9705,9692,1,0,0,0,9705,9693,1,0,0,0,9705,9694,1,0,0,0,9705,
  	9695,1,0,0,0,9705,9696,1,0,0,0,9705,9697,1,0,0,0,9705,9698,1,0,0,0,9705,
  	9699,1,0,0,0,9705,9700,1,0,0,0,9705,9701,1,0,0,0,9705,9702,1,0,0,0,9705,
  	9703,1,0,0,0,9705,9704,1,0,0,0,9706,1269,1,0,0,0,9707,9708,5,405,0,0,
  	9708,9717,5,368,0,0,9709,9714,3,1272,636,0,9710,9711,5,30,0,0,9711,9713,
  	3,1272,636,0,9712,9710,1,0,0,0,9713,9716,1,0,0,0,9714,9712,1,0,0,0,9714,
  	9715,1,0,0,0,9715,9718,1,0,0,0,9716,9714,1,0,0,0,9717,9709,1,0,0,0,9717,
  	9718,1,0,0,0,9718,1271,1,0,0,0,9719,9727,5,368,0,0,9720,9721,5,368,0,
  	0,9721,9722,5,362,0,0,9722,9727,3,1274,637,0,9723,9727,3,1274,637,0,9724,
  	9727,5,223,0,0,9725,9727,5,224,0,0,9726,9719,1,0,0,0,9726,9720,1,0,0,
  	0,9726,9723,1,0,0,0,9726,9724,1,0,0,0,9726,9725,1,0,0,0,9727,1273,1,0,
  	0,0,9728,9729,5,43,0,0,9729,9734,3,1272,636,0,9730,9731,5,30,0,0,9731,
  	9733,3,1272,636,0,9732,9730,1,0,0,0,9733,9736,1,0,0,0,9734,9732,1,0,0,
  	0,9734,9735,1,0,0,0,9735,9737,1,0,0,0,9736,9734,1,0,0,0,9737,9738,5,44,
  	0,0,9738,9743,1,0,0,0,9739,9743,3,1236,618,0,9740,9743,3,242,121,0,9741,
  	9743,5,368,0,0,9742,9728,1,0,0,0,9742,9739,1,0,0,0,9742,9740,1,0,0,0,
  	9742,9741,1,0,0,0,9743,1275,1,0,0,0,9744,9745,5,370,0,0,9745,9746,5,18,
  	0,0,9746,9747,5,368,0,0,9747,9748,5,178,0,0,9748,9749,5,18,0,0,9749,9750,
  	5,368,0,0,9750,1277,1,0,0,0,9751,9752,5,371,0,0,9752,9753,5,20,0,0,9753,
  	1279,1,0,0,0,9754,9755,5,372,0,0,9755,1281,1,0,0,0,9756,9757,5,373,0,
  	0,9757,9758,7,42,0,0,9758,1283,1,0,0,0,9759,9760,5,374,0,0,9760,1285,
  	1,0,0,0,9761,9764,5,377,0,0,9762,9765,5,368,0,0,9763,9765,3,272,136,0,
  	9764,9762,1,0,0,0,9764,9763,1,0,0,0,9765,1287,1,0,0,0,9766,9767,5,404,
  	0,0,9767,1289,1,0,0,0,9768,9769,5,375,0,0,9769,1291,1,0,0,0,9770,9771,
  	5,376,0,0,9771,1293,1,0,0,0,9772,9773,5,386,0,0,9773,1295,1,0,0,0,9774,
  	9775,5,393,0,0,9775,1297,1,0,0,0,9776,9777,5,394,0,0,9777,1299,1,0,0,
  	0,9778,9779,5,395,0,0,9779,1301,1,0,0,0,9780,9781,5,396,0,0,9781,1303,
  	1,0,0,0,9782,9783,5,397,0,0,9783,1305,1,0,0,0,9784,9785,5,398,0,0,9785,
  	1307,1,0,0,0,9786,9787,5,387,0,0,9787,1309,1,0,0,0,9788,9789,5,388,0,
  	0,9789,1311,1,0,0,0,9790,9791,5,389,0,0,9791,1313,1,0,0,0,9792,9793,5,
  	390,0,0,9793,1315,1,0,0,0,9794,9795,5,391,0,0,9795,1317,1,0,0,0,9796,
  	9797,5,392,0,0,9797,1319,1,0,0,0,9798,9799,5,399,0,0,9799,1321,1,0,0,
  	0,9800,9801,5,400,0,0,9801,1323,1,0,0,0,9802,9803,5,401,0,0,9803,1325,
  	1,0,0,0,9804,9805,5,402,0,0,9805,1327,1,0,0,0,9806,9807,5,384,0,0,9807,
  	1329,1,0,0,0,9808,9809,5,385,0,0,9809,1331,1,0,0,0,9810,9811,5,379,0,
  	0,9811,9812,3,1236,618,0,9812,1333,1,0,0,0,9813,9816,5,378,0,0,9814,9817,
  	3,1236,618,0,9815,9817,5,368,0,0,9816,9814,1,0,0,0,9816,9815,1,0,0,0,
  	9817,1335,1,0,0,0,9818,9819,5,380,0,0,9819,1337,1,0,0,0,9820,9821,5,381,
  	0,0,9821,1339,1,0,0,0,9822,9823,5,382,0,0,9823,1341,1,0,0,0,9824,9825,
  	5,383,0,0,9825,1343,1,0,0,0,9826,9827,5,407,0,0,9827,1345,1,0,0,0,9828,
  	9829,5,369,0,0,9829,9830,5,18,0,0,9830,9831,5,20,0,0,9831,9832,5,18,0,
  	0,9832,1347,1,0,0,0,9833,9834,5,62,0,0,9834,9835,3,1248,624,0,9835,9841,
  	5,31,0,0,9836,9837,3,186,93,0,9837,9838,5,31,0,0,9838,9840,1,0,0,0,9839,
  	9836,1,0,0,0,9840,9843,1,0,0,0,9841,9839,1,0,0,0,9841,9842,1,0,0,0,9842,
  	9844,1,0,0,0,9843,9841,1,0,0,0,9844,9848,3,1350,675,0,9845,9847,3,1352,
  	676,0,9846,9845,1,0,0,0,9847,9850,1,0,0,0,9848,9846,1,0,0,0,9848,9849,
  	1,0,0,0,9849,9851,1,0,0,0,9850,9848,1,0,0,0,9851,9854,5,63,0,0,9852,9853,
  	5,33,0,0,9853,9855,3,1248,624,0,9854,9852,1,0,0,0,9854,9855,1,0,0,0,9855,
  	1349,1,0,0,0,9856,9865,5,34,0,0,9857,9858,3,1248,624,0,9858,9859,5,35,
  	0,0,9859,9861,1,0,0,0,9860,9857,1,0,0,0,9860,9861,1,0,0,0,9861,9862,1,
  	0,0,0,9862,9864,3,1248,624,0,9863,9860,1,0,0,0,9864,9867,1,0,0,0,9865,
  	9863,1,0,0,0,9865,9866,1,0,0,0,9866,9868,1,0,0,0,9867,9865,1,0,0,0,9868,
  	9869,5,31,0,0,9869,1351,1,0,0,0,9870,9871,3,1354,677,0,9871,9872,3,1362,
  	681,0,9872,9873,5,31,0,0,9873,9899,1,0,0,0,9874,9875,3,1356,678,0,9875,
  	9876,3,1362,681,0,9876,9877,5,31,0,0,9877,9899,1,0,0,0,9878,9879,3,1356,
  	678,0,9879,9880,3,1364,682,0,9880,9881,5,31,0,0,9881,9899,1,0,0,0,9882,
  	9883,3,1356,678,0,9883,9884,3,1366,683,0,9884,9885,5,31,0,0,9885,9899,
  	1,0,0,0,9886,9887,3,1360,680,0,9887,9888,3,1362,681,0,9888,9889,5,31,
  	0,0,9889,9899,1,0,0,0,9890,9891,3,1360,680,0,9891,9892,3,1364,682,0,9892,
  	9893,5,31,0,0,9893,9899,1,0,0,0,9894,9895,3,1360,680,0,9895,9896,3,1366,
  	683,0,9896,9897,5,31,0,0,9897,9899,1,0,0,0,9898,9870,1,0,0,0,9898,9874,
  	1,0,0,0,9898,9878,1,0,0,0,9898,9882,1,0,0,0,9898,9886,1,0,0,0,9898,9890,
  	1,0,0,0,9898,9894,1,0,0,0,9899,1353,1,0,0,0,9900,9901,5,36,0,0,9901,1355,
  	1,0,0,0,9902,9903,5,37,0,0,9903,9904,3,1358,679,0,9904,1357,1,0,0,0,9905,
  	9910,3,1248,624,0,9906,9907,5,35,0,0,9907,9909,3,1248,624,0,9908,9906,
  	1,0,0,0,9909,9912,1,0,0,0,9910,9908,1,0,0,0,9910,9911,1,0,0,0,9911,1359,
  	1,0,0,0,9912,9910,1,0,0,0,9913,9917,5,38,0,0,9914,9915,3,1248,624,0,9915,
  	9916,5,35,0,0,9916,9918,1,0,0,0,9917,9914,1,0,0,0,9917,9918,1,0,0,0,9918,
  	9919,1,0,0,0,9919,9920,3,1248,624,0,9920,1361,1,0,0,0,9921,9925,5,39,
  	0,0,9922,9924,3,1248,624,0,9923,9922,1,0,0,0,9924,9927,1,0,0,0,9925,9923,
  	1,0,0,0,9925,9926,1,0,0,0,9926,1363,1,0,0,0,9927,9925,1,0,0,0,9928,9932,
  	5,40,0,0,9929,9930,3,1248,624,0,9930,9931,5,35,0,0,9931,9933,1,0,0,0,
  	9932,9929,1,0,0,0,9932,9933,1,0,0,0,9933,9934,1,0,0,0,9934,9935,3,1248,
  	624,0,9935,9936,5,33,0,0,9936,9937,5,62,0,0,9937,9969,1,0,0,0,9938,9939,
  	5,40,0,0,9939,9944,3,616,308,0,9940,9941,5,30,0,0,9941,9943,3,616,308,
  	0,9942,9940,1,0,0,0,9943,9946,1,0,0,0,9944,9942,1,0,0,0,9944,9945,1,0,
  	0,0,9945,9947,1,0,0,0,9946,9944,1,0,0,0,9947,9948,5,33,0,0,9948,9949,
  	5,62,0,0,9949,9969,1,0,0,0,9950,9954,5,40,0,0,9951,9952,3,1248,624,0,
  	9952,9953,5,35,0,0,9953,9955,1,0,0,0,9954,9951,1,0,0,0,9954,9955,1,0,
  	0,0,9955,9956,1,0,0,0,9956,9957,3,1248,624,0,9957,9962,3,616,308,0,9958,
  	9959,5,30,0,0,9959,9961,3,616,308,0,9960,9958,1,0,0,0,9961,9964,1,0,0,
  	0,9962,9960,1,0,0,0,9962,9963,1,0,0,0,9963,9965,1,0,0,0,9964,9962,1,0,
  	0,0,9965,9966,5,33,0,0,9966,9967,5,62,0,0,9967,9969,1,0,0,0,9968,9928,
  	1,0,0,0,9968,9938,1,0,0,0,9968,9950,1,0,0,0,9969,1365,1,0,0,0,9970,9974,
  	5,40,0,0,9971,9972,3,1248,624,0,9972,9973,5,35,0,0,9973,9975,1,0,0,0,
  	9974,9971,1,0,0,0,9974,9975,1,0,0,0,9975,9976,1,0,0,0,9976,10004,3,1248,
  	624,0,9977,9978,5,40,0,0,9978,9983,3,616,308,0,9979,9980,5,30,0,0,9980,
  	9982,3,616,308,0,9981,9979,1,0,0,0,9982,9985,1,0,0,0,9983,9981,1,0,0,
  	0,9983,9984,1,0,0,0,9984,10004,1,0,0,0,9985,9983,1,0,0,0,9986,9990,5,
  	40,0,0,9987,9988,3,1248,624,0,9988,9989,5,35,0,0,9989,9991,1,0,0,0,9990,
  	9987,1,0,0,0,9990,9991,1,0,0,0,9991,9992,1,0,0,0,9992,9993,3,1248,624,
  	0,9993,9998,3,616,308,0,9994,9995,5,30,0,0,9995,9997,3,616,308,0,9996,
  	9994,1,0,0,0,9997,10000,1,0,0,0,9998,9996,1,0,0,0,9998,9999,1,0,0,0,9999,
  	10004,1,0,0,0,10000,9998,1,0,0,0,10001,10002,5,40,0,0,10002,10004,3,610,
  	305,0,10003,9970,1,0,0,0,10003,9977,1,0,0,0,10003,9986,1,0,0,0,10003,
  	10001,1,0,0,0,10004,1367,1,0,0,0,1181,1379,1386,1395,1404,1407,1414,1421,
  	1426,1440,1445,1449,1454,1459,1465,1469,1477,1482,1488,1492,1495,1501,
  	1506,1512,1516,1521,1527,1532,1537,1546,1551,1557,1563,1570,1575,1581,
  	1585,1593,1598,1604,1608,1611,1617,1622,1628,1632,1637,1643,1646,1656,
  	1661,1667,1673,1678,1684,1688,1696,1701,1707,1711,1714,1722,1725,1731,
  	1737,1743,1747,1752,1758,1762,1767,1773,1778,1789,1794,1800,1806,1809,
  	1813,1817,1825,1827,1835,1838,1844,1850,1854,1860,1868,1871,1877,1883,
  	1889,1902,1911,1918,1923,1929,1935,1965,1974,1986,1994,2003,2011,2020,
  	2028,2034,2037,2044,2052,2055,2061,2065,2074,2079,2087,2092,2099,2104,
  	2106,2110,2116,2121,2124,2130,2135,2139,2145,2149,2157,2161,2168,2171,
  	2186,2192,2197,2205,2221,2229,2241,2250,2260,2263,2269,2274,2284,2290,
  	2301,2307,2313,2322,2328,2333,2342,2347,2353,2360,2366,2370,2377,2382,
  	2391,2396,2420,2426,2431,2440,2450,2453,2458,2466,2473,2477,2487,2493,
  	2499,2509,2516,2518,2524,2527,2531,2536,2541,2545,2549,2557,2562,2565,
  	2571,2579,2583,2588,2594,2597,2607,2619,2626,2633,2636,2645,2652,2658,
  	2677,2693,2705,2709,2716,2721,2728,2732,2735,2742,2754,2762,2784,2791,
  	2803,2808,2815,2821,2835,2838,2845,2848,2858,2865,2868,2873,2877,2882,
  	2889,2895,2897,2907,2913,2915,2926,2935,2944,2948,2957,2960,2964,2971,
  	2979,2985,2993,2996,3000,3005,3011,3025,3028,3049,3052,3056,3061,3067,
  	3073,3081,3091,3095,3100,3105,3111,3113,3120,3127,3132,3140,3149,3153,
  	3157,3161,3167,3170,3175,3179,3182,3186,3204,3209,3212,3215,3220,3225,
  	3229,3232,3236,3238,3245,3248,3252,3259,3264,3268,3273,3284,3290,3297,
  	3303,3310,3314,3319,3323,3331,3336,3338,3346,3370,3386,3388,3392,3400,
  	3404,3408,3412,3416,3424,3431,3438,3446,3451,3459,3467,3474,3482,3487,
  	3495,3502,3507,3514,3519,3523,3529,3535,3539,3547,3554,3562,3567,3574,
  	3579,3586,3591,3595,3601,3607,3611,3616,3625,3630,3636,3641,3648,3657,
  	3672,3677,3686,3691,3699,3704,3709,3711,3714,3722,3732,3743,3750,3757,
  	3763,3769,3778,3782,3787,3790,3794,3803,3810,3816,3822,3829,3834,3841,
  	3847,3853,3855,3862,3865,3871,3875,3883,3887,3896,3900,3904,3918,3926,
  	3933,3939,3945,3951,3956,3963,3969,3975,3977,3981,3988,3994,3998,4001,
  	4008,4013,4021,4026,4031,4041,4044,4049,4061,4088,4095,4100,4113,4121,
  	4129,4137,4147,4152,4159,4170,4175,4180,4184,4191,4224,4232,4248,4251,
  	4255,4259,4264,4270,4273,4279,4284,4289,4296,4302,4307,4309,4316,4321,
  	4327,4330,4338,4375,4385,4470,4496,4498,4506,4512,4516,4520,4522,4528,
  	4531,4537,4542,4547,4557,4562,4570,4575,4579,4587,4592,4601,4613,4635,
  	4638,4640,4657,4666,4673,4679,4684,4686,4693,4698,4703,4708,4715,4718,
  	4721,4727,4735,4741,4748,4756,4762,4765,4769,4776,4793,4796,4800,4805,
  	4815,4827,4837,4845,4855,4858,4869,4875,4883,4888,4892,4898,4901,4904,
  	4910,4916,4921,4928,4940,4944,4952,4960,4967,4974,4979,4988,4995,4999,
  	5003,5009,5018,5026,5034,5039,5043,5049,5052,5063,5070,5073,5079,5082,
  	5091,5098,5101,5107,5110,5119,5122,5127,5136,5142,5145,5154,5166,5168,
  	5173,5180,5193,5201,5220,5227,5232,5241,5252,5261,5266,5272,5277,5282,
  	5293,5308,5310,5323,5325,5327,5339,5344,5351,5356,5363,5370,5373,5380,
  	5387,5394,5401,5404,5411,5418,5421,5428,5435,5442,5453,5460,5467,5474,
  	5481,5486,5489,5502,5513,5524,5534,5540,5548,5556,5565,5576,5598,5616,
  	5620,5626,5632,5640,5644,5650,5654,5658,5665,5673,5679,5686,5694,5697,
  	5705,5718,5726,5734,5737,5742,5746,5751,5758,5761,5764,5776,5781,5783,
  	5788,5792,5797,5804,5807,5810,5816,5827,5831,5840,5850,5860,5868,5871,
  	5893,5896,5908,5914,5920,5925,5930,5936,5942,5956,5965,5975,5985,5993,
  	5996,6014,6020,6026,6031,6036,6042,6048,6064,6080,6084,6094,6103,6112,
  	6120,6123,6128,6134,6139,6146,6152,6161,6167,6172,6177,6190,6205,6212,
  	6219,6228,6240,6247,6249,6258,6268,6280,6285,6295,6297,6302,6311,6319,
  	6326,6337,6344,6364,6375,6381,6387,6394,6401,6406,6410,6420,6423,6430,
  	6436,6446,6453,6456,6463,6468,6475,6483,6492,6522,6526,6533,6544,6555,
  	6560,6562,6570,6574,6579,6584,6590,6596,6601,6606,6612,6618,6622,6634,
  	6638,6643,6648,6684,6690,6694,6707,6715,6726,6730,6735,6740,6746,6751,
  	6757,6767,6771,6778,6791,6797,6802,6806,6812,6817,6823,6827,6831,6837,
  	6842,6852,6861,6868,6873,6883,6891,6899,6902,6913,6921,6924,6929,6936,
  	6939,6947,6950,6957,6973,6982,6999,7004,7013,7030,7047,7062,7069,7073,
  	7080,7084,7088,7092,7095,7103,7114,7126,7142,7146,7150,7172,7177,7185,
  	7188,7191,7204,7212,7218,7223,7227,7231,7244,7248,7253,7260,7264,7269,
  	7292,7306,7322,7338,7341,7345,7352,7358,7363,7370,7372,7381,7394,7398,
  	7409,7413,7417,7421,7425,7428,7435,7441,7445,7448,7455,7464,7476,7479,
  	7488,7495,7504,7511,7517,7524,7532,7541,7543,7549,7558,7565,7568,7574,
  	7580,7590,7597,7606,7622,7632,7640,7643,7649,7659,7669,7679,7690,7700,
  	7705,7714,7725,7733,7741,7747,7754,7760,7767,7816,7860,7864,7877,7902,
  	7916,7928,7930,7945,7947,7964,7968,7972,7976,7980,7982,7984,7986,7988,
  	7990,8005,8007,8022,8024,8041,8045,8049,8053,8057,8059,8061,8063,8065,
  	8067,8082,8084,8099,8103,8107,8109,8111,8113,8130,8134,8138,8140,8142,
  	8144,8157,8159,8174,8176,8193,8195,8205,8212,8233,8238,8244,8249,8253,
  	8262,8272,8279,8300,8311,8319,8335,8340,8348,8364,8369,8374,8387,8405,
  	8414,8422,8433,8440,8451,8454,8463,8469,8477,8481,8484,8487,8490,8496,
  	8504,8510,8517,8525,8531,8534,8544,8550,8557,8560,8564,8570,8577,8584,
  	8590,8596,8599,8604,8607,8610,8615,8618,8627,8634,8639,8646,8660,8669,
  	8674,8682,8687,8694,8703,8712,8721,8730,8739,8748,8757,8766,8775,8784,
  	8793,8800,8812,8816,8818,8829,8834,8839,8843,8847,8867,8875,8883,8902,
  	8910,8920,8922,8929,8938,8947,8956,8965,8974,8983,8992,9001,9010,9019,
  	9028,9035,9047,9058,9065,9078,9080,9090,9098,9106,9111,9118,9128,9135,
  	9137,9146,9150,9154,9167,9175,9182,9189,9203,9207,9218,9228,9231,9240,
  	9247,9253,9261,9265,9271,9277,9300,9321,9328,9336,9345,9350,9357,9365,
  	9370,9380,9389,9394,9401,9408,9418,9428,9439,9445,9448,9454,9465,9471,
  	9475,9481,9485,9500,9511,9524,9532,9537,9546,9553,9558,9567,9574,9583,
  	9586,9590,9597,9600,9609,9616,9624,9633,9636,9640,9648,9661,9670,9705,
  	9714,9717,9726,9734,9742,9764,9816,9841,9848,9854,9860,9865,9898,9910,
  	9917,9925,9932,9944,9954,9962,9968,9974,9983,9990,9998,10003
  };
  staticData->serializedATN = antlr4::atn::SerializedATNView(serializedATNSegment, sizeof(serializedATNSegment) / sizeof(serializedATNSegment[0]));

  antlr4::atn::ATNDeserializer deserializer;
  staticData->atn = deserializer.deserialize(staticData->serializedATN);

  const size_t count = staticData->atn->getNumberOfDecisions();
  staticData->decisionToDFA.reserve(count);
  for (size_t i = 0; i < count; i++) { 
    staticData->decisionToDFA.emplace_back(staticData->atn->getDecisionState(i), i);
  }
  sv3_1aparserParserStaticData = std::move(staticData);
}

}

SV3_1aParser::SV3_1aParser(TokenStream *input) : SV3_1aParser(input, antlr4::atn::ParserATNSimulatorOptions()) {}

SV3_1aParser::SV3_1aParser(TokenStream *input, const antlr4::atn::ParserATNSimulatorOptions &options) : Parser(input) {
  SV3_1aParser::initialize();
  _interpreter = new atn::ParserATNSimulator(this, *sv3_1aparserParserStaticData->atn, sv3_1aparserParserStaticData->decisionToDFA, sv3_1aparserParserStaticData->sharedContextCache, options);
}

SV3_1aParser::~SV3_1aParser() {
  delete _interpreter;
}

const atn::ATN& SV3_1aParser::getATN() const {
  return *sv3_1aparserParserStaticData->atn;
}

std::string SV3_1aParser::getGrammarFileName() const {
  return "SV3_1aParser.g4";
}

const std::vector<std::string>& SV3_1aParser::getRuleNames() const {
  return sv3_1aparserParserStaticData->ruleNames;
}

const dfa::Vocabulary& SV3_1aParser::getVocabulary() const {
  return sv3_1aparserParserStaticData->vocabulary;
}

antlr4::atn::SerializedATNView SV3_1aParser::getSerializedATN() const {
  return sv3_1aparserParserStaticData->serializedATN;
}


//----------------- Top_level_ruleContext ------------------------------------------------------------------

SV3_1aParser::Top_level_ruleContext::Top_level_ruleContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::Null_ruleContext* SV3_1aParser::Top_level_ruleContext::null_rule() {
  return getRuleContext<SV3_1aParser::Null_ruleContext>(0);
}

SV3_1aParser::Source_textContext* SV3_1aParser::Top_level_ruleContext::source_text() {
  return getRuleContext<SV3_1aParser::Source_textContext>(0);
}

tree::TerminalNode* SV3_1aParser::Top_level_ruleContext::EOF() {
  return getToken(SV3_1aParser::EOF, 0);
}


size_t SV3_1aParser::Top_level_ruleContext::getRuleIndex() const {
  return SV3_1aParser::RuleTop_level_rule;
}

void SV3_1aParser::Top_level_ruleContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTop_level_rule(this);
}

void SV3_1aParser::Top_level_ruleContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTop_level_rule(this);
}

SV3_1aParser::Top_level_ruleContext* SV3_1aParser::top_level_rule() {
  Top_level_ruleContext *_localctx = _tracker.createInstance<Top_level_ruleContext>(_ctx, getState());
  enterRule(_localctx, 0, SV3_1aParser::RuleTop_level_rule);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1368);
    null_rule();
    setState(1369);
    source_text();
    setState(1370);
    match(SV3_1aParser::EOF);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Top_level_library_ruleContext ------------------------------------------------------------------

SV3_1aParser::Top_level_library_ruleContext::Top_level_library_ruleContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::Null_ruleContext* SV3_1aParser::Top_level_library_ruleContext::null_rule() {
  return getRuleContext<SV3_1aParser::Null_ruleContext>(0);
}

SV3_1aParser::Library_textContext* SV3_1aParser::Top_level_library_ruleContext::library_text() {
  return getRuleContext<SV3_1aParser::Library_textContext>(0);
}

tree::TerminalNode* SV3_1aParser::Top_level_library_ruleContext::EOF() {
  return getToken(SV3_1aParser::EOF, 0);
}


size_t SV3_1aParser::Top_level_library_ruleContext::getRuleIndex() const {
  return SV3_1aParser::RuleTop_level_library_rule;
}

void SV3_1aParser::Top_level_library_ruleContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTop_level_library_rule(this);
}

void SV3_1aParser::Top_level_library_ruleContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTop_level_library_rule(this);
}

SV3_1aParser::Top_level_library_ruleContext* SV3_1aParser::top_level_library_rule() {
  Top_level_library_ruleContext *_localctx = _tracker.createInstance<Top_level_library_ruleContext>(_ctx, getState());
  enterRule(_localctx, 2, SV3_1aParser::RuleTop_level_library_rule);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1372);
    null_rule();
    setState(1373);
    library_text();
    setState(1374);
    match(SV3_1aParser::EOF);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Library_textContext ------------------------------------------------------------------

SV3_1aParser::Library_textContext::Library_textContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<SV3_1aParser::Library_descriptionsContext *> SV3_1aParser::Library_textContext::library_descriptions() {
  return getRuleContexts<SV3_1aParser::Library_descriptionsContext>();
}

SV3_1aParser::Library_descriptionsContext* SV3_1aParser::Library_textContext::library_descriptions(size_t i) {
  return getRuleContext<SV3_1aParser::Library_descriptionsContext>(i);
}


size_t SV3_1aParser::Library_textContext::getRuleIndex() const {
  return SV3_1aParser::RuleLibrary_text;
}

void SV3_1aParser::Library_textContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLibrary_text(this);
}

void SV3_1aParser::Library_textContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLibrary_text(this);
}

SV3_1aParser::Library_textContext* SV3_1aParser::library_text() {
  Library_textContext *_localctx = _tracker.createInstance<Library_textContext>(_ctx, getState());
  enterRule(_localctx, 4, SV3_1aParser::RuleLibrary_text);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1379);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 4611686020977524736) != 0)) {
      setState(1376);
      library_descriptions();
      setState(1381);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Library_descriptionsContext ------------------------------------------------------------------

SV3_1aParser::Library_descriptionsContext::Library_descriptionsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::Library_declarationContext* SV3_1aParser::Library_descriptionsContext::library_declaration() {
  return getRuleContext<SV3_1aParser::Library_declarationContext>(0);
}

SV3_1aParser::Include_statementContext* SV3_1aParser::Library_descriptionsContext::include_statement() {
  return getRuleContext<SV3_1aParser::Include_statementContext>(0);
}

SV3_1aParser::Config_declarationContext* SV3_1aParser::Library_descriptionsContext::config_declaration() {
  return getRuleContext<SV3_1aParser::Config_declarationContext>(0);
}

tree::TerminalNode* SV3_1aParser::Library_descriptionsContext::SEMICOLON() {
  return getToken(SV3_1aParser::SEMICOLON, 0);
}


size_t SV3_1aParser::Library_descriptionsContext::getRuleIndex() const {
  return SV3_1aParser::RuleLibrary_descriptions;
}

void SV3_1aParser::Library_descriptionsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLibrary_descriptions(this);
}

void SV3_1aParser::Library_descriptionsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLibrary_descriptions(this);
}

SV3_1aParser::Library_descriptionsContext* SV3_1aParser::library_descriptions() {
  Library_descriptionsContext *_localctx = _tracker.createInstance<Library_descriptionsContext>(_ctx, getState());
  enterRule(_localctx, 6, SV3_1aParser::RuleLibrary_descriptions);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1386);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SV3_1aParser::LIBRARY: {
        enterOuterAlt(_localctx, 1);
        setState(1382);
        library_declaration();
        break;
      }

      case SV3_1aParser::INCLUDE: {
        enterOuterAlt(_localctx, 2);
        setState(1383);
        include_statement();
        break;
      }

      case SV3_1aParser::CONFIG: {
        enterOuterAlt(_localctx, 3);
        setState(1384);
        config_declaration();
        break;
      }

      case SV3_1aParser::SEMICOLON: {
        enterOuterAlt(_localctx, 4);
        setState(1385);
        match(SV3_1aParser::SEMICOLON);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Library_declarationContext ------------------------------------------------------------------

SV3_1aParser::Library_declarationContext::Library_declarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Library_declarationContext::LIBRARY() {
  return getToken(SV3_1aParser::LIBRARY, 0);
}

SV3_1aParser::IdentifierContext* SV3_1aParser::Library_declarationContext::identifier() {
  return getRuleContext<SV3_1aParser::IdentifierContext>(0);
}

std::vector<SV3_1aParser::File_path_specContext *> SV3_1aParser::Library_declarationContext::file_path_spec() {
  return getRuleContexts<SV3_1aParser::File_path_specContext>();
}

SV3_1aParser::File_path_specContext* SV3_1aParser::Library_declarationContext::file_path_spec(size_t i) {
  return getRuleContext<SV3_1aParser::File_path_specContext>(i);
}

tree::TerminalNode* SV3_1aParser::Library_declarationContext::SEMICOLON() {
  return getToken(SV3_1aParser::SEMICOLON, 0);
}

std::vector<tree::TerminalNode *> SV3_1aParser::Library_declarationContext::COMMA() {
  return getTokens(SV3_1aParser::COMMA);
}

tree::TerminalNode* SV3_1aParser::Library_declarationContext::COMMA(size_t i) {
  return getToken(SV3_1aParser::COMMA, i);
}

tree::TerminalNode* SV3_1aParser::Library_declarationContext::INCDIR() {
  return getToken(SV3_1aParser::INCDIR, 0);
}


size_t SV3_1aParser::Library_declarationContext::getRuleIndex() const {
  return SV3_1aParser::RuleLibrary_declaration;
}

void SV3_1aParser::Library_declarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLibrary_declaration(this);
}

void SV3_1aParser::Library_declarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLibrary_declaration(this);
}

SV3_1aParser::Library_declarationContext* SV3_1aParser::library_declaration() {
  Library_declarationContext *_localctx = _tracker.createInstance<Library_declarationContext>(_ctx, getState());
  enterRule(_localctx, 8, SV3_1aParser::RuleLibrary_declaration);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1388);
    match(SV3_1aParser::LIBRARY);
    setState(1389);
    identifier();
    setState(1390);
    file_path_spec();
    setState(1395);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == SV3_1aParser::COMMA) {
      setState(1391);
      match(SV3_1aParser::COMMA);
      setState(1392);
      file_path_spec();
      setState(1397);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(1407);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SV3_1aParser::INCDIR) {
      setState(1398);
      match(SV3_1aParser::INCDIR);
      setState(1399);
      file_path_spec();
      setState(1404);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == SV3_1aParser::COMMA) {
        setState(1400);
        match(SV3_1aParser::COMMA);
        setState(1401);
        file_path_spec();
        setState(1406);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
    }
    setState(1409);
    match(SV3_1aParser::SEMICOLON);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- File_path_specContext ------------------------------------------------------------------

SV3_1aParser::File_path_specContext::File_path_specContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> SV3_1aParser::File_path_specContext::Simple_identifier() {
  return getTokens(SV3_1aParser::Simple_identifier);
}

tree::TerminalNode* SV3_1aParser::File_path_specContext::Simple_identifier(size_t i) {
  return getToken(SV3_1aParser::Simple_identifier, i);
}

std::vector<tree::TerminalNode *> SV3_1aParser::File_path_specContext::DIV() {
  return getTokens(SV3_1aParser::DIV);
}

tree::TerminalNode* SV3_1aParser::File_path_specContext::DIV(size_t i) {
  return getToken(SV3_1aParser::DIV, i);
}

std::vector<tree::TerminalNode *> SV3_1aParser::File_path_specContext::DOT() {
  return getTokens(SV3_1aParser::DOT);
}

tree::TerminalNode* SV3_1aParser::File_path_specContext::DOT(size_t i) {
  return getToken(SV3_1aParser::DOT, i);
}

std::vector<tree::TerminalNode *> SV3_1aParser::File_path_specContext::STAR() {
  return getTokens(SV3_1aParser::STAR);
}

tree::TerminalNode* SV3_1aParser::File_path_specContext::STAR(size_t i) {
  return getToken(SV3_1aParser::STAR, i);
}

std::vector<tree::TerminalNode *> SV3_1aParser::File_path_specContext::DOTSTAR() {
  return getTokens(SV3_1aParser::DOTSTAR);
}

tree::TerminalNode* SV3_1aParser::File_path_specContext::DOTSTAR(size_t i) {
  return getToken(SV3_1aParser::DOTSTAR, i);
}

std::vector<tree::TerminalNode *> SV3_1aParser::File_path_specContext::QMARK() {
  return getTokens(SV3_1aParser::QMARK);
}

tree::TerminalNode* SV3_1aParser::File_path_specContext::QMARK(size_t i) {
  return getToken(SV3_1aParser::QMARK, i);
}


size_t SV3_1aParser::File_path_specContext::getRuleIndex() const {
  return SV3_1aParser::RuleFile_path_spec;
}

void SV3_1aParser::File_path_specContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFile_path_spec(this);
}

void SV3_1aParser::File_path_specContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFile_path_spec(this);
}

SV3_1aParser::File_path_specContext* SV3_1aParser::file_path_spec() {
  File_path_specContext *_localctx = _tracker.createInstance<File_path_specContext>(_ctx, getState());
  enterRule(_localctx, 10, SV3_1aParser::RuleFile_path_spec);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1412); 
    _errHandler->sync(this);
    _la = _input->LA(1);
    do {
      setState(1411);
      _la = _input->LA(1);
      if (!((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & 35218731827202) != 0) || _la == SV3_1aParser::DIV || _la == SV3_1aParser::DOTSTAR || _la == SV3_1aParser::Simple_identifier)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(1414); 
      _errHandler->sync(this);
      _la = _input->LA(1);
    } while ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 35218731827202) != 0) || _la == SV3_1aParser::DIV || _la == SV3_1aParser::DOTSTAR || _la == SV3_1aParser::Simple_identifier);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Include_statementContext ------------------------------------------------------------------

SV3_1aParser::Include_statementContext::Include_statementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Include_statementContext::INCLUDE() {
  return getToken(SV3_1aParser::INCLUDE, 0);
}

SV3_1aParser::File_path_specContext* SV3_1aParser::Include_statementContext::file_path_spec() {
  return getRuleContext<SV3_1aParser::File_path_specContext>(0);
}

tree::TerminalNode* SV3_1aParser::Include_statementContext::SEMICOLON() {
  return getToken(SV3_1aParser::SEMICOLON, 0);
}


size_t SV3_1aParser::Include_statementContext::getRuleIndex() const {
  return SV3_1aParser::RuleInclude_statement;
}

void SV3_1aParser::Include_statementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInclude_statement(this);
}

void SV3_1aParser::Include_statementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInclude_statement(this);
}

SV3_1aParser::Include_statementContext* SV3_1aParser::include_statement() {
  Include_statementContext *_localctx = _tracker.createInstance<Include_statementContext>(_ctx, getState());
  enterRule(_localctx, 12, SV3_1aParser::RuleInclude_statement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1416);
    match(SV3_1aParser::INCLUDE);
    setState(1417);
    file_path_spec();
    setState(1418);
    match(SV3_1aParser::SEMICOLON);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Source_textContext ------------------------------------------------------------------

SV3_1aParser::Source_textContext::Source_textContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::Timeunits_declarationContext* SV3_1aParser::Source_textContext::timeunits_declaration() {
  return getRuleContext<SV3_1aParser::Timeunits_declarationContext>(0);
}

std::vector<SV3_1aParser::DescriptionContext *> SV3_1aParser::Source_textContext::description() {
  return getRuleContexts<SV3_1aParser::DescriptionContext>();
}

SV3_1aParser::DescriptionContext* SV3_1aParser::Source_textContext::description(size_t i) {
  return getRuleContext<SV3_1aParser::DescriptionContext>(i);
}


size_t SV3_1aParser::Source_textContext::getRuleIndex() const {
  return SV3_1aParser::RuleSource_text;
}

void SV3_1aParser::Source_textContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSource_text(this);
}

void SV3_1aParser::Source_textContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSource_text(this);
}

SV3_1aParser::Source_textContext* SV3_1aParser::source_text() {
  Source_textContext *_localctx = _tracker.createInstance<Source_textContext>(_ctx, getState());
  enterRule(_localctx, 14, SV3_1aParser::RuleSource_text);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1421);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 6, _ctx)) {
    case 1: {
      setState(1420);
      timeunits_declaration();
      break;
    }

    default:
      break;
    }
    setState(1426);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (((((_la - 31) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 31)) & -9214265869835992063) != 0) || ((((_la - 95) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 95)) & 72056495063103375) != 0) || ((((_la - 167) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 167)) & 2251937292484609) != 0) || ((((_la - 268) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 268)) & 6052978636674301953) != 0) || ((((_la - 342) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 342)) & -2305843009408729087) != 0) || _la == SV3_1aParser::BACK_TICK

    || _la == SV3_1aParser::SURELOG_MACRO_NOT_DEFINED) {
      setState(1423);
      description();
      setState(1428);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Null_ruleContext ------------------------------------------------------------------

SV3_1aParser::Null_ruleContext::Null_ruleContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t SV3_1aParser::Null_ruleContext::getRuleIndex() const {
  return SV3_1aParser::RuleNull_rule;
}

void SV3_1aParser::Null_ruleContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNull_rule(this);
}

void SV3_1aParser::Null_ruleContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNull_rule(this);
}

SV3_1aParser::Null_ruleContext* SV3_1aParser::null_rule() {
  Null_ruleContext *_localctx = _tracker.createInstance<Null_ruleContext>(_ctx, getState());
  enterRule(_localctx, 16, SV3_1aParser::RuleNull_rule);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);

   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DescriptionContext ------------------------------------------------------------------

SV3_1aParser::DescriptionContext::DescriptionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::Module_declarationContext* SV3_1aParser::DescriptionContext::module_declaration() {
  return getRuleContext<SV3_1aParser::Module_declarationContext>(0);
}

SV3_1aParser::Udp_declarationContext* SV3_1aParser::DescriptionContext::udp_declaration() {
  return getRuleContext<SV3_1aParser::Udp_declarationContext>(0);
}

SV3_1aParser::Interface_declarationContext* SV3_1aParser::DescriptionContext::interface_declaration() {
  return getRuleContext<SV3_1aParser::Interface_declarationContext>(0);
}

SV3_1aParser::Program_declarationContext* SV3_1aParser::DescriptionContext::program_declaration() {
  return getRuleContext<SV3_1aParser::Program_declarationContext>(0);
}

SV3_1aParser::Package_declarationContext* SV3_1aParser::DescriptionContext::package_declaration() {
  return getRuleContext<SV3_1aParser::Package_declarationContext>(0);
}

SV3_1aParser::Surelog_macro_not_definedContext* SV3_1aParser::DescriptionContext::surelog_macro_not_defined() {
  return getRuleContext<SV3_1aParser::Surelog_macro_not_definedContext>(0);
}

SV3_1aParser::Package_itemContext* SV3_1aParser::DescriptionContext::package_item() {
  return getRuleContext<SV3_1aParser::Package_itemContext>(0);
}

SV3_1aParser::Bind_directiveContext* SV3_1aParser::DescriptionContext::bind_directive() {
  return getRuleContext<SV3_1aParser::Bind_directiveContext>(0);
}

std::vector<SV3_1aParser::Attribute_instanceContext *> SV3_1aParser::DescriptionContext::attribute_instance() {
  return getRuleContexts<SV3_1aParser::Attribute_instanceContext>();
}

SV3_1aParser::Attribute_instanceContext* SV3_1aParser::DescriptionContext::attribute_instance(size_t i) {
  return getRuleContext<SV3_1aParser::Attribute_instanceContext>(i);
}

SV3_1aParser::Config_declarationContext* SV3_1aParser::DescriptionContext::config_declaration() {
  return getRuleContext<SV3_1aParser::Config_declarationContext>(0);
}

SV3_1aParser::Top_directivesContext* SV3_1aParser::DescriptionContext::top_directives() {
  return getRuleContext<SV3_1aParser::Top_directivesContext>(0);
}


size_t SV3_1aParser::DescriptionContext::getRuleIndex() const {
  return SV3_1aParser::RuleDescription;
}

void SV3_1aParser::DescriptionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDescription(this);
}

void SV3_1aParser::DescriptionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDescription(this);
}

SV3_1aParser::DescriptionContext* SV3_1aParser::description() {
  DescriptionContext *_localctx = _tracker.createInstance<DescriptionContext>(_ctx, getState());
  enterRule(_localctx, 18, SV3_1aParser::RuleDescription);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1449);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 10, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1431);
      module_declaration();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1432);
      udp_declaration();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(1433);
      interface_declaration();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(1434);
      program_declaration();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(1435);
      package_declaration();
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(1436);
      surelog_macro_not_defined();
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(1440);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == SV3_1aParser::OPEN_PARENS_STAR) {
        setState(1437);
        attribute_instance();
        setState(1442);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(1445);
      _errHandler->sync(this);
      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 9, _ctx)) {
      case 1: {
        setState(1443);
        package_item();
        break;
      }

      case 2: {
        setState(1444);
        bind_directive();
        break;
      }

      default:
        break;
      }
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(1447);
      config_declaration();
      break;
    }

    case 9: {
      enterOuterAlt(_localctx, 9);
      setState(1448);
      top_directives();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Module_nonansi_headerContext ------------------------------------------------------------------

SV3_1aParser::Module_nonansi_headerContext::Module_nonansi_headerContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::Module_keywordContext* SV3_1aParser::Module_nonansi_headerContext::module_keyword() {
  return getRuleContext<SV3_1aParser::Module_keywordContext>(0);
}

SV3_1aParser::IdentifierContext* SV3_1aParser::Module_nonansi_headerContext::identifier() {
  return getRuleContext<SV3_1aParser::IdentifierContext>(0);
}

SV3_1aParser::List_of_portsContext* SV3_1aParser::Module_nonansi_headerContext::list_of_ports() {
  return getRuleContext<SV3_1aParser::List_of_portsContext>(0);
}

tree::TerminalNode* SV3_1aParser::Module_nonansi_headerContext::SEMICOLON() {
  return getToken(SV3_1aParser::SEMICOLON, 0);
}

std::vector<SV3_1aParser::Attribute_instanceContext *> SV3_1aParser::Module_nonansi_headerContext::attribute_instance() {
  return getRuleContexts<SV3_1aParser::Attribute_instanceContext>();
}

SV3_1aParser::Attribute_instanceContext* SV3_1aParser::Module_nonansi_headerContext::attribute_instance(size_t i) {
  return getRuleContext<SV3_1aParser::Attribute_instanceContext>(i);
}

SV3_1aParser::LifetimeContext* SV3_1aParser::Module_nonansi_headerContext::lifetime() {
  return getRuleContext<SV3_1aParser::LifetimeContext>(0);
}

std::vector<SV3_1aParser::Package_import_declarationContext *> SV3_1aParser::Module_nonansi_headerContext::package_import_declaration() {
  return getRuleContexts<SV3_1aParser::Package_import_declarationContext>();
}

SV3_1aParser::Package_import_declarationContext* SV3_1aParser::Module_nonansi_headerContext::package_import_declaration(size_t i) {
  return getRuleContext<SV3_1aParser::Package_import_declarationContext>(i);
}

SV3_1aParser::Parameter_port_listContext* SV3_1aParser::Module_nonansi_headerContext::parameter_port_list() {
  return getRuleContext<SV3_1aParser::Parameter_port_listContext>(0);
}


size_t SV3_1aParser::Module_nonansi_headerContext::getRuleIndex() const {
  return SV3_1aParser::RuleModule_nonansi_header;
}

void SV3_1aParser::Module_nonansi_headerContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterModule_nonansi_header(this);
}

void SV3_1aParser::Module_nonansi_headerContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitModule_nonansi_header(this);
}

SV3_1aParser::Module_nonansi_headerContext* SV3_1aParser::module_nonansi_header() {
  Module_nonansi_headerContext *_localctx = _tracker.createInstance<Module_nonansi_headerContext>(_ctx, getState());
  enterRule(_localctx, 20, SV3_1aParser::RuleModule_nonansi_header);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1454);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == SV3_1aParser::OPEN_PARENS_STAR) {
      setState(1451);
      attribute_instance();
      setState(1456);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(1457);
    module_keyword();
    setState(1459);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SV3_1aParser::STATIC

    || _la == SV3_1aParser::AUTOMATIC) {
      setState(1458);
      lifetime();
    }
    setState(1461);
    identifier();
    setState(1465);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == SV3_1aParser::IMPORT) {
      setState(1462);
      package_import_declaration();
      setState(1467);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(1469);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SV3_1aParser::POUND) {
      setState(1468);
      parameter_port_list();
    }
    setState(1471);
    list_of_ports();
    setState(1472);
    match(SV3_1aParser::SEMICOLON);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Module_ansi_headerContext ------------------------------------------------------------------

SV3_1aParser::Module_ansi_headerContext::Module_ansi_headerContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::Module_keywordContext* SV3_1aParser::Module_ansi_headerContext::module_keyword() {
  return getRuleContext<SV3_1aParser::Module_keywordContext>(0);
}

SV3_1aParser::IdentifierContext* SV3_1aParser::Module_ansi_headerContext::identifier() {
  return getRuleContext<SV3_1aParser::IdentifierContext>(0);
}

tree::TerminalNode* SV3_1aParser::Module_ansi_headerContext::SEMICOLON() {
  return getToken(SV3_1aParser::SEMICOLON, 0);
}

std::vector<SV3_1aParser::Attribute_instanceContext *> SV3_1aParser::Module_ansi_headerContext::attribute_instance() {
  return getRuleContexts<SV3_1aParser::Attribute_instanceContext>();
}

SV3_1aParser::Attribute_instanceContext* SV3_1aParser::Module_ansi_headerContext::attribute_instance(size_t i) {
  return getRuleContext<SV3_1aParser::Attribute_instanceContext>(i);
}

SV3_1aParser::LifetimeContext* SV3_1aParser::Module_ansi_headerContext::lifetime() {
  return getRuleContext<SV3_1aParser::LifetimeContext>(0);
}

std::vector<SV3_1aParser::Package_import_declarationContext *> SV3_1aParser::Module_ansi_headerContext::package_import_declaration() {
  return getRuleContexts<SV3_1aParser::Package_import_declarationContext>();
}

SV3_1aParser::Package_import_declarationContext* SV3_1aParser::Module_ansi_headerContext::package_import_declaration(size_t i) {
  return getRuleContext<SV3_1aParser::Package_import_declarationContext>(i);
}

SV3_1aParser::Parameter_port_listContext* SV3_1aParser::Module_ansi_headerContext::parameter_port_list() {
  return getRuleContext<SV3_1aParser::Parameter_port_listContext>(0);
}

SV3_1aParser::List_of_port_declarationsContext* SV3_1aParser::Module_ansi_headerContext::list_of_port_declarations() {
  return getRuleContext<SV3_1aParser::List_of_port_declarationsContext>(0);
}


size_t SV3_1aParser::Module_ansi_headerContext::getRuleIndex() const {
  return SV3_1aParser::RuleModule_ansi_header;
}

void SV3_1aParser::Module_ansi_headerContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterModule_ansi_header(this);
}

void SV3_1aParser::Module_ansi_headerContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitModule_ansi_header(this);
}

SV3_1aParser::Module_ansi_headerContext* SV3_1aParser::module_ansi_header() {
  Module_ansi_headerContext *_localctx = _tracker.createInstance<Module_ansi_headerContext>(_ctx, getState());
  enterRule(_localctx, 22, SV3_1aParser::RuleModule_ansi_header);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1477);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == SV3_1aParser::OPEN_PARENS_STAR) {
      setState(1474);
      attribute_instance();
      setState(1479);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(1480);
    module_keyword();
    setState(1482);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SV3_1aParser::STATIC

    || _la == SV3_1aParser::AUTOMATIC) {
      setState(1481);
      lifetime();
    }
    setState(1484);
    identifier();
    setState(1488);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == SV3_1aParser::IMPORT) {
      setState(1485);
      package_import_declaration();
      setState(1490);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(1492);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SV3_1aParser::POUND) {
      setState(1491);
      parameter_port_list();
    }
    setState(1495);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SV3_1aParser::OPEN_PARENS) {
      setState(1494);
      list_of_port_declarations();
    }
    setState(1497);
    match(SV3_1aParser::SEMICOLON);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Module_declarationContext ------------------------------------------------------------------

SV3_1aParser::Module_declarationContext::Module_declarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::Module_nonansi_headerContext* SV3_1aParser::Module_declarationContext::module_nonansi_header() {
  return getRuleContext<SV3_1aParser::Module_nonansi_headerContext>(0);
}

tree::TerminalNode* SV3_1aParser::Module_declarationContext::ENDMODULE() {
  return getToken(SV3_1aParser::ENDMODULE, 0);
}

SV3_1aParser::Timeunits_declarationContext* SV3_1aParser::Module_declarationContext::timeunits_declaration() {
  return getRuleContext<SV3_1aParser::Timeunits_declarationContext>(0);
}

std::vector<SV3_1aParser::Module_itemContext *> SV3_1aParser::Module_declarationContext::module_item() {
  return getRuleContexts<SV3_1aParser::Module_itemContext>();
}

SV3_1aParser::Module_itemContext* SV3_1aParser::Module_declarationContext::module_item(size_t i) {
  return getRuleContext<SV3_1aParser::Module_itemContext>(i);
}

tree::TerminalNode* SV3_1aParser::Module_declarationContext::COLON() {
  return getToken(SV3_1aParser::COLON, 0);
}

std::vector<SV3_1aParser::IdentifierContext *> SV3_1aParser::Module_declarationContext::identifier() {
  return getRuleContexts<SV3_1aParser::IdentifierContext>();
}

SV3_1aParser::IdentifierContext* SV3_1aParser::Module_declarationContext::identifier(size_t i) {
  return getRuleContext<SV3_1aParser::IdentifierContext>(i);
}

SV3_1aParser::Module_ansi_headerContext* SV3_1aParser::Module_declarationContext::module_ansi_header() {
  return getRuleContext<SV3_1aParser::Module_ansi_headerContext>(0);
}

std::vector<SV3_1aParser::Non_port_module_itemContext *> SV3_1aParser::Module_declarationContext::non_port_module_item() {
  return getRuleContexts<SV3_1aParser::Non_port_module_itemContext>();
}

SV3_1aParser::Non_port_module_itemContext* SV3_1aParser::Module_declarationContext::non_port_module_item(size_t i) {
  return getRuleContext<SV3_1aParser::Non_port_module_itemContext>(i);
}

SV3_1aParser::Module_keywordContext* SV3_1aParser::Module_declarationContext::module_keyword() {
  return getRuleContext<SV3_1aParser::Module_keywordContext>(0);
}

tree::TerminalNode* SV3_1aParser::Module_declarationContext::OPEN_PARENS() {
  return getToken(SV3_1aParser::OPEN_PARENS, 0);
}

tree::TerminalNode* SV3_1aParser::Module_declarationContext::DOT() {
  return getToken(SV3_1aParser::DOT, 0);
}

tree::TerminalNode* SV3_1aParser::Module_declarationContext::STAR() {
  return getToken(SV3_1aParser::STAR, 0);
}

tree::TerminalNode* SV3_1aParser::Module_declarationContext::CLOSE_PARENS() {
  return getToken(SV3_1aParser::CLOSE_PARENS, 0);
}

tree::TerminalNode* SV3_1aParser::Module_declarationContext::SEMICOLON() {
  return getToken(SV3_1aParser::SEMICOLON, 0);
}

std::vector<SV3_1aParser::Attribute_instanceContext *> SV3_1aParser::Module_declarationContext::attribute_instance() {
  return getRuleContexts<SV3_1aParser::Attribute_instanceContext>();
}

SV3_1aParser::Attribute_instanceContext* SV3_1aParser::Module_declarationContext::attribute_instance(size_t i) {
  return getRuleContext<SV3_1aParser::Attribute_instanceContext>(i);
}

SV3_1aParser::LifetimeContext* SV3_1aParser::Module_declarationContext::lifetime() {
  return getRuleContext<SV3_1aParser::LifetimeContext>(0);
}

tree::TerminalNode* SV3_1aParser::Module_declarationContext::EXTERN() {
  return getToken(SV3_1aParser::EXTERN, 0);
}


size_t SV3_1aParser::Module_declarationContext::getRuleIndex() const {
  return SV3_1aParser::RuleModule_declaration;
}

void SV3_1aParser::Module_declarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterModule_declaration(this);
}

void SV3_1aParser::Module_declarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitModule_declaration(this);
}

SV3_1aParser::Module_declarationContext* SV3_1aParser::module_declaration() {
  Module_declarationContext *_localctx = _tracker.createInstance<Module_declarationContext>(_ctx, getState());
  enterRule(_localctx, 24, SV3_1aParser::RuleModule_declaration);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1563);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 31, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1499);
      module_nonansi_header();
      setState(1501);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 20, _ctx)) {
      case 1: {
        setState(1500);
        timeunits_declaration();
        break;
      }

      default:
        break;
      }
      setState(1506);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (((((_la - 31) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 31)) & -8637802955050089439) != 0) || ((((_la - 95) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 95)) & 72056495063103391) != 0) || ((((_la - 166) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 166)) & 4504115539345411) != 0) || ((((_la - 238) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 238)) & 2182740967423) != 0) || ((((_la - 314) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 314)) & 19984723617116163) != 0) || _la == SV3_1aParser::TICK_PRAGMA

      || _la == SV3_1aParser::SURELOG_MACRO_NOT_DEFINED) {
        setState(1503);
        module_item();
        setState(1508);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(1509);
      match(SV3_1aParser::ENDMODULE);
      setState(1512);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == SV3_1aParser::COLON) {
        setState(1510);
        match(SV3_1aParser::COLON);
        setState(1511);
        identifier();
      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1514);
      module_ansi_header();
      setState(1516);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 23, _ctx)) {
      case 1: {
        setState(1515);
        timeunits_declaration();
        break;
      }

      default:
        break;
      }
      setState(1521);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (((((_la - 31) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 31)) & -8637803470446164959) != 0) || ((((_la - 95) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 95)) & 72056495063103391) != 0) || ((((_la - 166) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 166)) & 4504115539345411) != 0) || ((((_la - 238) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 238)) & 2182740967423) != 0) || ((((_la - 314) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 314)) & 19984723617107971) != 0) || _la == SV3_1aParser::TICK_PRAGMA

      || _la == SV3_1aParser::SURELOG_MACRO_NOT_DEFINED) {
        setState(1518);
        non_port_module_item();
        setState(1523);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(1524);
      match(SV3_1aParser::ENDMODULE);
      setState(1527);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == SV3_1aParser::COLON) {
        setState(1525);
        match(SV3_1aParser::COLON);
        setState(1526);
        identifier();
      }
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(1532);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == SV3_1aParser::OPEN_PARENS_STAR) {
        setState(1529);
        attribute_instance();
        setState(1534);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(1535);
      module_keyword();
      setState(1537);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == SV3_1aParser::STATIC

      || _la == SV3_1aParser::AUTOMATIC) {
        setState(1536);
        lifetime();
      }
      setState(1539);
      identifier();
      setState(1540);
      match(SV3_1aParser::OPEN_PARENS);
      setState(1541);
      match(SV3_1aParser::DOT);
      setState(1542);
      match(SV3_1aParser::STAR);
      setState(1543);
      match(SV3_1aParser::CLOSE_PARENS);
      setState(1544);
      match(SV3_1aParser::SEMICOLON);
      setState(1546);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 28, _ctx)) {
      case 1: {
        setState(1545);
        timeunits_declaration();
        break;
      }

      default:
        break;
      }
      setState(1551);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (((((_la - 31) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 31)) & -8637802955050089439) != 0) || ((((_la - 95) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 95)) & 72056495063103391) != 0) || ((((_la - 166) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 166)) & 4504115539345411) != 0) || ((((_la - 238) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 238)) & 2182740967423) != 0) || ((((_la - 314) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 314)) & 19984723617116163) != 0) || _la == SV3_1aParser::TICK_PRAGMA

      || _la == SV3_1aParser::SURELOG_MACRO_NOT_DEFINED) {
        setState(1548);
        module_item();
        setState(1553);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(1554);
      match(SV3_1aParser::ENDMODULE);
      setState(1557);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == SV3_1aParser::COLON) {
        setState(1555);
        match(SV3_1aParser::COLON);
        setState(1556);
        identifier();
      }
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(1559);
      match(SV3_1aParser::EXTERN);
      setState(1560);
      module_nonansi_header();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(1561);
      match(SV3_1aParser::EXTERN);
      setState(1562);
      module_ansi_header();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Module_keywordContext ------------------------------------------------------------------

SV3_1aParser::Module_keywordContext::Module_keywordContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Module_keywordContext::MODULE() {
  return getToken(SV3_1aParser::MODULE, 0);
}

tree::TerminalNode* SV3_1aParser::Module_keywordContext::MACROMODULE() {
  return getToken(SV3_1aParser::MACROMODULE, 0);
}


size_t SV3_1aParser::Module_keywordContext::getRuleIndex() const {
  return SV3_1aParser::RuleModule_keyword;
}

void SV3_1aParser::Module_keywordContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterModule_keyword(this);
}

void SV3_1aParser::Module_keywordContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitModule_keyword(this);
}

SV3_1aParser::Module_keywordContext* SV3_1aParser::module_keyword() {
  Module_keywordContext *_localctx = _tracker.createInstance<Module_keywordContext>(_ctx, getState());
  enterRule(_localctx, 26, SV3_1aParser::RuleModule_keyword);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1565);
    _la = _input->LA(1);
    if (!(_la == SV3_1aParser::MODULE

    || _la == SV3_1aParser::MACROMODULE)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Interface_nonansi_headerContext ------------------------------------------------------------------

SV3_1aParser::Interface_nonansi_headerContext::Interface_nonansi_headerContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Interface_nonansi_headerContext::INTERFACE() {
  return getToken(SV3_1aParser::INTERFACE, 0);
}

SV3_1aParser::Interface_identifierContext* SV3_1aParser::Interface_nonansi_headerContext::interface_identifier() {
  return getRuleContext<SV3_1aParser::Interface_identifierContext>(0);
}

SV3_1aParser::List_of_portsContext* SV3_1aParser::Interface_nonansi_headerContext::list_of_ports() {
  return getRuleContext<SV3_1aParser::List_of_portsContext>(0);
}

tree::TerminalNode* SV3_1aParser::Interface_nonansi_headerContext::SEMICOLON() {
  return getToken(SV3_1aParser::SEMICOLON, 0);
}

std::vector<SV3_1aParser::Attribute_instanceContext *> SV3_1aParser::Interface_nonansi_headerContext::attribute_instance() {
  return getRuleContexts<SV3_1aParser::Attribute_instanceContext>();
}

SV3_1aParser::Attribute_instanceContext* SV3_1aParser::Interface_nonansi_headerContext::attribute_instance(size_t i) {
  return getRuleContext<SV3_1aParser::Attribute_instanceContext>(i);
}

SV3_1aParser::LifetimeContext* SV3_1aParser::Interface_nonansi_headerContext::lifetime() {
  return getRuleContext<SV3_1aParser::LifetimeContext>(0);
}

std::vector<SV3_1aParser::Package_import_declarationContext *> SV3_1aParser::Interface_nonansi_headerContext::package_import_declaration() {
  return getRuleContexts<SV3_1aParser::Package_import_declarationContext>();
}

SV3_1aParser::Package_import_declarationContext* SV3_1aParser::Interface_nonansi_headerContext::package_import_declaration(size_t i) {
  return getRuleContext<SV3_1aParser::Package_import_declarationContext>(i);
}

SV3_1aParser::Parameter_port_listContext* SV3_1aParser::Interface_nonansi_headerContext::parameter_port_list() {
  return getRuleContext<SV3_1aParser::Parameter_port_listContext>(0);
}


size_t SV3_1aParser::Interface_nonansi_headerContext::getRuleIndex() const {
  return SV3_1aParser::RuleInterface_nonansi_header;
}

void SV3_1aParser::Interface_nonansi_headerContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInterface_nonansi_header(this);
}

void SV3_1aParser::Interface_nonansi_headerContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInterface_nonansi_header(this);
}

SV3_1aParser::Interface_nonansi_headerContext* SV3_1aParser::interface_nonansi_header() {
  Interface_nonansi_headerContext *_localctx = _tracker.createInstance<Interface_nonansi_headerContext>(_ctx, getState());
  enterRule(_localctx, 28, SV3_1aParser::RuleInterface_nonansi_header);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1570);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == SV3_1aParser::OPEN_PARENS_STAR) {
      setState(1567);
      attribute_instance();
      setState(1572);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(1573);
    match(SV3_1aParser::INTERFACE);
    setState(1575);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SV3_1aParser::STATIC

    || _la == SV3_1aParser::AUTOMATIC) {
      setState(1574);
      lifetime();
    }
    setState(1577);
    interface_identifier();
    setState(1581);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == SV3_1aParser::IMPORT) {
      setState(1578);
      package_import_declaration();
      setState(1583);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(1585);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SV3_1aParser::POUND) {
      setState(1584);
      parameter_port_list();
    }
    setState(1587);
    list_of_ports();
    setState(1588);
    match(SV3_1aParser::SEMICOLON);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Interface_ansi_headerContext ------------------------------------------------------------------

SV3_1aParser::Interface_ansi_headerContext::Interface_ansi_headerContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Interface_ansi_headerContext::INTERFACE() {
  return getToken(SV3_1aParser::INTERFACE, 0);
}

SV3_1aParser::Interface_identifierContext* SV3_1aParser::Interface_ansi_headerContext::interface_identifier() {
  return getRuleContext<SV3_1aParser::Interface_identifierContext>(0);
}

tree::TerminalNode* SV3_1aParser::Interface_ansi_headerContext::SEMICOLON() {
  return getToken(SV3_1aParser::SEMICOLON, 0);
}

std::vector<SV3_1aParser::Attribute_instanceContext *> SV3_1aParser::Interface_ansi_headerContext::attribute_instance() {
  return getRuleContexts<SV3_1aParser::Attribute_instanceContext>();
}

SV3_1aParser::Attribute_instanceContext* SV3_1aParser::Interface_ansi_headerContext::attribute_instance(size_t i) {
  return getRuleContext<SV3_1aParser::Attribute_instanceContext>(i);
}

SV3_1aParser::LifetimeContext* SV3_1aParser::Interface_ansi_headerContext::lifetime() {
  return getRuleContext<SV3_1aParser::LifetimeContext>(0);
}

std::vector<SV3_1aParser::Package_import_declarationContext *> SV3_1aParser::Interface_ansi_headerContext::package_import_declaration() {
  return getRuleContexts<SV3_1aParser::Package_import_declarationContext>();
}

SV3_1aParser::Package_import_declarationContext* SV3_1aParser::Interface_ansi_headerContext::package_import_declaration(size_t i) {
  return getRuleContext<SV3_1aParser::Package_import_declarationContext>(i);
}

SV3_1aParser::Parameter_port_listContext* SV3_1aParser::Interface_ansi_headerContext::parameter_port_list() {
  return getRuleContext<SV3_1aParser::Parameter_port_listContext>(0);
}

SV3_1aParser::List_of_port_declarationsContext* SV3_1aParser::Interface_ansi_headerContext::list_of_port_declarations() {
  return getRuleContext<SV3_1aParser::List_of_port_declarationsContext>(0);
}


size_t SV3_1aParser::Interface_ansi_headerContext::getRuleIndex() const {
  return SV3_1aParser::RuleInterface_ansi_header;
}

void SV3_1aParser::Interface_ansi_headerContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInterface_ansi_header(this);
}

void SV3_1aParser::Interface_ansi_headerContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInterface_ansi_header(this);
}

SV3_1aParser::Interface_ansi_headerContext* SV3_1aParser::interface_ansi_header() {
  Interface_ansi_headerContext *_localctx = _tracker.createInstance<Interface_ansi_headerContext>(_ctx, getState());
  enterRule(_localctx, 30, SV3_1aParser::RuleInterface_ansi_header);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1593);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == SV3_1aParser::OPEN_PARENS_STAR) {
      setState(1590);
      attribute_instance();
      setState(1595);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(1596);
    match(SV3_1aParser::INTERFACE);
    setState(1598);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SV3_1aParser::STATIC

    || _la == SV3_1aParser::AUTOMATIC) {
      setState(1597);
      lifetime();
    }
    setState(1600);
    interface_identifier();
    setState(1604);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == SV3_1aParser::IMPORT) {
      setState(1601);
      package_import_declaration();
      setState(1606);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(1608);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SV3_1aParser::POUND) {
      setState(1607);
      parameter_port_list();
    }
    setState(1611);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SV3_1aParser::OPEN_PARENS) {
      setState(1610);
      list_of_port_declarations();
    }
    setState(1613);
    match(SV3_1aParser::SEMICOLON);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Interface_declarationContext ------------------------------------------------------------------

SV3_1aParser::Interface_declarationContext::Interface_declarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::Interface_nonansi_headerContext* SV3_1aParser::Interface_declarationContext::interface_nonansi_header() {
  return getRuleContext<SV3_1aParser::Interface_nonansi_headerContext>(0);
}

tree::TerminalNode* SV3_1aParser::Interface_declarationContext::ENDINTERFACE() {
  return getToken(SV3_1aParser::ENDINTERFACE, 0);
}

SV3_1aParser::Timeunits_declarationContext* SV3_1aParser::Interface_declarationContext::timeunits_declaration() {
  return getRuleContext<SV3_1aParser::Timeunits_declarationContext>(0);
}

std::vector<SV3_1aParser::Interface_itemContext *> SV3_1aParser::Interface_declarationContext::interface_item() {
  return getRuleContexts<SV3_1aParser::Interface_itemContext>();
}

SV3_1aParser::Interface_itemContext* SV3_1aParser::Interface_declarationContext::interface_item(size_t i) {
  return getRuleContext<SV3_1aParser::Interface_itemContext>(i);
}

tree::TerminalNode* SV3_1aParser::Interface_declarationContext::COLON() {
  return getToken(SV3_1aParser::COLON, 0);
}

std::vector<SV3_1aParser::Interface_identifierContext *> SV3_1aParser::Interface_declarationContext::interface_identifier() {
  return getRuleContexts<SV3_1aParser::Interface_identifierContext>();
}

SV3_1aParser::Interface_identifierContext* SV3_1aParser::Interface_declarationContext::interface_identifier(size_t i) {
  return getRuleContext<SV3_1aParser::Interface_identifierContext>(i);
}

SV3_1aParser::Interface_ansi_headerContext* SV3_1aParser::Interface_declarationContext::interface_ansi_header() {
  return getRuleContext<SV3_1aParser::Interface_ansi_headerContext>(0);
}

std::vector<SV3_1aParser::Non_port_interface_itemContext *> SV3_1aParser::Interface_declarationContext::non_port_interface_item() {
  return getRuleContexts<SV3_1aParser::Non_port_interface_itemContext>();
}

SV3_1aParser::Non_port_interface_itemContext* SV3_1aParser::Interface_declarationContext::non_port_interface_item(size_t i) {
  return getRuleContext<SV3_1aParser::Non_port_interface_itemContext>(i);
}

tree::TerminalNode* SV3_1aParser::Interface_declarationContext::INTERFACE() {
  return getToken(SV3_1aParser::INTERFACE, 0);
}

tree::TerminalNode* SV3_1aParser::Interface_declarationContext::OPEN_PARENS() {
  return getToken(SV3_1aParser::OPEN_PARENS, 0);
}

tree::TerminalNode* SV3_1aParser::Interface_declarationContext::DOT() {
  return getToken(SV3_1aParser::DOT, 0);
}

tree::TerminalNode* SV3_1aParser::Interface_declarationContext::STAR() {
  return getToken(SV3_1aParser::STAR, 0);
}

tree::TerminalNode* SV3_1aParser::Interface_declarationContext::CLOSE_PARENS() {
  return getToken(SV3_1aParser::CLOSE_PARENS, 0);
}

tree::TerminalNode* SV3_1aParser::Interface_declarationContext::SEMICOLON() {
  return getToken(SV3_1aParser::SEMICOLON, 0);
}

SV3_1aParser::Attribute_instanceContext* SV3_1aParser::Interface_declarationContext::attribute_instance() {
  return getRuleContext<SV3_1aParser::Attribute_instanceContext>(0);
}

tree::TerminalNode* SV3_1aParser::Interface_declarationContext::EXTERN() {
  return getToken(SV3_1aParser::EXTERN, 0);
}


size_t SV3_1aParser::Interface_declarationContext::getRuleIndex() const {
  return SV3_1aParser::RuleInterface_declaration;
}

void SV3_1aParser::Interface_declarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInterface_declaration(this);
}

void SV3_1aParser::Interface_declarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInterface_declaration(this);
}

SV3_1aParser::Interface_declarationContext* SV3_1aParser::interface_declaration() {
  Interface_declarationContext *_localctx = _tracker.createInstance<Interface_declarationContext>(_ctx, getState());
  enterRule(_localctx, 32, SV3_1aParser::RuleInterface_declaration);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1673);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 51, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1615);
      interface_nonansi_header();
      setState(1617);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 41, _ctx)) {
      case 1: {
        setState(1616);
        timeunits_declaration();
        break;
      }

      default:
        break;
      }
      setState(1622);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (((((_la - 31) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 31)) & -8637804054561783775) != 0) || ((((_la - 95) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 95)) & 72056495063103391) != 0) || ((((_la - 166) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 166)) & 4503875023273987) != 0) || ((((_la - 262) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 262)) & 13510798882241589) != 0) || ((((_la - 326) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 326)) & 4879082913823) != 0) || _la == SV3_1aParser::SURELOG_MACRO_NOT_DEFINED) {
        setState(1619);
        interface_item();
        setState(1624);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(1625);
      match(SV3_1aParser::ENDINTERFACE);
      setState(1628);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == SV3_1aParser::COLON) {
        setState(1626);
        match(SV3_1aParser::COLON);
        setState(1627);
        interface_identifier();
      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1630);
      interface_ansi_header();
      setState(1632);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 44, _ctx)) {
      case 1: {
        setState(1631);
        timeunits_declaration();
        break;
      }

      default:
        break;
      }
      setState(1637);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (((((_la - 31) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 31)) & -8637804569957859295) != 0) || ((((_la - 95) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 95)) & 72056495063103391) != 0) || ((((_la - 166) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 166)) & 4503875023273987) != 0) || ((((_la - 262) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 262)) & 13510798882241589) != 0) || ((((_la - 326) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 326)) & 4879082913821) != 0) || _la == SV3_1aParser::SURELOG_MACRO_NOT_DEFINED) {
        setState(1634);
        non_port_interface_item();
        setState(1639);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(1640);
      match(SV3_1aParser::ENDINTERFACE);
      setState(1643);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == SV3_1aParser::COLON) {
        setState(1641);
        match(SV3_1aParser::COLON);
        setState(1642);
        interface_identifier();
      }
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(1646);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == SV3_1aParser::OPEN_PARENS_STAR) {
        setState(1645);
        attribute_instance();
      }
      setState(1648);
      match(SV3_1aParser::INTERFACE);
      setState(1649);
      interface_identifier();
      setState(1650);
      match(SV3_1aParser::OPEN_PARENS);
      setState(1651);
      match(SV3_1aParser::DOT);
      setState(1652);
      match(SV3_1aParser::STAR);
      setState(1653);
      match(SV3_1aParser::CLOSE_PARENS);
      setState(1654);
      match(SV3_1aParser::SEMICOLON);
      setState(1656);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 48, _ctx)) {
      case 1: {
        setState(1655);
        timeunits_declaration();
        break;
      }

      default:
        break;
      }
      setState(1661);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (((((_la - 31) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 31)) & -8637804054561783775) != 0) || ((((_la - 95) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 95)) & 72056495063103391) != 0) || ((((_la - 166) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 166)) & 4503875023273987) != 0) || ((((_la - 262) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 262)) & 13510798882241589) != 0) || ((((_la - 326) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 326)) & 4879082913823) != 0) || _la == SV3_1aParser::SURELOG_MACRO_NOT_DEFINED) {
        setState(1658);
        interface_item();
        setState(1663);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(1664);
      match(SV3_1aParser::ENDINTERFACE);
      setState(1667);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == SV3_1aParser::COLON) {
        setState(1665);
        match(SV3_1aParser::COLON);
        setState(1666);
        interface_identifier();
      }
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(1669);
      match(SV3_1aParser::EXTERN);
      setState(1670);
      interface_nonansi_header();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(1671);
      match(SV3_1aParser::EXTERN);
      setState(1672);
      interface_ansi_header();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Program_nonansi_headerContext ------------------------------------------------------------------

SV3_1aParser::Program_nonansi_headerContext::Program_nonansi_headerContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Program_nonansi_headerContext::PROGRAM() {
  return getToken(SV3_1aParser::PROGRAM, 0);
}

SV3_1aParser::IdentifierContext* SV3_1aParser::Program_nonansi_headerContext::identifier() {
  return getRuleContext<SV3_1aParser::IdentifierContext>(0);
}

SV3_1aParser::List_of_portsContext* SV3_1aParser::Program_nonansi_headerContext::list_of_ports() {
  return getRuleContext<SV3_1aParser::List_of_portsContext>(0);
}

tree::TerminalNode* SV3_1aParser::Program_nonansi_headerContext::SEMICOLON() {
  return getToken(SV3_1aParser::SEMICOLON, 0);
}

SV3_1aParser::Attribute_instanceContext* SV3_1aParser::Program_nonansi_headerContext::attribute_instance() {
  return getRuleContext<SV3_1aParser::Attribute_instanceContext>(0);
}

SV3_1aParser::LifetimeContext* SV3_1aParser::Program_nonansi_headerContext::lifetime() {
  return getRuleContext<SV3_1aParser::LifetimeContext>(0);
}

std::vector<SV3_1aParser::Package_import_declarationContext *> SV3_1aParser::Program_nonansi_headerContext::package_import_declaration() {
  return getRuleContexts<SV3_1aParser::Package_import_declarationContext>();
}

SV3_1aParser::Package_import_declarationContext* SV3_1aParser::Program_nonansi_headerContext::package_import_declaration(size_t i) {
  return getRuleContext<SV3_1aParser::Package_import_declarationContext>(i);
}

SV3_1aParser::Parameter_port_listContext* SV3_1aParser::Program_nonansi_headerContext::parameter_port_list() {
  return getRuleContext<SV3_1aParser::Parameter_port_listContext>(0);
}


size_t SV3_1aParser::Program_nonansi_headerContext::getRuleIndex() const {
  return SV3_1aParser::RuleProgram_nonansi_header;
}

void SV3_1aParser::Program_nonansi_headerContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterProgram_nonansi_header(this);
}

void SV3_1aParser::Program_nonansi_headerContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitProgram_nonansi_header(this);
}

SV3_1aParser::Program_nonansi_headerContext* SV3_1aParser::program_nonansi_header() {
  Program_nonansi_headerContext *_localctx = _tracker.createInstance<Program_nonansi_headerContext>(_ctx, getState());
  enterRule(_localctx, 34, SV3_1aParser::RuleProgram_nonansi_header);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1675);
    attribute_instance();
    setState(1676);
    match(SV3_1aParser::PROGRAM);
    setState(1678);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SV3_1aParser::STATIC

    || _la == SV3_1aParser::AUTOMATIC) {
      setState(1677);
      lifetime();
    }
    setState(1680);
    identifier();
    setState(1684);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == SV3_1aParser::IMPORT) {
      setState(1681);
      package_import_declaration();
      setState(1686);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(1688);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SV3_1aParser::POUND) {
      setState(1687);
      parameter_port_list();
    }
    setState(1690);
    list_of_ports();
    setState(1691);
    match(SV3_1aParser::SEMICOLON);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Program_ansi_headerContext ------------------------------------------------------------------

SV3_1aParser::Program_ansi_headerContext::Program_ansi_headerContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Program_ansi_headerContext::PROGRAM() {
  return getToken(SV3_1aParser::PROGRAM, 0);
}

SV3_1aParser::IdentifierContext* SV3_1aParser::Program_ansi_headerContext::identifier() {
  return getRuleContext<SV3_1aParser::IdentifierContext>(0);
}

tree::TerminalNode* SV3_1aParser::Program_ansi_headerContext::SEMICOLON() {
  return getToken(SV3_1aParser::SEMICOLON, 0);
}

std::vector<SV3_1aParser::Attribute_instanceContext *> SV3_1aParser::Program_ansi_headerContext::attribute_instance() {
  return getRuleContexts<SV3_1aParser::Attribute_instanceContext>();
}

SV3_1aParser::Attribute_instanceContext* SV3_1aParser::Program_ansi_headerContext::attribute_instance(size_t i) {
  return getRuleContext<SV3_1aParser::Attribute_instanceContext>(i);
}

SV3_1aParser::LifetimeContext* SV3_1aParser::Program_ansi_headerContext::lifetime() {
  return getRuleContext<SV3_1aParser::LifetimeContext>(0);
}

std::vector<SV3_1aParser::Package_import_declarationContext *> SV3_1aParser::Program_ansi_headerContext::package_import_declaration() {
  return getRuleContexts<SV3_1aParser::Package_import_declarationContext>();
}

SV3_1aParser::Package_import_declarationContext* SV3_1aParser::Program_ansi_headerContext::package_import_declaration(size_t i) {
  return getRuleContext<SV3_1aParser::Package_import_declarationContext>(i);
}

SV3_1aParser::Parameter_port_listContext* SV3_1aParser::Program_ansi_headerContext::parameter_port_list() {
  return getRuleContext<SV3_1aParser::Parameter_port_listContext>(0);
}

SV3_1aParser::List_of_port_declarationsContext* SV3_1aParser::Program_ansi_headerContext::list_of_port_declarations() {
  return getRuleContext<SV3_1aParser::List_of_port_declarationsContext>(0);
}


size_t SV3_1aParser::Program_ansi_headerContext::getRuleIndex() const {
  return SV3_1aParser::RuleProgram_ansi_header;
}

void SV3_1aParser::Program_ansi_headerContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterProgram_ansi_header(this);
}

void SV3_1aParser::Program_ansi_headerContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitProgram_ansi_header(this);
}

SV3_1aParser::Program_ansi_headerContext* SV3_1aParser::program_ansi_header() {
  Program_ansi_headerContext *_localctx = _tracker.createInstance<Program_ansi_headerContext>(_ctx, getState());
  enterRule(_localctx, 36, SV3_1aParser::RuleProgram_ansi_header);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1696);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == SV3_1aParser::OPEN_PARENS_STAR) {
      setState(1693);
      attribute_instance();
      setState(1698);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(1699);
    match(SV3_1aParser::PROGRAM);
    setState(1701);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SV3_1aParser::STATIC

    || _la == SV3_1aParser::AUTOMATIC) {
      setState(1700);
      lifetime();
    }
    setState(1703);
    identifier();
    setState(1707);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == SV3_1aParser::IMPORT) {
      setState(1704);
      package_import_declaration();
      setState(1709);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(1711);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SV3_1aParser::POUND) {
      setState(1710);
      parameter_port_list();
    }
    setState(1714);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SV3_1aParser::OPEN_PARENS) {
      setState(1713);
      list_of_port_declarations();
    }
    setState(1716);
    match(SV3_1aParser::SEMICOLON);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Checker_declarationContext ------------------------------------------------------------------

SV3_1aParser::Checker_declarationContext::Checker_declarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Checker_declarationContext::CHECKER() {
  return getToken(SV3_1aParser::CHECKER, 0);
}

std::vector<SV3_1aParser::IdentifierContext *> SV3_1aParser::Checker_declarationContext::identifier() {
  return getRuleContexts<SV3_1aParser::IdentifierContext>();
}

SV3_1aParser::IdentifierContext* SV3_1aParser::Checker_declarationContext::identifier(size_t i) {
  return getRuleContext<SV3_1aParser::IdentifierContext>(i);
}

tree::TerminalNode* SV3_1aParser::Checker_declarationContext::SEMICOLON() {
  return getToken(SV3_1aParser::SEMICOLON, 0);
}

tree::TerminalNode* SV3_1aParser::Checker_declarationContext::ENDCHECKER() {
  return getToken(SV3_1aParser::ENDCHECKER, 0);
}

tree::TerminalNode* SV3_1aParser::Checker_declarationContext::OPEN_PARENS() {
  return getToken(SV3_1aParser::OPEN_PARENS, 0);
}

tree::TerminalNode* SV3_1aParser::Checker_declarationContext::CLOSE_PARENS() {
  return getToken(SV3_1aParser::CLOSE_PARENS, 0);
}

std::vector<SV3_1aParser::Checker_or_generate_itemContext *> SV3_1aParser::Checker_declarationContext::checker_or_generate_item() {
  return getRuleContexts<SV3_1aParser::Checker_or_generate_itemContext>();
}

SV3_1aParser::Checker_or_generate_itemContext* SV3_1aParser::Checker_declarationContext::checker_or_generate_item(size_t i) {
  return getRuleContext<SV3_1aParser::Checker_or_generate_itemContext>(i);
}

tree::TerminalNode* SV3_1aParser::Checker_declarationContext::COLON() {
  return getToken(SV3_1aParser::COLON, 0);
}

SV3_1aParser::Checker_port_listContext* SV3_1aParser::Checker_declarationContext::checker_port_list() {
  return getRuleContext<SV3_1aParser::Checker_port_listContext>(0);
}

std::vector<SV3_1aParser::Attribute_instanceContext *> SV3_1aParser::Checker_declarationContext::attribute_instance() {
  return getRuleContexts<SV3_1aParser::Attribute_instanceContext>();
}

SV3_1aParser::Attribute_instanceContext* SV3_1aParser::Checker_declarationContext::attribute_instance(size_t i) {
  return getRuleContext<SV3_1aParser::Attribute_instanceContext>(i);
}


size_t SV3_1aParser::Checker_declarationContext::getRuleIndex() const {
  return SV3_1aParser::RuleChecker_declaration;
}

void SV3_1aParser::Checker_declarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterChecker_declaration(this);
}

void SV3_1aParser::Checker_declarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitChecker_declaration(this);
}

SV3_1aParser::Checker_declarationContext* SV3_1aParser::checker_declaration() {
  Checker_declarationContext *_localctx = _tracker.createInstance<Checker_declarationContext>(_ctx, getState());
  enterRule(_localctx, 38, SV3_1aParser::RuleChecker_declaration);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1718);
    match(SV3_1aParser::CHECKER);
    setState(1719);
    identifier();
    setState(1725);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SV3_1aParser::OPEN_PARENS) {
      setState(1720);
      match(SV3_1aParser::OPEN_PARENS);
      setState(1722);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == SV3_1aParser::VIRTUAL || ((((_la - 64) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 64)) & 1152775819316166671) != 0) || ((((_la - 147) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 147)) & 144156969517711363) != 0) || ((((_la - 326) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 326)) & 4672924483589) != 0)) {
        setState(1721);
        checker_port_list();
      }
      setState(1724);
      match(SV3_1aParser::CLOSE_PARENS);
    }
    setState(1727);
    match(SV3_1aParser::SEMICOLON);
    setState(1737);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 1157425175101177856) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 64)) & 1152776146874608961) != 0) || ((((_la - 147) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 147)) & 144385667936813067) != 0) || ((((_la - 218) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 218)) & 2216703402526638081) != 0) || ((((_la - 314) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 314)) & 19984723614945283) != 0) || _la == SV3_1aParser::SURELOG_MACRO_NOT_DEFINED) {
      setState(1731);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == SV3_1aParser::OPEN_PARENS_STAR) {
        setState(1728);
        attribute_instance();
        setState(1733);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(1734);
      checker_or_generate_item();
      setState(1739);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(1740);
    match(SV3_1aParser::ENDCHECKER);
    setState(1743);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 64, _ctx)) {
    case 1: {
      setState(1741);
      match(SV3_1aParser::COLON);
      setState(1742);
      identifier();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Program_declarationContext ------------------------------------------------------------------

SV3_1aParser::Program_declarationContext::Program_declarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::Program_nonansi_headerContext* SV3_1aParser::Program_declarationContext::program_nonansi_header() {
  return getRuleContext<SV3_1aParser::Program_nonansi_headerContext>(0);
}

tree::TerminalNode* SV3_1aParser::Program_declarationContext::ENDPROGRAM() {
  return getToken(SV3_1aParser::ENDPROGRAM, 0);
}

SV3_1aParser::Timeunits_declarationContext* SV3_1aParser::Program_declarationContext::timeunits_declaration() {
  return getRuleContext<SV3_1aParser::Timeunits_declarationContext>(0);
}

std::vector<SV3_1aParser::Program_itemContext *> SV3_1aParser::Program_declarationContext::program_item() {
  return getRuleContexts<SV3_1aParser::Program_itemContext>();
}

SV3_1aParser::Program_itemContext* SV3_1aParser::Program_declarationContext::program_item(size_t i) {
  return getRuleContext<SV3_1aParser::Program_itemContext>(i);
}

tree::TerminalNode* SV3_1aParser::Program_declarationContext::COLON() {
  return getToken(SV3_1aParser::COLON, 0);
}

std::vector<SV3_1aParser::IdentifierContext *> SV3_1aParser::Program_declarationContext::identifier() {
  return getRuleContexts<SV3_1aParser::IdentifierContext>();
}

SV3_1aParser::IdentifierContext* SV3_1aParser::Program_declarationContext::identifier(size_t i) {
  return getRuleContext<SV3_1aParser::IdentifierContext>(i);
}

SV3_1aParser::Program_ansi_headerContext* SV3_1aParser::Program_declarationContext::program_ansi_header() {
  return getRuleContext<SV3_1aParser::Program_ansi_headerContext>(0);
}

std::vector<SV3_1aParser::Non_port_program_itemContext *> SV3_1aParser::Program_declarationContext::non_port_program_item() {
  return getRuleContexts<SV3_1aParser::Non_port_program_itemContext>();
}

SV3_1aParser::Non_port_program_itemContext* SV3_1aParser::Program_declarationContext::non_port_program_item(size_t i) {
  return getRuleContext<SV3_1aParser::Non_port_program_itemContext>(i);
}

tree::TerminalNode* SV3_1aParser::Program_declarationContext::PROGRAM() {
  return getToken(SV3_1aParser::PROGRAM, 0);
}

tree::TerminalNode* SV3_1aParser::Program_declarationContext::OPEN_PARENS() {
  return getToken(SV3_1aParser::OPEN_PARENS, 0);
}

tree::TerminalNode* SV3_1aParser::Program_declarationContext::DOT() {
  return getToken(SV3_1aParser::DOT, 0);
}

tree::TerminalNode* SV3_1aParser::Program_declarationContext::STAR() {
  return getToken(SV3_1aParser::STAR, 0);
}

tree::TerminalNode* SV3_1aParser::Program_declarationContext::CLOSE_PARENS() {
  return getToken(SV3_1aParser::CLOSE_PARENS, 0);
}

tree::TerminalNode* SV3_1aParser::Program_declarationContext::SEMICOLON() {
  return getToken(SV3_1aParser::SEMICOLON, 0);
}

std::vector<SV3_1aParser::Attribute_instanceContext *> SV3_1aParser::Program_declarationContext::attribute_instance() {
  return getRuleContexts<SV3_1aParser::Attribute_instanceContext>();
}

SV3_1aParser::Attribute_instanceContext* SV3_1aParser::Program_declarationContext::attribute_instance(size_t i) {
  return getRuleContext<SV3_1aParser::Attribute_instanceContext>(i);
}

tree::TerminalNode* SV3_1aParser::Program_declarationContext::EXTERN() {
  return getToken(SV3_1aParser::EXTERN, 0);
}


size_t SV3_1aParser::Program_declarationContext::getRuleIndex() const {
  return SV3_1aParser::RuleProgram_declaration;
}

void SV3_1aParser::Program_declarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterProgram_declaration(this);
}

void SV3_1aParser::Program_declarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitProgram_declaration(this);
}

SV3_1aParser::Program_declarationContext* SV3_1aParser::program_declaration() {
  Program_declarationContext *_localctx = _tracker.createInstance<Program_declarationContext>(_ctx, getState());
  enterRule(_localctx, 40, SV3_1aParser::RuleProgram_declaration);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1806);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 75, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1745);
      program_nonansi_header();
      setState(1747);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 65, _ctx)) {
      case 1: {
        setState(1746);
        timeunits_declaration();
        break;
      }

      default:
        break;
      }
      setState(1752);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (((((_la - 31) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 31)) & -8637804054562340831) != 0) || ((((_la - 95) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 95)) & 72056495063103391) != 0) || ((((_la - 166) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 166)) & 4503875021176835) != 0) || ((((_la - 262) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 262)) & 13510798882114613) != 0) || ((((_la - 326) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 326)) & 4879082913823) != 0) || _la == SV3_1aParser::SURELOG_MACRO_NOT_DEFINED) {
        setState(1749);
        program_item();
        setState(1754);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(1755);
      match(SV3_1aParser::ENDPROGRAM);
      setState(1758);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == SV3_1aParser::COLON) {
        setState(1756);
        match(SV3_1aParser::COLON);
        setState(1757);
        identifier();
      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1760);
      program_ansi_header();
      setState(1762);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 68, _ctx)) {
      case 1: {
        setState(1761);
        timeunits_declaration();
        break;
      }

      default:
        break;
      }
      setState(1767);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (((((_la - 31) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 31)) & -8637804569958416351) != 0) || ((((_la - 95) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 95)) & 72056495063103391) != 0) || ((((_la - 166) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 166)) & 4503875021176835) != 0) || ((((_la - 262) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 262)) & 13510798882114613) != 0) || ((((_la - 326) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 326)) & 4879082913821) != 0) || _la == SV3_1aParser::SURELOG_MACRO_NOT_DEFINED) {
        setState(1764);
        non_port_program_item();
        setState(1769);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(1770);
      match(SV3_1aParser::ENDPROGRAM);
      setState(1773);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == SV3_1aParser::COLON) {
        setState(1771);
        match(SV3_1aParser::COLON);
        setState(1772);
        identifier();
      }
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(1778);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == SV3_1aParser::OPEN_PARENS_STAR) {
        setState(1775);
        attribute_instance();
        setState(1780);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(1781);
      match(SV3_1aParser::PROGRAM);
      setState(1782);
      identifier();
      setState(1783);
      match(SV3_1aParser::OPEN_PARENS);
      setState(1784);
      match(SV3_1aParser::DOT);
      setState(1785);
      match(SV3_1aParser::STAR);
      setState(1786);
      match(SV3_1aParser::CLOSE_PARENS);
      setState(1787);
      match(SV3_1aParser::SEMICOLON);
      setState(1789);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 72, _ctx)) {
      case 1: {
        setState(1788);
        timeunits_declaration();
        break;
      }

      default:
        break;
      }
      setState(1794);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (((((_la - 31) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 31)) & -8637804054562340831) != 0) || ((((_la - 95) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 95)) & 72056495063103391) != 0) || ((((_la - 166) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 166)) & 4503875021176835) != 0) || ((((_la - 262) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 262)) & 13510798882114613) != 0) || ((((_la - 326) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 326)) & 4879082913823) != 0) || _la == SV3_1aParser::SURELOG_MACRO_NOT_DEFINED) {
        setState(1791);
        program_item();
        setState(1796);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(1797);
      match(SV3_1aParser::ENDPROGRAM);
      setState(1800);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == SV3_1aParser::COLON) {
        setState(1798);
        match(SV3_1aParser::COLON);
        setState(1799);
        identifier();
      }
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(1802);
      match(SV3_1aParser::EXTERN);
      setState(1803);
      program_nonansi_header();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(1804);
      match(SV3_1aParser::EXTERN);
      setState(1805);
      program_ansi_header();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Class_declarationContext ------------------------------------------------------------------

SV3_1aParser::Class_declarationContext::Class_declarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Class_declarationContext::CLASS() {
  return getToken(SV3_1aParser::CLASS, 0);
}

std::vector<SV3_1aParser::IdentifierContext *> SV3_1aParser::Class_declarationContext::identifier() {
  return getRuleContexts<SV3_1aParser::IdentifierContext>();
}

SV3_1aParser::IdentifierContext* SV3_1aParser::Class_declarationContext::identifier(size_t i) {
  return getRuleContext<SV3_1aParser::IdentifierContext>(i);
}

tree::TerminalNode* SV3_1aParser::Class_declarationContext::SEMICOLON() {
  return getToken(SV3_1aParser::SEMICOLON, 0);
}

tree::TerminalNode* SV3_1aParser::Class_declarationContext::ENDCLASS() {
  return getToken(SV3_1aParser::ENDCLASS, 0);
}

tree::TerminalNode* SV3_1aParser::Class_declarationContext::VIRTUAL() {
  return getToken(SV3_1aParser::VIRTUAL, 0);
}

SV3_1aParser::LifetimeContext* SV3_1aParser::Class_declarationContext::lifetime() {
  return getRuleContext<SV3_1aParser::LifetimeContext>(0);
}

SV3_1aParser::Parameter_port_listContext* SV3_1aParser::Class_declarationContext::parameter_port_list() {
  return getRuleContext<SV3_1aParser::Parameter_port_listContext>(0);
}

tree::TerminalNode* SV3_1aParser::Class_declarationContext::EXTENDS() {
  return getToken(SV3_1aParser::EXTENDS, 0);
}

SV3_1aParser::Class_typeContext* SV3_1aParser::Class_declarationContext::class_type() {
  return getRuleContext<SV3_1aParser::Class_typeContext>(0);
}

tree::TerminalNode* SV3_1aParser::Class_declarationContext::IMPLEMENTS() {
  return getToken(SV3_1aParser::IMPLEMENTS, 0);
}

std::vector<SV3_1aParser::Interface_class_typeContext *> SV3_1aParser::Class_declarationContext::interface_class_type() {
  return getRuleContexts<SV3_1aParser::Interface_class_typeContext>();
}

SV3_1aParser::Interface_class_typeContext* SV3_1aParser::Class_declarationContext::interface_class_type(size_t i) {
  return getRuleContext<SV3_1aParser::Interface_class_typeContext>(i);
}

std::vector<SV3_1aParser::Class_itemContext *> SV3_1aParser::Class_declarationContext::class_item() {
  return getRuleContexts<SV3_1aParser::Class_itemContext>();
}

SV3_1aParser::Class_itemContext* SV3_1aParser::Class_declarationContext::class_item(size_t i) {
  return getRuleContext<SV3_1aParser::Class_itemContext>(i);
}

tree::TerminalNode* SV3_1aParser::Class_declarationContext::COLON() {
  return getToken(SV3_1aParser::COLON, 0);
}

tree::TerminalNode* SV3_1aParser::Class_declarationContext::OPEN_PARENS() {
  return getToken(SV3_1aParser::OPEN_PARENS, 0);
}

SV3_1aParser::List_of_argumentsContext* SV3_1aParser::Class_declarationContext::list_of_arguments() {
  return getRuleContext<SV3_1aParser::List_of_argumentsContext>(0);
}

tree::TerminalNode* SV3_1aParser::Class_declarationContext::CLOSE_PARENS() {
  return getToken(SV3_1aParser::CLOSE_PARENS, 0);
}

std::vector<tree::TerminalNode *> SV3_1aParser::Class_declarationContext::COMMA() {
  return getTokens(SV3_1aParser::COMMA);
}

tree::TerminalNode* SV3_1aParser::Class_declarationContext::COMMA(size_t i) {
  return getToken(SV3_1aParser::COMMA, i);
}


size_t SV3_1aParser::Class_declarationContext::getRuleIndex() const {
  return SV3_1aParser::RuleClass_declaration;
}

void SV3_1aParser::Class_declarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterClass_declaration(this);
}

void SV3_1aParser::Class_declarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitClass_declaration(this);
}

SV3_1aParser::Class_declarationContext* SV3_1aParser::class_declaration() {
  Class_declarationContext *_localctx = _tracker.createInstance<Class_declarationContext>(_ctx, getState());
  enterRule(_localctx, 42, SV3_1aParser::RuleClass_declaration);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1809);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SV3_1aParser::VIRTUAL) {
      setState(1808);
      match(SV3_1aParser::VIRTUAL);
    }
    setState(1811);
    match(SV3_1aParser::CLASS);
    setState(1813);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SV3_1aParser::STATIC

    || _la == SV3_1aParser::AUTOMATIC) {
      setState(1812);
      lifetime();
    }
    setState(1815);
    identifier();
    setState(1817);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SV3_1aParser::POUND) {
      setState(1816);
      parameter_port_list();
    }
    setState(1827);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SV3_1aParser::EXTENDS) {
      setState(1819);
      match(SV3_1aParser::EXTENDS);
      setState(1820);
      class_type();
      setState(1825);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == SV3_1aParser::OPEN_PARENS) {
        setState(1821);
        match(SV3_1aParser::OPEN_PARENS);
        setState(1822);
        list_of_arguments();
        setState(1823);
        match(SV3_1aParser::CLOSE_PARENS);
      }
    }
    setState(1838);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SV3_1aParser::IMPLEMENTS) {
      setState(1829);
      match(SV3_1aParser::IMPLEMENTS);
      setState(1830);
      interface_class_type();
      setState(1835);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == SV3_1aParser::COMMA) {
        setState(1831);
        match(SV3_1aParser::COMMA);
        setState(1832);
        interface_class_type();
        setState(1837);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
    }
    setState(1840);
    match(SV3_1aParser::SEMICOLON);
    setState(1844);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (((((_la - 31) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 31)) & -9212157009655201791) != 0) || ((((_la - 95) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 95)) & 49539596437878667) != 0) || ((((_la - 169) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 169)) & 562949954994177) != 0) || ((((_la - 326) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 326)) & 4810363437077) != 0) || _la == SV3_1aParser::SURELOG_MACRO_NOT_DEFINED) {
      setState(1841);
      class_item();
      setState(1846);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(1847);
    match(SV3_1aParser::ENDCLASS);
    setState(1850);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 84, _ctx)) {
    case 1: {
      setState(1848);
      match(SV3_1aParser::COLON);
      setState(1849);
      identifier();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Interface_class_typeContext ------------------------------------------------------------------

SV3_1aParser::Interface_class_typeContext::Interface_class_typeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::Ps_identifierContext* SV3_1aParser::Interface_class_typeContext::ps_identifier() {
  return getRuleContext<SV3_1aParser::Ps_identifierContext>(0);
}

SV3_1aParser::Parameter_value_assignmentContext* SV3_1aParser::Interface_class_typeContext::parameter_value_assignment() {
  return getRuleContext<SV3_1aParser::Parameter_value_assignmentContext>(0);
}


size_t SV3_1aParser::Interface_class_typeContext::getRuleIndex() const {
  return SV3_1aParser::RuleInterface_class_type;
}

void SV3_1aParser::Interface_class_typeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInterface_class_type(this);
}

void SV3_1aParser::Interface_class_typeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInterface_class_type(this);
}

SV3_1aParser::Interface_class_typeContext* SV3_1aParser::interface_class_type() {
  Interface_class_typeContext *_localctx = _tracker.createInstance<Interface_class_typeContext>(_ctx, getState());
  enterRule(_localctx, 44, SV3_1aParser::RuleInterface_class_type);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1852);
    ps_identifier();
    setState(1854);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SV3_1aParser::Pound_delay || _la == SV3_1aParser::POUND) {
      setState(1853);
      parameter_value_assignment();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Interface_class_declarationContext ------------------------------------------------------------------

SV3_1aParser::Interface_class_declarationContext::Interface_class_declarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Interface_class_declarationContext::INTERFACE() {
  return getToken(SV3_1aParser::INTERFACE, 0);
}

tree::TerminalNode* SV3_1aParser::Interface_class_declarationContext::CLASS() {
  return getToken(SV3_1aParser::CLASS, 0);
}

std::vector<SV3_1aParser::IdentifierContext *> SV3_1aParser::Interface_class_declarationContext::identifier() {
  return getRuleContexts<SV3_1aParser::IdentifierContext>();
}

SV3_1aParser::IdentifierContext* SV3_1aParser::Interface_class_declarationContext::identifier(size_t i) {
  return getRuleContext<SV3_1aParser::IdentifierContext>(i);
}

tree::TerminalNode* SV3_1aParser::Interface_class_declarationContext::SEMICOLON() {
  return getToken(SV3_1aParser::SEMICOLON, 0);
}

tree::TerminalNode* SV3_1aParser::Interface_class_declarationContext::ENDCLASS() {
  return getToken(SV3_1aParser::ENDCLASS, 0);
}

SV3_1aParser::Parameter_port_listContext* SV3_1aParser::Interface_class_declarationContext::parameter_port_list() {
  return getRuleContext<SV3_1aParser::Parameter_port_listContext>(0);
}

tree::TerminalNode* SV3_1aParser::Interface_class_declarationContext::EXTENDS() {
  return getToken(SV3_1aParser::EXTENDS, 0);
}

std::vector<SV3_1aParser::Interface_class_typeContext *> SV3_1aParser::Interface_class_declarationContext::interface_class_type() {
  return getRuleContexts<SV3_1aParser::Interface_class_typeContext>();
}

SV3_1aParser::Interface_class_typeContext* SV3_1aParser::Interface_class_declarationContext::interface_class_type(size_t i) {
  return getRuleContext<SV3_1aParser::Interface_class_typeContext>(i);
}

std::vector<SV3_1aParser::Interface_class_itemContext *> SV3_1aParser::Interface_class_declarationContext::interface_class_item() {
  return getRuleContexts<SV3_1aParser::Interface_class_itemContext>();
}

SV3_1aParser::Interface_class_itemContext* SV3_1aParser::Interface_class_declarationContext::interface_class_item(size_t i) {
  return getRuleContext<SV3_1aParser::Interface_class_itemContext>(i);
}

tree::TerminalNode* SV3_1aParser::Interface_class_declarationContext::COLON() {
  return getToken(SV3_1aParser::COLON, 0);
}

std::vector<tree::TerminalNode *> SV3_1aParser::Interface_class_declarationContext::COMMA() {
  return getTokens(SV3_1aParser::COMMA);
}

tree::TerminalNode* SV3_1aParser::Interface_class_declarationContext::COMMA(size_t i) {
  return getToken(SV3_1aParser::COMMA, i);
}


size_t SV3_1aParser::Interface_class_declarationContext::getRuleIndex() const {
  return SV3_1aParser::RuleInterface_class_declaration;
}

void SV3_1aParser::Interface_class_declarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInterface_class_declaration(this);
}

void SV3_1aParser::Interface_class_declarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInterface_class_declaration(this);
}

SV3_1aParser::Interface_class_declarationContext* SV3_1aParser::interface_class_declaration() {
  Interface_class_declarationContext *_localctx = _tracker.createInstance<Interface_class_declarationContext>(_ctx, getState());
  enterRule(_localctx, 46, SV3_1aParser::RuleInterface_class_declaration);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1856);
    match(SV3_1aParser::INTERFACE);
    setState(1857);
    match(SV3_1aParser::CLASS);
    setState(1858);
    identifier();
    setState(1860);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SV3_1aParser::POUND) {
      setState(1859);
      parameter_port_list();
    }
    setState(1871);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SV3_1aParser::EXTENDS) {
      setState(1862);
      match(SV3_1aParser::EXTENDS);
      setState(1863);
      interface_class_type();
      setState(1868);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == SV3_1aParser::COMMA) {
        setState(1864);
        match(SV3_1aParser::COMMA);
        setState(1865);
        interface_class_type();
        setState(1870);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
    }
    setState(1873);
    match(SV3_1aParser::SEMICOLON);
    setState(1877);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == SV3_1aParser::SEMICOLON || ((((_la - 95) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 95)) & 131) != 0) || _la == SV3_1aParser::PURE

    || _la == SV3_1aParser::OPEN_PARENS_STAR) {
      setState(1874);
      interface_class_item();
      setState(1879);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(1880);
    match(SV3_1aParser::ENDCLASS);
    setState(1883);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 90, _ctx)) {
    case 1: {
      setState(1881);
      match(SV3_1aParser::COLON);
      setState(1882);
      identifier();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Interface_class_itemContext ------------------------------------------------------------------

SV3_1aParser::Interface_class_itemContext::Interface_class_itemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::Type_declarationContext* SV3_1aParser::Interface_class_itemContext::type_declaration() {
  return getRuleContext<SV3_1aParser::Type_declarationContext>(0);
}

SV3_1aParser::Interface_class_methodContext* SV3_1aParser::Interface_class_itemContext::interface_class_method() {
  return getRuleContext<SV3_1aParser::Interface_class_methodContext>(0);
}

tree::TerminalNode* SV3_1aParser::Interface_class_itemContext::SEMICOLON() {
  return getToken(SV3_1aParser::SEMICOLON, 0);
}

std::vector<SV3_1aParser::Attribute_instanceContext *> SV3_1aParser::Interface_class_itemContext::attribute_instance() {
  return getRuleContexts<SV3_1aParser::Attribute_instanceContext>();
}

SV3_1aParser::Attribute_instanceContext* SV3_1aParser::Interface_class_itemContext::attribute_instance(size_t i) {
  return getRuleContext<SV3_1aParser::Attribute_instanceContext>(i);
}

SV3_1aParser::Local_parameter_declarationContext* SV3_1aParser::Interface_class_itemContext::local_parameter_declaration() {
  return getRuleContext<SV3_1aParser::Local_parameter_declarationContext>(0);
}

SV3_1aParser::Parameter_declarationContext* SV3_1aParser::Interface_class_itemContext::parameter_declaration() {
  return getRuleContext<SV3_1aParser::Parameter_declarationContext>(0);
}


size_t SV3_1aParser::Interface_class_itemContext::getRuleIndex() const {
  return SV3_1aParser::RuleInterface_class_item;
}

void SV3_1aParser::Interface_class_itemContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInterface_class_item(this);
}

void SV3_1aParser::Interface_class_itemContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInterface_class_item(this);
}

SV3_1aParser::Interface_class_itemContext* SV3_1aParser::interface_class_item() {
  Interface_class_itemContext *_localctx = _tracker.createInstance<Interface_class_itemContext>(_ctx, getState());
  enterRule(_localctx, 48, SV3_1aParser::RuleInterface_class_item);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1902);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SV3_1aParser::TYPEDEF: {
        enterOuterAlt(_localctx, 1);
        setState(1885);
        type_declaration();
        break;
      }

      case SV3_1aParser::PURE:
      case SV3_1aParser::OPEN_PARENS_STAR: {
        enterOuterAlt(_localctx, 2);
        setState(1889);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == SV3_1aParser::OPEN_PARENS_STAR) {
          setState(1886);
          attribute_instance();
          setState(1891);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(1892);
        interface_class_method();
        setState(1893);
        match(SV3_1aParser::SEMICOLON);
        break;
      }

      case SV3_1aParser::LOCALPARAM: {
        enterOuterAlt(_localctx, 3);
        setState(1895);
        local_parameter_declaration();
        setState(1896);
        match(SV3_1aParser::SEMICOLON);
        break;
      }

      case SV3_1aParser::PARAMETER: {
        enterOuterAlt(_localctx, 4);
        setState(1898);
        parameter_declaration();
        setState(1899);
        match(SV3_1aParser::SEMICOLON);
        break;
      }

      case SV3_1aParser::SEMICOLON: {
        enterOuterAlt(_localctx, 5);
        setState(1901);
        match(SV3_1aParser::SEMICOLON);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Interface_class_methodContext ------------------------------------------------------------------

SV3_1aParser::Interface_class_methodContext::Interface_class_methodContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Interface_class_methodContext::PURE() {
  return getToken(SV3_1aParser::PURE, 0);
}

tree::TerminalNode* SV3_1aParser::Interface_class_methodContext::VIRTUAL() {
  return getToken(SV3_1aParser::VIRTUAL, 0);
}

SV3_1aParser::Method_prototypeContext* SV3_1aParser::Interface_class_methodContext::method_prototype() {
  return getRuleContext<SV3_1aParser::Method_prototypeContext>(0);
}


size_t SV3_1aParser::Interface_class_methodContext::getRuleIndex() const {
  return SV3_1aParser::RuleInterface_class_method;
}

void SV3_1aParser::Interface_class_methodContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInterface_class_method(this);
}

void SV3_1aParser::Interface_class_methodContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInterface_class_method(this);
}

SV3_1aParser::Interface_class_methodContext* SV3_1aParser::interface_class_method() {
  Interface_class_methodContext *_localctx = _tracker.createInstance<Interface_class_methodContext>(_ctx, getState());
  enterRule(_localctx, 50, SV3_1aParser::RuleInterface_class_method);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1904);
    match(SV3_1aParser::PURE);
    setState(1905);
    match(SV3_1aParser::VIRTUAL);
    setState(1906);
    method_prototype();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Package_declarationContext ------------------------------------------------------------------

SV3_1aParser::Package_declarationContext::Package_declarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Package_declarationContext::PACKAGE() {
  return getToken(SV3_1aParser::PACKAGE, 0);
}

std::vector<SV3_1aParser::IdentifierContext *> SV3_1aParser::Package_declarationContext::identifier() {
  return getRuleContexts<SV3_1aParser::IdentifierContext>();
}

SV3_1aParser::IdentifierContext* SV3_1aParser::Package_declarationContext::identifier(size_t i) {
  return getRuleContext<SV3_1aParser::IdentifierContext>(i);
}

tree::TerminalNode* SV3_1aParser::Package_declarationContext::SEMICOLON() {
  return getToken(SV3_1aParser::SEMICOLON, 0);
}

tree::TerminalNode* SV3_1aParser::Package_declarationContext::ENDPACKAGE() {
  return getToken(SV3_1aParser::ENDPACKAGE, 0);
}

std::vector<SV3_1aParser::Attribute_instanceContext *> SV3_1aParser::Package_declarationContext::attribute_instance() {
  return getRuleContexts<SV3_1aParser::Attribute_instanceContext>();
}

SV3_1aParser::Attribute_instanceContext* SV3_1aParser::Package_declarationContext::attribute_instance(size_t i) {
  return getRuleContext<SV3_1aParser::Attribute_instanceContext>(i);
}

SV3_1aParser::Timeunits_declarationContext* SV3_1aParser::Package_declarationContext::timeunits_declaration() {
  return getRuleContext<SV3_1aParser::Timeunits_declarationContext>(0);
}

std::vector<SV3_1aParser::Package_itemContext *> SV3_1aParser::Package_declarationContext::package_item() {
  return getRuleContexts<SV3_1aParser::Package_itemContext>();
}

SV3_1aParser::Package_itemContext* SV3_1aParser::Package_declarationContext::package_item(size_t i) {
  return getRuleContext<SV3_1aParser::Package_itemContext>(i);
}

tree::TerminalNode* SV3_1aParser::Package_declarationContext::COLON() {
  return getToken(SV3_1aParser::COLON, 0);
}


size_t SV3_1aParser::Package_declarationContext::getRuleIndex() const {
  return SV3_1aParser::RulePackage_declaration;
}

void SV3_1aParser::Package_declarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPackage_declaration(this);
}

void SV3_1aParser::Package_declarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPackage_declaration(this);
}

SV3_1aParser::Package_declarationContext* SV3_1aParser::package_declaration() {
  Package_declarationContext *_localctx = _tracker.createInstance<Package_declarationContext>(_ctx, getState());
  enterRule(_localctx, 52, SV3_1aParser::RulePackage_declaration);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1911);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == SV3_1aParser::OPEN_PARENS_STAR) {
      setState(1908);
      attribute_instance();
      setState(1913);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(1914);
    match(SV3_1aParser::PACKAGE);
    setState(1915);
    identifier();
    setState(1916);
    match(SV3_1aParser::SEMICOLON);
    setState(1918);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 94, _ctx)) {
    case 1: {
      setState(1917);
      timeunits_declaration();
      break;
    }

    default:
      break;
    }
    setState(1929);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (((((_la - 31) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 31)) & -9214265872017129471) != 0) || ((((_la - 95) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 95)) & 72056495063103375) != 0) || ((((_la - 167) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 167)) & 2251937292484609) != 0) || ((((_la - 315) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 315)) & 9851624319133697) != 0)) {
      setState(1923);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == SV3_1aParser::OPEN_PARENS_STAR) {
        setState(1920);
        attribute_instance();
        setState(1925);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(1926);
      package_item();
      setState(1931);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(1932);
    match(SV3_1aParser::ENDPACKAGE);
    setState(1935);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SV3_1aParser::COLON) {
      setState(1933);
      match(SV3_1aParser::COLON);
      setState(1934);
      identifier();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Timeunits_declarationContext ------------------------------------------------------------------

SV3_1aParser::Timeunits_declarationContext::Timeunits_declarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t SV3_1aParser::Timeunits_declarationContext::getRuleIndex() const {
  return SV3_1aParser::RuleTimeunits_declaration;
}

void SV3_1aParser::Timeunits_declarationContext::copyFrom(Timeunits_declarationContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- TimeUnitsDecl_TimeUnitDivContext ------------------------------------------------------------------

tree::TerminalNode* SV3_1aParser::TimeUnitsDecl_TimeUnitDivContext::TIMEUNIT() {
  return getToken(SV3_1aParser::TIMEUNIT, 0);
}

std::vector<SV3_1aParser::Time_literalContext *> SV3_1aParser::TimeUnitsDecl_TimeUnitDivContext::time_literal() {
  return getRuleContexts<SV3_1aParser::Time_literalContext>();
}

SV3_1aParser::Time_literalContext* SV3_1aParser::TimeUnitsDecl_TimeUnitDivContext::time_literal(size_t i) {
  return getRuleContext<SV3_1aParser::Time_literalContext>(i);
}

tree::TerminalNode* SV3_1aParser::TimeUnitsDecl_TimeUnitDivContext::DIV() {
  return getToken(SV3_1aParser::DIV, 0);
}

tree::TerminalNode* SV3_1aParser::TimeUnitsDecl_TimeUnitDivContext::SEMICOLON() {
  return getToken(SV3_1aParser::SEMICOLON, 0);
}

SV3_1aParser::TimeUnitsDecl_TimeUnitDivContext::TimeUnitsDecl_TimeUnitDivContext(Timeunits_declarationContext *ctx) { copyFrom(ctx); }

void SV3_1aParser::TimeUnitsDecl_TimeUnitDivContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTimeUnitsDecl_TimeUnitDiv(this);
}
void SV3_1aParser::TimeUnitsDecl_TimeUnitDivContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTimeUnitsDecl_TimeUnitDiv(this);
}
//----------------- TimeUnitsDecl_TimePrecisionTimeUnitContext ------------------------------------------------------------------

tree::TerminalNode* SV3_1aParser::TimeUnitsDecl_TimePrecisionTimeUnitContext::TIMEPRECISION() {
  return getToken(SV3_1aParser::TIMEPRECISION, 0);
}

std::vector<SV3_1aParser::Time_literalContext *> SV3_1aParser::TimeUnitsDecl_TimePrecisionTimeUnitContext::time_literal() {
  return getRuleContexts<SV3_1aParser::Time_literalContext>();
}

SV3_1aParser::Time_literalContext* SV3_1aParser::TimeUnitsDecl_TimePrecisionTimeUnitContext::time_literal(size_t i) {
  return getRuleContext<SV3_1aParser::Time_literalContext>(i);
}

std::vector<tree::TerminalNode *> SV3_1aParser::TimeUnitsDecl_TimePrecisionTimeUnitContext::SEMICOLON() {
  return getTokens(SV3_1aParser::SEMICOLON);
}

tree::TerminalNode* SV3_1aParser::TimeUnitsDecl_TimePrecisionTimeUnitContext::SEMICOLON(size_t i) {
  return getToken(SV3_1aParser::SEMICOLON, i);
}

tree::TerminalNode* SV3_1aParser::TimeUnitsDecl_TimePrecisionTimeUnitContext::TIMEUNIT() {
  return getToken(SV3_1aParser::TIMEUNIT, 0);
}

SV3_1aParser::TimeUnitsDecl_TimePrecisionTimeUnitContext::TimeUnitsDecl_TimePrecisionTimeUnitContext(Timeunits_declarationContext *ctx) { copyFrom(ctx); }

void SV3_1aParser::TimeUnitsDecl_TimePrecisionTimeUnitContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTimeUnitsDecl_TimePrecisionTimeUnit(this);
}
void SV3_1aParser::TimeUnitsDecl_TimePrecisionTimeUnitContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTimeUnitsDecl_TimePrecisionTimeUnit(this);
}
//----------------- TimeUnitsDecl_TimeUnitTimePrecisionContext ------------------------------------------------------------------

tree::TerminalNode* SV3_1aParser::TimeUnitsDecl_TimeUnitTimePrecisionContext::TIMEUNIT() {
  return getToken(SV3_1aParser::TIMEUNIT, 0);
}

std::vector<SV3_1aParser::Time_literalContext *> SV3_1aParser::TimeUnitsDecl_TimeUnitTimePrecisionContext::time_literal() {
  return getRuleContexts<SV3_1aParser::Time_literalContext>();
}

SV3_1aParser::Time_literalContext* SV3_1aParser::TimeUnitsDecl_TimeUnitTimePrecisionContext::time_literal(size_t i) {
  return getRuleContext<SV3_1aParser::Time_literalContext>(i);
}

std::vector<tree::TerminalNode *> SV3_1aParser::TimeUnitsDecl_TimeUnitTimePrecisionContext::SEMICOLON() {
  return getTokens(SV3_1aParser::SEMICOLON);
}

tree::TerminalNode* SV3_1aParser::TimeUnitsDecl_TimeUnitTimePrecisionContext::SEMICOLON(size_t i) {
  return getToken(SV3_1aParser::SEMICOLON, i);
}

tree::TerminalNode* SV3_1aParser::TimeUnitsDecl_TimeUnitTimePrecisionContext::TIMEPRECISION() {
  return getToken(SV3_1aParser::TIMEPRECISION, 0);
}

SV3_1aParser::TimeUnitsDecl_TimeUnitTimePrecisionContext::TimeUnitsDecl_TimeUnitTimePrecisionContext(Timeunits_declarationContext *ctx) { copyFrom(ctx); }

void SV3_1aParser::TimeUnitsDecl_TimeUnitTimePrecisionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTimeUnitsDecl_TimeUnitTimePrecision(this);
}
void SV3_1aParser::TimeUnitsDecl_TimeUnitTimePrecisionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTimeUnitsDecl_TimeUnitTimePrecision(this);
}
//----------------- TimeUnitsDecl_TimeUnitContext ------------------------------------------------------------------

tree::TerminalNode* SV3_1aParser::TimeUnitsDecl_TimeUnitContext::TIMEUNIT() {
  return getToken(SV3_1aParser::TIMEUNIT, 0);
}

SV3_1aParser::Time_literalContext* SV3_1aParser::TimeUnitsDecl_TimeUnitContext::time_literal() {
  return getRuleContext<SV3_1aParser::Time_literalContext>(0);
}

tree::TerminalNode* SV3_1aParser::TimeUnitsDecl_TimeUnitContext::SEMICOLON() {
  return getToken(SV3_1aParser::SEMICOLON, 0);
}

SV3_1aParser::TimeUnitsDecl_TimeUnitContext::TimeUnitsDecl_TimeUnitContext(Timeunits_declarationContext *ctx) { copyFrom(ctx); }

void SV3_1aParser::TimeUnitsDecl_TimeUnitContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTimeUnitsDecl_TimeUnit(this);
}
void SV3_1aParser::TimeUnitsDecl_TimeUnitContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTimeUnitsDecl_TimeUnit(this);
}
//----------------- TimeUnitsDecl_TimePrecisionContext ------------------------------------------------------------------

tree::TerminalNode* SV3_1aParser::TimeUnitsDecl_TimePrecisionContext::TIMEPRECISION() {
  return getToken(SV3_1aParser::TIMEPRECISION, 0);
}

SV3_1aParser::Time_literalContext* SV3_1aParser::TimeUnitsDecl_TimePrecisionContext::time_literal() {
  return getRuleContext<SV3_1aParser::Time_literalContext>(0);
}

tree::TerminalNode* SV3_1aParser::TimeUnitsDecl_TimePrecisionContext::SEMICOLON() {
  return getToken(SV3_1aParser::SEMICOLON, 0);
}

SV3_1aParser::TimeUnitsDecl_TimePrecisionContext::TimeUnitsDecl_TimePrecisionContext(Timeunits_declarationContext *ctx) { copyFrom(ctx); }

void SV3_1aParser::TimeUnitsDecl_TimePrecisionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTimeUnitsDecl_TimePrecision(this);
}
void SV3_1aParser::TimeUnitsDecl_TimePrecisionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTimeUnitsDecl_TimePrecision(this);
}
SV3_1aParser::Timeunits_declarationContext* SV3_1aParser::timeunits_declaration() {
  Timeunits_declarationContext *_localctx = _tracker.createInstance<Timeunits_declarationContext>(_ctx, getState());
  enterRule(_localctx, 54, SV3_1aParser::RuleTimeunits_declaration);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1965);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 98, _ctx)) {
    case 1: {
      _localctx = _tracker.createInstance<SV3_1aParser::TimeUnitsDecl_TimeUnitDivContext>(_localctx);
      enterOuterAlt(_localctx, 1);
      setState(1937);
      match(SV3_1aParser::TIMEUNIT);
      setState(1938);
      time_literal();
      setState(1939);
      match(SV3_1aParser::DIV);
      setState(1940);
      time_literal();
      setState(1941);
      match(SV3_1aParser::SEMICOLON);
      break;
    }

    case 2: {
      _localctx = _tracker.createInstance<SV3_1aParser::TimeUnitsDecl_TimeUnitContext>(_localctx);
      enterOuterAlt(_localctx, 2);
      setState(1943);
      match(SV3_1aParser::TIMEUNIT);
      setState(1944);
      time_literal();
      setState(1945);
      match(SV3_1aParser::SEMICOLON);
      break;
    }

    case 3: {
      _localctx = _tracker.createInstance<SV3_1aParser::TimeUnitsDecl_TimePrecisionContext>(_localctx);
      enterOuterAlt(_localctx, 3);
      setState(1947);
      match(SV3_1aParser::TIMEPRECISION);
      setState(1948);
      time_literal();
      setState(1949);
      match(SV3_1aParser::SEMICOLON);
      break;
    }

    case 4: {
      _localctx = _tracker.createInstance<SV3_1aParser::TimeUnitsDecl_TimeUnitTimePrecisionContext>(_localctx);
      enterOuterAlt(_localctx, 4);
      setState(1951);
      match(SV3_1aParser::TIMEUNIT);
      setState(1952);
      time_literal();
      setState(1953);
      match(SV3_1aParser::SEMICOLON);
      setState(1954);
      match(SV3_1aParser::TIMEPRECISION);
      setState(1955);
      time_literal();
      setState(1956);
      match(SV3_1aParser::SEMICOLON);
      break;
    }

    case 5: {
      _localctx = _tracker.createInstance<SV3_1aParser::TimeUnitsDecl_TimePrecisionTimeUnitContext>(_localctx);
      enterOuterAlt(_localctx, 5);
      setState(1958);
      match(SV3_1aParser::TIMEPRECISION);
      setState(1959);
      time_literal();
      setState(1960);
      match(SV3_1aParser::SEMICOLON);
      setState(1961);
      match(SV3_1aParser::TIMEUNIT);
      setState(1962);
      time_literal();
      setState(1963);
      match(SV3_1aParser::SEMICOLON);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Parameter_port_listContext ------------------------------------------------------------------

SV3_1aParser::Parameter_port_listContext::Parameter_port_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Parameter_port_listContext::POUND() {
  return getToken(SV3_1aParser::POUND, 0);
}

tree::TerminalNode* SV3_1aParser::Parameter_port_listContext::OPEN_PARENS() {
  return getToken(SV3_1aParser::OPEN_PARENS, 0);
}

SV3_1aParser::List_of_param_assignmentsContext* SV3_1aParser::Parameter_port_listContext::list_of_param_assignments() {
  return getRuleContext<SV3_1aParser::List_of_param_assignmentsContext>(0);
}

tree::TerminalNode* SV3_1aParser::Parameter_port_listContext::CLOSE_PARENS() {
  return getToken(SV3_1aParser::CLOSE_PARENS, 0);
}

std::vector<tree::TerminalNode *> SV3_1aParser::Parameter_port_listContext::COMMA() {
  return getTokens(SV3_1aParser::COMMA);
}

tree::TerminalNode* SV3_1aParser::Parameter_port_listContext::COMMA(size_t i) {
  return getToken(SV3_1aParser::COMMA, i);
}

std::vector<SV3_1aParser::Parameter_port_declarationContext *> SV3_1aParser::Parameter_port_listContext::parameter_port_declaration() {
  return getRuleContexts<SV3_1aParser::Parameter_port_declarationContext>();
}

SV3_1aParser::Parameter_port_declarationContext* SV3_1aParser::Parameter_port_listContext::parameter_port_declaration(size_t i) {
  return getRuleContext<SV3_1aParser::Parameter_port_declarationContext>(i);
}


size_t SV3_1aParser::Parameter_port_listContext::getRuleIndex() const {
  return SV3_1aParser::RuleParameter_port_list;
}

void SV3_1aParser::Parameter_port_listContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterParameter_port_list(this);
}

void SV3_1aParser::Parameter_port_listContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitParameter_port_list(this);
}

SV3_1aParser::Parameter_port_listContext* SV3_1aParser::parameter_port_list() {
  Parameter_port_listContext *_localctx = _tracker.createInstance<Parameter_port_listContext>(_ctx, getState());
  enterRule(_localctx, 56, SV3_1aParser::RuleParameter_port_list);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1994);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 101, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1967);
      match(SV3_1aParser::POUND);
      setState(1968);
      match(SV3_1aParser::OPEN_PARENS);
      setState(1969);
      list_of_param_assignments();
      setState(1974);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == SV3_1aParser::COMMA) {
        setState(1970);
        match(SV3_1aParser::COMMA);
        setState(1971);
        parameter_port_declaration();
        setState(1976);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(1977);
      match(SV3_1aParser::CLOSE_PARENS);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1979);
      match(SV3_1aParser::POUND);
      setState(1980);
      match(SV3_1aParser::OPEN_PARENS);
      setState(1981);
      parameter_port_declaration();
      setState(1986);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == SV3_1aParser::COMMA) {
        setState(1982);
        match(SV3_1aParser::COMMA);
        setState(1983);
        parameter_port_declaration();
        setState(1988);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(1989);
      match(SV3_1aParser::CLOSE_PARENS);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(1991);
      match(SV3_1aParser::POUND);
      setState(1992);
      match(SV3_1aParser::OPEN_PARENS);
      setState(1993);
      match(SV3_1aParser::CLOSE_PARENS);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Parameter_port_declarationContext ------------------------------------------------------------------

SV3_1aParser::Parameter_port_declarationContext::Parameter_port_declarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::Parameter_declarationContext* SV3_1aParser::Parameter_port_declarationContext::parameter_declaration() {
  return getRuleContext<SV3_1aParser::Parameter_declarationContext>(0);
}

SV3_1aParser::Local_parameter_declarationContext* SV3_1aParser::Parameter_port_declarationContext::local_parameter_declaration() {
  return getRuleContext<SV3_1aParser::Local_parameter_declarationContext>(0);
}

SV3_1aParser::Data_typeContext* SV3_1aParser::Parameter_port_declarationContext::data_type() {
  return getRuleContext<SV3_1aParser::Data_typeContext>(0);
}

SV3_1aParser::List_of_param_assignmentsContext* SV3_1aParser::Parameter_port_declarationContext::list_of_param_assignments() {
  return getRuleContext<SV3_1aParser::List_of_param_assignmentsContext>(0);
}

tree::TerminalNode* SV3_1aParser::Parameter_port_declarationContext::TYPE() {
  return getToken(SV3_1aParser::TYPE, 0);
}

SV3_1aParser::List_of_type_assignmentsContext* SV3_1aParser::Parameter_port_declarationContext::list_of_type_assignments() {
  return getRuleContext<SV3_1aParser::List_of_type_assignmentsContext>(0);
}


size_t SV3_1aParser::Parameter_port_declarationContext::getRuleIndex() const {
  return SV3_1aParser::RuleParameter_port_declaration;
}

void SV3_1aParser::Parameter_port_declarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterParameter_port_declaration(this);
}

void SV3_1aParser::Parameter_port_declarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitParameter_port_declaration(this);
}

SV3_1aParser::Parameter_port_declarationContext* SV3_1aParser::parameter_port_declaration() {
  Parameter_port_declarationContext *_localctx = _tracker.createInstance<Parameter_port_declarationContext>(_ctx, getState());
  enterRule(_localctx, 58, SV3_1aParser::RuleParameter_port_declaration);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2003);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 102, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1996);
      parameter_declaration();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1997);
      local_parameter_declaration();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(1998);
      data_type();
      setState(1999);
      list_of_param_assignments();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(2001);
      match(SV3_1aParser::TYPE);
      setState(2002);
      list_of_type_assignments();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- List_of_portsContext ------------------------------------------------------------------

SV3_1aParser::List_of_portsContext::List_of_portsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::List_of_portsContext::OPEN_PARENS() {
  return getToken(SV3_1aParser::OPEN_PARENS, 0);
}

std::vector<SV3_1aParser::PortContext *> SV3_1aParser::List_of_portsContext::port() {
  return getRuleContexts<SV3_1aParser::PortContext>();
}

SV3_1aParser::PortContext* SV3_1aParser::List_of_portsContext::port(size_t i) {
  return getRuleContext<SV3_1aParser::PortContext>(i);
}

tree::TerminalNode* SV3_1aParser::List_of_portsContext::CLOSE_PARENS() {
  return getToken(SV3_1aParser::CLOSE_PARENS, 0);
}

std::vector<tree::TerminalNode *> SV3_1aParser::List_of_portsContext::COMMA() {
  return getTokens(SV3_1aParser::COMMA);
}

tree::TerminalNode* SV3_1aParser::List_of_portsContext::COMMA(size_t i) {
  return getToken(SV3_1aParser::COMMA, i);
}


size_t SV3_1aParser::List_of_portsContext::getRuleIndex() const {
  return SV3_1aParser::RuleList_of_ports;
}

void SV3_1aParser::List_of_portsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterList_of_ports(this);
}

void SV3_1aParser::List_of_portsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitList_of_ports(this);
}

SV3_1aParser::List_of_portsContext* SV3_1aParser::list_of_ports() {
  List_of_portsContext *_localctx = _tracker.createInstance<List_of_portsContext>(_ctx, getState());
  enterRule(_localctx, 60, SV3_1aParser::RuleList_of_ports);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2005);
    match(SV3_1aParser::OPEN_PARENS);
    setState(2006);
    port();
    setState(2011);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == SV3_1aParser::COMMA) {
      setState(2007);
      match(SV3_1aParser::COMMA);
      setState(2008);
      port();
      setState(2013);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(2014);
    match(SV3_1aParser::CLOSE_PARENS);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- List_of_port_declarationsContext ------------------------------------------------------------------

SV3_1aParser::List_of_port_declarationsContext::List_of_port_declarationsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::List_of_port_declarationsContext::OPEN_PARENS() {
  return getToken(SV3_1aParser::OPEN_PARENS, 0);
}

tree::TerminalNode* SV3_1aParser::List_of_port_declarationsContext::CLOSE_PARENS() {
  return getToken(SV3_1aParser::CLOSE_PARENS, 0);
}

std::vector<SV3_1aParser::Ansi_port_declarationContext *> SV3_1aParser::List_of_port_declarationsContext::ansi_port_declaration() {
  return getRuleContexts<SV3_1aParser::Ansi_port_declarationContext>();
}

SV3_1aParser::Ansi_port_declarationContext* SV3_1aParser::List_of_port_declarationsContext::ansi_port_declaration(size_t i) {
  return getRuleContext<SV3_1aParser::Ansi_port_declarationContext>(i);
}

std::vector<SV3_1aParser::Attribute_instanceContext *> SV3_1aParser::List_of_port_declarationsContext::attribute_instance() {
  return getRuleContexts<SV3_1aParser::Attribute_instanceContext>();
}

SV3_1aParser::Attribute_instanceContext* SV3_1aParser::List_of_port_declarationsContext::attribute_instance(size_t i) {
  return getRuleContext<SV3_1aParser::Attribute_instanceContext>(i);
}

std::vector<tree::TerminalNode *> SV3_1aParser::List_of_port_declarationsContext::COMMA() {
  return getTokens(SV3_1aParser::COMMA);
}

tree::TerminalNode* SV3_1aParser::List_of_port_declarationsContext::COMMA(size_t i) {
  return getToken(SV3_1aParser::COMMA, i);
}


size_t SV3_1aParser::List_of_port_declarationsContext::getRuleIndex() const {
  return SV3_1aParser::RuleList_of_port_declarations;
}

void SV3_1aParser::List_of_port_declarationsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterList_of_port_declarations(this);
}

void SV3_1aParser::List_of_port_declarationsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitList_of_port_declarations(this);
}

SV3_1aParser::List_of_port_declarationsContext* SV3_1aParser::list_of_port_declarations() {
  List_of_port_declarationsContext *_localctx = _tracker.createInstance<List_of_port_declarationsContext>(_ctx, getState());
  enterRule(_localctx, 62, SV3_1aParser::RuleList_of_port_declarations);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2016);
    match(SV3_1aParser::OPEN_PARENS);
    setState(2037);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 4785108963819520) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 64)) & 1152775819316166717) != 0) || ((((_la - 135) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 135)) & 27021597764288511) != 0) || ((((_la - 326) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 326)) & 4672924483591) != 0)) {
      setState(2020);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == SV3_1aParser::OPEN_PARENS_STAR) {
        setState(2017);
        attribute_instance();
        setState(2022);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(2023);
      ansi_port_declaration();
      setState(2034);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == SV3_1aParser::COMMA) {
        setState(2024);
        match(SV3_1aParser::COMMA);
        setState(2028);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == SV3_1aParser::OPEN_PARENS_STAR) {
          setState(2025);
          attribute_instance();
          setState(2030);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(2031);
        ansi_port_declaration();
        setState(2036);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
    }
    setState(2039);
    match(SV3_1aParser::CLOSE_PARENS);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Port_declarationContext ------------------------------------------------------------------

SV3_1aParser::Port_declarationContext::Port_declarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::Inout_declarationContext* SV3_1aParser::Port_declarationContext::inout_declaration() {
  return getRuleContext<SV3_1aParser::Inout_declarationContext>(0);
}

SV3_1aParser::Input_declarationContext* SV3_1aParser::Port_declarationContext::input_declaration() {
  return getRuleContext<SV3_1aParser::Input_declarationContext>(0);
}

SV3_1aParser::Output_declarationContext* SV3_1aParser::Port_declarationContext::output_declaration() {
  return getRuleContext<SV3_1aParser::Output_declarationContext>(0);
}

SV3_1aParser::Ref_declarationContext* SV3_1aParser::Port_declarationContext::ref_declaration() {
  return getRuleContext<SV3_1aParser::Ref_declarationContext>(0);
}

SV3_1aParser::Interface_port_declarationContext* SV3_1aParser::Port_declarationContext::interface_port_declaration() {
  return getRuleContext<SV3_1aParser::Interface_port_declarationContext>(0);
}

std::vector<SV3_1aParser::Attribute_instanceContext *> SV3_1aParser::Port_declarationContext::attribute_instance() {
  return getRuleContexts<SV3_1aParser::Attribute_instanceContext>();
}

SV3_1aParser::Attribute_instanceContext* SV3_1aParser::Port_declarationContext::attribute_instance(size_t i) {
  return getRuleContext<SV3_1aParser::Attribute_instanceContext>(i);
}


size_t SV3_1aParser::Port_declarationContext::getRuleIndex() const {
  return SV3_1aParser::RulePort_declaration;
}

void SV3_1aParser::Port_declarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPort_declaration(this);
}

void SV3_1aParser::Port_declarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPort_declaration(this);
}

SV3_1aParser::Port_declarationContext* SV3_1aParser::port_declaration() {
  Port_declarationContext *_localctx = _tracker.createInstance<Port_declarationContext>(_ctx, getState());
  enterRule(_localctx, 64, SV3_1aParser::RulePort_declaration);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2044);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == SV3_1aParser::OPEN_PARENS_STAR) {
      setState(2041);
      attribute_instance();
      setState(2046);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(2052);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SV3_1aParser::INOUT: {
        setState(2047);
        inout_declaration();
        break;
      }

      case SV3_1aParser::INPUT: {
        setState(2048);
        input_declaration();
        break;
      }

      case SV3_1aParser::OUTPUT: {
        setState(2049);
        output_declaration();
        break;
      }

      case SV3_1aParser::REF: {
        setState(2050);
        ref_declaration();
        break;
      }

      case SV3_1aParser::THIS:
      case SV3_1aParser::DOLLAR_ROOT:
      case SV3_1aParser::RANDOMIZE:
      case SV3_1aParser::SAMPLE:
      case SV3_1aParser::Escaped_identifier:
      case SV3_1aParser::Simple_identifier: {
        setState(2051);
        interface_port_declaration();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PortContext ------------------------------------------------------------------

SV3_1aParser::PortContext::PortContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::Port_expressionContext* SV3_1aParser::PortContext::port_expression() {
  return getRuleContext<SV3_1aParser::Port_expressionContext>(0);
}

tree::TerminalNode* SV3_1aParser::PortContext::DOT() {
  return getToken(SV3_1aParser::DOT, 0);
}

SV3_1aParser::IdentifierContext* SV3_1aParser::PortContext::identifier() {
  return getRuleContext<SV3_1aParser::IdentifierContext>(0);
}

tree::TerminalNode* SV3_1aParser::PortContext::OPEN_PARENS() {
  return getToken(SV3_1aParser::OPEN_PARENS, 0);
}

tree::TerminalNode* SV3_1aParser::PortContext::CLOSE_PARENS() {
  return getToken(SV3_1aParser::CLOSE_PARENS, 0);
}


size_t SV3_1aParser::PortContext::getRuleIndex() const {
  return SV3_1aParser::RulePort;
}

void SV3_1aParser::PortContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPort(this);
}

void SV3_1aParser::PortContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPort(this);
}

SV3_1aParser::PortContext* SV3_1aParser::port() {
  PortContext *_localctx = _tracker.createInstance<PortContext>(_ctx, getState());
  enterRule(_localctx, 66, SV3_1aParser::RulePort);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2065);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SV3_1aParser::COMMA:
      case SV3_1aParser::CLOSE_PARENS:
      case SV3_1aParser::OPEN_CURLY:
      case SV3_1aParser::THIS:
      case SV3_1aParser::RANDOMIZE:
      case SV3_1aParser::SAMPLE:
      case SV3_1aParser::Escaped_identifier:
      case SV3_1aParser::Simple_identifier: {
        enterOuterAlt(_localctx, 1);
        setState(2055);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == SV3_1aParser::OPEN_CURLY || ((((_la - 326) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 326)) & 4672924483589) != 0)) {
          setState(2054);
          port_expression();
        }
        break;
      }

      case SV3_1aParser::DOT: {
        enterOuterAlt(_localctx, 2);
        setState(2057);
        match(SV3_1aParser::DOT);
        setState(2058);
        identifier();
        setState(2059);
        match(SV3_1aParser::OPEN_PARENS);
        setState(2061);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == SV3_1aParser::OPEN_CURLY || ((((_la - 326) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 326)) & 4672924483589) != 0)) {
          setState(2060);
          port_expression();
        }
        setState(2063);
        match(SV3_1aParser::CLOSE_PARENS);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Port_expressionContext ------------------------------------------------------------------

SV3_1aParser::Port_expressionContext::Port_expressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<SV3_1aParser::Port_referenceContext *> SV3_1aParser::Port_expressionContext::port_reference() {
  return getRuleContexts<SV3_1aParser::Port_referenceContext>();
}

SV3_1aParser::Port_referenceContext* SV3_1aParser::Port_expressionContext::port_reference(size_t i) {
  return getRuleContext<SV3_1aParser::Port_referenceContext>(i);
}

tree::TerminalNode* SV3_1aParser::Port_expressionContext::OPEN_CURLY() {
  return getToken(SV3_1aParser::OPEN_CURLY, 0);
}

tree::TerminalNode* SV3_1aParser::Port_expressionContext::CLOSE_CURLY() {
  return getToken(SV3_1aParser::CLOSE_CURLY, 0);
}

std::vector<tree::TerminalNode *> SV3_1aParser::Port_expressionContext::COMMA() {
  return getTokens(SV3_1aParser::COMMA);
}

tree::TerminalNode* SV3_1aParser::Port_expressionContext::COMMA(size_t i) {
  return getToken(SV3_1aParser::COMMA, i);
}


size_t SV3_1aParser::Port_expressionContext::getRuleIndex() const {
  return SV3_1aParser::RulePort_expression;
}

void SV3_1aParser::Port_expressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPort_expression(this);
}

void SV3_1aParser::Port_expressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPort_expression(this);
}

SV3_1aParser::Port_expressionContext* SV3_1aParser::port_expression() {
  Port_expressionContext *_localctx = _tracker.createInstance<Port_expressionContext>(_ctx, getState());
  enterRule(_localctx, 68, SV3_1aParser::RulePort_expression);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2079);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SV3_1aParser::THIS:
      case SV3_1aParser::RANDOMIZE:
      case SV3_1aParser::SAMPLE:
      case SV3_1aParser::Escaped_identifier:
      case SV3_1aParser::Simple_identifier: {
        enterOuterAlt(_localctx, 1);
        setState(2067);
        port_reference();
        break;
      }

      case SV3_1aParser::OPEN_CURLY: {
        enterOuterAlt(_localctx, 2);
        setState(2068);
        match(SV3_1aParser::OPEN_CURLY);
        setState(2069);
        port_reference();
        setState(2074);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == SV3_1aParser::COMMA) {
          setState(2070);
          match(SV3_1aParser::COMMA);
          setState(2071);
          port_reference();
          setState(2076);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(2077);
        match(SV3_1aParser::CLOSE_CURLY);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Port_referenceContext ------------------------------------------------------------------

SV3_1aParser::Port_referenceContext::Port_referenceContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::IdentifierContext* SV3_1aParser::Port_referenceContext::identifier() {
  return getRuleContext<SV3_1aParser::IdentifierContext>(0);
}

SV3_1aParser::Constant_selectContext* SV3_1aParser::Port_referenceContext::constant_select() {
  return getRuleContext<SV3_1aParser::Constant_selectContext>(0);
}


size_t SV3_1aParser::Port_referenceContext::getRuleIndex() const {
  return SV3_1aParser::RulePort_reference;
}

void SV3_1aParser::Port_referenceContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPort_reference(this);
}

void SV3_1aParser::Port_referenceContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPort_reference(this);
}

SV3_1aParser::Port_referenceContext* SV3_1aParser::port_reference() {
  Port_referenceContext *_localctx = _tracker.createInstance<Port_referenceContext>(_ctx, getState());
  enterRule(_localctx, 70, SV3_1aParser::RulePort_reference);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2081);
    identifier();
    setState(2082);
    constant_select();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Port_directionContext ------------------------------------------------------------------

SV3_1aParser::Port_directionContext::Port_directionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Port_directionContext::INPUT() {
  return getToken(SV3_1aParser::INPUT, 0);
}

tree::TerminalNode* SV3_1aParser::Port_directionContext::OUTPUT() {
  return getToken(SV3_1aParser::OUTPUT, 0);
}

tree::TerminalNode* SV3_1aParser::Port_directionContext::INOUT() {
  return getToken(SV3_1aParser::INOUT, 0);
}

tree::TerminalNode* SV3_1aParser::Port_directionContext::REF() {
  return getToken(SV3_1aParser::REF, 0);
}


size_t SV3_1aParser::Port_directionContext::getRuleIndex() const {
  return SV3_1aParser::RulePort_direction;
}

void SV3_1aParser::Port_directionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPort_direction(this);
}

void SV3_1aParser::Port_directionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPort_direction(this);
}

SV3_1aParser::Port_directionContext* SV3_1aParser::port_direction() {
  Port_directionContext *_localctx = _tracker.createInstance<Port_directionContext>(_ctx, getState());
  enterRule(_localctx, 72, SV3_1aParser::RulePort_direction);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2084);
    _la = _input->LA(1);
    if (!(((((_la - 66) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 66)) & 15) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Net_port_headerContext ------------------------------------------------------------------

SV3_1aParser::Net_port_headerContext::Net_port_headerContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::Net_port_typeContext* SV3_1aParser::Net_port_headerContext::net_port_type() {
  return getRuleContext<SV3_1aParser::Net_port_typeContext>(0);
}

SV3_1aParser::Port_directionContext* SV3_1aParser::Net_port_headerContext::port_direction() {
  return getRuleContext<SV3_1aParser::Port_directionContext>(0);
}


size_t SV3_1aParser::Net_port_headerContext::getRuleIndex() const {
  return SV3_1aParser::RuleNet_port_header;
}

void SV3_1aParser::Net_port_headerContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNet_port_header(this);
}

void SV3_1aParser::Net_port_headerContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNet_port_header(this);
}

SV3_1aParser::Net_port_headerContext* SV3_1aParser::net_port_header() {
  Net_port_headerContext *_localctx = _tracker.createInstance<Net_port_headerContext>(_ctx, getState());
  enterRule(_localctx, 74, SV3_1aParser::RuleNet_port_header);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2087);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (((((_la - 66) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 66)) & 15) != 0)) {
      setState(2086);
      port_direction();
    }
    setState(2089);
    net_port_type();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Variable_port_headerContext ------------------------------------------------------------------

SV3_1aParser::Variable_port_headerContext::Variable_port_headerContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::Variable_port_typeContext* SV3_1aParser::Variable_port_headerContext::variable_port_type() {
  return getRuleContext<SV3_1aParser::Variable_port_typeContext>(0);
}

SV3_1aParser::Port_directionContext* SV3_1aParser::Variable_port_headerContext::port_direction() {
  return getRuleContext<SV3_1aParser::Port_directionContext>(0);
}


size_t SV3_1aParser::Variable_port_headerContext::getRuleIndex() const {
  return SV3_1aParser::RuleVariable_port_header;
}

void SV3_1aParser::Variable_port_headerContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterVariable_port_header(this);
}

void SV3_1aParser::Variable_port_headerContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitVariable_port_header(this);
}

SV3_1aParser::Variable_port_headerContext* SV3_1aParser::variable_port_header() {
  Variable_port_headerContext *_localctx = _tracker.createInstance<Variable_port_headerContext>(_ctx, getState());
  enterRule(_localctx, 76, SV3_1aParser::RuleVariable_port_header);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2092);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (((((_la - 66) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 66)) & 15) != 0)) {
      setState(2091);
      port_direction();
    }
    setState(2094);
    variable_port_type();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Interface_port_headerContext ------------------------------------------------------------------

SV3_1aParser::Interface_port_headerContext::Interface_port_headerContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::Interface_identifierContext* SV3_1aParser::Interface_port_headerContext::interface_identifier() {
  return getRuleContext<SV3_1aParser::Interface_identifierContext>(0);
}

tree::TerminalNode* SV3_1aParser::Interface_port_headerContext::DOT() {
  return getToken(SV3_1aParser::DOT, 0);
}

SV3_1aParser::IdentifierContext* SV3_1aParser::Interface_port_headerContext::identifier() {
  return getRuleContext<SV3_1aParser::IdentifierContext>(0);
}

tree::TerminalNode* SV3_1aParser::Interface_port_headerContext::INTERFACE() {
  return getToken(SV3_1aParser::INTERFACE, 0);
}


size_t SV3_1aParser::Interface_port_headerContext::getRuleIndex() const {
  return SV3_1aParser::RuleInterface_port_header;
}

void SV3_1aParser::Interface_port_headerContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInterface_port_header(this);
}

void SV3_1aParser::Interface_port_headerContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInterface_port_header(this);
}

SV3_1aParser::Interface_port_headerContext* SV3_1aParser::interface_port_header() {
  Interface_port_headerContext *_localctx = _tracker.createInstance<Interface_port_headerContext>(_ctx, getState());
  enterRule(_localctx, 78, SV3_1aParser::RuleInterface_port_header);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2106);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SV3_1aParser::THIS:
      case SV3_1aParser::DOLLAR_ROOT:
      case SV3_1aParser::RANDOMIZE:
      case SV3_1aParser::SAMPLE:
      case SV3_1aParser::Escaped_identifier:
      case SV3_1aParser::Simple_identifier: {
        enterOuterAlt(_localctx, 1);
        setState(2096);
        interface_identifier();
        setState(2099);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == SV3_1aParser::DOT) {
          setState(2097);
          match(SV3_1aParser::DOT);
          setState(2098);
          identifier();
        }
        break;
      }

      case SV3_1aParser::INTERFACE: {
        enterOuterAlt(_localctx, 2);
        setState(2101);
        match(SV3_1aParser::INTERFACE);
        setState(2104);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == SV3_1aParser::DOT) {
          setState(2102);
          match(SV3_1aParser::DOT);
          setState(2103);
          identifier();
        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Ansi_port_declarationContext ------------------------------------------------------------------

SV3_1aParser::Ansi_port_declarationContext::Ansi_port_declarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::IdentifierContext* SV3_1aParser::Ansi_port_declarationContext::identifier() {
  return getRuleContext<SV3_1aParser::IdentifierContext>(0);
}

SV3_1aParser::Net_port_headerContext* SV3_1aParser::Ansi_port_declarationContext::net_port_header() {
  return getRuleContext<SV3_1aParser::Net_port_headerContext>(0);
}

SV3_1aParser::Interface_port_headerContext* SV3_1aParser::Ansi_port_declarationContext::interface_port_header() {
  return getRuleContext<SV3_1aParser::Interface_port_headerContext>(0);
}

std::vector<SV3_1aParser::Unpacked_dimensionContext *> SV3_1aParser::Ansi_port_declarationContext::unpacked_dimension() {
  return getRuleContexts<SV3_1aParser::Unpacked_dimensionContext>();
}

SV3_1aParser::Unpacked_dimensionContext* SV3_1aParser::Ansi_port_declarationContext::unpacked_dimension(size_t i) {
  return getRuleContext<SV3_1aParser::Unpacked_dimensionContext>(i);
}

tree::TerminalNode* SV3_1aParser::Ansi_port_declarationContext::ASSIGN_OP() {
  return getToken(SV3_1aParser::ASSIGN_OP, 0);
}

SV3_1aParser::Constant_expressionContext* SV3_1aParser::Ansi_port_declarationContext::constant_expression() {
  return getRuleContext<SV3_1aParser::Constant_expressionContext>(0);
}

SV3_1aParser::Variable_port_headerContext* SV3_1aParser::Ansi_port_declarationContext::variable_port_header() {
  return getRuleContext<SV3_1aParser::Variable_port_headerContext>(0);
}

std::vector<SV3_1aParser::Variable_dimensionContext *> SV3_1aParser::Ansi_port_declarationContext::variable_dimension() {
  return getRuleContexts<SV3_1aParser::Variable_dimensionContext>();
}

SV3_1aParser::Variable_dimensionContext* SV3_1aParser::Ansi_port_declarationContext::variable_dimension(size_t i) {
  return getRuleContext<SV3_1aParser::Variable_dimensionContext>(i);
}

tree::TerminalNode* SV3_1aParser::Ansi_port_declarationContext::DOT() {
  return getToken(SV3_1aParser::DOT, 0);
}

tree::TerminalNode* SV3_1aParser::Ansi_port_declarationContext::OPEN_PARENS() {
  return getToken(SV3_1aParser::OPEN_PARENS, 0);
}

tree::TerminalNode* SV3_1aParser::Ansi_port_declarationContext::CLOSE_PARENS() {
  return getToken(SV3_1aParser::CLOSE_PARENS, 0);
}

SV3_1aParser::ExpressionContext* SV3_1aParser::Ansi_port_declarationContext::expression() {
  return getRuleContext<SV3_1aParser::ExpressionContext>(0);
}


size_t SV3_1aParser::Ansi_port_declarationContext::getRuleIndex() const {
  return SV3_1aParser::RuleAnsi_port_declaration;
}

void SV3_1aParser::Ansi_port_declarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAnsi_port_declaration(this);
}

void SV3_1aParser::Ansi_port_declarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAnsi_port_declaration(this);
}

SV3_1aParser::Ansi_port_declarationContext* SV3_1aParser::ansi_port_declaration() {
  Ansi_port_declarationContext *_localctx = _tracker.createInstance<Ansi_port_declarationContext>(_ctx, getState());
  enterRule(_localctx, 80, SV3_1aParser::RuleAnsi_port_declaration);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2149);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 128, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2110);
      _errHandler->sync(this);
      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 120, _ctx)) {
      case 1: {
        setState(2108);
        net_port_header();
        break;
      }

      case 2: {
        setState(2109);
        interface_port_header();
        break;
      }

      default:
        break;
      }
      setState(2112);
      identifier();
      setState(2116);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == SV3_1aParser::OPEN_BRACKET) {
        setState(2113);
        unpacked_dimension();
        setState(2118);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(2121);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == SV3_1aParser::ASSIGN_OP) {
        setState(2119);
        match(SV3_1aParser::ASSIGN_OP);
        setState(2120);
        constant_expression(0);
      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2124);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 123, _ctx)) {
      case 1: {
        setState(2123);
        variable_port_header();
        break;
      }

      default:
        break;
      }
      setState(2126);
      identifier();
      setState(2130);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == SV3_1aParser::ASSOCIATIVE_UNSPECIFIED || _la == SV3_1aParser::OPEN_BRACKET) {
        setState(2127);
        variable_dimension();
        setState(2132);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(2135);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == SV3_1aParser::ASSIGN_OP) {
        setState(2133);
        match(SV3_1aParser::ASSIGN_OP);
        setState(2134);
        constant_expression(0);
      }
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(2139);
      _errHandler->sync(this);
      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 126, _ctx)) {
      case 1: {
        setState(2137);
        net_port_header();
        break;
      }

      case 2: {
        setState(2138);
        variable_port_header();
        break;
      }

      default:
        break;
      }
      setState(2141);
      match(SV3_1aParser::DOT);
      setState(2142);
      identifier();
      setState(2143);
      match(SV3_1aParser::OPEN_PARENS);
      setState(2145);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if ((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & 8796094922748) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 64)) & 1152648825725551617) != 0) || ((((_la - 147) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 147)) & 2199527096323) != 0) || _la == SV3_1aParser::BANG || ((((_la - 310) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 310)) & 559537073624154177) != 0)) {
        setState(2144);
        expression(0);
      }
      setState(2147);
      match(SV3_1aParser::CLOSE_PARENS);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Elaboration_system_taskContext ------------------------------------------------------------------

SV3_1aParser::Elaboration_system_taskContext::Elaboration_system_taskContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Elaboration_system_taskContext::DOLLAR() {
  return getToken(SV3_1aParser::DOLLAR, 0);
}

tree::TerminalNode* SV3_1aParser::Elaboration_system_taskContext::Simple_identifier() {
  return getToken(SV3_1aParser::Simple_identifier, 0);
}

tree::TerminalNode* SV3_1aParser::Elaboration_system_taskContext::SEMICOLON() {
  return getToken(SV3_1aParser::SEMICOLON, 0);
}

tree::TerminalNode* SV3_1aParser::Elaboration_system_taskContext::OPEN_PARENS() {
  return getToken(SV3_1aParser::OPEN_PARENS, 0);
}

SV3_1aParser::NumberContext* SV3_1aParser::Elaboration_system_taskContext::number() {
  return getRuleContext<SV3_1aParser::NumberContext>(0);
}

tree::TerminalNode* SV3_1aParser::Elaboration_system_taskContext::CLOSE_PARENS() {
  return getToken(SV3_1aParser::CLOSE_PARENS, 0);
}

SV3_1aParser::List_of_argumentsContext* SV3_1aParser::Elaboration_system_taskContext::list_of_arguments() {
  return getRuleContext<SV3_1aParser::List_of_argumentsContext>(0);
}

tree::TerminalNode* SV3_1aParser::Elaboration_system_taskContext::COMMA() {
  return getToken(SV3_1aParser::COMMA, 0);
}


size_t SV3_1aParser::Elaboration_system_taskContext::getRuleIndex() const {
  return SV3_1aParser::RuleElaboration_system_task;
}

void SV3_1aParser::Elaboration_system_taskContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterElaboration_system_task(this);
}

void SV3_1aParser::Elaboration_system_taskContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitElaboration_system_task(this);
}

SV3_1aParser::Elaboration_system_taskContext* SV3_1aParser::elaboration_system_task() {
  Elaboration_system_taskContext *_localctx = _tracker.createInstance<Elaboration_system_taskContext>(_ctx, getState());
  enterRule(_localctx, 82, SV3_1aParser::RuleElaboration_system_task);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2151);
    match(SV3_1aParser::DOLLAR);
    setState(2152);
    match(SV3_1aParser::Simple_identifier);
    setState(2171);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 132, _ctx)) {
    case 1: {
      setState(2161);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == SV3_1aParser::OPEN_PARENS) {
        setState(2153);
        match(SV3_1aParser::OPEN_PARENS);
        setState(2154);
        number();
        setState(2157);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == SV3_1aParser::COMMA) {
          setState(2155);
          match(SV3_1aParser::COMMA);
          setState(2156);
          list_of_arguments();
        }
        setState(2159);
        match(SV3_1aParser::CLOSE_PARENS);
      }
      setState(2163);
      match(SV3_1aParser::SEMICOLON);
      break;
    }

    case 2: {
      setState(2168);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == SV3_1aParser::OPEN_PARENS) {
        setState(2164);
        match(SV3_1aParser::OPEN_PARENS);
        setState(2165);
        list_of_arguments();
        setState(2166);
        match(SV3_1aParser::CLOSE_PARENS);
      }
      setState(2170);
      match(SV3_1aParser::SEMICOLON);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Module_common_itemContext ------------------------------------------------------------------

SV3_1aParser::Module_common_itemContext::Module_common_itemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::Module_or_generate_item_declarationContext* SV3_1aParser::Module_common_itemContext::module_or_generate_item_declaration() {
  return getRuleContext<SV3_1aParser::Module_or_generate_item_declarationContext>(0);
}

SV3_1aParser::Module_instantiationContext* SV3_1aParser::Module_common_itemContext::module_instantiation() {
  return getRuleContext<SV3_1aParser::Module_instantiationContext>(0);
}

SV3_1aParser::Assertion_itemContext* SV3_1aParser::Module_common_itemContext::assertion_item() {
  return getRuleContext<SV3_1aParser::Assertion_itemContext>(0);
}

SV3_1aParser::Bind_directiveContext* SV3_1aParser::Module_common_itemContext::bind_directive() {
  return getRuleContext<SV3_1aParser::Bind_directiveContext>(0);
}

SV3_1aParser::Continuous_assignContext* SV3_1aParser::Module_common_itemContext::continuous_assign() {
  return getRuleContext<SV3_1aParser::Continuous_assignContext>(0);
}

SV3_1aParser::Net_aliasContext* SV3_1aParser::Module_common_itemContext::net_alias() {
  return getRuleContext<SV3_1aParser::Net_aliasContext>(0);
}

SV3_1aParser::Initial_constructContext* SV3_1aParser::Module_common_itemContext::initial_construct() {
  return getRuleContext<SV3_1aParser::Initial_constructContext>(0);
}

SV3_1aParser::Final_constructContext* SV3_1aParser::Module_common_itemContext::final_construct() {
  return getRuleContext<SV3_1aParser::Final_constructContext>(0);
}

SV3_1aParser::Always_constructContext* SV3_1aParser::Module_common_itemContext::always_construct() {
  return getRuleContext<SV3_1aParser::Always_constructContext>(0);
}

SV3_1aParser::Loop_generate_constructContext* SV3_1aParser::Module_common_itemContext::loop_generate_construct() {
  return getRuleContext<SV3_1aParser::Loop_generate_constructContext>(0);
}

SV3_1aParser::Conditional_generate_constructContext* SV3_1aParser::Module_common_itemContext::conditional_generate_construct() {
  return getRuleContext<SV3_1aParser::Conditional_generate_constructContext>(0);
}

SV3_1aParser::Elaboration_system_taskContext* SV3_1aParser::Module_common_itemContext::elaboration_system_task() {
  return getRuleContext<SV3_1aParser::Elaboration_system_taskContext>(0);
}

SV3_1aParser::System_taskContext* SV3_1aParser::Module_common_itemContext::system_task() {
  return getRuleContext<SV3_1aParser::System_taskContext>(0);
}


size_t SV3_1aParser::Module_common_itemContext::getRuleIndex() const {
  return SV3_1aParser::RuleModule_common_item;
}

void SV3_1aParser::Module_common_itemContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterModule_common_item(this);
}

void SV3_1aParser::Module_common_itemContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitModule_common_item(this);
}

SV3_1aParser::Module_common_itemContext* SV3_1aParser::module_common_item() {
  Module_common_itemContext *_localctx = _tracker.createInstance<Module_common_itemContext>(_ctx, getState());
  enterRule(_localctx, 84, SV3_1aParser::RuleModule_common_item);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2186);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 133, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2173);
      module_or_generate_item_declaration();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2174);
      module_instantiation();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(2175);
      assertion_item();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(2176);
      bind_directive();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(2177);
      continuous_assign();
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(2178);
      net_alias();
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(2179);
      initial_construct();
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(2180);
      final_construct();
      break;
    }

    case 9: {
      enterOuterAlt(_localctx, 9);
      setState(2181);
      always_construct();
      break;
    }

    case 10: {
      enterOuterAlt(_localctx, 10);
      setState(2182);
      loop_generate_construct();
      break;
    }

    case 11: {
      enterOuterAlt(_localctx, 11);
      setState(2183);
      conditional_generate_construct();
      break;
    }

    case 12: {
      enterOuterAlt(_localctx, 12);
      setState(2184);
      elaboration_system_task();
      break;
    }

    case 13: {
      enterOuterAlt(_localctx, 13);
      setState(2185);
      system_task();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Module_itemContext ------------------------------------------------------------------

SV3_1aParser::Module_itemContext::Module_itemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::Port_declarationContext* SV3_1aParser::Module_itemContext::port_declaration() {
  return getRuleContext<SV3_1aParser::Port_declarationContext>(0);
}

tree::TerminalNode* SV3_1aParser::Module_itemContext::SEMICOLON() {
  return getToken(SV3_1aParser::SEMICOLON, 0);
}

SV3_1aParser::Non_port_module_itemContext* SV3_1aParser::Module_itemContext::non_port_module_item() {
  return getRuleContext<SV3_1aParser::Non_port_module_itemContext>(0);
}


size_t SV3_1aParser::Module_itemContext::getRuleIndex() const {
  return SV3_1aParser::RuleModule_item;
}

void SV3_1aParser::Module_itemContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterModule_item(this);
}

void SV3_1aParser::Module_itemContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitModule_item(this);
}

SV3_1aParser::Module_itemContext* SV3_1aParser::module_item() {
  Module_itemContext *_localctx = _tracker.createInstance<Module_itemContext>(_ctx, getState());
  enterRule(_localctx, 86, SV3_1aParser::RuleModule_item);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2192);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 134, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2188);
      port_declaration();
      setState(2189);
      match(SV3_1aParser::SEMICOLON);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2191);
      non_port_module_item();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Module_or_generate_itemContext ------------------------------------------------------------------

SV3_1aParser::Module_or_generate_itemContext::Module_or_generate_itemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::Parameter_overrideContext* SV3_1aParser::Module_or_generate_itemContext::parameter_override() {
  return getRuleContext<SV3_1aParser::Parameter_overrideContext>(0);
}

SV3_1aParser::Gate_instantiationContext* SV3_1aParser::Module_or_generate_itemContext::gate_instantiation() {
  return getRuleContext<SV3_1aParser::Gate_instantiationContext>(0);
}

SV3_1aParser::Udp_instantiationContext* SV3_1aParser::Module_or_generate_itemContext::udp_instantiation() {
  return getRuleContext<SV3_1aParser::Udp_instantiationContext>(0);
}

SV3_1aParser::Module_instantiationContext* SV3_1aParser::Module_or_generate_itemContext::module_instantiation() {
  return getRuleContext<SV3_1aParser::Module_instantiationContext>(0);
}

SV3_1aParser::Module_common_itemContext* SV3_1aParser::Module_or_generate_itemContext::module_common_item() {
  return getRuleContext<SV3_1aParser::Module_common_itemContext>(0);
}

std::vector<SV3_1aParser::Attribute_instanceContext *> SV3_1aParser::Module_or_generate_itemContext::attribute_instance() {
  return getRuleContexts<SV3_1aParser::Attribute_instanceContext>();
}

SV3_1aParser::Attribute_instanceContext* SV3_1aParser::Module_or_generate_itemContext::attribute_instance(size_t i) {
  return getRuleContext<SV3_1aParser::Attribute_instanceContext>(i);
}


size_t SV3_1aParser::Module_or_generate_itemContext::getRuleIndex() const {
  return SV3_1aParser::RuleModule_or_generate_item;
}

void SV3_1aParser::Module_or_generate_itemContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterModule_or_generate_item(this);
}

void SV3_1aParser::Module_or_generate_itemContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitModule_or_generate_item(this);
}

SV3_1aParser::Module_or_generate_itemContext* SV3_1aParser::module_or_generate_item() {
  Module_or_generate_itemContext *_localctx = _tracker.createInstance<Module_or_generate_itemContext>(_ctx, getState());
  enterRule(_localctx, 88, SV3_1aParser::RuleModule_or_generate_item);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2197);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == SV3_1aParser::OPEN_PARENS_STAR) {
      setState(2194);
      attribute_instance();
      setState(2199);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(2205);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 136, _ctx)) {
    case 1: {
      setState(2200);
      parameter_override();
      break;
    }

    case 2: {
      setState(2201);
      gate_instantiation();
      break;
    }

    case 3: {
      setState(2202);
      udp_instantiation();
      break;
    }

    case 4: {
      setState(2203);
      module_instantiation();
      break;
    }

    case 5: {
      setState(2204);
      module_common_item();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Module_or_generate_item_declarationContext ------------------------------------------------------------------

SV3_1aParser::Module_or_generate_item_declarationContext::Module_or_generate_item_declarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::Package_or_generate_item_declarationContext* SV3_1aParser::Module_or_generate_item_declarationContext::package_or_generate_item_declaration() {
  return getRuleContext<SV3_1aParser::Package_or_generate_item_declarationContext>(0);
}

SV3_1aParser::Genvar_declarationContext* SV3_1aParser::Module_or_generate_item_declarationContext::genvar_declaration() {
  return getRuleContext<SV3_1aParser::Genvar_declarationContext>(0);
}

SV3_1aParser::Clocking_declarationContext* SV3_1aParser::Module_or_generate_item_declarationContext::clocking_declaration() {
  return getRuleContext<SV3_1aParser::Clocking_declarationContext>(0);
}

tree::TerminalNode* SV3_1aParser::Module_or_generate_item_declarationContext::DEFAULT() {
  return getToken(SV3_1aParser::DEFAULT, 0);
}

tree::TerminalNode* SV3_1aParser::Module_or_generate_item_declarationContext::CLOCKING() {
  return getToken(SV3_1aParser::CLOCKING, 0);
}

SV3_1aParser::IdentifierContext* SV3_1aParser::Module_or_generate_item_declarationContext::identifier() {
  return getRuleContext<SV3_1aParser::IdentifierContext>(0);
}

tree::TerminalNode* SV3_1aParser::Module_or_generate_item_declarationContext::SEMICOLON() {
  return getToken(SV3_1aParser::SEMICOLON, 0);
}

tree::TerminalNode* SV3_1aParser::Module_or_generate_item_declarationContext::DISABLE() {
  return getToken(SV3_1aParser::DISABLE, 0);
}

tree::TerminalNode* SV3_1aParser::Module_or_generate_item_declarationContext::IFF() {
  return getToken(SV3_1aParser::IFF, 0);
}

SV3_1aParser::Expression_or_distContext* SV3_1aParser::Module_or_generate_item_declarationContext::expression_or_dist() {
  return getRuleContext<SV3_1aParser::Expression_or_distContext>(0);
}


size_t SV3_1aParser::Module_or_generate_item_declarationContext::getRuleIndex() const {
  return SV3_1aParser::RuleModule_or_generate_item_declaration;
}

void SV3_1aParser::Module_or_generate_item_declarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterModule_or_generate_item_declaration(this);
}

void SV3_1aParser::Module_or_generate_item_declarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitModule_or_generate_item_declaration(this);
}

SV3_1aParser::Module_or_generate_item_declarationContext* SV3_1aParser::module_or_generate_item_declaration() {
  Module_or_generate_item_declarationContext *_localctx = _tracker.createInstance<Module_or_generate_item_declarationContext>(_ctx, getState());
  enterRule(_localctx, 90, SV3_1aParser::RuleModule_or_generate_item_declaration);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2221);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 137, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2207);
      package_or_generate_item_declaration();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2208);
      genvar_declaration();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(2209);
      clocking_declaration();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(2210);
      match(SV3_1aParser::DEFAULT);
      setState(2211);
      match(SV3_1aParser::CLOCKING);
      setState(2212);
      identifier();
      setState(2213);
      match(SV3_1aParser::SEMICOLON);
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(2215);
      match(SV3_1aParser::DEFAULT);
      setState(2216);
      match(SV3_1aParser::DISABLE);
      setState(2217);
      match(SV3_1aParser::IFF);
      setState(2218);
      expression_or_dist();
      setState(2219);
      match(SV3_1aParser::SEMICOLON);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Non_port_module_itemContext ------------------------------------------------------------------

SV3_1aParser::Non_port_module_itemContext::Non_port_module_itemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::Generate_regionContext* SV3_1aParser::Non_port_module_itemContext::generate_region() {
  return getRuleContext<SV3_1aParser::Generate_regionContext>(0);
}

SV3_1aParser::Module_or_generate_itemContext* SV3_1aParser::Non_port_module_itemContext::module_or_generate_item() {
  return getRuleContext<SV3_1aParser::Module_or_generate_itemContext>(0);
}

SV3_1aParser::Specify_blockContext* SV3_1aParser::Non_port_module_itemContext::specify_block() {
  return getRuleContext<SV3_1aParser::Specify_blockContext>(0);
}

SV3_1aParser::Specparam_declarationContext* SV3_1aParser::Non_port_module_itemContext::specparam_declaration() {
  return getRuleContext<SV3_1aParser::Specparam_declarationContext>(0);
}

std::vector<SV3_1aParser::Attribute_instanceContext *> SV3_1aParser::Non_port_module_itemContext::attribute_instance() {
  return getRuleContexts<SV3_1aParser::Attribute_instanceContext>();
}

SV3_1aParser::Attribute_instanceContext* SV3_1aParser::Non_port_module_itemContext::attribute_instance(size_t i) {
  return getRuleContext<SV3_1aParser::Attribute_instanceContext>(i);
}

SV3_1aParser::Program_declarationContext* SV3_1aParser::Non_port_module_itemContext::program_declaration() {
  return getRuleContext<SV3_1aParser::Program_declarationContext>(0);
}

SV3_1aParser::Module_declarationContext* SV3_1aParser::Non_port_module_itemContext::module_declaration() {
  return getRuleContext<SV3_1aParser::Module_declarationContext>(0);
}

SV3_1aParser::Timeunits_declarationContext* SV3_1aParser::Non_port_module_itemContext::timeunits_declaration() {
  return getRuleContext<SV3_1aParser::Timeunits_declarationContext>(0);
}

SV3_1aParser::System_taskContext* SV3_1aParser::Non_port_module_itemContext::system_task() {
  return getRuleContext<SV3_1aParser::System_taskContext>(0);
}

tree::TerminalNode* SV3_1aParser::Non_port_module_itemContext::SEMICOLON() {
  return getToken(SV3_1aParser::SEMICOLON, 0);
}

SV3_1aParser::Surelog_macro_not_definedContext* SV3_1aParser::Non_port_module_itemContext::surelog_macro_not_defined() {
  return getRuleContext<SV3_1aParser::Surelog_macro_not_definedContext>(0);
}

SV3_1aParser::Pragma_directiveContext* SV3_1aParser::Non_port_module_itemContext::pragma_directive() {
  return getRuleContext<SV3_1aParser::Pragma_directiveContext>(0);
}


size_t SV3_1aParser::Non_port_module_itemContext::getRuleIndex() const {
  return SV3_1aParser::RuleNon_port_module_item;
}

void SV3_1aParser::Non_port_module_itemContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNon_port_module_item(this);
}

void SV3_1aParser::Non_port_module_itemContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNon_port_module_item(this);
}

SV3_1aParser::Non_port_module_itemContext* SV3_1aParser::non_port_module_item() {
  Non_port_module_itemContext *_localctx = _tracker.createInstance<Non_port_module_itemContext>(_ctx, getState());
  enterRule(_localctx, 92, SV3_1aParser::RuleNon_port_module_item);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2241);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 139, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2223);
      generate_region();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2224);
      module_or_generate_item();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(2225);
      specify_block();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(2229);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == SV3_1aParser::OPEN_PARENS_STAR) {
        setState(2226);
        attribute_instance();
        setState(2231);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(2232);
      specparam_declaration();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(2233);
      program_declaration();
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(2234);
      module_declaration();
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(2235);
      timeunits_declaration();
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(2236);
      system_task();
      setState(2237);
      match(SV3_1aParser::SEMICOLON);
      break;
    }

    case 9: {
      enterOuterAlt(_localctx, 9);
      setState(2239);
      surelog_macro_not_defined();
      break;
    }

    case 10: {
      enterOuterAlt(_localctx, 10);
      setState(2240);
      pragma_directive();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Parameter_overrideContext ------------------------------------------------------------------

SV3_1aParser::Parameter_overrideContext::Parameter_overrideContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Parameter_overrideContext::DEFPARAM() {
  return getToken(SV3_1aParser::DEFPARAM, 0);
}

SV3_1aParser::List_of_defparam_assignmentsContext* SV3_1aParser::Parameter_overrideContext::list_of_defparam_assignments() {
  return getRuleContext<SV3_1aParser::List_of_defparam_assignmentsContext>(0);
}

tree::TerminalNode* SV3_1aParser::Parameter_overrideContext::SEMICOLON() {
  return getToken(SV3_1aParser::SEMICOLON, 0);
}


size_t SV3_1aParser::Parameter_overrideContext::getRuleIndex() const {
  return SV3_1aParser::RuleParameter_override;
}

void SV3_1aParser::Parameter_overrideContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterParameter_override(this);
}

void SV3_1aParser::Parameter_overrideContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitParameter_override(this);
}

SV3_1aParser::Parameter_overrideContext* SV3_1aParser::parameter_override() {
  Parameter_overrideContext *_localctx = _tracker.createInstance<Parameter_overrideContext>(_ctx, getState());
  enterRule(_localctx, 94, SV3_1aParser::RuleParameter_override);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2243);
    match(SV3_1aParser::DEFPARAM);
    setState(2244);
    list_of_defparam_assignments();
    setState(2245);
    match(SV3_1aParser::SEMICOLON);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Bind_directiveContext ------------------------------------------------------------------

SV3_1aParser::Bind_directiveContext::Bind_directiveContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Bind_directiveContext::BIND() {
  return getToken(SV3_1aParser::BIND, 0);
}

std::vector<SV3_1aParser::IdentifierContext *> SV3_1aParser::Bind_directiveContext::identifier() {
  return getRuleContexts<SV3_1aParser::IdentifierContext>();
}

SV3_1aParser::IdentifierContext* SV3_1aParser::Bind_directiveContext::identifier(size_t i) {
  return getRuleContext<SV3_1aParser::IdentifierContext>(i);
}

SV3_1aParser::Bind_instantiationContext* SV3_1aParser::Bind_directiveContext::bind_instantiation() {
  return getRuleContext<SV3_1aParser::Bind_instantiationContext>(0);
}

std::vector<SV3_1aParser::Constant_bit_selectContext *> SV3_1aParser::Bind_directiveContext::constant_bit_select() {
  return getRuleContexts<SV3_1aParser::Constant_bit_selectContext>();
}

SV3_1aParser::Constant_bit_selectContext* SV3_1aParser::Bind_directiveContext::constant_bit_select(size_t i) {
  return getRuleContext<SV3_1aParser::Constant_bit_selectContext>(i);
}

tree::TerminalNode* SV3_1aParser::Bind_directiveContext::COLON() {
  return getToken(SV3_1aParser::COLON, 0);
}

std::vector<tree::TerminalNode *> SV3_1aParser::Bind_directiveContext::COMMA() {
  return getTokens(SV3_1aParser::COMMA);
}

tree::TerminalNode* SV3_1aParser::Bind_directiveContext::COMMA(size_t i) {
  return getToken(SV3_1aParser::COMMA, i);
}


size_t SV3_1aParser::Bind_directiveContext::getRuleIndex() const {
  return SV3_1aParser::RuleBind_directive;
}

void SV3_1aParser::Bind_directiveContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBind_directive(this);
}

void SV3_1aParser::Bind_directiveContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBind_directive(this);
}

SV3_1aParser::Bind_directiveContext* SV3_1aParser::bind_directive() {
  Bind_directiveContext *_localctx = _tracker.createInstance<Bind_directiveContext>(_ctx, getState());
  enterRule(_localctx, 96, SV3_1aParser::RuleBind_directive);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2247);
    match(SV3_1aParser::BIND);
    setState(2248);
    identifier();
    setState(2263);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 142, _ctx)) {
    case 1: {
      setState(2250);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == SV3_1aParser::COLON) {
        setState(2249);
        match(SV3_1aParser::COLON);
      }
      setState(2252);
      identifier();
      setState(2253);
      constant_bit_select();
      setState(2260);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == SV3_1aParser::COMMA) {
        setState(2254);
        match(SV3_1aParser::COMMA);
        setState(2255);
        identifier();
        setState(2256);
        constant_bit_select();
        setState(2262);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      break;
    }

    default:
      break;
    }
    setState(2265);
    bind_instantiation();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Bind_instantiationContext ------------------------------------------------------------------

SV3_1aParser::Bind_instantiationContext::Bind_instantiationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::Module_instantiationContext* SV3_1aParser::Bind_instantiationContext::module_instantiation() {
  return getRuleContext<SV3_1aParser::Module_instantiationContext>(0);
}

SV3_1aParser::Checker_instantiationContext* SV3_1aParser::Bind_instantiationContext::checker_instantiation() {
  return getRuleContext<SV3_1aParser::Checker_instantiationContext>(0);
}


size_t SV3_1aParser::Bind_instantiationContext::getRuleIndex() const {
  return SV3_1aParser::RuleBind_instantiation;
}

void SV3_1aParser::Bind_instantiationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBind_instantiation(this);
}

void SV3_1aParser::Bind_instantiationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBind_instantiation(this);
}

SV3_1aParser::Bind_instantiationContext* SV3_1aParser::bind_instantiation() {
  Bind_instantiationContext *_localctx = _tracker.createInstance<Bind_instantiationContext>(_ctx, getState());
  enterRule(_localctx, 98, SV3_1aParser::RuleBind_instantiation);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2269);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 143, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2267);
      module_instantiation();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2268);
      checker_instantiation();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Interface_or_generate_itemContext ------------------------------------------------------------------

SV3_1aParser::Interface_or_generate_itemContext::Interface_or_generate_itemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::Module_common_itemContext* SV3_1aParser::Interface_or_generate_itemContext::module_common_item() {
  return getRuleContext<SV3_1aParser::Module_common_itemContext>(0);
}

tree::TerminalNode* SV3_1aParser::Interface_or_generate_itemContext::MODPORT() {
  return getToken(SV3_1aParser::MODPORT, 0);
}

std::vector<SV3_1aParser::Modport_itemContext *> SV3_1aParser::Interface_or_generate_itemContext::modport_item() {
  return getRuleContexts<SV3_1aParser::Modport_itemContext>();
}

SV3_1aParser::Modport_itemContext* SV3_1aParser::Interface_or_generate_itemContext::modport_item(size_t i) {
  return getRuleContext<SV3_1aParser::Modport_itemContext>(i);
}

tree::TerminalNode* SV3_1aParser::Interface_or_generate_itemContext::SEMICOLON() {
  return getToken(SV3_1aParser::SEMICOLON, 0);
}

SV3_1aParser::Extern_tf_declarationContext* SV3_1aParser::Interface_or_generate_itemContext::extern_tf_declaration() {
  return getRuleContext<SV3_1aParser::Extern_tf_declarationContext>(0);
}

std::vector<SV3_1aParser::Attribute_instanceContext *> SV3_1aParser::Interface_or_generate_itemContext::attribute_instance() {
  return getRuleContexts<SV3_1aParser::Attribute_instanceContext>();
}

SV3_1aParser::Attribute_instanceContext* SV3_1aParser::Interface_or_generate_itemContext::attribute_instance(size_t i) {
  return getRuleContext<SV3_1aParser::Attribute_instanceContext>(i);
}

std::vector<tree::TerminalNode *> SV3_1aParser::Interface_or_generate_itemContext::COMMA() {
  return getTokens(SV3_1aParser::COMMA);
}

tree::TerminalNode* SV3_1aParser::Interface_or_generate_itemContext::COMMA(size_t i) {
  return getToken(SV3_1aParser::COMMA, i);
}


size_t SV3_1aParser::Interface_or_generate_itemContext::getRuleIndex() const {
  return SV3_1aParser::RuleInterface_or_generate_item;
}

void SV3_1aParser::Interface_or_generate_itemContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInterface_or_generate_item(this);
}

void SV3_1aParser::Interface_or_generate_itemContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInterface_or_generate_item(this);
}

SV3_1aParser::Interface_or_generate_itemContext* SV3_1aParser::interface_or_generate_item() {
  Interface_or_generate_itemContext *_localctx = _tracker.createInstance<Interface_or_generate_itemContext>(_ctx, getState());
  enterRule(_localctx, 100, SV3_1aParser::RuleInterface_or_generate_item);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2274);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == SV3_1aParser::OPEN_PARENS_STAR) {
      setState(2271);
      attribute_instance();
      setState(2276);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(2290);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SV3_1aParser::SEMICOLON:
      case SV3_1aParser::DEFAULT:
      case SV3_1aParser::INTERFACE:
      case SV3_1aParser::VIRTUAL:
      case SV3_1aParser::CLASS:
      case SV3_1aParser::CHECKER:
      case SV3_1aParser::TYPE:
      case SV3_1aParser::CLOCKING:
      case SV3_1aParser::BIND:
      case SV3_1aParser::CONST:
      case SV3_1aParser::FUNCTION:
      case SV3_1aParser::STATIC:
      case SV3_1aParser::CONSTRAINT:
      case SV3_1aParser::IF:
      case SV3_1aParser::AUTOMATIC:
      case SV3_1aParser::LOCALPARAM:
      case SV3_1aParser::PARAMETER:
      case SV3_1aParser::IMPORT:
      case SV3_1aParser::GENVAR:
      case SV3_1aParser::TYPEDEF:
      case SV3_1aParser::ENUM:
      case SV3_1aParser::STRUCT:
      case SV3_1aParser::UNION:
      case SV3_1aParser::STRING:
      case SV3_1aParser::CHANDLE:
      case SV3_1aParser::EVENT:
      case SV3_1aParser::OPEN_BRACKET:
      case SV3_1aParser::BYTE:
      case SV3_1aParser::SHORTINT:
      case SV3_1aParser::INT:
      case SV3_1aParser::LONGINT:
      case SV3_1aParser::INTEGER:
      case SV3_1aParser::TIME:
      case SV3_1aParser::BIT:
      case SV3_1aParser::LOGIC:
      case SV3_1aParser::REG:
      case SV3_1aParser::SHORTREAL:
      case SV3_1aParser::REAL:
      case SV3_1aParser::REALTIME:
      case SV3_1aParser::SUPPLY0:
      case SV3_1aParser::SUPPLY1:
      case SV3_1aParser::TRI:
      case SV3_1aParser::TRIAND:
      case SV3_1aParser::TRIOR:
      case SV3_1aParser::TRI0:
      case SV3_1aParser::TRI1:
      case SV3_1aParser::WIRE:
      case SV3_1aParser::UWIRE:
      case SV3_1aParser::WAND:
      case SV3_1aParser::WOR:
      case SV3_1aParser::TRIREG:
      case SV3_1aParser::SIGNED:
      case SV3_1aParser::UNSIGNED:
      case SV3_1aParser::INTERCONNECT:
      case SV3_1aParser::VAR:
      case SV3_1aParser::DOLLAR:
      case SV3_1aParser::EXPORT:
      case SV3_1aParser::DOLLAR_UNIT:
      case SV3_1aParser::ASSERT:
      case SV3_1aParser::PROPERTY:
      case SV3_1aParser::ASSUME:
      case SV3_1aParser::COVER:
      case SV3_1aParser::SEQUENCE:
      case SV3_1aParser::COVERGROUP:
      case SV3_1aParser::CASE:
      case SV3_1aParser::FOR:
      case SV3_1aParser::GLOBAL:
      case SV3_1aParser::INITIAL:
      case SV3_1aParser::ASSIGN:
      case SV3_1aParser::ALIAS:
      case SV3_1aParser::ALWAYS:
      case SV3_1aParser::ALWAYS_COMB:
      case SV3_1aParser::ALWAYS_LATCH:
      case SV3_1aParser::ALWAYS_FF:
      case SV3_1aParser::RESTRICT:
      case SV3_1aParser::LET:
      case SV3_1aParser::THIS:
      case SV3_1aParser::RANDOMIZE:
      case SV3_1aParser::FINAL:
      case SV3_1aParser::TASK:
      case SV3_1aParser::SAMPLE:
      case SV3_1aParser::ASSIGN_OP:
      case SV3_1aParser::NETTYPE:
      case SV3_1aParser::Escaped_identifier:
      case SV3_1aParser::Simple_identifier: {
        setState(2277);
        module_common_item();
        break;
      }

      case SV3_1aParser::MODPORT: {
        setState(2278);
        match(SV3_1aParser::MODPORT);
        setState(2279);
        modport_item();
        setState(2284);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == SV3_1aParser::COMMA) {
          setState(2280);
          match(SV3_1aParser::COMMA);
          setState(2281);
          modport_item();
          setState(2286);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(2287);
        match(SV3_1aParser::SEMICOLON);
        break;
      }

      case SV3_1aParser::EXTERN: {
        setState(2289);
        extern_tf_declaration();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Extern_tf_declarationContext ------------------------------------------------------------------

SV3_1aParser::Extern_tf_declarationContext::Extern_tf_declarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Extern_tf_declarationContext::EXTERN() {
  return getToken(SV3_1aParser::EXTERN, 0);
}

SV3_1aParser::Method_prototypeContext* SV3_1aParser::Extern_tf_declarationContext::method_prototype() {
  return getRuleContext<SV3_1aParser::Method_prototypeContext>(0);
}

tree::TerminalNode* SV3_1aParser::Extern_tf_declarationContext::SEMICOLON() {
  return getToken(SV3_1aParser::SEMICOLON, 0);
}

tree::TerminalNode* SV3_1aParser::Extern_tf_declarationContext::FORKJOIN() {
  return getToken(SV3_1aParser::FORKJOIN, 0);
}

SV3_1aParser::Task_prototypeContext* SV3_1aParser::Extern_tf_declarationContext::task_prototype() {
  return getRuleContext<SV3_1aParser::Task_prototypeContext>(0);
}


size_t SV3_1aParser::Extern_tf_declarationContext::getRuleIndex() const {
  return SV3_1aParser::RuleExtern_tf_declaration;
}

void SV3_1aParser::Extern_tf_declarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExtern_tf_declaration(this);
}

void SV3_1aParser::Extern_tf_declarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExtern_tf_declaration(this);
}

SV3_1aParser::Extern_tf_declarationContext* SV3_1aParser::extern_tf_declaration() {
  Extern_tf_declarationContext *_localctx = _tracker.createInstance<Extern_tf_declarationContext>(_ctx, getState());
  enterRule(_localctx, 102, SV3_1aParser::RuleExtern_tf_declaration);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2301);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 147, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2292);
      match(SV3_1aParser::EXTERN);
      setState(2293);
      method_prototype();
      setState(2294);
      match(SV3_1aParser::SEMICOLON);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2296);
      match(SV3_1aParser::EXTERN);
      setState(2297);
      match(SV3_1aParser::FORKJOIN);
      setState(2298);
      task_prototype();
      setState(2299);
      match(SV3_1aParser::SEMICOLON);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Interface_itemContext ------------------------------------------------------------------

SV3_1aParser::Interface_itemContext::Interface_itemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::Port_declarationContext* SV3_1aParser::Interface_itemContext::port_declaration() {
  return getRuleContext<SV3_1aParser::Port_declarationContext>(0);
}

tree::TerminalNode* SV3_1aParser::Interface_itemContext::SEMICOLON() {
  return getToken(SV3_1aParser::SEMICOLON, 0);
}

SV3_1aParser::Non_port_interface_itemContext* SV3_1aParser::Interface_itemContext::non_port_interface_item() {
  return getRuleContext<SV3_1aParser::Non_port_interface_itemContext>(0);
}


size_t SV3_1aParser::Interface_itemContext::getRuleIndex() const {
  return SV3_1aParser::RuleInterface_item;
}

void SV3_1aParser::Interface_itemContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInterface_item(this);
}

void SV3_1aParser::Interface_itemContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInterface_item(this);
}

SV3_1aParser::Interface_itemContext* SV3_1aParser::interface_item() {
  Interface_itemContext *_localctx = _tracker.createInstance<Interface_itemContext>(_ctx, getState());
  enterRule(_localctx, 104, SV3_1aParser::RuleInterface_item);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2307);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 148, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2303);
      port_declaration();
      setState(2304);
      match(SV3_1aParser::SEMICOLON);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2306);
      non_port_interface_item();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Non_port_interface_itemContext ------------------------------------------------------------------

SV3_1aParser::Non_port_interface_itemContext::Non_port_interface_itemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::Generated_interface_instantiationContext* SV3_1aParser::Non_port_interface_itemContext::generated_interface_instantiation() {
  return getRuleContext<SV3_1aParser::Generated_interface_instantiationContext>(0);
}

SV3_1aParser::Specparam_declarationContext* SV3_1aParser::Non_port_interface_itemContext::specparam_declaration() {
  return getRuleContext<SV3_1aParser::Specparam_declarationContext>(0);
}

std::vector<SV3_1aParser::Attribute_instanceContext *> SV3_1aParser::Non_port_interface_itemContext::attribute_instance() {
  return getRuleContexts<SV3_1aParser::Attribute_instanceContext>();
}

SV3_1aParser::Attribute_instanceContext* SV3_1aParser::Non_port_interface_itemContext::attribute_instance(size_t i) {
  return getRuleContext<SV3_1aParser::Attribute_instanceContext>(i);
}

SV3_1aParser::Interface_or_generate_itemContext* SV3_1aParser::Non_port_interface_itemContext::interface_or_generate_item() {
  return getRuleContext<SV3_1aParser::Interface_or_generate_itemContext>(0);
}

SV3_1aParser::Program_declarationContext* SV3_1aParser::Non_port_interface_itemContext::program_declaration() {
  return getRuleContext<SV3_1aParser::Program_declarationContext>(0);
}

SV3_1aParser::Interface_declarationContext* SV3_1aParser::Non_port_interface_itemContext::interface_declaration() {
  return getRuleContext<SV3_1aParser::Interface_declarationContext>(0);
}

SV3_1aParser::Timeunits_declarationContext* SV3_1aParser::Non_port_interface_itemContext::timeunits_declaration() {
  return getRuleContext<SV3_1aParser::Timeunits_declarationContext>(0);
}

SV3_1aParser::Surelog_macro_not_definedContext* SV3_1aParser::Non_port_interface_itemContext::surelog_macro_not_defined() {
  return getRuleContext<SV3_1aParser::Surelog_macro_not_definedContext>(0);
}


size_t SV3_1aParser::Non_port_interface_itemContext::getRuleIndex() const {
  return SV3_1aParser::RuleNon_port_interface_item;
}

void SV3_1aParser::Non_port_interface_itemContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNon_port_interface_item(this);
}

void SV3_1aParser::Non_port_interface_itemContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNon_port_interface_item(this);
}

SV3_1aParser::Non_port_interface_itemContext* SV3_1aParser::non_port_interface_item() {
  Non_port_interface_itemContext *_localctx = _tracker.createInstance<Non_port_interface_itemContext>(_ctx, getState());
  enterRule(_localctx, 106, SV3_1aParser::RuleNon_port_interface_item);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2322);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 150, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2309);
      generated_interface_instantiation();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2313);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == SV3_1aParser::OPEN_PARENS_STAR) {
        setState(2310);
        attribute_instance();
        setState(2315);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(2316);
      specparam_declaration();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(2317);
      interface_or_generate_item();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(2318);
      program_declaration();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(2319);
      interface_declaration();
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(2320);
      timeunits_declaration();
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(2321);
      surelog_macro_not_defined();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Program_itemContext ------------------------------------------------------------------

SV3_1aParser::Program_itemContext::Program_itemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::Port_declarationContext* SV3_1aParser::Program_itemContext::port_declaration() {
  return getRuleContext<SV3_1aParser::Port_declarationContext>(0);
}

tree::TerminalNode* SV3_1aParser::Program_itemContext::SEMICOLON() {
  return getToken(SV3_1aParser::SEMICOLON, 0);
}

SV3_1aParser::Non_port_program_itemContext* SV3_1aParser::Program_itemContext::non_port_program_item() {
  return getRuleContext<SV3_1aParser::Non_port_program_itemContext>(0);
}


size_t SV3_1aParser::Program_itemContext::getRuleIndex() const {
  return SV3_1aParser::RuleProgram_item;
}

void SV3_1aParser::Program_itemContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterProgram_item(this);
}

void SV3_1aParser::Program_itemContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitProgram_item(this);
}

SV3_1aParser::Program_itemContext* SV3_1aParser::program_item() {
  Program_itemContext *_localctx = _tracker.createInstance<Program_itemContext>(_ctx, getState());
  enterRule(_localctx, 108, SV3_1aParser::RuleProgram_item);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2328);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 151, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2324);
      port_declaration();
      setState(2325);
      match(SV3_1aParser::SEMICOLON);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2327);
      non_port_program_item();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Non_port_program_itemContext ------------------------------------------------------------------

SV3_1aParser::Non_port_program_itemContext::Non_port_program_itemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::Continuous_assignContext* SV3_1aParser::Non_port_program_itemContext::continuous_assign() {
  return getRuleContext<SV3_1aParser::Continuous_assignContext>(0);
}

SV3_1aParser::Module_or_generate_item_declarationContext* SV3_1aParser::Non_port_program_itemContext::module_or_generate_item_declaration() {
  return getRuleContext<SV3_1aParser::Module_or_generate_item_declarationContext>(0);
}

SV3_1aParser::Specparam_declarationContext* SV3_1aParser::Non_port_program_itemContext::specparam_declaration() {
  return getRuleContext<SV3_1aParser::Specparam_declarationContext>(0);
}

SV3_1aParser::Initial_constructContext* SV3_1aParser::Non_port_program_itemContext::initial_construct() {
  return getRuleContext<SV3_1aParser::Initial_constructContext>(0);
}

SV3_1aParser::Final_constructContext* SV3_1aParser::Non_port_program_itemContext::final_construct() {
  return getRuleContext<SV3_1aParser::Final_constructContext>(0);
}

SV3_1aParser::Concurrent_assertion_itemContext* SV3_1aParser::Non_port_program_itemContext::concurrent_assertion_item() {
  return getRuleContext<SV3_1aParser::Concurrent_assertion_itemContext>(0);
}

std::vector<SV3_1aParser::Attribute_instanceContext *> SV3_1aParser::Non_port_program_itemContext::attribute_instance() {
  return getRuleContexts<SV3_1aParser::Attribute_instanceContext>();
}

SV3_1aParser::Attribute_instanceContext* SV3_1aParser::Non_port_program_itemContext::attribute_instance(size_t i) {
  return getRuleContext<SV3_1aParser::Attribute_instanceContext>(i);
}

SV3_1aParser::Timeunits_declarationContext* SV3_1aParser::Non_port_program_itemContext::timeunits_declaration() {
  return getRuleContext<SV3_1aParser::Timeunits_declarationContext>(0);
}

SV3_1aParser::Program_generate_itemContext* SV3_1aParser::Non_port_program_itemContext::program_generate_item() {
  return getRuleContext<SV3_1aParser::Program_generate_itemContext>(0);
}

SV3_1aParser::Surelog_macro_not_definedContext* SV3_1aParser::Non_port_program_itemContext::surelog_macro_not_defined() {
  return getRuleContext<SV3_1aParser::Surelog_macro_not_definedContext>(0);
}


size_t SV3_1aParser::Non_port_program_itemContext::getRuleIndex() const {
  return SV3_1aParser::RuleNon_port_program_item;
}

void SV3_1aParser::Non_port_program_itemContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNon_port_program_item(this);
}

void SV3_1aParser::Non_port_program_itemContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNon_port_program_item(this);
}

SV3_1aParser::Non_port_program_itemContext* SV3_1aParser::non_port_program_item() {
  Non_port_program_itemContext *_localctx = _tracker.createInstance<Non_port_program_itemContext>(_ctx, getState());
  enterRule(_localctx, 110, SV3_1aParser::RuleNon_port_program_item);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2347);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SV3_1aParser::SEMICOLON:
      case SV3_1aParser::DEFAULT:
      case SV3_1aParser::INTERFACE:
      case SV3_1aParser::VIRTUAL:
      case SV3_1aParser::CLASS:
      case SV3_1aParser::CHECKER:
      case SV3_1aParser::TYPE:
      case SV3_1aParser::CLOCKING:
      case SV3_1aParser::BIND:
      case SV3_1aParser::CONST:
      case SV3_1aParser::FUNCTION:
      case SV3_1aParser::STATIC:
      case SV3_1aParser::CONSTRAINT:
      case SV3_1aParser::AUTOMATIC:
      case SV3_1aParser::LOCALPARAM:
      case SV3_1aParser::PARAMETER:
      case SV3_1aParser::SPECPARAM:
      case SV3_1aParser::IMPORT:
      case SV3_1aParser::GENVAR:
      case SV3_1aParser::TYPEDEF:
      case SV3_1aParser::ENUM:
      case SV3_1aParser::STRUCT:
      case SV3_1aParser::UNION:
      case SV3_1aParser::STRING:
      case SV3_1aParser::CHANDLE:
      case SV3_1aParser::EVENT:
      case SV3_1aParser::OPEN_BRACKET:
      case SV3_1aParser::BYTE:
      case SV3_1aParser::SHORTINT:
      case SV3_1aParser::INT:
      case SV3_1aParser::LONGINT:
      case SV3_1aParser::INTEGER:
      case SV3_1aParser::TIME:
      case SV3_1aParser::BIT:
      case SV3_1aParser::LOGIC:
      case SV3_1aParser::REG:
      case SV3_1aParser::SHORTREAL:
      case SV3_1aParser::REAL:
      case SV3_1aParser::REALTIME:
      case SV3_1aParser::SUPPLY0:
      case SV3_1aParser::SUPPLY1:
      case SV3_1aParser::TRI:
      case SV3_1aParser::TRIAND:
      case SV3_1aParser::TRIOR:
      case SV3_1aParser::TRI0:
      case SV3_1aParser::TRI1:
      case SV3_1aParser::WIRE:
      case SV3_1aParser::UWIRE:
      case SV3_1aParser::WAND:
      case SV3_1aParser::WOR:
      case SV3_1aParser::TRIREG:
      case SV3_1aParser::SIGNED:
      case SV3_1aParser::UNSIGNED:
      case SV3_1aParser::INTERCONNECT:
      case SV3_1aParser::VAR:
      case SV3_1aParser::EXPORT:
      case SV3_1aParser::DOLLAR_UNIT:
      case SV3_1aParser::OPEN_PARENS_STAR:
      case SV3_1aParser::ASSERT:
      case SV3_1aParser::PROPERTY:
      case SV3_1aParser::ASSUME:
      case SV3_1aParser::COVER:
      case SV3_1aParser::SEQUENCE:
      case SV3_1aParser::COVERGROUP:
      case SV3_1aParser::GLOBAL:
      case SV3_1aParser::INITIAL:
      case SV3_1aParser::ASSIGN:
      case SV3_1aParser::RESTRICT:
      case SV3_1aParser::LET:
      case SV3_1aParser::THIS:
      case SV3_1aParser::RANDOMIZE:
      case SV3_1aParser::FINAL:
      case SV3_1aParser::TASK:
      case SV3_1aParser::SAMPLE:
      case SV3_1aParser::ASSIGN_OP:
      case SV3_1aParser::NETTYPE:
      case SV3_1aParser::Escaped_identifier:
      case SV3_1aParser::Simple_identifier: {
        enterOuterAlt(_localctx, 1);
        setState(2333);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == SV3_1aParser::OPEN_PARENS_STAR) {
          setState(2330);
          attribute_instance();
          setState(2335);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(2342);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 153, _ctx)) {
        case 1: {
          setState(2336);
          continuous_assign();
          break;
        }

        case 2: {
          setState(2337);
          module_or_generate_item_declaration();
          break;
        }

        case 3: {
          setState(2338);
          specparam_declaration();
          break;
        }

        case 4: {
          setState(2339);
          initial_construct();
          break;
        }

        case 5: {
          setState(2340);
          final_construct();
          break;
        }

        case 6: {
          setState(2341);
          concurrent_assertion_item();
          break;
        }

        default:
          break;
        }
        break;
      }

      case SV3_1aParser::TIMEUNIT:
      case SV3_1aParser::TIMEPRECISION: {
        enterOuterAlt(_localctx, 2);
        setState(2344);
        timeunits_declaration();
        break;
      }

      case SV3_1aParser::IF:
      case SV3_1aParser::DOLLAR:
      case SV3_1aParser::GENERATE:
      case SV3_1aParser::CASE:
      case SV3_1aParser::FOR: {
        enterOuterAlt(_localctx, 3);
        setState(2345);
        program_generate_item();
        break;
      }

      case SV3_1aParser::SURELOG_MACRO_NOT_DEFINED: {
        enterOuterAlt(_localctx, 4);
        setState(2346);
        surelog_macro_not_defined();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Program_generate_itemContext ------------------------------------------------------------------

SV3_1aParser::Program_generate_itemContext::Program_generate_itemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::Loop_generate_constructContext* SV3_1aParser::Program_generate_itemContext::loop_generate_construct() {
  return getRuleContext<SV3_1aParser::Loop_generate_constructContext>(0);
}

SV3_1aParser::Conditional_generate_constructContext* SV3_1aParser::Program_generate_itemContext::conditional_generate_construct() {
  return getRuleContext<SV3_1aParser::Conditional_generate_constructContext>(0);
}

SV3_1aParser::Generate_regionContext* SV3_1aParser::Program_generate_itemContext::generate_region() {
  return getRuleContext<SV3_1aParser::Generate_regionContext>(0);
}

SV3_1aParser::Elaboration_system_taskContext* SV3_1aParser::Program_generate_itemContext::elaboration_system_task() {
  return getRuleContext<SV3_1aParser::Elaboration_system_taskContext>(0);
}


size_t SV3_1aParser::Program_generate_itemContext::getRuleIndex() const {
  return SV3_1aParser::RuleProgram_generate_item;
}

void SV3_1aParser::Program_generate_itemContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterProgram_generate_item(this);
}

void SV3_1aParser::Program_generate_itemContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitProgram_generate_item(this);
}

SV3_1aParser::Program_generate_itemContext* SV3_1aParser::program_generate_item() {
  Program_generate_itemContext *_localctx = _tracker.createInstance<Program_generate_itemContext>(_ctx, getState());
  enterRule(_localctx, 112, SV3_1aParser::RuleProgram_generate_item);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2353);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SV3_1aParser::FOR: {
        enterOuterAlt(_localctx, 1);
        setState(2349);
        loop_generate_construct();
        break;
      }

      case SV3_1aParser::IF:
      case SV3_1aParser::CASE: {
        enterOuterAlt(_localctx, 2);
        setState(2350);
        conditional_generate_construct();
        break;
      }

      case SV3_1aParser::GENERATE: {
        enterOuterAlt(_localctx, 3);
        setState(2351);
        generate_region();
        break;
      }

      case SV3_1aParser::DOLLAR: {
        enterOuterAlt(_localctx, 4);
        setState(2352);
        elaboration_system_task();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Checker_port_listContext ------------------------------------------------------------------

SV3_1aParser::Checker_port_listContext::Checker_port_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<SV3_1aParser::Checker_port_itemContext *> SV3_1aParser::Checker_port_listContext::checker_port_item() {
  return getRuleContexts<SV3_1aParser::Checker_port_itemContext>();
}

SV3_1aParser::Checker_port_itemContext* SV3_1aParser::Checker_port_listContext::checker_port_item(size_t i) {
  return getRuleContext<SV3_1aParser::Checker_port_itemContext>(i);
}

std::vector<tree::TerminalNode *> SV3_1aParser::Checker_port_listContext::COMMA() {
  return getTokens(SV3_1aParser::COMMA);
}

tree::TerminalNode* SV3_1aParser::Checker_port_listContext::COMMA(size_t i) {
  return getToken(SV3_1aParser::COMMA, i);
}


size_t SV3_1aParser::Checker_port_listContext::getRuleIndex() const {
  return SV3_1aParser::RuleChecker_port_list;
}

void SV3_1aParser::Checker_port_listContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterChecker_port_list(this);
}

void SV3_1aParser::Checker_port_listContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitChecker_port_list(this);
}

SV3_1aParser::Checker_port_listContext* SV3_1aParser::checker_port_list() {
  Checker_port_listContext *_localctx = _tracker.createInstance<Checker_port_listContext>(_ctx, getState());
  enterRule(_localctx, 114, SV3_1aParser::RuleChecker_port_list);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2355);
    checker_port_item();
    setState(2360);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == SV3_1aParser::COMMA) {
      setState(2356);
      match(SV3_1aParser::COMMA);
      setState(2357);
      checker_port_item();
      setState(2362);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Checker_port_itemContext ------------------------------------------------------------------

SV3_1aParser::Checker_port_itemContext::Checker_port_itemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::Property_formal_typeContext* SV3_1aParser::Checker_port_itemContext::property_formal_type() {
  return getRuleContext<SV3_1aParser::Property_formal_typeContext>(0);
}

SV3_1aParser::IdentifierContext* SV3_1aParser::Checker_port_itemContext::identifier() {
  return getRuleContext<SV3_1aParser::IdentifierContext>(0);
}

std::vector<SV3_1aParser::Attribute_instanceContext *> SV3_1aParser::Checker_port_itemContext::attribute_instance() {
  return getRuleContexts<SV3_1aParser::Attribute_instanceContext>();
}

SV3_1aParser::Attribute_instanceContext* SV3_1aParser::Checker_port_itemContext::attribute_instance(size_t i) {
  return getRuleContext<SV3_1aParser::Attribute_instanceContext>(i);
}

std::vector<SV3_1aParser::Variable_dimensionContext *> SV3_1aParser::Checker_port_itemContext::variable_dimension() {
  return getRuleContexts<SV3_1aParser::Variable_dimensionContext>();
}

SV3_1aParser::Variable_dimensionContext* SV3_1aParser::Checker_port_itemContext::variable_dimension(size_t i) {
  return getRuleContext<SV3_1aParser::Variable_dimensionContext>(i);
}

tree::TerminalNode* SV3_1aParser::Checker_port_itemContext::ASSIGN_OP() {
  return getToken(SV3_1aParser::ASSIGN_OP, 0);
}

SV3_1aParser::Property_actual_argContext* SV3_1aParser::Checker_port_itemContext::property_actual_arg() {
  return getRuleContext<SV3_1aParser::Property_actual_argContext>(0);
}

tree::TerminalNode* SV3_1aParser::Checker_port_itemContext::INPUT() {
  return getToken(SV3_1aParser::INPUT, 0);
}

tree::TerminalNode* SV3_1aParser::Checker_port_itemContext::OUTPUT() {
  return getToken(SV3_1aParser::OUTPUT, 0);
}


size_t SV3_1aParser::Checker_port_itemContext::getRuleIndex() const {
  return SV3_1aParser::RuleChecker_port_item;
}

void SV3_1aParser::Checker_port_itemContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterChecker_port_item(this);
}

void SV3_1aParser::Checker_port_itemContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitChecker_port_item(this);
}

SV3_1aParser::Checker_port_itemContext* SV3_1aParser::checker_port_item() {
  Checker_port_itemContext *_localctx = _tracker.createInstance<Checker_port_itemContext>(_ctx, getState());
  enterRule(_localctx, 116, SV3_1aParser::RuleChecker_port_item);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2366);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == SV3_1aParser::OPEN_PARENS_STAR) {
      setState(2363);
      attribute_instance();
      setState(2368);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(2370);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SV3_1aParser::INPUT

    || _la == SV3_1aParser::OUTPUT) {
      setState(2369);
      _la = _input->LA(1);
      if (!(_la == SV3_1aParser::INPUT

      || _la == SV3_1aParser::OUTPUT)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
    }
    setState(2372);
    property_formal_type();
    setState(2373);
    identifier();
    setState(2377);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == SV3_1aParser::ASSOCIATIVE_UNSPECIFIED || _la == SV3_1aParser::OPEN_BRACKET) {
      setState(2374);
      variable_dimension();
      setState(2379);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(2382);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SV3_1aParser::ASSIGN_OP) {
      setState(2380);
      match(SV3_1aParser::ASSIGN_OP);
      setState(2381);
      property_actual_arg();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Checker_or_generate_itemContext ------------------------------------------------------------------

SV3_1aParser::Checker_or_generate_itemContext::Checker_or_generate_itemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::Checker_or_generate_item_declarationContext* SV3_1aParser::Checker_or_generate_itemContext::checker_or_generate_item_declaration() {
  return getRuleContext<SV3_1aParser::Checker_or_generate_item_declarationContext>(0);
}

SV3_1aParser::Initial_constructContext* SV3_1aParser::Checker_or_generate_itemContext::initial_construct() {
  return getRuleContext<SV3_1aParser::Initial_constructContext>(0);
}

SV3_1aParser::Always_constructContext* SV3_1aParser::Checker_or_generate_itemContext::always_construct() {
  return getRuleContext<SV3_1aParser::Always_constructContext>(0);
}

SV3_1aParser::Final_constructContext* SV3_1aParser::Checker_or_generate_itemContext::final_construct() {
  return getRuleContext<SV3_1aParser::Final_constructContext>(0);
}

SV3_1aParser::Assertion_itemContext* SV3_1aParser::Checker_or_generate_itemContext::assertion_item() {
  return getRuleContext<SV3_1aParser::Assertion_itemContext>(0);
}

SV3_1aParser::Continuous_assignContext* SV3_1aParser::Checker_or_generate_itemContext::continuous_assign() {
  return getRuleContext<SV3_1aParser::Continuous_assignContext>(0);
}

SV3_1aParser::Checker_generate_itemContext* SV3_1aParser::Checker_or_generate_itemContext::checker_generate_item() {
  return getRuleContext<SV3_1aParser::Checker_generate_itemContext>(0);
}


size_t SV3_1aParser::Checker_or_generate_itemContext::getRuleIndex() const {
  return SV3_1aParser::RuleChecker_or_generate_item;
}

void SV3_1aParser::Checker_or_generate_itemContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterChecker_or_generate_item(this);
}

void SV3_1aParser::Checker_or_generate_itemContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitChecker_or_generate_item(this);
}

SV3_1aParser::Checker_or_generate_itemContext* SV3_1aParser::checker_or_generate_item() {
  Checker_or_generate_itemContext *_localctx = _tracker.createInstance<Checker_or_generate_itemContext>(_ctx, getState());
  enterRule(_localctx, 118, SV3_1aParser::RuleChecker_or_generate_item);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2391);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 161, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2384);
      checker_or_generate_item_declaration();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2385);
      initial_construct();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(2386);
      always_construct();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(2387);
      final_construct();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(2388);
      assertion_item();
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(2389);
      continuous_assign();
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(2390);
      checker_generate_item();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Checker_or_generate_item_declarationContext ------------------------------------------------------------------

SV3_1aParser::Checker_or_generate_item_declarationContext::Checker_or_generate_item_declarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::Data_declarationContext* SV3_1aParser::Checker_or_generate_item_declarationContext::data_declaration() {
  return getRuleContext<SV3_1aParser::Data_declarationContext>(0);
}

std::vector<tree::TerminalNode *> SV3_1aParser::Checker_or_generate_item_declarationContext::RAND() {
  return getTokens(SV3_1aParser::RAND);
}

tree::TerminalNode* SV3_1aParser::Checker_or_generate_item_declarationContext::RAND(size_t i) {
  return getToken(SV3_1aParser::RAND, i);
}

SV3_1aParser::Function_declarationContext* SV3_1aParser::Checker_or_generate_item_declarationContext::function_declaration() {
  return getRuleContext<SV3_1aParser::Function_declarationContext>(0);
}

SV3_1aParser::Checker_declarationContext* SV3_1aParser::Checker_or_generate_item_declarationContext::checker_declaration() {
  return getRuleContext<SV3_1aParser::Checker_declarationContext>(0);
}

SV3_1aParser::Assertion_item_declarationContext* SV3_1aParser::Checker_or_generate_item_declarationContext::assertion_item_declaration() {
  return getRuleContext<SV3_1aParser::Assertion_item_declarationContext>(0);
}

SV3_1aParser::Covergroup_declarationContext* SV3_1aParser::Checker_or_generate_item_declarationContext::covergroup_declaration() {
  return getRuleContext<SV3_1aParser::Covergroup_declarationContext>(0);
}

SV3_1aParser::Overload_declarationContext* SV3_1aParser::Checker_or_generate_item_declarationContext::overload_declaration() {
  return getRuleContext<SV3_1aParser::Overload_declarationContext>(0);
}

SV3_1aParser::Genvar_declarationContext* SV3_1aParser::Checker_or_generate_item_declarationContext::genvar_declaration() {
  return getRuleContext<SV3_1aParser::Genvar_declarationContext>(0);
}

SV3_1aParser::Clocking_declarationContext* SV3_1aParser::Checker_or_generate_item_declarationContext::clocking_declaration() {
  return getRuleContext<SV3_1aParser::Clocking_declarationContext>(0);
}

tree::TerminalNode* SV3_1aParser::Checker_or_generate_item_declarationContext::DEFAULT() {
  return getToken(SV3_1aParser::DEFAULT, 0);
}

tree::TerminalNode* SV3_1aParser::Checker_or_generate_item_declarationContext::CLOCKING() {
  return getToken(SV3_1aParser::CLOCKING, 0);
}

SV3_1aParser::IdentifierContext* SV3_1aParser::Checker_or_generate_item_declarationContext::identifier() {
  return getRuleContext<SV3_1aParser::IdentifierContext>(0);
}

tree::TerminalNode* SV3_1aParser::Checker_or_generate_item_declarationContext::SEMICOLON() {
  return getToken(SV3_1aParser::SEMICOLON, 0);
}

tree::TerminalNode* SV3_1aParser::Checker_or_generate_item_declarationContext::DISABLE() {
  return getToken(SV3_1aParser::DISABLE, 0);
}

tree::TerminalNode* SV3_1aParser::Checker_or_generate_item_declarationContext::IFF() {
  return getToken(SV3_1aParser::IFF, 0);
}

SV3_1aParser::Expression_or_distContext* SV3_1aParser::Checker_or_generate_item_declarationContext::expression_or_dist() {
  return getRuleContext<SV3_1aParser::Expression_or_distContext>(0);
}

SV3_1aParser::Surelog_macro_not_definedContext* SV3_1aParser::Checker_or_generate_item_declarationContext::surelog_macro_not_defined() {
  return getRuleContext<SV3_1aParser::Surelog_macro_not_definedContext>(0);
}


size_t SV3_1aParser::Checker_or_generate_item_declarationContext::getRuleIndex() const {
  return SV3_1aParser::RuleChecker_or_generate_item_declaration;
}

void SV3_1aParser::Checker_or_generate_item_declarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterChecker_or_generate_item_declaration(this);
}

void SV3_1aParser::Checker_or_generate_item_declarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitChecker_or_generate_item_declaration(this);
}

SV3_1aParser::Checker_or_generate_item_declarationContext* SV3_1aParser::checker_or_generate_item_declaration() {
  Checker_or_generate_item_declarationContext *_localctx = _tracker.createInstance<Checker_or_generate_item_declarationContext>(_ctx, getState());
  enterRule(_localctx, 120, SV3_1aParser::RuleChecker_or_generate_item_declaration);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2420);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 163, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2396);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == SV3_1aParser::RAND) {
        setState(2393);
        match(SV3_1aParser::RAND);
        setState(2398);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(2399);
      data_declaration();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2400);
      function_declaration();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(2401);
      checker_declaration();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(2402);
      assertion_item_declaration();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(2403);
      covergroup_declaration();
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(2404);
      overload_declaration();
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(2405);
      genvar_declaration();
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(2406);
      clocking_declaration();
      break;
    }

    case 9: {
      enterOuterAlt(_localctx, 9);
      setState(2407);
      match(SV3_1aParser::DEFAULT);
      setState(2408);
      match(SV3_1aParser::CLOCKING);
      setState(2409);
      identifier();
      setState(2410);
      match(SV3_1aParser::SEMICOLON);
      break;
    }

    case 10: {
      enterOuterAlt(_localctx, 10);
      setState(2412);
      match(SV3_1aParser::DEFAULT);
      setState(2413);
      match(SV3_1aParser::DISABLE);
      setState(2414);
      match(SV3_1aParser::IFF);
      setState(2415);
      expression_or_dist();
      setState(2416);
      match(SV3_1aParser::SEMICOLON);
      break;
    }

    case 11: {
      enterOuterAlt(_localctx, 11);
      setState(2418);
      match(SV3_1aParser::SEMICOLON);
      break;
    }

    case 12: {
      enterOuterAlt(_localctx, 12);
      setState(2419);
      surelog_macro_not_defined();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Checker_generate_itemContext ------------------------------------------------------------------

SV3_1aParser::Checker_generate_itemContext::Checker_generate_itemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::Loop_generate_constructContext* SV3_1aParser::Checker_generate_itemContext::loop_generate_construct() {
  return getRuleContext<SV3_1aParser::Loop_generate_constructContext>(0);
}

SV3_1aParser::Conditional_generate_constructContext* SV3_1aParser::Checker_generate_itemContext::conditional_generate_construct() {
  return getRuleContext<SV3_1aParser::Conditional_generate_constructContext>(0);
}

SV3_1aParser::Generate_regionContext* SV3_1aParser::Checker_generate_itemContext::generate_region() {
  return getRuleContext<SV3_1aParser::Generate_regionContext>(0);
}

SV3_1aParser::Elaboration_system_taskContext* SV3_1aParser::Checker_generate_itemContext::elaboration_system_task() {
  return getRuleContext<SV3_1aParser::Elaboration_system_taskContext>(0);
}


size_t SV3_1aParser::Checker_generate_itemContext::getRuleIndex() const {
  return SV3_1aParser::RuleChecker_generate_item;
}

void SV3_1aParser::Checker_generate_itemContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterChecker_generate_item(this);
}

void SV3_1aParser::Checker_generate_itemContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitChecker_generate_item(this);
}

SV3_1aParser::Checker_generate_itemContext* SV3_1aParser::checker_generate_item() {
  Checker_generate_itemContext *_localctx = _tracker.createInstance<Checker_generate_itemContext>(_ctx, getState());
  enterRule(_localctx, 122, SV3_1aParser::RuleChecker_generate_item);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2426);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SV3_1aParser::FOR: {
        enterOuterAlt(_localctx, 1);
        setState(2422);
        loop_generate_construct();
        break;
      }

      case SV3_1aParser::IF:
      case SV3_1aParser::CASE: {
        enterOuterAlt(_localctx, 2);
        setState(2423);
        conditional_generate_construct();
        break;
      }

      case SV3_1aParser::GENERATE: {
        enterOuterAlt(_localctx, 3);
        setState(2424);
        generate_region();
        break;
      }

      case SV3_1aParser::DOLLAR: {
        enterOuterAlt(_localctx, 4);
        setState(2425);
        elaboration_system_task();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Class_itemContext ------------------------------------------------------------------

SV3_1aParser::Class_itemContext::Class_itemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::Class_propertyContext* SV3_1aParser::Class_itemContext::class_property() {
  return getRuleContext<SV3_1aParser::Class_propertyContext>(0);
}

SV3_1aParser::Class_methodContext* SV3_1aParser::Class_itemContext::class_method() {
  return getRuleContext<SV3_1aParser::Class_methodContext>(0);
}

SV3_1aParser::Class_constraintContext* SV3_1aParser::Class_itemContext::class_constraint() {
  return getRuleContext<SV3_1aParser::Class_constraintContext>(0);
}

SV3_1aParser::Type_declarationContext* SV3_1aParser::Class_itemContext::type_declaration() {
  return getRuleContext<SV3_1aParser::Type_declarationContext>(0);
}

SV3_1aParser::Class_declarationContext* SV3_1aParser::Class_itemContext::class_declaration() {
  return getRuleContext<SV3_1aParser::Class_declarationContext>(0);
}

SV3_1aParser::Covergroup_declarationContext* SV3_1aParser::Class_itemContext::covergroup_declaration() {
  return getRuleContext<SV3_1aParser::Covergroup_declarationContext>(0);
}

std::vector<SV3_1aParser::Attribute_instanceContext *> SV3_1aParser::Class_itemContext::attribute_instance() {
  return getRuleContexts<SV3_1aParser::Attribute_instanceContext>();
}

SV3_1aParser::Attribute_instanceContext* SV3_1aParser::Class_itemContext::attribute_instance(size_t i) {
  return getRuleContext<SV3_1aParser::Attribute_instanceContext>(i);
}

SV3_1aParser::Local_parameter_declarationContext* SV3_1aParser::Class_itemContext::local_parameter_declaration() {
  return getRuleContext<SV3_1aParser::Local_parameter_declarationContext>(0);
}

tree::TerminalNode* SV3_1aParser::Class_itemContext::SEMICOLON() {
  return getToken(SV3_1aParser::SEMICOLON, 0);
}

SV3_1aParser::Parameter_declarationContext* SV3_1aParser::Class_itemContext::parameter_declaration() {
  return getRuleContext<SV3_1aParser::Parameter_declarationContext>(0);
}

SV3_1aParser::Surelog_macro_not_definedContext* SV3_1aParser::Class_itemContext::surelog_macro_not_defined() {
  return getRuleContext<SV3_1aParser::Surelog_macro_not_definedContext>(0);
}


size_t SV3_1aParser::Class_itemContext::getRuleIndex() const {
  return SV3_1aParser::RuleClass_item;
}

void SV3_1aParser::Class_itemContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterClass_item(this);
}

void SV3_1aParser::Class_itemContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitClass_item(this);
}

SV3_1aParser::Class_itemContext* SV3_1aParser::class_item() {
  Class_itemContext *_localctx = _tracker.createInstance<Class_itemContext>(_ctx, getState());
  enterRule(_localctx, 124, SV3_1aParser::RuleClass_item);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2450);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SV3_1aParser::EXTERN:
      case SV3_1aParser::VIRTUAL:
      case SV3_1aParser::CLASS:
      case SV3_1aParser::TYPE:
      case SV3_1aParser::CONST:
      case SV3_1aParser::FUNCTION:
      case SV3_1aParser::STATIC:
      case SV3_1aParser::PROTECTED:
      case SV3_1aParser::LOCAL:
      case SV3_1aParser::RAND:
      case SV3_1aParser::RANDC:
      case SV3_1aParser::CONSTRAINT:
      case SV3_1aParser::AUTOMATIC:
      case SV3_1aParser::IMPORT:
      case SV3_1aParser::TYPEDEF:
      case SV3_1aParser::ENUM:
      case SV3_1aParser::STRUCT:
      case SV3_1aParser::UNION:
      case SV3_1aParser::STRING:
      case SV3_1aParser::CHANDLE:
      case SV3_1aParser::EVENT:
      case SV3_1aParser::OPEN_BRACKET:
      case SV3_1aParser::BYTE:
      case SV3_1aParser::SHORTINT:
      case SV3_1aParser::INT:
      case SV3_1aParser::LONGINT:
      case SV3_1aParser::INTEGER:
      case SV3_1aParser::TIME:
      case SV3_1aParser::BIT:
      case SV3_1aParser::LOGIC:
      case SV3_1aParser::REG:
      case SV3_1aParser::SHORTREAL:
      case SV3_1aParser::REAL:
      case SV3_1aParser::REALTIME:
      case SV3_1aParser::SIGNED:
      case SV3_1aParser::UNSIGNED:
      case SV3_1aParser::VAR:
      case SV3_1aParser::PURE:
      case SV3_1aParser::DOLLAR_UNIT:
      case SV3_1aParser::OPEN_PARENS_STAR:
      case SV3_1aParser::COVERGROUP:
      case SV3_1aParser::THIS:
      case SV3_1aParser::RANDOMIZE:
      case SV3_1aParser::TASK:
      case SV3_1aParser::SAMPLE:
      case SV3_1aParser::NETTYPE:
      case SV3_1aParser::Escaped_identifier:
      case SV3_1aParser::Simple_identifier: {
        enterOuterAlt(_localctx, 1);
        setState(2431);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == SV3_1aParser::OPEN_PARENS_STAR) {
          setState(2428);
          attribute_instance();
          setState(2433);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(2440);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 166, _ctx)) {
        case 1: {
          setState(2434);
          class_property();
          break;
        }

        case 2: {
          setState(2435);
          class_method();
          break;
        }

        case 3: {
          setState(2436);
          class_constraint();
          break;
        }

        case 4: {
          setState(2437);
          type_declaration();
          break;
        }

        case 5: {
          setState(2438);
          class_declaration();
          break;
        }

        case 6: {
          setState(2439);
          covergroup_declaration();
          break;
        }

        default:
          break;
        }
        break;
      }

      case SV3_1aParser::LOCALPARAM: {
        enterOuterAlt(_localctx, 2);
        setState(2442);
        local_parameter_declaration();
        setState(2443);
        match(SV3_1aParser::SEMICOLON);
        break;
      }

      case SV3_1aParser::PARAMETER: {
        enterOuterAlt(_localctx, 3);
        setState(2445);
        parameter_declaration();
        setState(2446);
        match(SV3_1aParser::SEMICOLON);
        break;
      }

      case SV3_1aParser::SURELOG_MACRO_NOT_DEFINED: {
        enterOuterAlt(_localctx, 4);
        setState(2448);
        surelog_macro_not_defined();
        break;
      }

      case SV3_1aParser::SEMICOLON: {
        enterOuterAlt(_localctx, 5);
        setState(2449);
        match(SV3_1aParser::SEMICOLON);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Class_propertyContext ------------------------------------------------------------------

SV3_1aParser::Class_propertyContext::Class_propertyContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::Data_declarationContext* SV3_1aParser::Class_propertyContext::data_declaration() {
  return getRuleContext<SV3_1aParser::Data_declarationContext>(0);
}

SV3_1aParser::Const_typeContext* SV3_1aParser::Class_propertyContext::const_type() {
  return getRuleContext<SV3_1aParser::Const_typeContext>(0);
}

std::vector<SV3_1aParser::Property_qualifierContext *> SV3_1aParser::Class_propertyContext::property_qualifier() {
  return getRuleContexts<SV3_1aParser::Property_qualifierContext>();
}

SV3_1aParser::Property_qualifierContext* SV3_1aParser::Class_propertyContext::property_qualifier(size_t i) {
  return getRuleContext<SV3_1aParser::Property_qualifierContext>(i);
}

SV3_1aParser::Data_typeContext* SV3_1aParser::Class_propertyContext::data_type() {
  return getRuleContext<SV3_1aParser::Data_typeContext>(0);
}

SV3_1aParser::IdentifierContext* SV3_1aParser::Class_propertyContext::identifier() {
  return getRuleContext<SV3_1aParser::IdentifierContext>(0);
}

tree::TerminalNode* SV3_1aParser::Class_propertyContext::SEMICOLON() {
  return getToken(SV3_1aParser::SEMICOLON, 0);
}

std::vector<SV3_1aParser::Class_item_qualifierContext *> SV3_1aParser::Class_propertyContext::class_item_qualifier() {
  return getRuleContexts<SV3_1aParser::Class_item_qualifierContext>();
}

SV3_1aParser::Class_item_qualifierContext* SV3_1aParser::Class_propertyContext::class_item_qualifier(size_t i) {
  return getRuleContext<SV3_1aParser::Class_item_qualifierContext>(i);
}

tree::TerminalNode* SV3_1aParser::Class_propertyContext::ASSIGN_OP() {
  return getToken(SV3_1aParser::ASSIGN_OP, 0);
}

SV3_1aParser::Constant_expressionContext* SV3_1aParser::Class_propertyContext::constant_expression() {
  return getRuleContext<SV3_1aParser::Constant_expressionContext>(0);
}


size_t SV3_1aParser::Class_propertyContext::getRuleIndex() const {
  return SV3_1aParser::RuleClass_property;
}

void SV3_1aParser::Class_propertyContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterClass_property(this);
}

void SV3_1aParser::Class_propertyContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitClass_property(this);
}

SV3_1aParser::Class_propertyContext* SV3_1aParser::class_property() {
  Class_propertyContext *_localctx = _tracker.createInstance<Class_propertyContext>(_ctx, getState());
  enterRule(_localctx, 126, SV3_1aParser::RuleClass_property);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    setState(2477);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 172, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2453);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 168, _ctx)) {
      case 1: {
        setState(2452);
        const_type();
        break;
      }

      default:
        break;
      }
      setState(2458);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 169, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(2455);
          property_qualifier(); 
        }
        setState(2460);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 169, _ctx);
      }
      setState(2461);
      data_declaration();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2462);
      const_type();
      setState(2466);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (((((_la - 77) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 77)) & 7) != 0)) {
        setState(2463);
        class_item_qualifier();
        setState(2468);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(2469);
      data_type();
      setState(2470);
      identifier();
      setState(2473);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == SV3_1aParser::ASSIGN_OP) {
        setState(2471);
        match(SV3_1aParser::ASSIGN_OP);
        setState(2472);
        constant_expression(0);
      }
      setState(2475);
      match(SV3_1aParser::SEMICOLON);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Pure_virtual_qualifierContext ------------------------------------------------------------------

SV3_1aParser::Pure_virtual_qualifierContext::Pure_virtual_qualifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Pure_virtual_qualifierContext::PURE() {
  return getToken(SV3_1aParser::PURE, 0);
}

tree::TerminalNode* SV3_1aParser::Pure_virtual_qualifierContext::VIRTUAL() {
  return getToken(SV3_1aParser::VIRTUAL, 0);
}


size_t SV3_1aParser::Pure_virtual_qualifierContext::getRuleIndex() const {
  return SV3_1aParser::RulePure_virtual_qualifier;
}

void SV3_1aParser::Pure_virtual_qualifierContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPure_virtual_qualifier(this);
}

void SV3_1aParser::Pure_virtual_qualifierContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPure_virtual_qualifier(this);
}

SV3_1aParser::Pure_virtual_qualifierContext* SV3_1aParser::pure_virtual_qualifier() {
  Pure_virtual_qualifierContext *_localctx = _tracker.createInstance<Pure_virtual_qualifierContext>(_ctx, getState());
  enterRule(_localctx, 128, SV3_1aParser::RulePure_virtual_qualifier);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2479);
    match(SV3_1aParser::PURE);
    setState(2480);
    match(SV3_1aParser::VIRTUAL);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Extern_qualifierContext ------------------------------------------------------------------

SV3_1aParser::Extern_qualifierContext::Extern_qualifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Extern_qualifierContext::EXTERN() {
  return getToken(SV3_1aParser::EXTERN, 0);
}


size_t SV3_1aParser::Extern_qualifierContext::getRuleIndex() const {
  return SV3_1aParser::RuleExtern_qualifier;
}

void SV3_1aParser::Extern_qualifierContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExtern_qualifier(this);
}

void SV3_1aParser::Extern_qualifierContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExtern_qualifier(this);
}

SV3_1aParser::Extern_qualifierContext* SV3_1aParser::extern_qualifier() {
  Extern_qualifierContext *_localctx = _tracker.createInstance<Extern_qualifierContext>(_ctx, getState());
  enterRule(_localctx, 130, SV3_1aParser::RuleExtern_qualifier);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2482);
    match(SV3_1aParser::EXTERN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Class_methodContext ------------------------------------------------------------------

SV3_1aParser::Class_methodContext::Class_methodContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::Task_declarationContext* SV3_1aParser::Class_methodContext::task_declaration() {
  return getRuleContext<SV3_1aParser::Task_declarationContext>(0);
}

SV3_1aParser::Function_declarationContext* SV3_1aParser::Class_methodContext::function_declaration() {
  return getRuleContext<SV3_1aParser::Function_declarationContext>(0);
}

SV3_1aParser::Class_constructor_declarationContext* SV3_1aParser::Class_methodContext::class_constructor_declaration() {
  return getRuleContext<SV3_1aParser::Class_constructor_declarationContext>(0);
}

std::vector<SV3_1aParser::Method_qualifierContext *> SV3_1aParser::Class_methodContext::method_qualifier() {
  return getRuleContexts<SV3_1aParser::Method_qualifierContext>();
}

SV3_1aParser::Method_qualifierContext* SV3_1aParser::Class_methodContext::method_qualifier(size_t i) {
  return getRuleContext<SV3_1aParser::Method_qualifierContext>(i);
}

SV3_1aParser::Pure_virtual_qualifierContext* SV3_1aParser::Class_methodContext::pure_virtual_qualifier() {
  return getRuleContext<SV3_1aParser::Pure_virtual_qualifierContext>(0);
}

SV3_1aParser::Method_prototypeContext* SV3_1aParser::Class_methodContext::method_prototype() {
  return getRuleContext<SV3_1aParser::Method_prototypeContext>(0);
}

tree::TerminalNode* SV3_1aParser::Class_methodContext::SEMICOLON() {
  return getToken(SV3_1aParser::SEMICOLON, 0);
}

std::vector<SV3_1aParser::Class_item_qualifierContext *> SV3_1aParser::Class_methodContext::class_item_qualifier() {
  return getRuleContexts<SV3_1aParser::Class_item_qualifierContext>();
}

SV3_1aParser::Class_item_qualifierContext* SV3_1aParser::Class_methodContext::class_item_qualifier(size_t i) {
  return getRuleContext<SV3_1aParser::Class_item_qualifierContext>(i);
}

SV3_1aParser::Extern_qualifierContext* SV3_1aParser::Class_methodContext::extern_qualifier() {
  return getRuleContext<SV3_1aParser::Extern_qualifierContext>(0);
}

SV3_1aParser::Class_constructor_prototypeContext* SV3_1aParser::Class_methodContext::class_constructor_prototype() {
  return getRuleContext<SV3_1aParser::Class_constructor_prototypeContext>(0);
}


size_t SV3_1aParser::Class_methodContext::getRuleIndex() const {
  return SV3_1aParser::RuleClass_method;
}

void SV3_1aParser::Class_methodContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterClass_method(this);
}

void SV3_1aParser::Class_methodContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitClass_method(this);
}

SV3_1aParser::Class_methodContext* SV3_1aParser::class_method() {
  Class_methodContext *_localctx = _tracker.createInstance<Class_methodContext>(_ctx, getState());
  enterRule(_localctx, 132, SV3_1aParser::RuleClass_method);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2518);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SV3_1aParser::VIRTUAL:
      case SV3_1aParser::FUNCTION:
      case SV3_1aParser::STATIC:
      case SV3_1aParser::PROTECTED:
      case SV3_1aParser::LOCAL:
      case SV3_1aParser::TASK: {
        enterOuterAlt(_localctx, 1);
        setState(2487);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (((((_la - 52) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 52)) & 234881025) != 0)) {
          setState(2484);
          method_qualifier();
          setState(2489);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(2493);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 174, _ctx)) {
        case 1: {
          setState(2490);
          task_declaration();
          break;
        }

        case 2: {
          setState(2491);
          function_declaration();
          break;
        }

        case 3: {
          setState(2492);
          class_constructor_declaration();
          break;
        }

        default:
          break;
        }
        break;
      }

      case SV3_1aParser::PURE: {
        enterOuterAlt(_localctx, 2);
        setState(2495);
        pure_virtual_qualifier();
        setState(2499);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (((((_la - 77) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 77)) & 7) != 0)) {
          setState(2496);
          class_item_qualifier();
          setState(2501);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(2502);
        method_prototype();
        setState(2503);
        match(SV3_1aParser::SEMICOLON);
        break;
      }

      case SV3_1aParser::EXTERN: {
        enterOuterAlt(_localctx, 3);
        setState(2505);
        extern_qualifier();
        setState(2509);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (((((_la - 52) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 52)) & 234881025) != 0)) {
          setState(2506);
          method_qualifier();
          setState(2511);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(2516);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 177, _ctx)) {
        case 1: {
          setState(2512);
          method_prototype();
          setState(2513);
          match(SV3_1aParser::SEMICOLON);
          break;
        }

        case 2: {
          setState(2515);
          class_constructor_prototype();
          break;
        }

        default:
          break;
        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Class_constructor_prototypeContext ------------------------------------------------------------------

SV3_1aParser::Class_constructor_prototypeContext::Class_constructor_prototypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Class_constructor_prototypeContext::FUNCTION() {
  return getToken(SV3_1aParser::FUNCTION, 0);
}

tree::TerminalNode* SV3_1aParser::Class_constructor_prototypeContext::NEW() {
  return getToken(SV3_1aParser::NEW, 0);
}

tree::TerminalNode* SV3_1aParser::Class_constructor_prototypeContext::OPEN_PARENS() {
  return getToken(SV3_1aParser::OPEN_PARENS, 0);
}

tree::TerminalNode* SV3_1aParser::Class_constructor_prototypeContext::CLOSE_PARENS() {
  return getToken(SV3_1aParser::CLOSE_PARENS, 0);
}

SV3_1aParser::Tf_port_listContext* SV3_1aParser::Class_constructor_prototypeContext::tf_port_list() {
  return getRuleContext<SV3_1aParser::Tf_port_listContext>(0);
}


size_t SV3_1aParser::Class_constructor_prototypeContext::getRuleIndex() const {
  return SV3_1aParser::RuleClass_constructor_prototype;
}

void SV3_1aParser::Class_constructor_prototypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterClass_constructor_prototype(this);
}

void SV3_1aParser::Class_constructor_prototypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitClass_constructor_prototype(this);
}

SV3_1aParser::Class_constructor_prototypeContext* SV3_1aParser::class_constructor_prototype() {
  Class_constructor_prototypeContext *_localctx = _tracker.createInstance<Class_constructor_prototypeContext>(_ctx, getState());
  enterRule(_localctx, 134, SV3_1aParser::RuleClass_constructor_prototype);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2520);
    match(SV3_1aParser::FUNCTION);
    setState(2521);
    match(SV3_1aParser::NEW);
    setState(2527);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SV3_1aParser::OPEN_PARENS) {
      setState(2522);
      match(SV3_1aParser::OPEN_PARENS);
      setState(2524);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == SV3_1aParser::VIRTUAL || ((((_la - 64) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 64)) & 1152775819316167741) != 0) || ((((_la - 147) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 147)) & 6597069766667) != 0) || ((((_la - 326) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 326)) & 4672924483589) != 0)) {
        setState(2523);
        tf_port_list();
      }
      setState(2526);
      match(SV3_1aParser::CLOSE_PARENS);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Class_constraintContext ------------------------------------------------------------------

SV3_1aParser::Class_constraintContext::Class_constraintContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::Constraint_prototypeContext* SV3_1aParser::Class_constraintContext::constraint_prototype() {
  return getRuleContext<SV3_1aParser::Constraint_prototypeContext>(0);
}

SV3_1aParser::Constraint_declarationContext* SV3_1aParser::Class_constraintContext::constraint_declaration() {
  return getRuleContext<SV3_1aParser::Constraint_declarationContext>(0);
}


size_t SV3_1aParser::Class_constraintContext::getRuleIndex() const {
  return SV3_1aParser::RuleClass_constraint;
}

void SV3_1aParser::Class_constraintContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterClass_constraint(this);
}

void SV3_1aParser::Class_constraintContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitClass_constraint(this);
}

SV3_1aParser::Class_constraintContext* SV3_1aParser::class_constraint() {
  Class_constraintContext *_localctx = _tracker.createInstance<Class_constraintContext>(_ctx, getState());
  enterRule(_localctx, 136, SV3_1aParser::RuleClass_constraint);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2531);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 181, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2529);
      constraint_prototype();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2530);
      constraint_declaration();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Class_item_qualifierContext ------------------------------------------------------------------

SV3_1aParser::Class_item_qualifierContext::Class_item_qualifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t SV3_1aParser::Class_item_qualifierContext::getRuleIndex() const {
  return SV3_1aParser::RuleClass_item_qualifier;
}

void SV3_1aParser::Class_item_qualifierContext::copyFrom(Class_item_qualifierContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- ClassItemQualifier_StaticContext ------------------------------------------------------------------

tree::TerminalNode* SV3_1aParser::ClassItemQualifier_StaticContext::STATIC() {
  return getToken(SV3_1aParser::STATIC, 0);
}

SV3_1aParser::ClassItemQualifier_StaticContext::ClassItemQualifier_StaticContext(Class_item_qualifierContext *ctx) { copyFrom(ctx); }

void SV3_1aParser::ClassItemQualifier_StaticContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterClassItemQualifier_Static(this);
}
void SV3_1aParser::ClassItemQualifier_StaticContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitClassItemQualifier_Static(this);
}
//----------------- ClassItemQualifier_LocalContext ------------------------------------------------------------------

tree::TerminalNode* SV3_1aParser::ClassItemQualifier_LocalContext::LOCAL() {
  return getToken(SV3_1aParser::LOCAL, 0);
}

SV3_1aParser::ClassItemQualifier_LocalContext::ClassItemQualifier_LocalContext(Class_item_qualifierContext *ctx) { copyFrom(ctx); }

void SV3_1aParser::ClassItemQualifier_LocalContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterClassItemQualifier_Local(this);
}
void SV3_1aParser::ClassItemQualifier_LocalContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitClassItemQualifier_Local(this);
}
//----------------- ClassItemQualifier_ProtectedContext ------------------------------------------------------------------

tree::TerminalNode* SV3_1aParser::ClassItemQualifier_ProtectedContext::PROTECTED() {
  return getToken(SV3_1aParser::PROTECTED, 0);
}

SV3_1aParser::ClassItemQualifier_ProtectedContext::ClassItemQualifier_ProtectedContext(Class_item_qualifierContext *ctx) { copyFrom(ctx); }

void SV3_1aParser::ClassItemQualifier_ProtectedContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterClassItemQualifier_Protected(this);
}
void SV3_1aParser::ClassItemQualifier_ProtectedContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitClassItemQualifier_Protected(this);
}
SV3_1aParser::Class_item_qualifierContext* SV3_1aParser::class_item_qualifier() {
  Class_item_qualifierContext *_localctx = _tracker.createInstance<Class_item_qualifierContext>(_ctx, getState());
  enterRule(_localctx, 138, SV3_1aParser::RuleClass_item_qualifier);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2536);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SV3_1aParser::STATIC: {
        _localctx = _tracker.createInstance<SV3_1aParser::ClassItemQualifier_StaticContext>(_localctx);
        enterOuterAlt(_localctx, 1);
        setState(2533);
        match(SV3_1aParser::STATIC);
        break;
      }

      case SV3_1aParser::PROTECTED: {
        _localctx = _tracker.createInstance<SV3_1aParser::ClassItemQualifier_ProtectedContext>(_localctx);
        enterOuterAlt(_localctx, 2);
        setState(2534);
        match(SV3_1aParser::PROTECTED);
        break;
      }

      case SV3_1aParser::LOCAL: {
        _localctx = _tracker.createInstance<SV3_1aParser::ClassItemQualifier_LocalContext>(_localctx);
        enterOuterAlt(_localctx, 3);
        setState(2535);
        match(SV3_1aParser::LOCAL);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Property_qualifierContext ------------------------------------------------------------------

SV3_1aParser::Property_qualifierContext::Property_qualifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t SV3_1aParser::Property_qualifierContext::getRuleIndex() const {
  return SV3_1aParser::RuleProperty_qualifier;
}

void SV3_1aParser::Property_qualifierContext::copyFrom(Property_qualifierContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- PropQualifier_ClassItemContext ------------------------------------------------------------------

SV3_1aParser::Class_item_qualifierContext* SV3_1aParser::PropQualifier_ClassItemContext::class_item_qualifier() {
  return getRuleContext<SV3_1aParser::Class_item_qualifierContext>(0);
}

SV3_1aParser::PropQualifier_ClassItemContext::PropQualifier_ClassItemContext(Property_qualifierContext *ctx) { copyFrom(ctx); }

void SV3_1aParser::PropQualifier_ClassItemContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPropQualifier_ClassItem(this);
}
void SV3_1aParser::PropQualifier_ClassItemContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPropQualifier_ClassItem(this);
}
//----------------- PropQualifier_RandContext ------------------------------------------------------------------

tree::TerminalNode* SV3_1aParser::PropQualifier_RandContext::RAND() {
  return getToken(SV3_1aParser::RAND, 0);
}

SV3_1aParser::PropQualifier_RandContext::PropQualifier_RandContext(Property_qualifierContext *ctx) { copyFrom(ctx); }

void SV3_1aParser::PropQualifier_RandContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPropQualifier_Rand(this);
}
void SV3_1aParser::PropQualifier_RandContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPropQualifier_Rand(this);
}
//----------------- PropQualifier_RandcContext ------------------------------------------------------------------

tree::TerminalNode* SV3_1aParser::PropQualifier_RandcContext::RANDC() {
  return getToken(SV3_1aParser::RANDC, 0);
}

SV3_1aParser::PropQualifier_RandcContext::PropQualifier_RandcContext(Property_qualifierContext *ctx) { copyFrom(ctx); }

void SV3_1aParser::PropQualifier_RandcContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPropQualifier_Randc(this);
}
void SV3_1aParser::PropQualifier_RandcContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPropQualifier_Randc(this);
}
SV3_1aParser::Property_qualifierContext* SV3_1aParser::property_qualifier() {
  Property_qualifierContext *_localctx = _tracker.createInstance<Property_qualifierContext>(_ctx, getState());
  enterRule(_localctx, 140, SV3_1aParser::RuleProperty_qualifier);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2541);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SV3_1aParser::RAND: {
        _localctx = _tracker.createInstance<SV3_1aParser::PropQualifier_RandContext>(_localctx);
        enterOuterAlt(_localctx, 1);
        setState(2538);
        match(SV3_1aParser::RAND);
        break;
      }

      case SV3_1aParser::RANDC: {
        _localctx = _tracker.createInstance<SV3_1aParser::PropQualifier_RandcContext>(_localctx);
        enterOuterAlt(_localctx, 2);
        setState(2539);
        match(SV3_1aParser::RANDC);
        break;
      }

      case SV3_1aParser::STATIC:
      case SV3_1aParser::PROTECTED:
      case SV3_1aParser::LOCAL: {
        _localctx = _tracker.createInstance<SV3_1aParser::PropQualifier_ClassItemContext>(_localctx);
        enterOuterAlt(_localctx, 3);
        setState(2540);
        class_item_qualifier();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Method_qualifierContext ------------------------------------------------------------------

SV3_1aParser::Method_qualifierContext::Method_qualifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t SV3_1aParser::Method_qualifierContext::getRuleIndex() const {
  return SV3_1aParser::RuleMethod_qualifier;
}

void SV3_1aParser::Method_qualifierContext::copyFrom(Method_qualifierContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- MethodQualifier_VirtualContext ------------------------------------------------------------------

tree::TerminalNode* SV3_1aParser::MethodQualifier_VirtualContext::VIRTUAL() {
  return getToken(SV3_1aParser::VIRTUAL, 0);
}

SV3_1aParser::MethodQualifier_VirtualContext::MethodQualifier_VirtualContext(Method_qualifierContext *ctx) { copyFrom(ctx); }

void SV3_1aParser::MethodQualifier_VirtualContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterMethodQualifier_Virtual(this);
}
void SV3_1aParser::MethodQualifier_VirtualContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitMethodQualifier_Virtual(this);
}
//----------------- MethodQualifier_ClassItemContext ------------------------------------------------------------------

SV3_1aParser::Class_item_qualifierContext* SV3_1aParser::MethodQualifier_ClassItemContext::class_item_qualifier() {
  return getRuleContext<SV3_1aParser::Class_item_qualifierContext>(0);
}

SV3_1aParser::MethodQualifier_ClassItemContext::MethodQualifier_ClassItemContext(Method_qualifierContext *ctx) { copyFrom(ctx); }

void SV3_1aParser::MethodQualifier_ClassItemContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterMethodQualifier_ClassItem(this);
}
void SV3_1aParser::MethodQualifier_ClassItemContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitMethodQualifier_ClassItem(this);
}
SV3_1aParser::Method_qualifierContext* SV3_1aParser::method_qualifier() {
  Method_qualifierContext *_localctx = _tracker.createInstance<Method_qualifierContext>(_ctx, getState());
  enterRule(_localctx, 142, SV3_1aParser::RuleMethod_qualifier);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2545);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SV3_1aParser::VIRTUAL: {
        _localctx = _tracker.createInstance<SV3_1aParser::MethodQualifier_VirtualContext>(_localctx);
        enterOuterAlt(_localctx, 1);
        setState(2543);
        match(SV3_1aParser::VIRTUAL);
        break;
      }

      case SV3_1aParser::STATIC:
      case SV3_1aParser::PROTECTED:
      case SV3_1aParser::LOCAL: {
        _localctx = _tracker.createInstance<SV3_1aParser::MethodQualifier_ClassItemContext>(_localctx);
        enterOuterAlt(_localctx, 2);
        setState(2544);
        class_item_qualifier();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Method_prototypeContext ------------------------------------------------------------------

SV3_1aParser::Method_prototypeContext::Method_prototypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::Task_prototypeContext* SV3_1aParser::Method_prototypeContext::task_prototype() {
  return getRuleContext<SV3_1aParser::Task_prototypeContext>(0);
}

SV3_1aParser::Function_prototypeContext* SV3_1aParser::Method_prototypeContext::function_prototype() {
  return getRuleContext<SV3_1aParser::Function_prototypeContext>(0);
}


size_t SV3_1aParser::Method_prototypeContext::getRuleIndex() const {
  return SV3_1aParser::RuleMethod_prototype;
}

void SV3_1aParser::Method_prototypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterMethod_prototype(this);
}

void SV3_1aParser::Method_prototypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitMethod_prototype(this);
}

SV3_1aParser::Method_prototypeContext* SV3_1aParser::method_prototype() {
  Method_prototypeContext *_localctx = _tracker.createInstance<Method_prototypeContext>(_ctx, getState());
  enterRule(_localctx, 144, SV3_1aParser::RuleMethod_prototype);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2549);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SV3_1aParser::TASK: {
        enterOuterAlt(_localctx, 1);
        setState(2547);
        task_prototype();
        break;
      }

      case SV3_1aParser::FUNCTION: {
        enterOuterAlt(_localctx, 2);
        setState(2548);
        function_prototype();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Super_dot_newContext ------------------------------------------------------------------

SV3_1aParser::Super_dot_newContext::Super_dot_newContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Super_dot_newContext::SUPER() {
  return getToken(SV3_1aParser::SUPER, 0);
}

tree::TerminalNode* SV3_1aParser::Super_dot_newContext::DOT() {
  return getToken(SV3_1aParser::DOT, 0);
}

tree::TerminalNode* SV3_1aParser::Super_dot_newContext::NEW() {
  return getToken(SV3_1aParser::NEW, 0);
}


size_t SV3_1aParser::Super_dot_newContext::getRuleIndex() const {
  return SV3_1aParser::RuleSuper_dot_new;
}

void SV3_1aParser::Super_dot_newContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSuper_dot_new(this);
}

void SV3_1aParser::Super_dot_newContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSuper_dot_new(this);
}

SV3_1aParser::Super_dot_newContext* SV3_1aParser::super_dot_new() {
  Super_dot_newContext *_localctx = _tracker.createInstance<Super_dot_newContext>(_ctx, getState());
  enterRule(_localctx, 146, SV3_1aParser::RuleSuper_dot_new);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2551);
    match(SV3_1aParser::SUPER);
    setState(2552);
    match(SV3_1aParser::DOT);
    setState(2553);
    match(SV3_1aParser::NEW);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Class_constructor_declarationContext ------------------------------------------------------------------

SV3_1aParser::Class_constructor_declarationContext::Class_constructor_declarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Class_constructor_declarationContext::FUNCTION() {
  return getToken(SV3_1aParser::FUNCTION, 0);
}

std::vector<tree::TerminalNode *> SV3_1aParser::Class_constructor_declarationContext::NEW() {
  return getTokens(SV3_1aParser::NEW);
}

tree::TerminalNode* SV3_1aParser::Class_constructor_declarationContext::NEW(size_t i) {
  return getToken(SV3_1aParser::NEW, i);
}

std::vector<tree::TerminalNode *> SV3_1aParser::Class_constructor_declarationContext::SEMICOLON() {
  return getTokens(SV3_1aParser::SEMICOLON);
}

tree::TerminalNode* SV3_1aParser::Class_constructor_declarationContext::SEMICOLON(size_t i) {
  return getToken(SV3_1aParser::SEMICOLON, i);
}

tree::TerminalNode* SV3_1aParser::Class_constructor_declarationContext::ENDFUNCTION() {
  return getToken(SV3_1aParser::ENDFUNCTION, 0);
}

SV3_1aParser::Class_scopeContext* SV3_1aParser::Class_constructor_declarationContext::class_scope() {
  return getRuleContext<SV3_1aParser::Class_scopeContext>(0);
}

std::vector<tree::TerminalNode *> SV3_1aParser::Class_constructor_declarationContext::OPEN_PARENS() {
  return getTokens(SV3_1aParser::OPEN_PARENS);
}

tree::TerminalNode* SV3_1aParser::Class_constructor_declarationContext::OPEN_PARENS(size_t i) {
  return getToken(SV3_1aParser::OPEN_PARENS, i);
}

std::vector<tree::TerminalNode *> SV3_1aParser::Class_constructor_declarationContext::CLOSE_PARENS() {
  return getTokens(SV3_1aParser::CLOSE_PARENS);
}

tree::TerminalNode* SV3_1aParser::Class_constructor_declarationContext::CLOSE_PARENS(size_t i) {
  return getToken(SV3_1aParser::CLOSE_PARENS, i);
}

std::vector<SV3_1aParser::Block_item_declarationContext *> SV3_1aParser::Class_constructor_declarationContext::block_item_declaration() {
  return getRuleContexts<SV3_1aParser::Block_item_declarationContext>();
}

SV3_1aParser::Block_item_declarationContext* SV3_1aParser::Class_constructor_declarationContext::block_item_declaration(size_t i) {
  return getRuleContext<SV3_1aParser::Block_item_declarationContext>(i);
}

SV3_1aParser::Super_dot_newContext* SV3_1aParser::Class_constructor_declarationContext::super_dot_new() {
  return getRuleContext<SV3_1aParser::Super_dot_newContext>(0);
}

std::vector<SV3_1aParser::Function_statement_or_nullContext *> SV3_1aParser::Class_constructor_declarationContext::function_statement_or_null() {
  return getRuleContexts<SV3_1aParser::Function_statement_or_nullContext>();
}

SV3_1aParser::Function_statement_or_nullContext* SV3_1aParser::Class_constructor_declarationContext::function_statement_or_null(size_t i) {
  return getRuleContext<SV3_1aParser::Function_statement_or_nullContext>(i);
}

tree::TerminalNode* SV3_1aParser::Class_constructor_declarationContext::COLON() {
  return getToken(SV3_1aParser::COLON, 0);
}

SV3_1aParser::Tf_port_listContext* SV3_1aParser::Class_constructor_declarationContext::tf_port_list() {
  return getRuleContext<SV3_1aParser::Tf_port_listContext>(0);
}

SV3_1aParser::List_of_argumentsContext* SV3_1aParser::Class_constructor_declarationContext::list_of_arguments() {
  return getRuleContext<SV3_1aParser::List_of_argumentsContext>(0);
}


size_t SV3_1aParser::Class_constructor_declarationContext::getRuleIndex() const {
  return SV3_1aParser::RuleClass_constructor_declaration;
}

void SV3_1aParser::Class_constructor_declarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterClass_constructor_declaration(this);
}

void SV3_1aParser::Class_constructor_declarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitClass_constructor_declaration(this);
}

SV3_1aParser::Class_constructor_declarationContext* SV3_1aParser::class_constructor_declaration() {
  Class_constructor_declarationContext *_localctx = _tracker.createInstance<Class_constructor_declarationContext>(_ctx, getState());
  enterRule(_localctx, 148, SV3_1aParser::RuleClass_constructor_declaration);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(2555);
    match(SV3_1aParser::FUNCTION);
    setState(2557);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SV3_1aParser::DOLLAR_UNIT || ((((_la - 326) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 326)) & 4672924483589) != 0)) {
      setState(2556);
      class_scope();
    }
    setState(2559);
    match(SV3_1aParser::NEW);
    setState(2565);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SV3_1aParser::OPEN_PARENS) {
      setState(2560);
      match(SV3_1aParser::OPEN_PARENS);
      setState(2562);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == SV3_1aParser::VIRTUAL || ((((_la - 64) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 64)) & 1152775819316167741) != 0) || ((((_la - 147) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 147)) & 6597069766667) != 0) || ((((_la - 326) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 326)) & 4672924483589) != 0)) {
        setState(2561);
        tf_port_list();
      }
      setState(2564);
      match(SV3_1aParser::CLOSE_PARENS);
    }
    setState(2567);
    match(SV3_1aParser::SEMICOLON);
    setState(2571);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 189, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(2568);
        block_item_declaration(); 
      }
      setState(2573);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 189, _ctx);
    }
    setState(2583);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 191, _ctx)) {
    case 1: {
      setState(2574);
      super_dot_new();
      setState(2579);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == SV3_1aParser::OPEN_PARENS) {
        setState(2575);
        match(SV3_1aParser::OPEN_PARENS);
        setState(2576);
        list_of_arguments();
        setState(2577);
        match(SV3_1aParser::CLOSE_PARENS);
      }
      setState(2581);
      match(SV3_1aParser::SEMICOLON);
      break;
    }

    default:
      break;
    }
    setState(2588);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 2198011904) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 64)) & 17732923904262145) != 0) || ((((_la - 151) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 151)) & 5188249437639573505) != 0) || ((((_la - 223) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 223)) & 1136895023120385) != 0) || ((((_la - 289) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 289)) & 45036959082348431) != 0) || ((((_la - 364) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 364)) & 8796093022225) != 0)) {
      setState(2585);
      function_statement_or_null();
      setState(2590);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(2591);
    match(SV3_1aParser::ENDFUNCTION);
    setState(2594);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 193, _ctx)) {
    case 1: {
      setState(2592);
      match(SV3_1aParser::COLON);
      setState(2593);
      match(SV3_1aParser::NEW);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Constraint_declarationContext ------------------------------------------------------------------

SV3_1aParser::Constraint_declarationContext::Constraint_declarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Constraint_declarationContext::CONSTRAINT() {
  return getToken(SV3_1aParser::CONSTRAINT, 0);
}

SV3_1aParser::IdentifierContext* SV3_1aParser::Constraint_declarationContext::identifier() {
  return getRuleContext<SV3_1aParser::IdentifierContext>(0);
}

SV3_1aParser::Constraint_blockContext* SV3_1aParser::Constraint_declarationContext::constraint_block() {
  return getRuleContext<SV3_1aParser::Constraint_blockContext>(0);
}

tree::TerminalNode* SV3_1aParser::Constraint_declarationContext::STATIC() {
  return getToken(SV3_1aParser::STATIC, 0);
}


size_t SV3_1aParser::Constraint_declarationContext::getRuleIndex() const {
  return SV3_1aParser::RuleConstraint_declaration;
}

void SV3_1aParser::Constraint_declarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterConstraint_declaration(this);
}

void SV3_1aParser::Constraint_declarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitConstraint_declaration(this);
}

SV3_1aParser::Constraint_declarationContext* SV3_1aParser::constraint_declaration() {
  Constraint_declarationContext *_localctx = _tracker.createInstance<Constraint_declarationContext>(_ctx, getState());
  enterRule(_localctx, 150, SV3_1aParser::RuleConstraint_declaration);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2597);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SV3_1aParser::STATIC) {
      setState(2596);
      match(SV3_1aParser::STATIC);
    }
    setState(2599);
    match(SV3_1aParser::CONSTRAINT);
    setState(2600);
    identifier();
    setState(2601);
    constraint_block();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Constraint_blockContext ------------------------------------------------------------------

SV3_1aParser::Constraint_blockContext::Constraint_blockContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Constraint_blockContext::OPEN_CURLY() {
  return getToken(SV3_1aParser::OPEN_CURLY, 0);
}

tree::TerminalNode* SV3_1aParser::Constraint_blockContext::CLOSE_CURLY() {
  return getToken(SV3_1aParser::CLOSE_CURLY, 0);
}

std::vector<SV3_1aParser::Constraint_block_itemContext *> SV3_1aParser::Constraint_blockContext::constraint_block_item() {
  return getRuleContexts<SV3_1aParser::Constraint_block_itemContext>();
}

SV3_1aParser::Constraint_block_itemContext* SV3_1aParser::Constraint_blockContext::constraint_block_item(size_t i) {
  return getRuleContext<SV3_1aParser::Constraint_block_itemContext>(i);
}


size_t SV3_1aParser::Constraint_blockContext::getRuleIndex() const {
  return SV3_1aParser::RuleConstraint_block;
}

void SV3_1aParser::Constraint_blockContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterConstraint_block(this);
}

void SV3_1aParser::Constraint_blockContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitConstraint_block(this);
}

SV3_1aParser::Constraint_blockContext* SV3_1aParser::constraint_block() {
  Constraint_blockContext *_localctx = _tracker.createInstance<Constraint_blockContext>(_ctx, getState());
  enterRule(_localctx, 152, SV3_1aParser::RuleConstraint_block);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2603);
    match(SV3_1aParser::OPEN_CURLY);
    setState(2607);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 8796094922748) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 64)) & 1152648826069484545) != 0) || ((((_la - 147) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 147)) & 1128099433938947) != 0) || _la == SV3_1aParser::BANG

    || _la == SV3_1aParser::SOFT || ((((_la - 303) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 303)) & -2166230870946471807) != 0) || _la == SV3_1aParser::REDUCTION_XNOR2

    || _la == SV3_1aParser::Simple_identifier) {
      setState(2604);
      constraint_block_item();
      setState(2609);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(2610);
    match(SV3_1aParser::CLOSE_CURLY);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Constraint_block_itemContext ------------------------------------------------------------------

SV3_1aParser::Constraint_block_itemContext::Constraint_block_itemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Constraint_block_itemContext::SOLVE() {
  return getToken(SV3_1aParser::SOLVE, 0);
}

std::vector<SV3_1aParser::Solve_before_listContext *> SV3_1aParser::Constraint_block_itemContext::solve_before_list() {
  return getRuleContexts<SV3_1aParser::Solve_before_listContext>();
}

SV3_1aParser::Solve_before_listContext* SV3_1aParser::Constraint_block_itemContext::solve_before_list(size_t i) {
  return getRuleContext<SV3_1aParser::Solve_before_listContext>(i);
}

tree::TerminalNode* SV3_1aParser::Constraint_block_itemContext::BEFORE() {
  return getToken(SV3_1aParser::BEFORE, 0);
}

tree::TerminalNode* SV3_1aParser::Constraint_block_itemContext::SEMICOLON() {
  return getToken(SV3_1aParser::SEMICOLON, 0);
}

SV3_1aParser::Constraint_expressionContext* SV3_1aParser::Constraint_block_itemContext::constraint_expression() {
  return getRuleContext<SV3_1aParser::Constraint_expressionContext>(0);
}


size_t SV3_1aParser::Constraint_block_itemContext::getRuleIndex() const {
  return SV3_1aParser::RuleConstraint_block_item;
}

void SV3_1aParser::Constraint_block_itemContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterConstraint_block_item(this);
}

void SV3_1aParser::Constraint_block_itemContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitConstraint_block_item(this);
}

SV3_1aParser::Constraint_block_itemContext* SV3_1aParser::constraint_block_item() {
  Constraint_block_itemContext *_localctx = _tracker.createInstance<Constraint_block_itemContext>(_ctx, getState());
  enterRule(_localctx, 154, SV3_1aParser::RuleConstraint_block_item);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2619);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SV3_1aParser::SOLVE: {
        enterOuterAlt(_localctx, 1);
        setState(2612);
        match(SV3_1aParser::SOLVE);
        setState(2613);
        solve_before_list();
        setState(2614);
        match(SV3_1aParser::BEFORE);
        setState(2615);
        solve_before_list();
        setState(2616);
        match(SV3_1aParser::SEMICOLON);
        break;
      }

      case SV3_1aParser::TICK_b0:
      case SV3_1aParser::TICK_b1:
      case SV3_1aParser::TICK_B0:
      case SV3_1aParser::TICK_B1:
      case SV3_1aParser::TICK_0:
      case SV3_1aParser::TICK_1:
      case SV3_1aParser::ONE_TICK_b0:
      case SV3_1aParser::ONE_TICK_b1:
      case SV3_1aParser::ONE_TICK_bx:
      case SV3_1aParser::ONE_TICK_bX:
      case SV3_1aParser::ONE_TICK_B0:
      case SV3_1aParser::ONE_TICK_B1:
      case SV3_1aParser::ONE_TICK_Bx:
      case SV3_1aParser::ONE_TICK_BX:
      case SV3_1aParser::Integral_number:
      case SV3_1aParser::Real_number:
      case SV3_1aParser::String:
      case SV3_1aParser::OPEN_PARENS:
      case SV3_1aParser::TYPE:
      case SV3_1aParser::CONST:
      case SV3_1aParser::LOCAL:
      case SV3_1aParser::SUPER:
      case SV3_1aParser::OPEN_CURLY:
      case SV3_1aParser::IF:
      case SV3_1aParser::FOREACH:
      case SV3_1aParser::STRING:
      case SV3_1aParser::BYTE:
      case SV3_1aParser::SHORTINT:
      case SV3_1aParser::INT:
      case SV3_1aParser::LONGINT:
      case SV3_1aParser::INTEGER:
      case SV3_1aParser::TIME:
      case SV3_1aParser::BIT:
      case SV3_1aParser::LOGIC:
      case SV3_1aParser::REG:
      case SV3_1aParser::SHORTREAL:
      case SV3_1aParser::REAL:
      case SV3_1aParser::REALTIME:
      case SV3_1aParser::SIGNED:
      case SV3_1aParser::UNSIGNED:
      case SV3_1aParser::DOLLAR:
      case SV3_1aParser::PLUSPLUS:
      case SV3_1aParser::PLUS:
      case SV3_1aParser::MINUSMINUS:
      case SV3_1aParser::MINUS:
      case SV3_1aParser::DOLLAR_UNIT:
      case SV3_1aParser::DISABLE:
      case SV3_1aParser::BANG:
      case SV3_1aParser::SOFT:
      case SV3_1aParser::UNIQUE:
      case SV3_1aParser::TAGGED:
      case SV3_1aParser::TICK:
      case SV3_1aParser::NULL_KEYWORD:
      case SV3_1aParser::THIS:
      case SV3_1aParser::DOLLAR_ROOT:
      case SV3_1aParser::RANDOMIZE:
      case SV3_1aParser::SAMPLE:
      case SV3_1aParser::BITW_AND:
      case SV3_1aParser::BITW_OR:
      case SV3_1aParser::REDUCTION_NOR:
      case SV3_1aParser::REDUCTION_NAND:
      case SV3_1aParser::REDUCTION_XNOR1:
      case SV3_1aParser::Escaped_identifier:
      case SV3_1aParser::TILDA:
      case SV3_1aParser::BITW_XOR:
      case SV3_1aParser::REDUCTION_XNOR2:
      case SV3_1aParser::Simple_identifier: {
        enterOuterAlt(_localctx, 2);
        setState(2618);
        constraint_expression();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Solve_before_listContext ------------------------------------------------------------------

SV3_1aParser::Solve_before_listContext::Solve_before_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<SV3_1aParser::Constraint_primaryContext *> SV3_1aParser::Solve_before_listContext::constraint_primary() {
  return getRuleContexts<SV3_1aParser::Constraint_primaryContext>();
}

SV3_1aParser::Constraint_primaryContext* SV3_1aParser::Solve_before_listContext::constraint_primary(size_t i) {
  return getRuleContext<SV3_1aParser::Constraint_primaryContext>(i);
}

std::vector<tree::TerminalNode *> SV3_1aParser::Solve_before_listContext::COMMA() {
  return getTokens(SV3_1aParser::COMMA);
}

tree::TerminalNode* SV3_1aParser::Solve_before_listContext::COMMA(size_t i) {
  return getToken(SV3_1aParser::COMMA, i);
}


size_t SV3_1aParser::Solve_before_listContext::getRuleIndex() const {
  return SV3_1aParser::RuleSolve_before_list;
}

void SV3_1aParser::Solve_before_listContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSolve_before_list(this);
}

void SV3_1aParser::Solve_before_listContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSolve_before_list(this);
}

SV3_1aParser::Solve_before_listContext* SV3_1aParser::solve_before_list() {
  Solve_before_listContext *_localctx = _tracker.createInstance<Solve_before_listContext>(_ctx, getState());
  enterRule(_localctx, 156, SV3_1aParser::RuleSolve_before_list);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2621);
    constraint_primary();
    setState(2626);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == SV3_1aParser::COMMA) {
      setState(2622);
      match(SV3_1aParser::COMMA);
      setState(2623);
      constraint_primary();
      setState(2628);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Constraint_primaryContext ------------------------------------------------------------------

SV3_1aParser::Constraint_primaryContext::Constraint_primaryContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<SV3_1aParser::IdentifierContext *> SV3_1aParser::Constraint_primaryContext::identifier() {
  return getRuleContexts<SV3_1aParser::IdentifierContext>();
}

SV3_1aParser::IdentifierContext* SV3_1aParser::Constraint_primaryContext::identifier(size_t i) {
  return getRuleContext<SV3_1aParser::IdentifierContext>(i);
}

SV3_1aParser::SelectContext* SV3_1aParser::Constraint_primaryContext::select() {
  return getRuleContext<SV3_1aParser::SelectContext>(0);
}

SV3_1aParser::Implicit_class_handleContext* SV3_1aParser::Constraint_primaryContext::implicit_class_handle() {
  return getRuleContext<SV3_1aParser::Implicit_class_handleContext>(0);
}

std::vector<tree::TerminalNode *> SV3_1aParser::Constraint_primaryContext::DOT() {
  return getTokens(SV3_1aParser::DOT);
}

tree::TerminalNode* SV3_1aParser::Constraint_primaryContext::DOT(size_t i) {
  return getToken(SV3_1aParser::DOT, i);
}

SV3_1aParser::Class_scopeContext* SV3_1aParser::Constraint_primaryContext::class_scope() {
  return getRuleContext<SV3_1aParser::Class_scopeContext>(0);
}

SV3_1aParser::Dollar_root_keywordContext* SV3_1aParser::Constraint_primaryContext::dollar_root_keyword() {
  return getRuleContext<SV3_1aParser::Dollar_root_keywordContext>(0);
}

std::vector<tree::TerminalNode *> SV3_1aParser::Constraint_primaryContext::OPEN_BRACKET() {
  return getTokens(SV3_1aParser::OPEN_BRACKET);
}

tree::TerminalNode* SV3_1aParser::Constraint_primaryContext::OPEN_BRACKET(size_t i) {
  return getToken(SV3_1aParser::OPEN_BRACKET, i);
}

std::vector<SV3_1aParser::Constant_expressionContext *> SV3_1aParser::Constraint_primaryContext::constant_expression() {
  return getRuleContexts<SV3_1aParser::Constant_expressionContext>();
}

SV3_1aParser::Constant_expressionContext* SV3_1aParser::Constraint_primaryContext::constant_expression(size_t i) {
  return getRuleContext<SV3_1aParser::Constant_expressionContext>(i);
}

std::vector<tree::TerminalNode *> SV3_1aParser::Constraint_primaryContext::CLOSE_BRACKET() {
  return getTokens(SV3_1aParser::CLOSE_BRACKET);
}

tree::TerminalNode* SV3_1aParser::Constraint_primaryContext::CLOSE_BRACKET(size_t i) {
  return getToken(SV3_1aParser::CLOSE_BRACKET, i);
}


size_t SV3_1aParser::Constraint_primaryContext::getRuleIndex() const {
  return SV3_1aParser::RuleConstraint_primary;
}

void SV3_1aParser::Constraint_primaryContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterConstraint_primary(this);
}

void SV3_1aParser::Constraint_primaryContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitConstraint_primary(this);
}

SV3_1aParser::Constraint_primaryContext* SV3_1aParser::constraint_primary() {
  Constraint_primaryContext *_localctx = _tracker.createInstance<Constraint_primaryContext>(_ctx, getState());
  enterRule(_localctx, 158, SV3_1aParser::RuleConstraint_primary);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(2633);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 198, _ctx)) {
    case 1: {
      setState(2629);
      implicit_class_handle();
      setState(2630);
      match(SV3_1aParser::DOT);
      break;
    }

    case 2: {
      setState(2632);
      class_scope();
      break;
    }

    default:
      break;
    }
    setState(2636);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SV3_1aParser::DOLLAR_ROOT) {
      setState(2635);
      dollar_root_keyword();
    }
    setState(2638);
    identifier();
    setState(2652);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 201, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(2645);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == SV3_1aParser::OPEN_BRACKET) {
          setState(2639);
          match(SV3_1aParser::OPEN_BRACKET);
          setState(2640);
          constant_expression(0);
          setState(2641);
          match(SV3_1aParser::CLOSE_BRACKET);
          setState(2647);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(2648);
        match(SV3_1aParser::DOT);
        setState(2649);
        identifier(); 
      }
      setState(2654);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 201, _ctx);
    }
    setState(2655);
    select();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Constraint_expressionContext ------------------------------------------------------------------

SV3_1aParser::Constraint_expressionContext::Constraint_expressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::Expression_or_distContext* SV3_1aParser::Constraint_expressionContext::expression_or_dist() {
  return getRuleContext<SV3_1aParser::Expression_or_distContext>(0);
}

tree::TerminalNode* SV3_1aParser::Constraint_expressionContext::SEMICOLON() {
  return getToken(SV3_1aParser::SEMICOLON, 0);
}

tree::TerminalNode* SV3_1aParser::Constraint_expressionContext::SOFT() {
  return getToken(SV3_1aParser::SOFT, 0);
}

SV3_1aParser::Uniqueness_constraintContext* SV3_1aParser::Constraint_expressionContext::uniqueness_constraint() {
  return getRuleContext<SV3_1aParser::Uniqueness_constraintContext>(0);
}

SV3_1aParser::ExpressionContext* SV3_1aParser::Constraint_expressionContext::expression() {
  return getRuleContext<SV3_1aParser::ExpressionContext>(0);
}

tree::TerminalNode* SV3_1aParser::Constraint_expressionContext::IMPLY() {
  return getToken(SV3_1aParser::IMPLY, 0);
}

std::vector<SV3_1aParser::Constraint_setContext *> SV3_1aParser::Constraint_expressionContext::constraint_set() {
  return getRuleContexts<SV3_1aParser::Constraint_setContext>();
}

SV3_1aParser::Constraint_setContext* SV3_1aParser::Constraint_expressionContext::constraint_set(size_t i) {
  return getRuleContext<SV3_1aParser::Constraint_setContext>(i);
}

tree::TerminalNode* SV3_1aParser::Constraint_expressionContext::IF() {
  return getToken(SV3_1aParser::IF, 0);
}

tree::TerminalNode* SV3_1aParser::Constraint_expressionContext::OPEN_PARENS() {
  return getToken(SV3_1aParser::OPEN_PARENS, 0);
}

tree::TerminalNode* SV3_1aParser::Constraint_expressionContext::CLOSE_PARENS() {
  return getToken(SV3_1aParser::CLOSE_PARENS, 0);
}

tree::TerminalNode* SV3_1aParser::Constraint_expressionContext::ELSE() {
  return getToken(SV3_1aParser::ELSE, 0);
}

tree::TerminalNode* SV3_1aParser::Constraint_expressionContext::FOREACH() {
  return getToken(SV3_1aParser::FOREACH, 0);
}

SV3_1aParser::Ps_or_hierarchical_array_identifierContext* SV3_1aParser::Constraint_expressionContext::ps_or_hierarchical_array_identifier() {
  return getRuleContext<SV3_1aParser::Ps_or_hierarchical_array_identifierContext>(0);
}

tree::TerminalNode* SV3_1aParser::Constraint_expressionContext::OPEN_BRACKET() {
  return getToken(SV3_1aParser::OPEN_BRACKET, 0);
}

SV3_1aParser::Loop_variablesContext* SV3_1aParser::Constraint_expressionContext::loop_variables() {
  return getRuleContext<SV3_1aParser::Loop_variablesContext>(0);
}

tree::TerminalNode* SV3_1aParser::Constraint_expressionContext::CLOSE_BRACKET() {
  return getToken(SV3_1aParser::CLOSE_BRACKET, 0);
}

tree::TerminalNode* SV3_1aParser::Constraint_expressionContext::DISABLE() {
  return getToken(SV3_1aParser::DISABLE, 0);
}

SV3_1aParser::Constraint_primaryContext* SV3_1aParser::Constraint_expressionContext::constraint_primary() {
  return getRuleContext<SV3_1aParser::Constraint_primaryContext>(0);
}


size_t SV3_1aParser::Constraint_expressionContext::getRuleIndex() const {
  return SV3_1aParser::RuleConstraint_expression;
}

void SV3_1aParser::Constraint_expressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterConstraint_expression(this);
}

void SV3_1aParser::Constraint_expressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitConstraint_expression(this);
}

SV3_1aParser::Constraint_expressionContext* SV3_1aParser::constraint_expression() {
  Constraint_expressionContext *_localctx = _tracker.createInstance<Constraint_expressionContext>(_ctx, getState());
  enterRule(_localctx, 160, SV3_1aParser::RuleConstraint_expression);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2693);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 204, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2658);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == SV3_1aParser::SOFT) {
        setState(2657);
        match(SV3_1aParser::SOFT);
      }
      setState(2660);
      expression_or_dist();
      setState(2661);
      match(SV3_1aParser::SEMICOLON);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2663);
      uniqueness_constraint();
      setState(2664);
      match(SV3_1aParser::SEMICOLON);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(2666);
      expression(0);
      setState(2667);
      match(SV3_1aParser::IMPLY);
      setState(2668);
      constraint_set();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(2670);
      match(SV3_1aParser::IF);
      setState(2671);
      match(SV3_1aParser::OPEN_PARENS);
      setState(2672);
      expression(0);
      setState(2673);
      match(SV3_1aParser::CLOSE_PARENS);
      setState(2674);
      constraint_set();
      setState(2677);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 203, _ctx)) {
      case 1: {
        setState(2675);
        match(SV3_1aParser::ELSE);
        setState(2676);
        constraint_set();
        break;
      }

      default:
        break;
      }
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(2679);
      match(SV3_1aParser::FOREACH);
      setState(2680);
      match(SV3_1aParser::OPEN_PARENS);
      setState(2681);
      ps_or_hierarchical_array_identifier();
      setState(2682);
      match(SV3_1aParser::OPEN_BRACKET);
      setState(2683);
      loop_variables();
      setState(2684);
      match(SV3_1aParser::CLOSE_BRACKET);
      setState(2685);
      match(SV3_1aParser::CLOSE_PARENS);
      setState(2686);
      constraint_set();
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(2688);
      match(SV3_1aParser::DISABLE);
      setState(2689);
      match(SV3_1aParser::SOFT);
      setState(2690);
      constraint_primary();
      setState(2691);
      match(SV3_1aParser::SEMICOLON);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Uniqueness_constraintContext ------------------------------------------------------------------

SV3_1aParser::Uniqueness_constraintContext::Uniqueness_constraintContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Uniqueness_constraintContext::UNIQUE() {
  return getToken(SV3_1aParser::UNIQUE, 0);
}

tree::TerminalNode* SV3_1aParser::Uniqueness_constraintContext::OPEN_CURLY() {
  return getToken(SV3_1aParser::OPEN_CURLY, 0);
}

SV3_1aParser::Open_range_listContext* SV3_1aParser::Uniqueness_constraintContext::open_range_list() {
  return getRuleContext<SV3_1aParser::Open_range_listContext>(0);
}

tree::TerminalNode* SV3_1aParser::Uniqueness_constraintContext::CLOSE_CURLY() {
  return getToken(SV3_1aParser::CLOSE_CURLY, 0);
}


size_t SV3_1aParser::Uniqueness_constraintContext::getRuleIndex() const {
  return SV3_1aParser::RuleUniqueness_constraint;
}

void SV3_1aParser::Uniqueness_constraintContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUniqueness_constraint(this);
}

void SV3_1aParser::Uniqueness_constraintContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUniqueness_constraint(this);
}

SV3_1aParser::Uniqueness_constraintContext* SV3_1aParser::uniqueness_constraint() {
  Uniqueness_constraintContext *_localctx = _tracker.createInstance<Uniqueness_constraintContext>(_ctx, getState());
  enterRule(_localctx, 162, SV3_1aParser::RuleUniqueness_constraint);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2695);
    match(SV3_1aParser::UNIQUE);
    setState(2696);
    match(SV3_1aParser::OPEN_CURLY);
    setState(2697);
    open_range_list();
    setState(2698);
    match(SV3_1aParser::CLOSE_CURLY);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Constraint_setContext ------------------------------------------------------------------

SV3_1aParser::Constraint_setContext::Constraint_setContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<SV3_1aParser::Constraint_expressionContext *> SV3_1aParser::Constraint_setContext::constraint_expression() {
  return getRuleContexts<SV3_1aParser::Constraint_expressionContext>();
}

SV3_1aParser::Constraint_expressionContext* SV3_1aParser::Constraint_setContext::constraint_expression(size_t i) {
  return getRuleContext<SV3_1aParser::Constraint_expressionContext>(i);
}

tree::TerminalNode* SV3_1aParser::Constraint_setContext::OPEN_CURLY() {
  return getToken(SV3_1aParser::OPEN_CURLY, 0);
}

tree::TerminalNode* SV3_1aParser::Constraint_setContext::CLOSE_CURLY() {
  return getToken(SV3_1aParser::CLOSE_CURLY, 0);
}


size_t SV3_1aParser::Constraint_setContext::getRuleIndex() const {
  return SV3_1aParser::RuleConstraint_set;
}

void SV3_1aParser::Constraint_setContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterConstraint_set(this);
}

void SV3_1aParser::Constraint_setContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitConstraint_set(this);
}

SV3_1aParser::Constraint_setContext* SV3_1aParser::constraint_set() {
  Constraint_setContext *_localctx = _tracker.createInstance<Constraint_setContext>(_ctx, getState());
  enterRule(_localctx, 164, SV3_1aParser::RuleConstraint_set);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2709);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 206, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2700);
      constraint_expression();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2701);
      match(SV3_1aParser::OPEN_CURLY);
      setState(2705);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while ((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & 8796094922748) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 64)) & 1152648826061095937) != 0) || ((((_la - 147) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 147)) & 1128099433938947) != 0) || _la == SV3_1aParser::BANG

      || _la == SV3_1aParser::SOFT || ((((_la - 303) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 303)) & -2166230870946471807) != 0) || _la == SV3_1aParser::REDUCTION_XNOR2

      || _la == SV3_1aParser::Simple_identifier) {
        setState(2702);
        constraint_expression();
        setState(2707);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(2708);
      match(SV3_1aParser::CLOSE_CURLY);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Dist_listContext ------------------------------------------------------------------

SV3_1aParser::Dist_listContext::Dist_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<SV3_1aParser::Dist_itemContext *> SV3_1aParser::Dist_listContext::dist_item() {
  return getRuleContexts<SV3_1aParser::Dist_itemContext>();
}

SV3_1aParser::Dist_itemContext* SV3_1aParser::Dist_listContext::dist_item(size_t i) {
  return getRuleContext<SV3_1aParser::Dist_itemContext>(i);
}

std::vector<tree::TerminalNode *> SV3_1aParser::Dist_listContext::COMMA() {
  return getTokens(SV3_1aParser::COMMA);
}

tree::TerminalNode* SV3_1aParser::Dist_listContext::COMMA(size_t i) {
  return getToken(SV3_1aParser::COMMA, i);
}


size_t SV3_1aParser::Dist_listContext::getRuleIndex() const {
  return SV3_1aParser::RuleDist_list;
}

void SV3_1aParser::Dist_listContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDist_list(this);
}

void SV3_1aParser::Dist_listContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDist_list(this);
}

SV3_1aParser::Dist_listContext* SV3_1aParser::dist_list() {
  Dist_listContext *_localctx = _tracker.createInstance<Dist_listContext>(_ctx, getState());
  enterRule(_localctx, 166, SV3_1aParser::RuleDist_list);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2711);
    dist_item();
    setState(2716);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == SV3_1aParser::COMMA) {
      setState(2712);
      match(SV3_1aParser::COMMA);
      setState(2713);
      dist_item();
      setState(2718);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Dist_itemContext ------------------------------------------------------------------

SV3_1aParser::Dist_itemContext::Dist_itemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::Value_rangeContext* SV3_1aParser::Dist_itemContext::value_range() {
  return getRuleContext<SV3_1aParser::Value_rangeContext>(0);
}

SV3_1aParser::Dist_weightContext* SV3_1aParser::Dist_itemContext::dist_weight() {
  return getRuleContext<SV3_1aParser::Dist_weightContext>(0);
}


size_t SV3_1aParser::Dist_itemContext::getRuleIndex() const {
  return SV3_1aParser::RuleDist_item;
}

void SV3_1aParser::Dist_itemContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDist_item(this);
}

void SV3_1aParser::Dist_itemContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDist_item(this);
}

SV3_1aParser::Dist_itemContext* SV3_1aParser::dist_item() {
  Dist_itemContext *_localctx = _tracker.createInstance<Dist_itemContext>(_ctx, getState());
  enterRule(_localctx, 168, SV3_1aParser::RuleDist_item);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2719);
    value_range();
    setState(2721);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SV3_1aParser::COLON

    || _la == SV3_1aParser::ASSIGN_VALUE) {
      setState(2720);
      dist_weight();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Dist_weightContext ------------------------------------------------------------------

SV3_1aParser::Dist_weightContext::Dist_weightContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t SV3_1aParser::Dist_weightContext::getRuleIndex() const {
  return SV3_1aParser::RuleDist_weight;
}

void SV3_1aParser::Dist_weightContext::copyFrom(Dist_weightContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- DistWeight_AssignValueContext ------------------------------------------------------------------

tree::TerminalNode* SV3_1aParser::DistWeight_AssignValueContext::ASSIGN_VALUE() {
  return getToken(SV3_1aParser::ASSIGN_VALUE, 0);
}

SV3_1aParser::ExpressionContext* SV3_1aParser::DistWeight_AssignValueContext::expression() {
  return getRuleContext<SV3_1aParser::ExpressionContext>(0);
}

SV3_1aParser::DistWeight_AssignValueContext::DistWeight_AssignValueContext(Dist_weightContext *ctx) { copyFrom(ctx); }

void SV3_1aParser::DistWeight_AssignValueContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDistWeight_AssignValue(this);
}
void SV3_1aParser::DistWeight_AssignValueContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDistWeight_AssignValue(this);
}
//----------------- DistWeight_AssignRangeContext ------------------------------------------------------------------

tree::TerminalNode* SV3_1aParser::DistWeight_AssignRangeContext::COLON() {
  return getToken(SV3_1aParser::COLON, 0);
}

tree::TerminalNode* SV3_1aParser::DistWeight_AssignRangeContext::DIV() {
  return getToken(SV3_1aParser::DIV, 0);
}

SV3_1aParser::ExpressionContext* SV3_1aParser::DistWeight_AssignRangeContext::expression() {
  return getRuleContext<SV3_1aParser::ExpressionContext>(0);
}

SV3_1aParser::DistWeight_AssignRangeContext::DistWeight_AssignRangeContext(Dist_weightContext *ctx) { copyFrom(ctx); }

void SV3_1aParser::DistWeight_AssignRangeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDistWeight_AssignRange(this);
}
void SV3_1aParser::DistWeight_AssignRangeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDistWeight_AssignRange(this);
}
SV3_1aParser::Dist_weightContext* SV3_1aParser::dist_weight() {
  Dist_weightContext *_localctx = _tracker.createInstance<Dist_weightContext>(_ctx, getState());
  enterRule(_localctx, 170, SV3_1aParser::RuleDist_weight);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2728);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SV3_1aParser::ASSIGN_VALUE: {
        _localctx = _tracker.createInstance<SV3_1aParser::DistWeight_AssignValueContext>(_localctx);
        enterOuterAlt(_localctx, 1);
        setState(2723);
        match(SV3_1aParser::ASSIGN_VALUE);
        setState(2724);
        expression(0);
        break;
      }

      case SV3_1aParser::COLON: {
        _localctx = _tracker.createInstance<SV3_1aParser::DistWeight_AssignRangeContext>(_localctx);
        enterOuterAlt(_localctx, 2);
        setState(2725);
        match(SV3_1aParser::COLON);
        setState(2726);
        match(SV3_1aParser::DIV);
        setState(2727);
        expression(0);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Constraint_prototypeContext ------------------------------------------------------------------

SV3_1aParser::Constraint_prototypeContext::Constraint_prototypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Constraint_prototypeContext::CONSTRAINT() {
  return getToken(SV3_1aParser::CONSTRAINT, 0);
}

SV3_1aParser::IdentifierContext* SV3_1aParser::Constraint_prototypeContext::identifier() {
  return getRuleContext<SV3_1aParser::IdentifierContext>(0);
}

tree::TerminalNode* SV3_1aParser::Constraint_prototypeContext::SEMICOLON() {
  return getToken(SV3_1aParser::SEMICOLON, 0);
}

SV3_1aParser::Extern_qualifierContext* SV3_1aParser::Constraint_prototypeContext::extern_qualifier() {
  return getRuleContext<SV3_1aParser::Extern_qualifierContext>(0);
}

SV3_1aParser::Pure_keywordContext* SV3_1aParser::Constraint_prototypeContext::pure_keyword() {
  return getRuleContext<SV3_1aParser::Pure_keywordContext>(0);
}

tree::TerminalNode* SV3_1aParser::Constraint_prototypeContext::STATIC() {
  return getToken(SV3_1aParser::STATIC, 0);
}


size_t SV3_1aParser::Constraint_prototypeContext::getRuleIndex() const {
  return SV3_1aParser::RuleConstraint_prototype;
}

void SV3_1aParser::Constraint_prototypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterConstraint_prototype(this);
}

void SV3_1aParser::Constraint_prototypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitConstraint_prototype(this);
}

SV3_1aParser::Constraint_prototypeContext* SV3_1aParser::constraint_prototype() {
  Constraint_prototypeContext *_localctx = _tracker.createInstance<Constraint_prototypeContext>(_ctx, getState());
  enterRule(_localctx, 172, SV3_1aParser::RuleConstraint_prototype);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2732);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SV3_1aParser::EXTERN: {
        setState(2730);
        extern_qualifier();
        break;
      }

      case SV3_1aParser::PURE: {
        setState(2731);
        pure_keyword();
        break;
      }

      case SV3_1aParser::STATIC:
      case SV3_1aParser::CONSTRAINT: {
        break;
      }

    default:
      break;
    }
    setState(2735);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SV3_1aParser::STATIC) {
      setState(2734);
      match(SV3_1aParser::STATIC);
    }
    setState(2737);
    match(SV3_1aParser::CONSTRAINT);
    setState(2738);
    identifier();
    setState(2739);
    match(SV3_1aParser::SEMICOLON);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Extern_constraint_declarationContext ------------------------------------------------------------------

SV3_1aParser::Extern_constraint_declarationContext::Extern_constraint_declarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Extern_constraint_declarationContext::CONSTRAINT() {
  return getToken(SV3_1aParser::CONSTRAINT, 0);
}

SV3_1aParser::Class_scopeContext* SV3_1aParser::Extern_constraint_declarationContext::class_scope() {
  return getRuleContext<SV3_1aParser::Class_scopeContext>(0);
}

SV3_1aParser::IdentifierContext* SV3_1aParser::Extern_constraint_declarationContext::identifier() {
  return getRuleContext<SV3_1aParser::IdentifierContext>(0);
}

SV3_1aParser::Constraint_blockContext* SV3_1aParser::Extern_constraint_declarationContext::constraint_block() {
  return getRuleContext<SV3_1aParser::Constraint_blockContext>(0);
}

tree::TerminalNode* SV3_1aParser::Extern_constraint_declarationContext::STATIC() {
  return getToken(SV3_1aParser::STATIC, 0);
}


size_t SV3_1aParser::Extern_constraint_declarationContext::getRuleIndex() const {
  return SV3_1aParser::RuleExtern_constraint_declaration;
}

void SV3_1aParser::Extern_constraint_declarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExtern_constraint_declaration(this);
}

void SV3_1aParser::Extern_constraint_declarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExtern_constraint_declaration(this);
}

SV3_1aParser::Extern_constraint_declarationContext* SV3_1aParser::extern_constraint_declaration() {
  Extern_constraint_declarationContext *_localctx = _tracker.createInstance<Extern_constraint_declarationContext>(_ctx, getState());
  enterRule(_localctx, 174, SV3_1aParser::RuleExtern_constraint_declaration);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2742);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SV3_1aParser::STATIC) {
      setState(2741);
      match(SV3_1aParser::STATIC);
    }
    setState(2744);
    match(SV3_1aParser::CONSTRAINT);
    setState(2745);
    class_scope();
    setState(2746);
    identifier();
    setState(2747);
    constraint_block();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Identifier_listContext ------------------------------------------------------------------

SV3_1aParser::Identifier_listContext::Identifier_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<SV3_1aParser::IdentifierContext *> SV3_1aParser::Identifier_listContext::identifier() {
  return getRuleContexts<SV3_1aParser::IdentifierContext>();
}

SV3_1aParser::IdentifierContext* SV3_1aParser::Identifier_listContext::identifier(size_t i) {
  return getRuleContext<SV3_1aParser::IdentifierContext>(i);
}

std::vector<tree::TerminalNode *> SV3_1aParser::Identifier_listContext::COMMA() {
  return getTokens(SV3_1aParser::COMMA);
}

tree::TerminalNode* SV3_1aParser::Identifier_listContext::COMMA(size_t i) {
  return getToken(SV3_1aParser::COMMA, i);
}


size_t SV3_1aParser::Identifier_listContext::getRuleIndex() const {
  return SV3_1aParser::RuleIdentifier_list;
}

void SV3_1aParser::Identifier_listContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIdentifier_list(this);
}

void SV3_1aParser::Identifier_listContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIdentifier_list(this);
}

SV3_1aParser::Identifier_listContext* SV3_1aParser::identifier_list() {
  Identifier_listContext *_localctx = _tracker.createInstance<Identifier_listContext>(_ctx, getState());
  enterRule(_localctx, 176, SV3_1aParser::RuleIdentifier_list);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(2749);
    identifier();
    setState(2754);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 213, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(2750);
        match(SV3_1aParser::COMMA);
        setState(2751);
        identifier(); 
      }
      setState(2756);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 213, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Package_itemContext ------------------------------------------------------------------

SV3_1aParser::Package_itemContext::Package_itemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::Package_or_generate_item_declarationContext* SV3_1aParser::Package_itemContext::package_or_generate_item_declaration() {
  return getRuleContext<SV3_1aParser::Package_or_generate_item_declarationContext>(0);
}

SV3_1aParser::Specparam_declarationContext* SV3_1aParser::Package_itemContext::specparam_declaration() {
  return getRuleContext<SV3_1aParser::Specparam_declarationContext>(0);
}

SV3_1aParser::Anonymous_programContext* SV3_1aParser::Package_itemContext::anonymous_program() {
  return getRuleContext<SV3_1aParser::Anonymous_programContext>(0);
}

SV3_1aParser::Package_export_declarationContext* SV3_1aParser::Package_itemContext::package_export_declaration() {
  return getRuleContext<SV3_1aParser::Package_export_declarationContext>(0);
}

SV3_1aParser::Timeunits_declarationContext* SV3_1aParser::Package_itemContext::timeunits_declaration() {
  return getRuleContext<SV3_1aParser::Timeunits_declarationContext>(0);
}


size_t SV3_1aParser::Package_itemContext::getRuleIndex() const {
  return SV3_1aParser::RulePackage_item;
}

void SV3_1aParser::Package_itemContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPackage_item(this);
}

void SV3_1aParser::Package_itemContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPackage_item(this);
}

SV3_1aParser::Package_itemContext* SV3_1aParser::package_item() {
  Package_itemContext *_localctx = _tracker.createInstance<Package_itemContext>(_ctx, getState());
  enterRule(_localctx, 178, SV3_1aParser::RulePackage_item);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2762);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 214, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2757);
      package_or_generate_item_declaration();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2758);
      specparam_declaration();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(2759);
      anonymous_program();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(2760);
      package_export_declaration();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(2761);
      timeunits_declaration();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Package_or_generate_item_declarationContext ------------------------------------------------------------------

SV3_1aParser::Package_or_generate_item_declarationContext::Package_or_generate_item_declarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::Net_declarationContext* SV3_1aParser::Package_or_generate_item_declarationContext::net_declaration() {
  return getRuleContext<SV3_1aParser::Net_declarationContext>(0);
}

SV3_1aParser::Data_declarationContext* SV3_1aParser::Package_or_generate_item_declarationContext::data_declaration() {
  return getRuleContext<SV3_1aParser::Data_declarationContext>(0);
}

SV3_1aParser::Task_declarationContext* SV3_1aParser::Package_or_generate_item_declarationContext::task_declaration() {
  return getRuleContext<SV3_1aParser::Task_declarationContext>(0);
}

SV3_1aParser::Function_declarationContext* SV3_1aParser::Package_or_generate_item_declarationContext::function_declaration() {
  return getRuleContext<SV3_1aParser::Function_declarationContext>(0);
}

SV3_1aParser::Checker_declarationContext* SV3_1aParser::Package_or_generate_item_declarationContext::checker_declaration() {
  return getRuleContext<SV3_1aParser::Checker_declarationContext>(0);
}

SV3_1aParser::Dpi_import_exportContext* SV3_1aParser::Package_or_generate_item_declarationContext::dpi_import_export() {
  return getRuleContext<SV3_1aParser::Dpi_import_exportContext>(0);
}

SV3_1aParser::Extern_constraint_declarationContext* SV3_1aParser::Package_or_generate_item_declarationContext::extern_constraint_declaration() {
  return getRuleContext<SV3_1aParser::Extern_constraint_declarationContext>(0);
}

SV3_1aParser::Class_declarationContext* SV3_1aParser::Package_or_generate_item_declarationContext::class_declaration() {
  return getRuleContext<SV3_1aParser::Class_declarationContext>(0);
}

SV3_1aParser::Interface_class_declarationContext* SV3_1aParser::Package_or_generate_item_declarationContext::interface_class_declaration() {
  return getRuleContext<SV3_1aParser::Interface_class_declarationContext>(0);
}

SV3_1aParser::Class_constructor_declarationContext* SV3_1aParser::Package_or_generate_item_declarationContext::class_constructor_declaration() {
  return getRuleContext<SV3_1aParser::Class_constructor_declarationContext>(0);
}

SV3_1aParser::Parameter_declarationContext* SV3_1aParser::Package_or_generate_item_declarationContext::parameter_declaration() {
  return getRuleContext<SV3_1aParser::Parameter_declarationContext>(0);
}

tree::TerminalNode* SV3_1aParser::Package_or_generate_item_declarationContext::SEMICOLON() {
  return getToken(SV3_1aParser::SEMICOLON, 0);
}

SV3_1aParser::Local_parameter_declarationContext* SV3_1aParser::Package_or_generate_item_declarationContext::local_parameter_declaration() {
  return getRuleContext<SV3_1aParser::Local_parameter_declarationContext>(0);
}

SV3_1aParser::Covergroup_declarationContext* SV3_1aParser::Package_or_generate_item_declarationContext::covergroup_declaration() {
  return getRuleContext<SV3_1aParser::Covergroup_declarationContext>(0);
}

SV3_1aParser::Overload_declarationContext* SV3_1aParser::Package_or_generate_item_declarationContext::overload_declaration() {
  return getRuleContext<SV3_1aParser::Overload_declarationContext>(0);
}

SV3_1aParser::Assertion_item_declarationContext* SV3_1aParser::Package_or_generate_item_declarationContext::assertion_item_declaration() {
  return getRuleContext<SV3_1aParser::Assertion_item_declarationContext>(0);
}


size_t SV3_1aParser::Package_or_generate_item_declarationContext::getRuleIndex() const {
  return SV3_1aParser::RulePackage_or_generate_item_declaration;
}

void SV3_1aParser::Package_or_generate_item_declarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPackage_or_generate_item_declaration(this);
}

void SV3_1aParser::Package_or_generate_item_declarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPackage_or_generate_item_declaration(this);
}

SV3_1aParser::Package_or_generate_item_declarationContext* SV3_1aParser::package_or_generate_item_declaration() {
  Package_or_generate_item_declarationContext *_localctx = _tracker.createInstance<Package_or_generate_item_declarationContext>(_ctx, getState());
  enterRule(_localctx, 180, SV3_1aParser::RulePackage_or_generate_item_declaration);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2784);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 215, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2764);
      net_declaration();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2765);
      data_declaration();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(2766);
      task_declaration();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(2767);
      function_declaration();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(2768);
      checker_declaration();
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(2769);
      dpi_import_export();
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(2770);
      extern_constraint_declaration();
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(2771);
      class_declaration();
      break;
    }

    case 9: {
      enterOuterAlt(_localctx, 9);
      setState(2772);
      interface_class_declaration();
      break;
    }

    case 10: {
      enterOuterAlt(_localctx, 10);
      setState(2773);
      class_constructor_declaration();
      break;
    }

    case 11: {
      enterOuterAlt(_localctx, 11);
      setState(2774);
      parameter_declaration();
      setState(2775);
      match(SV3_1aParser::SEMICOLON);
      break;
    }

    case 12: {
      enterOuterAlt(_localctx, 12);
      setState(2777);
      local_parameter_declaration();
      setState(2778);
      match(SV3_1aParser::SEMICOLON);
      break;
    }

    case 13: {
      enterOuterAlt(_localctx, 13);
      setState(2780);
      covergroup_declaration();
      break;
    }

    case 14: {
      enterOuterAlt(_localctx, 14);
      setState(2781);
      overload_declaration();
      break;
    }

    case 15: {
      enterOuterAlt(_localctx, 15);
      setState(2782);
      assertion_item_declaration();
      break;
    }

    case 16: {
      enterOuterAlt(_localctx, 16);
      setState(2783);
      match(SV3_1aParser::SEMICOLON);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Anonymous_programContext ------------------------------------------------------------------

SV3_1aParser::Anonymous_programContext::Anonymous_programContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Anonymous_programContext::PROGRAM() {
  return getToken(SV3_1aParser::PROGRAM, 0);
}

tree::TerminalNode* SV3_1aParser::Anonymous_programContext::SEMICOLON() {
  return getToken(SV3_1aParser::SEMICOLON, 0);
}

tree::TerminalNode* SV3_1aParser::Anonymous_programContext::ENDPROGRAM() {
  return getToken(SV3_1aParser::ENDPROGRAM, 0);
}

std::vector<SV3_1aParser::Anonymous_program_itemContext *> SV3_1aParser::Anonymous_programContext::anonymous_program_item() {
  return getRuleContexts<SV3_1aParser::Anonymous_program_itemContext>();
}

SV3_1aParser::Anonymous_program_itemContext* SV3_1aParser::Anonymous_programContext::anonymous_program_item(size_t i) {
  return getRuleContext<SV3_1aParser::Anonymous_program_itemContext>(i);
}


size_t SV3_1aParser::Anonymous_programContext::getRuleIndex() const {
  return SV3_1aParser::RuleAnonymous_program;
}

void SV3_1aParser::Anonymous_programContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAnonymous_program(this);
}

void SV3_1aParser::Anonymous_programContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAnonymous_program(this);
}

SV3_1aParser::Anonymous_programContext* SV3_1aParser::anonymous_program() {
  Anonymous_programContext *_localctx = _tracker.createInstance<Anonymous_programContext>(_ctx, getState());
  enterRule(_localctx, 182, SV3_1aParser::RuleAnonymous_program);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2786);
    match(SV3_1aParser::PROGRAM);
    setState(2787);
    match(SV3_1aParser::SEMICOLON);
    setState(2791);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (((((_la - 31) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 31)) & 17592192335873) != 0) || _la == SV3_1aParser::COVERGROUP || _la == SV3_1aParser::TASK || _la == SV3_1aParser::SURELOG_MACRO_NOT_DEFINED) {
      setState(2788);
      anonymous_program_item();
      setState(2793);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(2794);
    match(SV3_1aParser::ENDPROGRAM);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Anonymous_program_itemContext ------------------------------------------------------------------

SV3_1aParser::Anonymous_program_itemContext::Anonymous_program_itemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::Task_declarationContext* SV3_1aParser::Anonymous_program_itemContext::task_declaration() {
  return getRuleContext<SV3_1aParser::Task_declarationContext>(0);
}

SV3_1aParser::Function_declarationContext* SV3_1aParser::Anonymous_program_itemContext::function_declaration() {
  return getRuleContext<SV3_1aParser::Function_declarationContext>(0);
}

SV3_1aParser::Class_declarationContext* SV3_1aParser::Anonymous_program_itemContext::class_declaration() {
  return getRuleContext<SV3_1aParser::Class_declarationContext>(0);
}

SV3_1aParser::Covergroup_declarationContext* SV3_1aParser::Anonymous_program_itemContext::covergroup_declaration() {
  return getRuleContext<SV3_1aParser::Covergroup_declarationContext>(0);
}

SV3_1aParser::Class_constructor_declarationContext* SV3_1aParser::Anonymous_program_itemContext::class_constructor_declaration() {
  return getRuleContext<SV3_1aParser::Class_constructor_declarationContext>(0);
}

tree::TerminalNode* SV3_1aParser::Anonymous_program_itemContext::SEMICOLON() {
  return getToken(SV3_1aParser::SEMICOLON, 0);
}

SV3_1aParser::Surelog_macro_not_definedContext* SV3_1aParser::Anonymous_program_itemContext::surelog_macro_not_defined() {
  return getRuleContext<SV3_1aParser::Surelog_macro_not_definedContext>(0);
}


size_t SV3_1aParser::Anonymous_program_itemContext::getRuleIndex() const {
  return SV3_1aParser::RuleAnonymous_program_item;
}

void SV3_1aParser::Anonymous_program_itemContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAnonymous_program_item(this);
}

void SV3_1aParser::Anonymous_program_itemContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAnonymous_program_item(this);
}

SV3_1aParser::Anonymous_program_itemContext* SV3_1aParser::anonymous_program_item() {
  Anonymous_program_itemContext *_localctx = _tracker.createInstance<Anonymous_program_itemContext>(_ctx, getState());
  enterRule(_localctx, 184, SV3_1aParser::RuleAnonymous_program_item);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2803);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 217, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2796);
      task_declaration();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2797);
      function_declaration();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(2798);
      class_declaration();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(2799);
      covergroup_declaration();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(2800);
      class_constructor_declaration();
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(2801);
      match(SV3_1aParser::SEMICOLON);
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(2802);
      surelog_macro_not_defined();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Local_parameter_declarationContext ------------------------------------------------------------------

SV3_1aParser::Local_parameter_declarationContext::Local_parameter_declarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Local_parameter_declarationContext::LOCALPARAM() {
  return getToken(SV3_1aParser::LOCALPARAM, 0);
}

SV3_1aParser::List_of_param_assignmentsContext* SV3_1aParser::Local_parameter_declarationContext::list_of_param_assignments() {
  return getRuleContext<SV3_1aParser::List_of_param_assignmentsContext>(0);
}

SV3_1aParser::Data_type_or_implicitContext* SV3_1aParser::Local_parameter_declarationContext::data_type_or_implicit() {
  return getRuleContext<SV3_1aParser::Data_type_or_implicitContext>(0);
}

tree::TerminalNode* SV3_1aParser::Local_parameter_declarationContext::TYPE() {
  return getToken(SV3_1aParser::TYPE, 0);
}


size_t SV3_1aParser::Local_parameter_declarationContext::getRuleIndex() const {
  return SV3_1aParser::RuleLocal_parameter_declaration;
}

void SV3_1aParser::Local_parameter_declarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLocal_parameter_declaration(this);
}

void SV3_1aParser::Local_parameter_declarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLocal_parameter_declaration(this);
}

SV3_1aParser::Local_parameter_declarationContext* SV3_1aParser::local_parameter_declaration() {
  Local_parameter_declarationContext *_localctx = _tracker.createInstance<Local_parameter_declarationContext>(_ctx, getState());
  enterRule(_localctx, 186, SV3_1aParser::RuleLocal_parameter_declaration);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2805);
    match(SV3_1aParser::LOCALPARAM);
    setState(2808);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 218, _ctx)) {
    case 1: {
      setState(2806);
      data_type_or_implicit();
      break;
    }

    case 2: {
      setState(2807);
      match(SV3_1aParser::TYPE);
      break;
    }

    default:
      break;
    }
    setState(2810);
    list_of_param_assignments();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Parameter_declarationContext ------------------------------------------------------------------

SV3_1aParser::Parameter_declarationContext::Parameter_declarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Parameter_declarationContext::PARAMETER() {
  return getToken(SV3_1aParser::PARAMETER, 0);
}

SV3_1aParser::List_of_param_assignmentsContext* SV3_1aParser::Parameter_declarationContext::list_of_param_assignments() {
  return getRuleContext<SV3_1aParser::List_of_param_assignmentsContext>(0);
}

SV3_1aParser::Data_type_or_implicitContext* SV3_1aParser::Parameter_declarationContext::data_type_or_implicit() {
  return getRuleContext<SV3_1aParser::Data_type_or_implicitContext>(0);
}

tree::TerminalNode* SV3_1aParser::Parameter_declarationContext::TYPE() {
  return getToken(SV3_1aParser::TYPE, 0);
}


size_t SV3_1aParser::Parameter_declarationContext::getRuleIndex() const {
  return SV3_1aParser::RuleParameter_declaration;
}

void SV3_1aParser::Parameter_declarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterParameter_declaration(this);
}

void SV3_1aParser::Parameter_declarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitParameter_declaration(this);
}

SV3_1aParser::Parameter_declarationContext* SV3_1aParser::parameter_declaration() {
  Parameter_declarationContext *_localctx = _tracker.createInstance<Parameter_declarationContext>(_ctx, getState());
  enterRule(_localctx, 188, SV3_1aParser::RuleParameter_declaration);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2812);
    match(SV3_1aParser::PARAMETER);
    setState(2815);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 219, _ctx)) {
    case 1: {
      setState(2813);
      data_type_or_implicit();
      break;
    }

    case 2: {
      setState(2814);
      match(SV3_1aParser::TYPE);
      break;
    }

    default:
      break;
    }
    setState(2817);
    list_of_param_assignments();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Specparam_declarationContext ------------------------------------------------------------------

SV3_1aParser::Specparam_declarationContext::Specparam_declarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Specparam_declarationContext::SPECPARAM() {
  return getToken(SV3_1aParser::SPECPARAM, 0);
}

SV3_1aParser::List_of_specparam_assignmentsContext* SV3_1aParser::Specparam_declarationContext::list_of_specparam_assignments() {
  return getRuleContext<SV3_1aParser::List_of_specparam_assignmentsContext>(0);
}

tree::TerminalNode* SV3_1aParser::Specparam_declarationContext::SEMICOLON() {
  return getToken(SV3_1aParser::SEMICOLON, 0);
}

SV3_1aParser::Packed_dimensionContext* SV3_1aParser::Specparam_declarationContext::packed_dimension() {
  return getRuleContext<SV3_1aParser::Packed_dimensionContext>(0);
}


size_t SV3_1aParser::Specparam_declarationContext::getRuleIndex() const {
  return SV3_1aParser::RuleSpecparam_declaration;
}

void SV3_1aParser::Specparam_declarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSpecparam_declaration(this);
}

void SV3_1aParser::Specparam_declarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSpecparam_declaration(this);
}

SV3_1aParser::Specparam_declarationContext* SV3_1aParser::specparam_declaration() {
  Specparam_declarationContext *_localctx = _tracker.createInstance<Specparam_declarationContext>(_ctx, getState());
  enterRule(_localctx, 190, SV3_1aParser::RuleSpecparam_declaration);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2819);
    match(SV3_1aParser::SPECPARAM);
    setState(2821);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SV3_1aParser::OPEN_BRACKET) {
      setState(2820);
      packed_dimension();
    }
    setState(2823);
    list_of_specparam_assignments();
    setState(2824);
    match(SV3_1aParser::SEMICOLON);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Inout_declarationContext ------------------------------------------------------------------

SV3_1aParser::Inout_declarationContext::Inout_declarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Inout_declarationContext::INOUT() {
  return getToken(SV3_1aParser::INOUT, 0);
}

SV3_1aParser::Net_port_typeContext* SV3_1aParser::Inout_declarationContext::net_port_type() {
  return getRuleContext<SV3_1aParser::Net_port_typeContext>(0);
}

SV3_1aParser::List_of_port_identifiersContext* SV3_1aParser::Inout_declarationContext::list_of_port_identifiers() {
  return getRuleContext<SV3_1aParser::List_of_port_identifiersContext>(0);
}


size_t SV3_1aParser::Inout_declarationContext::getRuleIndex() const {
  return SV3_1aParser::RuleInout_declaration;
}

void SV3_1aParser::Inout_declarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInout_declaration(this);
}

void SV3_1aParser::Inout_declarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInout_declaration(this);
}

SV3_1aParser::Inout_declarationContext* SV3_1aParser::inout_declaration() {
  Inout_declarationContext *_localctx = _tracker.createInstance<Inout_declarationContext>(_ctx, getState());
  enterRule(_localctx, 192, SV3_1aParser::RuleInout_declaration);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2826);
    match(SV3_1aParser::INOUT);
    setState(2827);
    net_port_type();
    setState(2828);
    list_of_port_identifiers();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Input_declarationContext ------------------------------------------------------------------

SV3_1aParser::Input_declarationContext::Input_declarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Input_declarationContext::INPUT() {
  return getToken(SV3_1aParser::INPUT, 0);
}

SV3_1aParser::Net_port_typeContext* SV3_1aParser::Input_declarationContext::net_port_type() {
  return getRuleContext<SV3_1aParser::Net_port_typeContext>(0);
}

SV3_1aParser::List_of_port_identifiersContext* SV3_1aParser::Input_declarationContext::list_of_port_identifiers() {
  return getRuleContext<SV3_1aParser::List_of_port_identifiersContext>(0);
}

SV3_1aParser::List_of_variable_identifiersContext* SV3_1aParser::Input_declarationContext::list_of_variable_identifiers() {
  return getRuleContext<SV3_1aParser::List_of_variable_identifiersContext>(0);
}

SV3_1aParser::Variable_port_typeContext* SV3_1aParser::Input_declarationContext::variable_port_type() {
  return getRuleContext<SV3_1aParser::Variable_port_typeContext>(0);
}


size_t SV3_1aParser::Input_declarationContext::getRuleIndex() const {
  return SV3_1aParser::RuleInput_declaration;
}

void SV3_1aParser::Input_declarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInput_declaration(this);
}

void SV3_1aParser::Input_declarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInput_declaration(this);
}

SV3_1aParser::Input_declarationContext* SV3_1aParser::input_declaration() {
  Input_declarationContext *_localctx = _tracker.createInstance<Input_declarationContext>(_ctx, getState());
  enterRule(_localctx, 194, SV3_1aParser::RuleInput_declaration);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2830);
    match(SV3_1aParser::INPUT);
    setState(2838);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 222, _ctx)) {
    case 1: {
      setState(2831);
      net_port_type();
      setState(2832);
      list_of_port_identifiers();
      break;
    }

    case 2: {
      setState(2835);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 221, _ctx)) {
      case 1: {
        setState(2834);
        variable_port_type();
        break;
      }

      default:
        break;
      }
      setState(2837);
      list_of_variable_identifiers();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Output_declarationContext ------------------------------------------------------------------

SV3_1aParser::Output_declarationContext::Output_declarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Output_declarationContext::OUTPUT() {
  return getToken(SV3_1aParser::OUTPUT, 0);
}

SV3_1aParser::Net_port_typeContext* SV3_1aParser::Output_declarationContext::net_port_type() {
  return getRuleContext<SV3_1aParser::Net_port_typeContext>(0);
}

SV3_1aParser::List_of_port_identifiersContext* SV3_1aParser::Output_declarationContext::list_of_port_identifiers() {
  return getRuleContext<SV3_1aParser::List_of_port_identifiersContext>(0);
}

SV3_1aParser::List_of_variable_port_identifiersContext* SV3_1aParser::Output_declarationContext::list_of_variable_port_identifiers() {
  return getRuleContext<SV3_1aParser::List_of_variable_port_identifiersContext>(0);
}

SV3_1aParser::Variable_port_typeContext* SV3_1aParser::Output_declarationContext::variable_port_type() {
  return getRuleContext<SV3_1aParser::Variable_port_typeContext>(0);
}


size_t SV3_1aParser::Output_declarationContext::getRuleIndex() const {
  return SV3_1aParser::RuleOutput_declaration;
}

void SV3_1aParser::Output_declarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOutput_declaration(this);
}

void SV3_1aParser::Output_declarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOutput_declaration(this);
}

SV3_1aParser::Output_declarationContext* SV3_1aParser::output_declaration() {
  Output_declarationContext *_localctx = _tracker.createInstance<Output_declarationContext>(_ctx, getState());
  enterRule(_localctx, 196, SV3_1aParser::RuleOutput_declaration);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2840);
    match(SV3_1aParser::OUTPUT);
    setState(2848);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 224, _ctx)) {
    case 1: {
      setState(2841);
      net_port_type();
      setState(2842);
      list_of_port_identifiers();
      break;
    }

    case 2: {
      setState(2845);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 223, _ctx)) {
      case 1: {
        setState(2844);
        variable_port_type();
        break;
      }

      default:
        break;
      }
      setState(2847);
      list_of_variable_port_identifiers();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Interface_port_declarationContext ------------------------------------------------------------------

SV3_1aParser::Interface_port_declarationContext::Interface_port_declarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::Interface_identifierContext* SV3_1aParser::Interface_port_declarationContext::interface_identifier() {
  return getRuleContext<SV3_1aParser::Interface_identifierContext>(0);
}

SV3_1aParser::List_of_interface_identifiersContext* SV3_1aParser::Interface_port_declarationContext::list_of_interface_identifiers() {
  return getRuleContext<SV3_1aParser::List_of_interface_identifiersContext>(0);
}

tree::TerminalNode* SV3_1aParser::Interface_port_declarationContext::DOT() {
  return getToken(SV3_1aParser::DOT, 0);
}

SV3_1aParser::IdentifierContext* SV3_1aParser::Interface_port_declarationContext::identifier() {
  return getRuleContext<SV3_1aParser::IdentifierContext>(0);
}


size_t SV3_1aParser::Interface_port_declarationContext::getRuleIndex() const {
  return SV3_1aParser::RuleInterface_port_declaration;
}

void SV3_1aParser::Interface_port_declarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInterface_port_declaration(this);
}

void SV3_1aParser::Interface_port_declarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInterface_port_declaration(this);
}

SV3_1aParser::Interface_port_declarationContext* SV3_1aParser::interface_port_declaration() {
  Interface_port_declarationContext *_localctx = _tracker.createInstance<Interface_port_declarationContext>(_ctx, getState());
  enterRule(_localctx, 198, SV3_1aParser::RuleInterface_port_declaration);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2858);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 225, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2850);
      interface_identifier();
      setState(2851);
      list_of_interface_identifiers();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2853);
      interface_identifier();
      setState(2854);
      match(SV3_1aParser::DOT);
      setState(2855);
      identifier();
      setState(2856);
      list_of_interface_identifiers();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Ref_declarationContext ------------------------------------------------------------------

SV3_1aParser::Ref_declarationContext::Ref_declarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Ref_declarationContext::REF() {
  return getToken(SV3_1aParser::REF, 0);
}

SV3_1aParser::Variable_port_typeContext* SV3_1aParser::Ref_declarationContext::variable_port_type() {
  return getRuleContext<SV3_1aParser::Variable_port_typeContext>(0);
}

SV3_1aParser::List_of_variable_identifiersContext* SV3_1aParser::Ref_declarationContext::list_of_variable_identifiers() {
  return getRuleContext<SV3_1aParser::List_of_variable_identifiersContext>(0);
}


size_t SV3_1aParser::Ref_declarationContext::getRuleIndex() const {
  return SV3_1aParser::RuleRef_declaration;
}

void SV3_1aParser::Ref_declarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRef_declaration(this);
}

void SV3_1aParser::Ref_declarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRef_declaration(this);
}

SV3_1aParser::Ref_declarationContext* SV3_1aParser::ref_declaration() {
  Ref_declarationContext *_localctx = _tracker.createInstance<Ref_declarationContext>(_ctx, getState());
  enterRule(_localctx, 200, SV3_1aParser::RuleRef_declaration);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2860);
    match(SV3_1aParser::REF);
    setState(2861);
    variable_port_type();
    setState(2862);
    list_of_variable_identifiers();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Data_declarationContext ------------------------------------------------------------------

SV3_1aParser::Data_declarationContext::Data_declarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::Variable_declarationContext* SV3_1aParser::Data_declarationContext::variable_declaration() {
  return getRuleContext<SV3_1aParser::Variable_declarationContext>(0);
}

SV3_1aParser::Var_typeContext* SV3_1aParser::Data_declarationContext::var_type() {
  return getRuleContext<SV3_1aParser::Var_typeContext>(0);
}

SV3_1aParser::Variable_impl_declarationContext* SV3_1aParser::Data_declarationContext::variable_impl_declaration() {
  return getRuleContext<SV3_1aParser::Variable_impl_declarationContext>(0);
}

SV3_1aParser::Const_typeContext* SV3_1aParser::Data_declarationContext::const_type() {
  return getRuleContext<SV3_1aParser::Const_typeContext>(0);
}

SV3_1aParser::LifetimeContext* SV3_1aParser::Data_declarationContext::lifetime() {
  return getRuleContext<SV3_1aParser::LifetimeContext>(0);
}

SV3_1aParser::Type_declarationContext* SV3_1aParser::Data_declarationContext::type_declaration() {
  return getRuleContext<SV3_1aParser::Type_declarationContext>(0);
}

SV3_1aParser::Package_import_declarationContext* SV3_1aParser::Data_declarationContext::package_import_declaration() {
  return getRuleContext<SV3_1aParser::Package_import_declarationContext>(0);
}

SV3_1aParser::Net_type_declarationContext* SV3_1aParser::Data_declarationContext::net_type_declaration() {
  return getRuleContext<SV3_1aParser::Net_type_declarationContext>(0);
}


size_t SV3_1aParser::Data_declarationContext::getRuleIndex() const {
  return SV3_1aParser::RuleData_declaration;
}

void SV3_1aParser::Data_declarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterData_declaration(this);
}

void SV3_1aParser::Data_declarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitData_declaration(this);
}

SV3_1aParser::Data_declarationContext* SV3_1aParser::data_declaration() {
  Data_declarationContext *_localctx = _tracker.createInstance<Data_declarationContext>(_ctx, getState());
  enterRule(_localctx, 202, SV3_1aParser::RuleData_declaration);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2882);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SV3_1aParser::VIRTUAL:
      case SV3_1aParser::TYPE:
      case SV3_1aParser::CONST:
      case SV3_1aParser::STATIC:
      case SV3_1aParser::AUTOMATIC:
      case SV3_1aParser::ENUM:
      case SV3_1aParser::STRUCT:
      case SV3_1aParser::UNION:
      case SV3_1aParser::STRING:
      case SV3_1aParser::CHANDLE:
      case SV3_1aParser::EVENT:
      case SV3_1aParser::OPEN_BRACKET:
      case SV3_1aParser::BYTE:
      case SV3_1aParser::SHORTINT:
      case SV3_1aParser::INT:
      case SV3_1aParser::LONGINT:
      case SV3_1aParser::INTEGER:
      case SV3_1aParser::TIME:
      case SV3_1aParser::BIT:
      case SV3_1aParser::LOGIC:
      case SV3_1aParser::REG:
      case SV3_1aParser::SHORTREAL:
      case SV3_1aParser::REAL:
      case SV3_1aParser::REALTIME:
      case SV3_1aParser::SIGNED:
      case SV3_1aParser::UNSIGNED:
      case SV3_1aParser::VAR:
      case SV3_1aParser::DOLLAR_UNIT:
      case SV3_1aParser::THIS:
      case SV3_1aParser::RANDOMIZE:
      case SV3_1aParser::SAMPLE:
      case SV3_1aParser::Escaped_identifier:
      case SV3_1aParser::Simple_identifier: {
        enterOuterAlt(_localctx, 1);
        setState(2865);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == SV3_1aParser::CONST) {
          setState(2864);
          const_type();
        }
        setState(2877);
        _errHandler->sync(this);
        switch (_input->LA(1)) {
          case SV3_1aParser::VIRTUAL:
          case SV3_1aParser::TYPE:
          case SV3_1aParser::STATIC:
          case SV3_1aParser::AUTOMATIC:
          case SV3_1aParser::ENUM:
          case SV3_1aParser::STRUCT:
          case SV3_1aParser::UNION:
          case SV3_1aParser::STRING:
          case SV3_1aParser::CHANDLE:
          case SV3_1aParser::EVENT:
          case SV3_1aParser::OPEN_BRACKET:
          case SV3_1aParser::BYTE:
          case SV3_1aParser::SHORTINT:
          case SV3_1aParser::INT:
          case SV3_1aParser::LONGINT:
          case SV3_1aParser::INTEGER:
          case SV3_1aParser::TIME:
          case SV3_1aParser::BIT:
          case SV3_1aParser::LOGIC:
          case SV3_1aParser::REG:
          case SV3_1aParser::SHORTREAL:
          case SV3_1aParser::REAL:
          case SV3_1aParser::REALTIME:
          case SV3_1aParser::SIGNED:
          case SV3_1aParser::UNSIGNED:
          case SV3_1aParser::DOLLAR_UNIT:
          case SV3_1aParser::THIS:
          case SV3_1aParser::RANDOMIZE:
          case SV3_1aParser::SAMPLE:
          case SV3_1aParser::Escaped_identifier:
          case SV3_1aParser::Simple_identifier: {
            setState(2868);
            _errHandler->sync(this);

            _la = _input->LA(1);
            if (_la == SV3_1aParser::STATIC

            || _la == SV3_1aParser::AUTOMATIC) {
              setState(2867);
              lifetime();
            }
            setState(2870);
            variable_declaration();
            break;
          }

          case SV3_1aParser::VAR: {
            setState(2871);
            var_type();
            setState(2873);
            _errHandler->sync(this);

            _la = _input->LA(1);
            if (_la == SV3_1aParser::STATIC

            || _la == SV3_1aParser::AUTOMATIC) {
              setState(2872);
              lifetime();
            }
            setState(2875);
            variable_impl_declaration();
            break;
          }

        default:
          throw NoViableAltException(this);
        }
        break;
      }

      case SV3_1aParser::TYPEDEF: {
        enterOuterAlt(_localctx, 2);
        setState(2879);
        type_declaration();
        break;
      }

      case SV3_1aParser::IMPORT: {
        enterOuterAlt(_localctx, 3);
        setState(2880);
        package_import_declaration();
        break;
      }

      case SV3_1aParser::NETTYPE: {
        enterOuterAlt(_localctx, 4);
        setState(2881);
        net_type_declaration();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Variable_impl_declarationContext ------------------------------------------------------------------

SV3_1aParser::Variable_impl_declarationContext::Variable_impl_declarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::List_of_variable_decl_assignmentsContext* SV3_1aParser::Variable_impl_declarationContext::list_of_variable_decl_assignments() {
  return getRuleContext<SV3_1aParser::List_of_variable_decl_assignmentsContext>(0);
}

tree::TerminalNode* SV3_1aParser::Variable_impl_declarationContext::SEMICOLON() {
  return getToken(SV3_1aParser::SEMICOLON, 0);
}

SV3_1aParser::Data_type_or_implicitContext* SV3_1aParser::Variable_impl_declarationContext::data_type_or_implicit() {
  return getRuleContext<SV3_1aParser::Data_type_or_implicitContext>(0);
}

SV3_1aParser::SigningContext* SV3_1aParser::Variable_impl_declarationContext::signing() {
  return getRuleContext<SV3_1aParser::SigningContext>(0);
}

std::vector<SV3_1aParser::Packed_dimensionContext *> SV3_1aParser::Variable_impl_declarationContext::packed_dimension() {
  return getRuleContexts<SV3_1aParser::Packed_dimensionContext>();
}

SV3_1aParser::Packed_dimensionContext* SV3_1aParser::Variable_impl_declarationContext::packed_dimension(size_t i) {
  return getRuleContext<SV3_1aParser::Packed_dimensionContext>(i);
}


size_t SV3_1aParser::Variable_impl_declarationContext::getRuleIndex() const {
  return SV3_1aParser::RuleVariable_impl_declaration;
}

void SV3_1aParser::Variable_impl_declarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterVariable_impl_declaration(this);
}

void SV3_1aParser::Variable_impl_declarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitVariable_impl_declaration(this);
}

SV3_1aParser::Variable_impl_declarationContext* SV3_1aParser::variable_impl_declaration() {
  Variable_impl_declarationContext *_localctx = _tracker.createInstance<Variable_impl_declarationContext>(_ctx, getState());
  enterRule(_localctx, 204, SV3_1aParser::RuleVariable_impl_declaration);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2897);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 233, _ctx)) {
    case 1: {
      setState(2884);
      data_type_or_implicit();
      break;
    }

    case 2: {
      setState(2885);
      signing();
      setState(2889);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == SV3_1aParser::OPEN_BRACKET) {
        setState(2886);
        packed_dimension();
        setState(2891);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      break;
    }

    case 3: {
      setState(2893); 
      _errHandler->sync(this);
      _la = _input->LA(1);
      do {
        setState(2892);
        packed_dimension();
        setState(2895); 
        _errHandler->sync(this);
        _la = _input->LA(1);
      } while (_la == SV3_1aParser::OPEN_BRACKET);
      break;
    }

    default:
      break;
    }
    setState(2899);
    list_of_variable_decl_assignments();
    setState(2900);
    match(SV3_1aParser::SEMICOLON);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Variable_declarationContext ------------------------------------------------------------------

SV3_1aParser::Variable_declarationContext::Variable_declarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::List_of_variable_decl_assignmentsContext* SV3_1aParser::Variable_declarationContext::list_of_variable_decl_assignments() {
  return getRuleContext<SV3_1aParser::List_of_variable_decl_assignmentsContext>(0);
}

tree::TerminalNode* SV3_1aParser::Variable_declarationContext::SEMICOLON() {
  return getToken(SV3_1aParser::SEMICOLON, 0);
}

SV3_1aParser::Data_typeContext* SV3_1aParser::Variable_declarationContext::data_type() {
  return getRuleContext<SV3_1aParser::Data_typeContext>(0);
}

SV3_1aParser::SigningContext* SV3_1aParser::Variable_declarationContext::signing() {
  return getRuleContext<SV3_1aParser::SigningContext>(0);
}

std::vector<SV3_1aParser::Packed_dimensionContext *> SV3_1aParser::Variable_declarationContext::packed_dimension() {
  return getRuleContexts<SV3_1aParser::Packed_dimensionContext>();
}

SV3_1aParser::Packed_dimensionContext* SV3_1aParser::Variable_declarationContext::packed_dimension(size_t i) {
  return getRuleContext<SV3_1aParser::Packed_dimensionContext>(i);
}


size_t SV3_1aParser::Variable_declarationContext::getRuleIndex() const {
  return SV3_1aParser::RuleVariable_declaration;
}

void SV3_1aParser::Variable_declarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterVariable_declaration(this);
}

void SV3_1aParser::Variable_declarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitVariable_declaration(this);
}

SV3_1aParser::Variable_declarationContext* SV3_1aParser::variable_declaration() {
  Variable_declarationContext *_localctx = _tracker.createInstance<Variable_declarationContext>(_ctx, getState());
  enterRule(_localctx, 206, SV3_1aParser::RuleVariable_declaration);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2915);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SV3_1aParser::VIRTUAL:
      case SV3_1aParser::TYPE:
      case SV3_1aParser::ENUM:
      case SV3_1aParser::STRUCT:
      case SV3_1aParser::UNION:
      case SV3_1aParser::STRING:
      case SV3_1aParser::CHANDLE:
      case SV3_1aParser::EVENT:
      case SV3_1aParser::BYTE:
      case SV3_1aParser::SHORTINT:
      case SV3_1aParser::INT:
      case SV3_1aParser::LONGINT:
      case SV3_1aParser::INTEGER:
      case SV3_1aParser::TIME:
      case SV3_1aParser::BIT:
      case SV3_1aParser::LOGIC:
      case SV3_1aParser::REG:
      case SV3_1aParser::SHORTREAL:
      case SV3_1aParser::REAL:
      case SV3_1aParser::REALTIME:
      case SV3_1aParser::DOLLAR_UNIT:
      case SV3_1aParser::THIS:
      case SV3_1aParser::RANDOMIZE:
      case SV3_1aParser::SAMPLE:
      case SV3_1aParser::Escaped_identifier:
      case SV3_1aParser::Simple_identifier: {
        setState(2902);
        data_type();
        break;
      }

      case SV3_1aParser::SIGNED:
      case SV3_1aParser::UNSIGNED: {
        setState(2903);
        signing();
        setState(2907);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == SV3_1aParser::OPEN_BRACKET) {
          setState(2904);
          packed_dimension();
          setState(2909);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        break;
      }

      case SV3_1aParser::OPEN_BRACKET: {
        setState(2911); 
        _errHandler->sync(this);
        _la = _input->LA(1);
        do {
          setState(2910);
          packed_dimension();
          setState(2913); 
          _errHandler->sync(this);
          _la = _input->LA(1);
        } while (_la == SV3_1aParser::OPEN_BRACKET);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
    setState(2917);
    list_of_variable_decl_assignments();
    setState(2918);
    match(SV3_1aParser::SEMICOLON);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Package_import_declarationContext ------------------------------------------------------------------

SV3_1aParser::Package_import_declarationContext::Package_import_declarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Package_import_declarationContext::IMPORT() {
  return getToken(SV3_1aParser::IMPORT, 0);
}

std::vector<SV3_1aParser::Package_import_itemContext *> SV3_1aParser::Package_import_declarationContext::package_import_item() {
  return getRuleContexts<SV3_1aParser::Package_import_itemContext>();
}

SV3_1aParser::Package_import_itemContext* SV3_1aParser::Package_import_declarationContext::package_import_item(size_t i) {
  return getRuleContext<SV3_1aParser::Package_import_itemContext>(i);
}

tree::TerminalNode* SV3_1aParser::Package_import_declarationContext::SEMICOLON() {
  return getToken(SV3_1aParser::SEMICOLON, 0);
}

std::vector<tree::TerminalNode *> SV3_1aParser::Package_import_declarationContext::COMMA() {
  return getTokens(SV3_1aParser::COMMA);
}

tree::TerminalNode* SV3_1aParser::Package_import_declarationContext::COMMA(size_t i) {
  return getToken(SV3_1aParser::COMMA, i);
}


size_t SV3_1aParser::Package_import_declarationContext::getRuleIndex() const {
  return SV3_1aParser::RulePackage_import_declaration;
}

void SV3_1aParser::Package_import_declarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPackage_import_declaration(this);
}

void SV3_1aParser::Package_import_declarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPackage_import_declaration(this);
}

SV3_1aParser::Package_import_declarationContext* SV3_1aParser::package_import_declaration() {
  Package_import_declarationContext *_localctx = _tracker.createInstance<Package_import_declarationContext>(_ctx, getState());
  enterRule(_localctx, 208, SV3_1aParser::RulePackage_import_declaration);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2920);
    match(SV3_1aParser::IMPORT);
    setState(2921);
    package_import_item();
    setState(2926);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == SV3_1aParser::COMMA) {
      setState(2922);
      match(SV3_1aParser::COMMA);
      setState(2923);
      package_import_item();
      setState(2928);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(2929);
    match(SV3_1aParser::SEMICOLON);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Package_import_itemContext ------------------------------------------------------------------

SV3_1aParser::Package_import_itemContext::Package_import_itemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<SV3_1aParser::IdentifierContext *> SV3_1aParser::Package_import_itemContext::identifier() {
  return getRuleContexts<SV3_1aParser::IdentifierContext>();
}

SV3_1aParser::IdentifierContext* SV3_1aParser::Package_import_itemContext::identifier(size_t i) {
  return getRuleContext<SV3_1aParser::IdentifierContext>(i);
}

tree::TerminalNode* SV3_1aParser::Package_import_itemContext::COLONCOLON() {
  return getToken(SV3_1aParser::COLONCOLON, 0);
}

tree::TerminalNode* SV3_1aParser::Package_import_itemContext::STAR() {
  return getToken(SV3_1aParser::STAR, 0);
}


size_t SV3_1aParser::Package_import_itemContext::getRuleIndex() const {
  return SV3_1aParser::RulePackage_import_item;
}

void SV3_1aParser::Package_import_itemContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPackage_import_item(this);
}

void SV3_1aParser::Package_import_itemContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPackage_import_item(this);
}

SV3_1aParser::Package_import_itemContext* SV3_1aParser::package_import_item() {
  Package_import_itemContext *_localctx = _tracker.createInstance<Package_import_itemContext>(_ctx, getState());
  enterRule(_localctx, 210, SV3_1aParser::RulePackage_import_item);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2931);
    identifier();
    setState(2932);
    match(SV3_1aParser::COLONCOLON);
    setState(2935);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SV3_1aParser::THIS:
      case SV3_1aParser::RANDOMIZE:
      case SV3_1aParser::SAMPLE:
      case SV3_1aParser::Escaped_identifier:
      case SV3_1aParser::Simple_identifier: {
        setState(2933);
        identifier();
        break;
      }

      case SV3_1aParser::STAR: {
        setState(2934);
        match(SV3_1aParser::STAR);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Package_export_declarationContext ------------------------------------------------------------------

SV3_1aParser::Package_export_declarationContext::Package_export_declarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Package_export_declarationContext::EXPORT() {
  return getToken(SV3_1aParser::EXPORT, 0);
}

tree::TerminalNode* SV3_1aParser::Package_export_declarationContext::STARCOLONCOLONSTAR() {
  return getToken(SV3_1aParser::STARCOLONCOLONSTAR, 0);
}

tree::TerminalNode* SV3_1aParser::Package_export_declarationContext::SEMICOLON() {
  return getToken(SV3_1aParser::SEMICOLON, 0);
}

std::vector<SV3_1aParser::Package_import_itemContext *> SV3_1aParser::Package_export_declarationContext::package_import_item() {
  return getRuleContexts<SV3_1aParser::Package_import_itemContext>();
}

SV3_1aParser::Package_import_itemContext* SV3_1aParser::Package_export_declarationContext::package_import_item(size_t i) {
  return getRuleContext<SV3_1aParser::Package_import_itemContext>(i);
}

tree::TerminalNode* SV3_1aParser::Package_export_declarationContext::COMMA() {
  return getToken(SV3_1aParser::COMMA, 0);
}


size_t SV3_1aParser::Package_export_declarationContext::getRuleIndex() const {
  return SV3_1aParser::RulePackage_export_declaration;
}

void SV3_1aParser::Package_export_declarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPackage_export_declaration(this);
}

void SV3_1aParser::Package_export_declarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPackage_export_declaration(this);
}

SV3_1aParser::Package_export_declarationContext* SV3_1aParser::package_export_declaration() {
  Package_export_declarationContext *_localctx = _tracker.createInstance<Package_export_declarationContext>(_ctx, getState());
  enterRule(_localctx, 212, SV3_1aParser::RulePackage_export_declaration);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2948);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 240, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2937);
      match(SV3_1aParser::EXPORT);
      setState(2938);
      match(SV3_1aParser::STARCOLONCOLONSTAR);
      setState(2939);
      match(SV3_1aParser::SEMICOLON);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2940);
      match(SV3_1aParser::EXPORT);
      setState(2941);
      package_import_item();
      setState(2944);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == SV3_1aParser::COMMA) {
        setState(2942);
        match(SV3_1aParser::COMMA);
        setState(2943);
        package_import_item();
      }
      setState(2946);
      match(SV3_1aParser::SEMICOLON);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Genvar_declarationContext ------------------------------------------------------------------

SV3_1aParser::Genvar_declarationContext::Genvar_declarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Genvar_declarationContext::GENVAR() {
  return getToken(SV3_1aParser::GENVAR, 0);
}

SV3_1aParser::Identifier_listContext* SV3_1aParser::Genvar_declarationContext::identifier_list() {
  return getRuleContext<SV3_1aParser::Identifier_listContext>(0);
}

tree::TerminalNode* SV3_1aParser::Genvar_declarationContext::SEMICOLON() {
  return getToken(SV3_1aParser::SEMICOLON, 0);
}


size_t SV3_1aParser::Genvar_declarationContext::getRuleIndex() const {
  return SV3_1aParser::RuleGenvar_declaration;
}

void SV3_1aParser::Genvar_declarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGenvar_declaration(this);
}

void SV3_1aParser::Genvar_declarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGenvar_declaration(this);
}

SV3_1aParser::Genvar_declarationContext* SV3_1aParser::genvar_declaration() {
  Genvar_declarationContext *_localctx = _tracker.createInstance<Genvar_declarationContext>(_ctx, getState());
  enterRule(_localctx, 214, SV3_1aParser::RuleGenvar_declaration);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2950);
    match(SV3_1aParser::GENVAR);
    setState(2951);
    identifier_list();
    setState(2952);
    match(SV3_1aParser::SEMICOLON);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Net_declarationContext ------------------------------------------------------------------

SV3_1aParser::Net_declarationContext::Net_declarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::Net_typeContext* SV3_1aParser::Net_declarationContext::net_type() {
  return getRuleContext<SV3_1aParser::Net_typeContext>(0);
}

SV3_1aParser::Data_type_or_implicitContext* SV3_1aParser::Net_declarationContext::data_type_or_implicit() {
  return getRuleContext<SV3_1aParser::Data_type_or_implicitContext>(0);
}

SV3_1aParser::List_of_net_decl_assignmentsContext* SV3_1aParser::Net_declarationContext::list_of_net_decl_assignments() {
  return getRuleContext<SV3_1aParser::List_of_net_decl_assignmentsContext>(0);
}

tree::TerminalNode* SV3_1aParser::Net_declarationContext::SEMICOLON() {
  return getToken(SV3_1aParser::SEMICOLON, 0);
}

SV3_1aParser::Drive_strengthContext* SV3_1aParser::Net_declarationContext::drive_strength() {
  return getRuleContext<SV3_1aParser::Drive_strengthContext>(0);
}

SV3_1aParser::Charge_strengthContext* SV3_1aParser::Net_declarationContext::charge_strength() {
  return getRuleContext<SV3_1aParser::Charge_strengthContext>(0);
}

SV3_1aParser::Delay3Context* SV3_1aParser::Net_declarationContext::delay3() {
  return getRuleContext<SV3_1aParser::Delay3Context>(0);
}

tree::TerminalNode* SV3_1aParser::Net_declarationContext::VECTORED() {
  return getToken(SV3_1aParser::VECTORED, 0);
}

tree::TerminalNode* SV3_1aParser::Net_declarationContext::SCALARED() {
  return getToken(SV3_1aParser::SCALARED, 0);
}

std::vector<SV3_1aParser::IdentifierContext *> SV3_1aParser::Net_declarationContext::identifier() {
  return getRuleContexts<SV3_1aParser::IdentifierContext>();
}

SV3_1aParser::IdentifierContext* SV3_1aParser::Net_declarationContext::identifier(size_t i) {
  return getRuleContext<SV3_1aParser::IdentifierContext>(i);
}

SV3_1aParser::Delay_controlContext* SV3_1aParser::Net_declarationContext::delay_control() {
  return getRuleContext<SV3_1aParser::Delay_controlContext>(0);
}

tree::TerminalNode* SV3_1aParser::Net_declarationContext::INTERCONNECT() {
  return getToken(SV3_1aParser::INTERCONNECT, 0);
}

SV3_1aParser::Implicit_data_typeContext* SV3_1aParser::Net_declarationContext::implicit_data_type() {
  return getRuleContext<SV3_1aParser::Implicit_data_typeContext>(0);
}

SV3_1aParser::Pound_delay_valueContext* SV3_1aParser::Net_declarationContext::pound_delay_value() {
  return getRuleContext<SV3_1aParser::Pound_delay_valueContext>(0);
}

std::vector<SV3_1aParser::Unpacked_dimensionContext *> SV3_1aParser::Net_declarationContext::unpacked_dimension() {
  return getRuleContexts<SV3_1aParser::Unpacked_dimensionContext>();
}

SV3_1aParser::Unpacked_dimensionContext* SV3_1aParser::Net_declarationContext::unpacked_dimension(size_t i) {
  return getRuleContext<SV3_1aParser::Unpacked_dimensionContext>(i);
}

tree::TerminalNode* SV3_1aParser::Net_declarationContext::COMMA() {
  return getToken(SV3_1aParser::COMMA, 0);
}


size_t SV3_1aParser::Net_declarationContext::getRuleIndex() const {
  return SV3_1aParser::RuleNet_declaration;
}

void SV3_1aParser::Net_declarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNet_declaration(this);
}

void SV3_1aParser::Net_declarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNet_declaration(this);
}

SV3_1aParser::Net_declarationContext* SV3_1aParser::net_declaration() {
  Net_declarationContext *_localctx = _tracker.createInstance<Net_declarationContext>(_ctx, getState());
  enterRule(_localctx, 216, SV3_1aParser::RuleNet_declaration);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(3000);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SV3_1aParser::SUPPLY0:
      case SV3_1aParser::SUPPLY1:
      case SV3_1aParser::TRI:
      case SV3_1aParser::TRIAND:
      case SV3_1aParser::TRIOR:
      case SV3_1aParser::TRI0:
      case SV3_1aParser::TRI1:
      case SV3_1aParser::WIRE:
      case SV3_1aParser::UWIRE:
      case SV3_1aParser::WAND:
      case SV3_1aParser::WOR:
      case SV3_1aParser::TRIREG: {
        enterOuterAlt(_localctx, 1);
        setState(2954);
        net_type();
        setState(2957);
        _errHandler->sync(this);
        switch (_input->LA(1)) {
          case SV3_1aParser::OPEN_PARENS: {
            setState(2955);
            drive_strength();
            break;
          }

          case SV3_1aParser::SMALL:
          case SV3_1aParser::MEDIUM:
          case SV3_1aParser::LARGE: {
            setState(2956);
            charge_strength();
            break;
          }

          case SV3_1aParser::Pound_Pound_delay:
          case SV3_1aParser::Pound_delay:
          case SV3_1aParser::VIRTUAL:
          case SV3_1aParser::TYPE:
          case SV3_1aParser::VECTORED:
          case SV3_1aParser::SCALARED:
          case SV3_1aParser::ENUM:
          case SV3_1aParser::STRUCT:
          case SV3_1aParser::UNION:
          case SV3_1aParser::STRING:
          case SV3_1aParser::CHANDLE:
          case SV3_1aParser::EVENT:
          case SV3_1aParser::OPEN_BRACKET:
          case SV3_1aParser::BYTE:
          case SV3_1aParser::SHORTINT:
          case SV3_1aParser::INT:
          case SV3_1aParser::LONGINT:
          case SV3_1aParser::INTEGER:
          case SV3_1aParser::TIME:
          case SV3_1aParser::BIT:
          case SV3_1aParser::LOGIC:
          case SV3_1aParser::REG:
          case SV3_1aParser::SHORTREAL:
          case SV3_1aParser::REAL:
          case SV3_1aParser::REALTIME:
          case SV3_1aParser::SIGNED:
          case SV3_1aParser::UNSIGNED:
          case SV3_1aParser::DOLLAR_UNIT:
          case SV3_1aParser::POUND:
          case SV3_1aParser::THIS:
          case SV3_1aParser::RANDOMIZE:
          case SV3_1aParser::SAMPLE:
          case SV3_1aParser::Escaped_identifier:
          case SV3_1aParser::Simple_identifier: {
            break;
          }

        default:
          break;
        }
        setState(2960);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == SV3_1aParser::VECTORED

        || _la == SV3_1aParser::SCALARED) {
          setState(2959);
          _la = _input->LA(1);
          if (!(_la == SV3_1aParser::VECTORED

          || _la == SV3_1aParser::SCALARED)) {
          _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
        }
        setState(2962);
        data_type_or_implicit();
        setState(2964);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == SV3_1aParser::Pound_Pound_delay

        || _la == SV3_1aParser::Pound_delay || _la == SV3_1aParser::POUND) {
          setState(2963);
          delay3();
        }
        setState(2966);
        list_of_net_decl_assignments();
        setState(2967);
        match(SV3_1aParser::SEMICOLON);
        break;
      }

      case SV3_1aParser::THIS:
      case SV3_1aParser::RANDOMIZE:
      case SV3_1aParser::SAMPLE:
      case SV3_1aParser::Escaped_identifier:
      case SV3_1aParser::Simple_identifier: {
        enterOuterAlt(_localctx, 2);
        setState(2969);
        identifier();
        setState(2971);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == SV3_1aParser::Pound_Pound_delay

        || _la == SV3_1aParser::Pound_delay || _la == SV3_1aParser::POUND) {
          setState(2970);
          delay_control();
        }
        setState(2973);
        list_of_net_decl_assignments();
        setState(2974);
        match(SV3_1aParser::SEMICOLON);
        break;
      }

      case SV3_1aParser::INTERCONNECT: {
        enterOuterAlt(_localctx, 3);
        setState(2976);
        match(SV3_1aParser::INTERCONNECT);
        setState(2977);
        implicit_data_type();
        setState(2979);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == SV3_1aParser::Pound_Pound_delay

        || _la == SV3_1aParser::Pound_delay || _la == SV3_1aParser::POUND) {
          setState(2978);
          pound_delay_value();
        }
        setState(2981);
        identifier();
        setState(2985);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == SV3_1aParser::OPEN_BRACKET) {
          setState(2982);
          unpacked_dimension();
          setState(2987);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(2996);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == SV3_1aParser::COMMA) {
          setState(2988);
          match(SV3_1aParser::COMMA);
          setState(2989);
          identifier();
          setState(2993);
          _errHandler->sync(this);
          _la = _input->LA(1);
          while (_la == SV3_1aParser::OPEN_BRACKET) {
            setState(2990);
            unpacked_dimension();
            setState(2995);
            _errHandler->sync(this);
            _la = _input->LA(1);
          }
        }
        setState(2998);
        match(SV3_1aParser::SEMICOLON);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Type_declarationContext ------------------------------------------------------------------

SV3_1aParser::Type_declarationContext::Type_declarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Type_declarationContext::TYPEDEF() {
  return getToken(SV3_1aParser::TYPEDEF, 0);
}

tree::TerminalNode* SV3_1aParser::Type_declarationContext::SEMICOLON() {
  return getToken(SV3_1aParser::SEMICOLON, 0);
}

std::vector<SV3_1aParser::IdentifierContext *> SV3_1aParser::Type_declarationContext::identifier() {
  return getRuleContexts<SV3_1aParser::IdentifierContext>();
}

SV3_1aParser::IdentifierContext* SV3_1aParser::Type_declarationContext::identifier(size_t i) {
  return getRuleContext<SV3_1aParser::IdentifierContext>(i);
}

SV3_1aParser::Constant_bit_selectContext* SV3_1aParser::Type_declarationContext::constant_bit_select() {
  return getRuleContext<SV3_1aParser::Constant_bit_selectContext>(0);
}

tree::TerminalNode* SV3_1aParser::Type_declarationContext::DOT() {
  return getToken(SV3_1aParser::DOT, 0);
}

SV3_1aParser::Data_typeContext* SV3_1aParser::Type_declarationContext::data_type() {
  return getRuleContext<SV3_1aParser::Data_typeContext>(0);
}

SV3_1aParser::Net_typeContext* SV3_1aParser::Type_declarationContext::net_type() {
  return getRuleContext<SV3_1aParser::Net_typeContext>(0);
}

std::vector<SV3_1aParser::Variable_dimensionContext *> SV3_1aParser::Type_declarationContext::variable_dimension() {
  return getRuleContexts<SV3_1aParser::Variable_dimensionContext>();
}

SV3_1aParser::Variable_dimensionContext* SV3_1aParser::Type_declarationContext::variable_dimension(size_t i) {
  return getRuleContext<SV3_1aParser::Variable_dimensionContext>(i);
}

SV3_1aParser::Enum_keywordContext* SV3_1aParser::Type_declarationContext::enum_keyword() {
  return getRuleContext<SV3_1aParser::Enum_keywordContext>(0);
}

SV3_1aParser::Struct_keywordContext* SV3_1aParser::Type_declarationContext::struct_keyword() {
  return getRuleContext<SV3_1aParser::Struct_keywordContext>(0);
}

SV3_1aParser::Union_keywordContext* SV3_1aParser::Type_declarationContext::union_keyword() {
  return getRuleContext<SV3_1aParser::Union_keywordContext>(0);
}

SV3_1aParser::Class_keywordContext* SV3_1aParser::Type_declarationContext::class_keyword() {
  return getRuleContext<SV3_1aParser::Class_keywordContext>(0);
}

SV3_1aParser::Interface_class_keywordContext* SV3_1aParser::Type_declarationContext::interface_class_keyword() {
  return getRuleContext<SV3_1aParser::Interface_class_keywordContext>(0);
}


size_t SV3_1aParser::Type_declarationContext::getRuleIndex() const {
  return SV3_1aParser::RuleType_declaration;
}

void SV3_1aParser::Type_declarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterType_declaration(this);
}

void SV3_1aParser::Type_declarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitType_declaration(this);
}

SV3_1aParser::Type_declarationContext* SV3_1aParser::type_declaration() {
  Type_declarationContext *_localctx = _tracker.createInstance<Type_declarationContext>(_ctx, getState());
  enterRule(_localctx, 218, SV3_1aParser::RuleType_declaration);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3002);
    match(SV3_1aParser::TYPEDEF);
    setState(3028);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 253, _ctx)) {
    case 1: {
      setState(3005);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case SV3_1aParser::VIRTUAL:
        case SV3_1aParser::TYPE:
        case SV3_1aParser::ENUM:
        case SV3_1aParser::STRUCT:
        case SV3_1aParser::UNION:
        case SV3_1aParser::STRING:
        case SV3_1aParser::CHANDLE:
        case SV3_1aParser::EVENT:
        case SV3_1aParser::BYTE:
        case SV3_1aParser::SHORTINT:
        case SV3_1aParser::INT:
        case SV3_1aParser::LONGINT:
        case SV3_1aParser::INTEGER:
        case SV3_1aParser::TIME:
        case SV3_1aParser::BIT:
        case SV3_1aParser::LOGIC:
        case SV3_1aParser::REG:
        case SV3_1aParser::SHORTREAL:
        case SV3_1aParser::REAL:
        case SV3_1aParser::REALTIME:
        case SV3_1aParser::DOLLAR_UNIT:
        case SV3_1aParser::THIS:
        case SV3_1aParser::RANDOMIZE:
        case SV3_1aParser::SAMPLE:
        case SV3_1aParser::Escaped_identifier:
        case SV3_1aParser::Simple_identifier: {
          setState(3003);
          data_type();
          break;
        }

        case SV3_1aParser::SUPPLY0:
        case SV3_1aParser::SUPPLY1:
        case SV3_1aParser::TRI:
        case SV3_1aParser::TRIAND:
        case SV3_1aParser::TRIOR:
        case SV3_1aParser::TRI0:
        case SV3_1aParser::TRI1:
        case SV3_1aParser::WIRE:
        case SV3_1aParser::UWIRE:
        case SV3_1aParser::WAND:
        case SV3_1aParser::WOR:
        case SV3_1aParser::TRIREG: {
          setState(3004);
          net_type();
          break;
        }

      default:
        throw NoViableAltException(this);
      }
      setState(3007);
      identifier();
      setState(3011);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == SV3_1aParser::ASSOCIATIVE_UNSPECIFIED || _la == SV3_1aParser::OPEN_BRACKET) {
        setState(3008);
        variable_dimension();
        setState(3013);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      break;
    }

    case 2: {
      setState(3014);
      identifier();
      setState(3015);
      constant_bit_select();
      setState(3016);
      match(SV3_1aParser::DOT);
      setState(3017);
      identifier();
      setState(3018);
      identifier();
      break;
    }

    case 3: {
      setState(3025);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case SV3_1aParser::ENUM: {
          setState(3020);
          enum_keyword();
          break;
        }

        case SV3_1aParser::STRUCT: {
          setState(3021);
          struct_keyword();
          break;
        }

        case SV3_1aParser::UNION: {
          setState(3022);
          union_keyword();
          break;
        }

        case SV3_1aParser::CLASS: {
          setState(3023);
          class_keyword();
          break;
        }

        case SV3_1aParser::INTERFACE: {
          setState(3024);
          interface_class_keyword();
          break;
        }

        case SV3_1aParser::THIS:
        case SV3_1aParser::RANDOMIZE:
        case SV3_1aParser::SAMPLE:
        case SV3_1aParser::Escaped_identifier:
        case SV3_1aParser::Simple_identifier: {
          break;
        }

      default:
        break;
      }
      setState(3027);
      identifier();
      break;
    }

    default:
      break;
    }
    setState(3030);
    match(SV3_1aParser::SEMICOLON);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Enum_keywordContext ------------------------------------------------------------------

SV3_1aParser::Enum_keywordContext::Enum_keywordContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Enum_keywordContext::ENUM() {
  return getToken(SV3_1aParser::ENUM, 0);
}


size_t SV3_1aParser::Enum_keywordContext::getRuleIndex() const {
  return SV3_1aParser::RuleEnum_keyword;
}

void SV3_1aParser::Enum_keywordContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterEnum_keyword(this);
}

void SV3_1aParser::Enum_keywordContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitEnum_keyword(this);
}

SV3_1aParser::Enum_keywordContext* SV3_1aParser::enum_keyword() {
  Enum_keywordContext *_localctx = _tracker.createInstance<Enum_keywordContext>(_ctx, getState());
  enterRule(_localctx, 220, SV3_1aParser::RuleEnum_keyword);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3032);
    match(SV3_1aParser::ENUM);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Struct_keywordContext ------------------------------------------------------------------

SV3_1aParser::Struct_keywordContext::Struct_keywordContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Struct_keywordContext::STRUCT() {
  return getToken(SV3_1aParser::STRUCT, 0);
}


size_t SV3_1aParser::Struct_keywordContext::getRuleIndex() const {
  return SV3_1aParser::RuleStruct_keyword;
}

void SV3_1aParser::Struct_keywordContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterStruct_keyword(this);
}

void SV3_1aParser::Struct_keywordContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitStruct_keyword(this);
}

SV3_1aParser::Struct_keywordContext* SV3_1aParser::struct_keyword() {
  Struct_keywordContext *_localctx = _tracker.createInstance<Struct_keywordContext>(_ctx, getState());
  enterRule(_localctx, 222, SV3_1aParser::RuleStruct_keyword);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3034);
    match(SV3_1aParser::STRUCT);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Union_keywordContext ------------------------------------------------------------------

SV3_1aParser::Union_keywordContext::Union_keywordContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Union_keywordContext::UNION() {
  return getToken(SV3_1aParser::UNION, 0);
}


size_t SV3_1aParser::Union_keywordContext::getRuleIndex() const {
  return SV3_1aParser::RuleUnion_keyword;
}

void SV3_1aParser::Union_keywordContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUnion_keyword(this);
}

void SV3_1aParser::Union_keywordContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUnion_keyword(this);
}

SV3_1aParser::Union_keywordContext* SV3_1aParser::union_keyword() {
  Union_keywordContext *_localctx = _tracker.createInstance<Union_keywordContext>(_ctx, getState());
  enterRule(_localctx, 224, SV3_1aParser::RuleUnion_keyword);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3036);
    match(SV3_1aParser::UNION);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Class_keywordContext ------------------------------------------------------------------

SV3_1aParser::Class_keywordContext::Class_keywordContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Class_keywordContext::CLASS() {
  return getToken(SV3_1aParser::CLASS, 0);
}


size_t SV3_1aParser::Class_keywordContext::getRuleIndex() const {
  return SV3_1aParser::RuleClass_keyword;
}

void SV3_1aParser::Class_keywordContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterClass_keyword(this);
}

void SV3_1aParser::Class_keywordContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitClass_keyword(this);
}

SV3_1aParser::Class_keywordContext* SV3_1aParser::class_keyword() {
  Class_keywordContext *_localctx = _tracker.createInstance<Class_keywordContext>(_ctx, getState());
  enterRule(_localctx, 226, SV3_1aParser::RuleClass_keyword);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3038);
    match(SV3_1aParser::CLASS);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Interface_class_keywordContext ------------------------------------------------------------------

SV3_1aParser::Interface_class_keywordContext::Interface_class_keywordContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Interface_class_keywordContext::INTERFACE() {
  return getToken(SV3_1aParser::INTERFACE, 0);
}

tree::TerminalNode* SV3_1aParser::Interface_class_keywordContext::CLASS() {
  return getToken(SV3_1aParser::CLASS, 0);
}


size_t SV3_1aParser::Interface_class_keywordContext::getRuleIndex() const {
  return SV3_1aParser::RuleInterface_class_keyword;
}

void SV3_1aParser::Interface_class_keywordContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInterface_class_keyword(this);
}

void SV3_1aParser::Interface_class_keywordContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInterface_class_keyword(this);
}

SV3_1aParser::Interface_class_keywordContext* SV3_1aParser::interface_class_keyword() {
  Interface_class_keywordContext *_localctx = _tracker.createInstance<Interface_class_keywordContext>(_ctx, getState());
  enterRule(_localctx, 228, SV3_1aParser::RuleInterface_class_keyword);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3040);
    match(SV3_1aParser::INTERFACE);
    setState(3041);
    match(SV3_1aParser::CLASS);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Net_type_declarationContext ------------------------------------------------------------------

SV3_1aParser::Net_type_declarationContext::Net_type_declarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Net_type_declarationContext::NETTYPE() {
  return getToken(SV3_1aParser::NETTYPE, 0);
}

tree::TerminalNode* SV3_1aParser::Net_type_declarationContext::SEMICOLON() {
  return getToken(SV3_1aParser::SEMICOLON, 0);
}

SV3_1aParser::Data_typeContext* SV3_1aParser::Net_type_declarationContext::data_type() {
  return getRuleContext<SV3_1aParser::Data_typeContext>(0);
}

std::vector<SV3_1aParser::IdentifierContext *> SV3_1aParser::Net_type_declarationContext::identifier() {
  return getRuleContexts<SV3_1aParser::IdentifierContext>();
}

SV3_1aParser::IdentifierContext* SV3_1aParser::Net_type_declarationContext::identifier(size_t i) {
  return getRuleContext<SV3_1aParser::IdentifierContext>(i);
}

tree::TerminalNode* SV3_1aParser::Net_type_declarationContext::WITH() {
  return getToken(SV3_1aParser::WITH, 0);
}

SV3_1aParser::Package_scopeContext* SV3_1aParser::Net_type_declarationContext::package_scope() {
  return getRuleContext<SV3_1aParser::Package_scopeContext>(0);
}

SV3_1aParser::Class_scopeContext* SV3_1aParser::Net_type_declarationContext::class_scope() {
  return getRuleContext<SV3_1aParser::Class_scopeContext>(0);
}


size_t SV3_1aParser::Net_type_declarationContext::getRuleIndex() const {
  return SV3_1aParser::RuleNet_type_declaration;
}

void SV3_1aParser::Net_type_declarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNet_type_declaration(this);
}

void SV3_1aParser::Net_type_declarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNet_type_declaration(this);
}

SV3_1aParser::Net_type_declarationContext* SV3_1aParser::net_type_declaration() {
  Net_type_declarationContext *_localctx = _tracker.createInstance<Net_type_declarationContext>(_ctx, getState());
  enterRule(_localctx, 230, SV3_1aParser::RuleNet_type_declaration);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3043);
    match(SV3_1aParser::NETTYPE);
    setState(3061);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 257, _ctx)) {
    case 1: {
      setState(3044);
      data_type();
      setState(3045);
      identifier();
      setState(3052);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == SV3_1aParser::WITH) {
        setState(3046);
        match(SV3_1aParser::WITH);
        setState(3049);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 254, _ctx)) {
        case 1: {
          setState(3047);
          package_scope();
          break;
        }

        case 2: {
          setState(3048);
          class_scope();
          break;
        }

        default:
          break;
        }
        setState(3051);
        identifier();
      }
      break;
    }

    case 2: {
      setState(3056);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 256, _ctx)) {
      case 1: {
        setState(3054);
        package_scope();
        break;
      }

      case 2: {
        setState(3055);
        class_scope();
        break;
      }

      default:
        break;
      }
      setState(3058);
      identifier();
      setState(3059);
      identifier();
      break;
    }

    default:
      break;
    }
    setState(3063);
    match(SV3_1aParser::SEMICOLON);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LifetimeContext ------------------------------------------------------------------

SV3_1aParser::LifetimeContext::LifetimeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t SV3_1aParser::LifetimeContext::getRuleIndex() const {
  return SV3_1aParser::RuleLifetime;
}

void SV3_1aParser::LifetimeContext::copyFrom(LifetimeContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- Lifetime_StaticContext ------------------------------------------------------------------

tree::TerminalNode* SV3_1aParser::Lifetime_StaticContext::STATIC() {
  return getToken(SV3_1aParser::STATIC, 0);
}

SV3_1aParser::Lifetime_StaticContext::Lifetime_StaticContext(LifetimeContext *ctx) { copyFrom(ctx); }

void SV3_1aParser::Lifetime_StaticContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLifetime_Static(this);
}
void SV3_1aParser::Lifetime_StaticContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLifetime_Static(this);
}
//----------------- Lifetime_AutomaticContext ------------------------------------------------------------------

tree::TerminalNode* SV3_1aParser::Lifetime_AutomaticContext::AUTOMATIC() {
  return getToken(SV3_1aParser::AUTOMATIC, 0);
}

SV3_1aParser::Lifetime_AutomaticContext::Lifetime_AutomaticContext(LifetimeContext *ctx) { copyFrom(ctx); }

void SV3_1aParser::Lifetime_AutomaticContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLifetime_Automatic(this);
}
void SV3_1aParser::Lifetime_AutomaticContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLifetime_Automatic(this);
}
SV3_1aParser::LifetimeContext* SV3_1aParser::lifetime() {
  LifetimeContext *_localctx = _tracker.createInstance<LifetimeContext>(_ctx, getState());
  enterRule(_localctx, 232, SV3_1aParser::RuleLifetime);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(3067);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SV3_1aParser::STATIC: {
        _localctx = _tracker.createInstance<SV3_1aParser::Lifetime_StaticContext>(_localctx);
        enterOuterAlt(_localctx, 1);
        setState(3065);
        match(SV3_1aParser::STATIC);
        break;
      }

      case SV3_1aParser::AUTOMATIC: {
        _localctx = _tracker.createInstance<SV3_1aParser::Lifetime_AutomaticContext>(_localctx);
        enterOuterAlt(_localctx, 2);
        setState(3066);
        match(SV3_1aParser::AUTOMATIC);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Casting_typeContext ------------------------------------------------------------------

SV3_1aParser::Casting_typeContext::Casting_typeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::Simple_typeContext* SV3_1aParser::Casting_typeContext::simple_type() {
  return getRuleContext<SV3_1aParser::Simple_typeContext>(0);
}

SV3_1aParser::Primary_literalContext* SV3_1aParser::Casting_typeContext::primary_literal() {
  return getRuleContext<SV3_1aParser::Primary_literalContext>(0);
}

SV3_1aParser::IdentifierContext* SV3_1aParser::Casting_typeContext::identifier() {
  return getRuleContext<SV3_1aParser::IdentifierContext>(0);
}

SV3_1aParser::Constant_selectContext* SV3_1aParser::Casting_typeContext::constant_select() {
  return getRuleContext<SV3_1aParser::Constant_selectContext>(0);
}

SV3_1aParser::Package_scopeContext* SV3_1aParser::Casting_typeContext::package_scope() {
  return getRuleContext<SV3_1aParser::Package_scopeContext>(0);
}

SV3_1aParser::Class_scopeContext* SV3_1aParser::Casting_typeContext::class_scope() {
  return getRuleContext<SV3_1aParser::Class_scopeContext>(0);
}

tree::TerminalNode* SV3_1aParser::Casting_typeContext::OPEN_BRACKET() {
  return getToken(SV3_1aParser::OPEN_BRACKET, 0);
}

SV3_1aParser::Constant_range_expressionContext* SV3_1aParser::Casting_typeContext::constant_range_expression() {
  return getRuleContext<SV3_1aParser::Constant_range_expressionContext>(0);
}

tree::TerminalNode* SV3_1aParser::Casting_typeContext::CLOSE_BRACKET() {
  return getToken(SV3_1aParser::CLOSE_BRACKET, 0);
}

tree::TerminalNode* SV3_1aParser::Casting_typeContext::OPEN_PARENS() {
  return getToken(SV3_1aParser::OPEN_PARENS, 0);
}

SV3_1aParser::Constant_expressionContext* SV3_1aParser::Casting_typeContext::constant_expression() {
  return getRuleContext<SV3_1aParser::Constant_expressionContext>(0);
}

tree::TerminalNode* SV3_1aParser::Casting_typeContext::CLOSE_PARENS() {
  return getToken(SV3_1aParser::CLOSE_PARENS, 0);
}

SV3_1aParser::SigningContext* SV3_1aParser::Casting_typeContext::signing() {
  return getRuleContext<SV3_1aParser::SigningContext>(0);
}

SV3_1aParser::String_typeContext* SV3_1aParser::Casting_typeContext::string_type() {
  return getRuleContext<SV3_1aParser::String_typeContext>(0);
}

SV3_1aParser::Const_typeContext* SV3_1aParser::Casting_typeContext::const_type() {
  return getRuleContext<SV3_1aParser::Const_typeContext>(0);
}

SV3_1aParser::System_taskContext* SV3_1aParser::Casting_typeContext::system_task() {
  return getRuleContext<SV3_1aParser::System_taskContext>(0);
}


size_t SV3_1aParser::Casting_typeContext::getRuleIndex() const {
  return SV3_1aParser::RuleCasting_type;
}

void SV3_1aParser::Casting_typeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCasting_type(this);
}

void SV3_1aParser::Casting_typeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCasting_type(this);
}

SV3_1aParser::Casting_typeContext* SV3_1aParser::casting_type() {
  Casting_typeContext *_localctx = _tracker.createInstance<Casting_typeContext>(_ctx, getState());
  enterRule(_localctx, 234, SV3_1aParser::RuleCasting_type);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(3091);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 261, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(3069);
      simple_type();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(3070);
      primary_literal();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(3073);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 259, _ctx)) {
      case 1: {
        setState(3071);
        package_scope();
        break;
      }

      case 2: {
        setState(3072);
        class_scope();
        break;
      }

      default:
        break;
      }
      setState(3075);
      identifier();
      setState(3076);
      constant_select();
      setState(3081);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == SV3_1aParser::OPEN_BRACKET) {
        setState(3077);
        match(SV3_1aParser::OPEN_BRACKET);
        setState(3078);
        constant_range_expression();
        setState(3079);
        match(SV3_1aParser::CLOSE_BRACKET);
      }
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(3083);
      match(SV3_1aParser::OPEN_PARENS);
      setState(3084);
      constant_expression(0);
      setState(3085);
      match(SV3_1aParser::CLOSE_PARENS);
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(3087);
      signing();
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(3088);
      string_type();
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(3089);
      const_type();
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(3090);
      system_task();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Data_typeContext ------------------------------------------------------------------

SV3_1aParser::Data_typeContext::Data_typeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::Integer_vector_typeContext* SV3_1aParser::Data_typeContext::integer_vector_type() {
  return getRuleContext<SV3_1aParser::Integer_vector_typeContext>(0);
}

SV3_1aParser::SigningContext* SV3_1aParser::Data_typeContext::signing() {
  return getRuleContext<SV3_1aParser::SigningContext>(0);
}

std::vector<SV3_1aParser::Packed_dimensionContext *> SV3_1aParser::Data_typeContext::packed_dimension() {
  return getRuleContexts<SV3_1aParser::Packed_dimensionContext>();
}

SV3_1aParser::Packed_dimensionContext* SV3_1aParser::Data_typeContext::packed_dimension(size_t i) {
  return getRuleContext<SV3_1aParser::Packed_dimensionContext>(i);
}

SV3_1aParser::Integer_atom_typeContext* SV3_1aParser::Data_typeContext::integer_atom_type() {
  return getRuleContext<SV3_1aParser::Integer_atom_typeContext>(0);
}

SV3_1aParser::Non_integer_typeContext* SV3_1aParser::Data_typeContext::non_integer_type() {
  return getRuleContext<SV3_1aParser::Non_integer_typeContext>(0);
}

SV3_1aParser::Struct_unionContext* SV3_1aParser::Data_typeContext::struct_union() {
  return getRuleContext<SV3_1aParser::Struct_unionContext>(0);
}

tree::TerminalNode* SV3_1aParser::Data_typeContext::OPEN_CURLY() {
  return getToken(SV3_1aParser::OPEN_CURLY, 0);
}

std::vector<SV3_1aParser::Struct_union_memberContext *> SV3_1aParser::Data_typeContext::struct_union_member() {
  return getRuleContexts<SV3_1aParser::Struct_union_memberContext>();
}

SV3_1aParser::Struct_union_memberContext* SV3_1aParser::Data_typeContext::struct_union_member(size_t i) {
  return getRuleContext<SV3_1aParser::Struct_union_memberContext>(i);
}

tree::TerminalNode* SV3_1aParser::Data_typeContext::CLOSE_CURLY() {
  return getToken(SV3_1aParser::CLOSE_CURLY, 0);
}

SV3_1aParser::Packed_keywordContext* SV3_1aParser::Data_typeContext::packed_keyword() {
  return getRuleContext<SV3_1aParser::Packed_keywordContext>(0);
}

tree::TerminalNode* SV3_1aParser::Data_typeContext::ENUM() {
  return getToken(SV3_1aParser::ENUM, 0);
}

std::vector<SV3_1aParser::Enum_name_declarationContext *> SV3_1aParser::Data_typeContext::enum_name_declaration() {
  return getRuleContexts<SV3_1aParser::Enum_name_declarationContext>();
}

SV3_1aParser::Enum_name_declarationContext* SV3_1aParser::Data_typeContext::enum_name_declaration(size_t i) {
  return getRuleContext<SV3_1aParser::Enum_name_declarationContext>(i);
}

SV3_1aParser::Enum_base_typeContext* SV3_1aParser::Data_typeContext::enum_base_type() {
  return getRuleContext<SV3_1aParser::Enum_base_typeContext>(0);
}

std::vector<tree::TerminalNode *> SV3_1aParser::Data_typeContext::COMMA() {
  return getTokens(SV3_1aParser::COMMA);
}

tree::TerminalNode* SV3_1aParser::Data_typeContext::COMMA(size_t i) {
  return getToken(SV3_1aParser::COMMA, i);
}

SV3_1aParser::String_typeContext* SV3_1aParser::Data_typeContext::string_type() {
  return getRuleContext<SV3_1aParser::String_typeContext>(0);
}

SV3_1aParser::Chandle_typeContext* SV3_1aParser::Data_typeContext::chandle_type() {
  return getRuleContext<SV3_1aParser::Chandle_typeContext>(0);
}

tree::TerminalNode* SV3_1aParser::Data_typeContext::VIRTUAL() {
  return getToken(SV3_1aParser::VIRTUAL, 0);
}

SV3_1aParser::Interface_identifierContext* SV3_1aParser::Data_typeContext::interface_identifier() {
  return getRuleContext<SV3_1aParser::Interface_identifierContext>(0);
}

tree::TerminalNode* SV3_1aParser::Data_typeContext::INTERFACE() {
  return getToken(SV3_1aParser::INTERFACE, 0);
}

std::vector<SV3_1aParser::Parameter_value_assignmentContext *> SV3_1aParser::Data_typeContext::parameter_value_assignment() {
  return getRuleContexts<SV3_1aParser::Parameter_value_assignmentContext>();
}

SV3_1aParser::Parameter_value_assignmentContext* SV3_1aParser::Data_typeContext::parameter_value_assignment(size_t i) {
  return getRuleContext<SV3_1aParser::Parameter_value_assignmentContext>(i);
}

tree::TerminalNode* SV3_1aParser::Data_typeContext::DOT() {
  return getToken(SV3_1aParser::DOT, 0);
}

std::vector<SV3_1aParser::IdentifierContext *> SV3_1aParser::Data_typeContext::identifier() {
  return getRuleContexts<SV3_1aParser::IdentifierContext>();
}

SV3_1aParser::IdentifierContext* SV3_1aParser::Data_typeContext::identifier(size_t i) {
  return getRuleContext<SV3_1aParser::IdentifierContext>(i);
}

SV3_1aParser::Class_scopeContext* SV3_1aParser::Data_typeContext::class_scope() {
  return getRuleContext<SV3_1aParser::Class_scopeContext>(0);
}

SV3_1aParser::Package_scopeContext* SV3_1aParser::Data_typeContext::package_scope() {
  return getRuleContext<SV3_1aParser::Package_scopeContext>(0);
}

std::vector<tree::TerminalNode *> SV3_1aParser::Data_typeContext::COLONCOLON() {
  return getTokens(SV3_1aParser::COLONCOLON);
}

tree::TerminalNode* SV3_1aParser::Data_typeContext::COLONCOLON(size_t i) {
  return getToken(SV3_1aParser::COLONCOLON, i);
}

SV3_1aParser::Event_typeContext* SV3_1aParser::Data_typeContext::event_type() {
  return getRuleContext<SV3_1aParser::Event_typeContext>(0);
}

SV3_1aParser::Type_referenceContext* SV3_1aParser::Data_typeContext::type_reference() {
  return getRuleContext<SV3_1aParser::Type_referenceContext>(0);
}


size_t SV3_1aParser::Data_typeContext::getRuleIndex() const {
  return SV3_1aParser::RuleData_type;
}

void SV3_1aParser::Data_typeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterData_type(this);
}

void SV3_1aParser::Data_typeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitData_type(this);
}

SV3_1aParser::Data_typeContext* SV3_1aParser::data_type() {
  Data_typeContext *_localctx = _tracker.createInstance<Data_typeContext>(_ctx, getState());
  enterRule(_localctx, 236, SV3_1aParser::RuleData_type);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(3186);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SV3_1aParser::BIT:
      case SV3_1aParser::LOGIC:
      case SV3_1aParser::REG: {
        enterOuterAlt(_localctx, 1);
        setState(3093);
        integer_vector_type();
        setState(3095);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == SV3_1aParser::SIGNED

        || _la == SV3_1aParser::UNSIGNED) {
          setState(3094);
          signing();
        }
        setState(3100);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == SV3_1aParser::OPEN_BRACKET) {
          setState(3097);
          packed_dimension();
          setState(3102);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        break;
      }

      case SV3_1aParser::BYTE:
      case SV3_1aParser::SHORTINT:
      case SV3_1aParser::INT:
      case SV3_1aParser::LONGINT:
      case SV3_1aParser::INTEGER:
      case SV3_1aParser::TIME: {
        enterOuterAlt(_localctx, 2);
        setState(3103);
        integer_atom_type();
        setState(3105);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == SV3_1aParser::SIGNED

        || _la == SV3_1aParser::UNSIGNED) {
          setState(3104);
          signing();
        }
        break;
      }

      case SV3_1aParser::SHORTREAL:
      case SV3_1aParser::REAL:
      case SV3_1aParser::REALTIME: {
        enterOuterAlt(_localctx, 3);
        setState(3107);
        non_integer_type();
        break;
      }

      case SV3_1aParser::STRUCT:
      case SV3_1aParser::UNION: {
        enterOuterAlt(_localctx, 4);
        setState(3108);
        struct_union();
        setState(3113);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == SV3_1aParser::PACKED) {
          setState(3109);
          packed_keyword();
          setState(3111);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if (_la == SV3_1aParser::SIGNED

          || _la == SV3_1aParser::UNSIGNED) {
            setState(3110);
            signing();
          }
        }
        setState(3115);
        match(SV3_1aParser::OPEN_CURLY);
        setState(3116);
        struct_union_member();
        setState(3120);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == SV3_1aParser::VIRTUAL || ((((_la - 64) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 64)) & 1152705450572185601) != 0) || ((((_la - 151) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 151)) & 412316860417) != 0) || ((((_la - 326) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 326)) & 4672924483589) != 0)) {
          setState(3117);
          struct_union_member();
          setState(3122);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(3123);
        match(SV3_1aParser::CLOSE_CURLY);
        setState(3127);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == SV3_1aParser::OPEN_BRACKET) {
          setState(3124);
          packed_dimension();
          setState(3129);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        break;
      }

      case SV3_1aParser::ENUM: {
        enterOuterAlt(_localctx, 5);
        setState(3130);
        match(SV3_1aParser::ENUM);
        setState(3132);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (((((_la - 112) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 112)) & 511) != 0) || ((((_la - 326) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 326)) & 4672924483589) != 0)) {
          setState(3131);
          enum_base_type();
        }
        setState(3134);
        match(SV3_1aParser::OPEN_CURLY);
        setState(3135);
        enum_name_declaration();
        setState(3140);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == SV3_1aParser::COMMA) {
          setState(3136);
          match(SV3_1aParser::COMMA);
          setState(3137);
          enum_name_declaration();
          setState(3142);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(3143);
        match(SV3_1aParser::CLOSE_CURLY);
        break;
      }

      case SV3_1aParser::STRING: {
        enterOuterAlt(_localctx, 6);
        setState(3145);
        string_type();
        break;
      }

      case SV3_1aParser::CHANDLE: {
        enterOuterAlt(_localctx, 7);
        setState(3146);
        chandle_type();
        break;
      }

      case SV3_1aParser::VIRTUAL: {
        enterOuterAlt(_localctx, 8);
        setState(3147);
        match(SV3_1aParser::VIRTUAL);
        setState(3149);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == SV3_1aParser::INTERFACE) {
          setState(3148);
          match(SV3_1aParser::INTERFACE);
        }
        setState(3151);
        interface_identifier();
        setState(3153);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 272, _ctx)) {
        case 1: {
          setState(3152);
          parameter_value_assignment();
          break;
        }

        default:
          break;
        }
        setState(3157);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 273, _ctx)) {
        case 1: {
          setState(3155);
          match(SV3_1aParser::DOT);
          setState(3156);
          identifier();
          break;
        }

        default:
          break;
        }
        break;
      }

      case SV3_1aParser::DOLLAR_UNIT:
      case SV3_1aParser::THIS:
      case SV3_1aParser::RANDOMIZE:
      case SV3_1aParser::SAMPLE:
      case SV3_1aParser::Escaped_identifier:
      case SV3_1aParser::Simple_identifier: {
        enterOuterAlt(_localctx, 9);
        setState(3161);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 274, _ctx)) {
        case 1: {
          setState(3159);
          class_scope();
          break;
        }

        case 2: {
          setState(3160);
          package_scope();
          break;
        }

        default:
          break;
        }
        setState(3163);
        identifier();
        setState(3182);
        _errHandler->sync(this);
        switch (_input->LA(1)) {
          case SV3_1aParser::OPEN_BRACKET: {
            setState(3165); 
            _errHandler->sync(this);
            _la = _input->LA(1);
            do {
              setState(3164);
              packed_dimension();
              setState(3167); 
              _errHandler->sync(this);
              _la = _input->LA(1);
            } while (_la == SV3_1aParser::OPEN_BRACKET);
            break;
          }

          case SV3_1aParser::Pound_Pound_delay:
          case SV3_1aParser::Pound_delay:
          case SV3_1aParser::COMMA:
          case SV3_1aParser::SEMICOLON:
          case SV3_1aParser::COLONCOLON:
          case SV3_1aParser::DOT:
          case SV3_1aParser::CLOSE_PARENS:
          case SV3_1aParser::CLOSE_BRACKET:
          case SV3_1aParser::DOLLAR_UNIT:
          case SV3_1aParser::POUND:
          case SV3_1aParser::THIS:
          case SV3_1aParser::DOLLAR_ROOT:
          case SV3_1aParser::RANDOMIZE:
          case SV3_1aParser::SAMPLE:
          case SV3_1aParser::Escaped_identifier:
          case SV3_1aParser::Simple_identifier: {
            setState(3170);
            _errHandler->sync(this);

            switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 276, _ctx)) {
            case 1: {
              setState(3169);
              parameter_value_assignment();
              break;
            }

            default:
              break;
            }
            setState(3179);
            _errHandler->sync(this);
            _la = _input->LA(1);
            while (_la == SV3_1aParser::COLONCOLON) {
              setState(3172);
              match(SV3_1aParser::COLONCOLON);
              setState(3173);
              identifier();
              setState(3175);
              _errHandler->sync(this);

              switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 277, _ctx)) {
              case 1: {
                setState(3174);
                parameter_value_assignment();
                break;
              }

              default:
                break;
              }
              setState(3181);
              _errHandler->sync(this);
              _la = _input->LA(1);
            }
            break;
          }

        default:
          throw NoViableAltException(this);
        }
        break;
      }

      case SV3_1aParser::EVENT: {
        enterOuterAlt(_localctx, 10);
        setState(3184);
        event_type();
        break;
      }

      case SV3_1aParser::TYPE: {
        enterOuterAlt(_localctx, 11);
        setState(3185);
        type_reference();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Packed_keywordContext ------------------------------------------------------------------

SV3_1aParser::Packed_keywordContext::Packed_keywordContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Packed_keywordContext::PACKED() {
  return getToken(SV3_1aParser::PACKED, 0);
}


size_t SV3_1aParser::Packed_keywordContext::getRuleIndex() const {
  return SV3_1aParser::RulePacked_keyword;
}

void SV3_1aParser::Packed_keywordContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPacked_keyword(this);
}

void SV3_1aParser::Packed_keywordContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPacked_keyword(this);
}

SV3_1aParser::Packed_keywordContext* SV3_1aParser::packed_keyword() {
  Packed_keywordContext *_localctx = _tracker.createInstance<Packed_keywordContext>(_ctx, getState());
  enterRule(_localctx, 238, SV3_1aParser::RulePacked_keyword);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3188);
    match(SV3_1aParser::PACKED);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- String_typeContext ------------------------------------------------------------------

SV3_1aParser::String_typeContext::String_typeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::String_typeContext::STRING() {
  return getToken(SV3_1aParser::STRING, 0);
}


size_t SV3_1aParser::String_typeContext::getRuleIndex() const {
  return SV3_1aParser::RuleString_type;
}

void SV3_1aParser::String_typeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterString_type(this);
}

void SV3_1aParser::String_typeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitString_type(this);
}

SV3_1aParser::String_typeContext* SV3_1aParser::string_type() {
  String_typeContext *_localctx = _tracker.createInstance<String_typeContext>(_ctx, getState());
  enterRule(_localctx, 240, SV3_1aParser::RuleString_type);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3190);
    match(SV3_1aParser::STRING);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- String_valueContext ------------------------------------------------------------------

SV3_1aParser::String_valueContext::String_valueContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::String_valueContext::String() {
  return getToken(SV3_1aParser::String, 0);
}


size_t SV3_1aParser::String_valueContext::getRuleIndex() const {
  return SV3_1aParser::RuleString_value;
}

void SV3_1aParser::String_valueContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterString_value(this);
}

void SV3_1aParser::String_valueContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitString_value(this);
}

SV3_1aParser::String_valueContext* SV3_1aParser::string_value() {
  String_valueContext *_localctx = _tracker.createInstance<String_valueContext>(_ctx, getState());
  enterRule(_localctx, 242, SV3_1aParser::RuleString_value);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3192);
    match(SV3_1aParser::String);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Chandle_typeContext ------------------------------------------------------------------

SV3_1aParser::Chandle_typeContext::Chandle_typeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Chandle_typeContext::CHANDLE() {
  return getToken(SV3_1aParser::CHANDLE, 0);
}


size_t SV3_1aParser::Chandle_typeContext::getRuleIndex() const {
  return SV3_1aParser::RuleChandle_type;
}

void SV3_1aParser::Chandle_typeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterChandle_type(this);
}

void SV3_1aParser::Chandle_typeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitChandle_type(this);
}

SV3_1aParser::Chandle_typeContext* SV3_1aParser::chandle_type() {
  Chandle_typeContext *_localctx = _tracker.createInstance<Chandle_typeContext>(_ctx, getState());
  enterRule(_localctx, 244, SV3_1aParser::RuleChandle_type);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3194);
    match(SV3_1aParser::CHANDLE);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Event_typeContext ------------------------------------------------------------------

SV3_1aParser::Event_typeContext::Event_typeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Event_typeContext::EVENT() {
  return getToken(SV3_1aParser::EVENT, 0);
}


size_t SV3_1aParser::Event_typeContext::getRuleIndex() const {
  return SV3_1aParser::RuleEvent_type;
}

void SV3_1aParser::Event_typeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterEvent_type(this);
}

void SV3_1aParser::Event_typeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitEvent_type(this);
}

SV3_1aParser::Event_typeContext* SV3_1aParser::event_type() {
  Event_typeContext *_localctx = _tracker.createInstance<Event_typeContext>(_ctx, getState());
  enterRule(_localctx, 246, SV3_1aParser::RuleEvent_type);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3196);
    match(SV3_1aParser::EVENT);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Const_typeContext ------------------------------------------------------------------

SV3_1aParser::Const_typeContext::Const_typeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Const_typeContext::CONST() {
  return getToken(SV3_1aParser::CONST, 0);
}


size_t SV3_1aParser::Const_typeContext::getRuleIndex() const {
  return SV3_1aParser::RuleConst_type;
}

void SV3_1aParser::Const_typeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterConst_type(this);
}

void SV3_1aParser::Const_typeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitConst_type(this);
}

SV3_1aParser::Const_typeContext* SV3_1aParser::const_type() {
  Const_typeContext *_localctx = _tracker.createInstance<Const_typeContext>(_ctx, getState());
  enterRule(_localctx, 248, SV3_1aParser::RuleConst_type);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3198);
    match(SV3_1aParser::CONST);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Var_typeContext ------------------------------------------------------------------

SV3_1aParser::Var_typeContext::Var_typeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Var_typeContext::VAR() {
  return getToken(SV3_1aParser::VAR, 0);
}


size_t SV3_1aParser::Var_typeContext::getRuleIndex() const {
  return SV3_1aParser::RuleVar_type;
}

void SV3_1aParser::Var_typeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterVar_type(this);
}

void SV3_1aParser::Var_typeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitVar_type(this);
}

SV3_1aParser::Var_typeContext* SV3_1aParser::var_type() {
  Var_typeContext *_localctx = _tracker.createInstance<Var_typeContext>(_ctx, getState());
  enterRule(_localctx, 250, SV3_1aParser::RuleVar_type);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3200);
    match(SV3_1aParser::VAR);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Data_type_or_implicitContext ------------------------------------------------------------------

SV3_1aParser::Data_type_or_implicitContext::Data_type_or_implicitContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::Data_typeContext* SV3_1aParser::Data_type_or_implicitContext::data_type() {
  return getRuleContext<SV3_1aParser::Data_typeContext>(0);
}

SV3_1aParser::SigningContext* SV3_1aParser::Data_type_or_implicitContext::signing() {
  return getRuleContext<SV3_1aParser::SigningContext>(0);
}

std::vector<SV3_1aParser::Packed_dimensionContext *> SV3_1aParser::Data_type_or_implicitContext::packed_dimension() {
  return getRuleContexts<SV3_1aParser::Packed_dimensionContext>();
}

SV3_1aParser::Packed_dimensionContext* SV3_1aParser::Data_type_or_implicitContext::packed_dimension(size_t i) {
  return getRuleContext<SV3_1aParser::Packed_dimensionContext>(i);
}


size_t SV3_1aParser::Data_type_or_implicitContext::getRuleIndex() const {
  return SV3_1aParser::RuleData_type_or_implicit;
}

void SV3_1aParser::Data_type_or_implicitContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterData_type_or_implicit(this);
}

void SV3_1aParser::Data_type_or_implicitContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitData_type_or_implicit(this);
}

SV3_1aParser::Data_type_or_implicitContext* SV3_1aParser::data_type_or_implicit() {
  Data_type_or_implicitContext *_localctx = _tracker.createInstance<Data_type_or_implicitContext>(_ctx, getState());
  enterRule(_localctx, 252, SV3_1aParser::RuleData_type_or_implicit);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(3212);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 283, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(3202);
      data_type();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(3204);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == SV3_1aParser::SIGNED

      || _la == SV3_1aParser::UNSIGNED) {
        setState(3203);
        signing();
      }
      setState(3209);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == SV3_1aParser::OPEN_BRACKET) {
        setState(3206);
        packed_dimension();
        setState(3211);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Implicit_data_typeContext ------------------------------------------------------------------

SV3_1aParser::Implicit_data_typeContext::Implicit_data_typeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::SigningContext* SV3_1aParser::Implicit_data_typeContext::signing() {
  return getRuleContext<SV3_1aParser::SigningContext>(0);
}

std::vector<SV3_1aParser::Packed_dimensionContext *> SV3_1aParser::Implicit_data_typeContext::packed_dimension() {
  return getRuleContexts<SV3_1aParser::Packed_dimensionContext>();
}

SV3_1aParser::Packed_dimensionContext* SV3_1aParser::Implicit_data_typeContext::packed_dimension(size_t i) {
  return getRuleContext<SV3_1aParser::Packed_dimensionContext>(i);
}


size_t SV3_1aParser::Implicit_data_typeContext::getRuleIndex() const {
  return SV3_1aParser::RuleImplicit_data_type;
}

void SV3_1aParser::Implicit_data_typeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterImplicit_data_type(this);
}

void SV3_1aParser::Implicit_data_typeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitImplicit_data_type(this);
}

SV3_1aParser::Implicit_data_typeContext* SV3_1aParser::implicit_data_type() {
  Implicit_data_typeContext *_localctx = _tracker.createInstance<Implicit_data_typeContext>(_ctx, getState());
  enterRule(_localctx, 254, SV3_1aParser::RuleImplicit_data_type);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3215);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SV3_1aParser::SIGNED

    || _la == SV3_1aParser::UNSIGNED) {
      setState(3214);
      signing();
    }
    setState(3220);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == SV3_1aParser::OPEN_BRACKET) {
      setState(3217);
      packed_dimension();
      setState(3222);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Enum_base_typeContext ------------------------------------------------------------------

SV3_1aParser::Enum_base_typeContext::Enum_base_typeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::Integer_atom_typeContext* SV3_1aParser::Enum_base_typeContext::integer_atom_type() {
  return getRuleContext<SV3_1aParser::Integer_atom_typeContext>(0);
}

SV3_1aParser::SigningContext* SV3_1aParser::Enum_base_typeContext::signing() {
  return getRuleContext<SV3_1aParser::SigningContext>(0);
}

SV3_1aParser::Integer_vector_typeContext* SV3_1aParser::Enum_base_typeContext::integer_vector_type() {
  return getRuleContext<SV3_1aParser::Integer_vector_typeContext>(0);
}

SV3_1aParser::Packed_dimensionContext* SV3_1aParser::Enum_base_typeContext::packed_dimension() {
  return getRuleContext<SV3_1aParser::Packed_dimensionContext>(0);
}

SV3_1aParser::IdentifierContext* SV3_1aParser::Enum_base_typeContext::identifier() {
  return getRuleContext<SV3_1aParser::IdentifierContext>(0);
}


size_t SV3_1aParser::Enum_base_typeContext::getRuleIndex() const {
  return SV3_1aParser::RuleEnum_base_type;
}

void SV3_1aParser::Enum_base_typeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterEnum_base_type(this);
}

void SV3_1aParser::Enum_base_typeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitEnum_base_type(this);
}

SV3_1aParser::Enum_base_typeContext* SV3_1aParser::enum_base_type() {
  Enum_base_typeContext *_localctx = _tracker.createInstance<Enum_base_typeContext>(_ctx, getState());
  enterRule(_localctx, 256, SV3_1aParser::RuleEnum_base_type);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(3238);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SV3_1aParser::BYTE:
      case SV3_1aParser::SHORTINT:
      case SV3_1aParser::INT:
      case SV3_1aParser::LONGINT:
      case SV3_1aParser::INTEGER:
      case SV3_1aParser::TIME: {
        enterOuterAlt(_localctx, 1);
        setState(3223);
        integer_atom_type();
        setState(3225);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == SV3_1aParser::SIGNED

        || _la == SV3_1aParser::UNSIGNED) {
          setState(3224);
          signing();
        }
        break;
      }

      case SV3_1aParser::BIT:
      case SV3_1aParser::LOGIC:
      case SV3_1aParser::REG: {
        enterOuterAlt(_localctx, 2);
        setState(3227);
        integer_vector_type();
        setState(3229);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == SV3_1aParser::SIGNED

        || _la == SV3_1aParser::UNSIGNED) {
          setState(3228);
          signing();
        }
        setState(3232);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == SV3_1aParser::OPEN_BRACKET) {
          setState(3231);
          packed_dimension();
        }
        break;
      }

      case SV3_1aParser::THIS:
      case SV3_1aParser::RANDOMIZE:
      case SV3_1aParser::SAMPLE:
      case SV3_1aParser::Escaped_identifier:
      case SV3_1aParser::Simple_identifier: {
        enterOuterAlt(_localctx, 3);
        setState(3234);
        identifier();
        setState(3236);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == SV3_1aParser::OPEN_BRACKET) {
          setState(3235);
          packed_dimension();
        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Enum_name_declarationContext ------------------------------------------------------------------

SV3_1aParser::Enum_name_declarationContext::Enum_name_declarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::IdentifierContext* SV3_1aParser::Enum_name_declarationContext::identifier() {
  return getRuleContext<SV3_1aParser::IdentifierContext>(0);
}

tree::TerminalNode* SV3_1aParser::Enum_name_declarationContext::OPEN_BRACKET() {
  return getToken(SV3_1aParser::OPEN_BRACKET, 0);
}

std::vector<tree::TerminalNode *> SV3_1aParser::Enum_name_declarationContext::Integral_number() {
  return getTokens(SV3_1aParser::Integral_number);
}

tree::TerminalNode* SV3_1aParser::Enum_name_declarationContext::Integral_number(size_t i) {
  return getToken(SV3_1aParser::Integral_number, i);
}

tree::TerminalNode* SV3_1aParser::Enum_name_declarationContext::CLOSE_BRACKET() {
  return getToken(SV3_1aParser::CLOSE_BRACKET, 0);
}

tree::TerminalNode* SV3_1aParser::Enum_name_declarationContext::ASSIGN_OP() {
  return getToken(SV3_1aParser::ASSIGN_OP, 0);
}

SV3_1aParser::Constant_expressionContext* SV3_1aParser::Enum_name_declarationContext::constant_expression() {
  return getRuleContext<SV3_1aParser::Constant_expressionContext>(0);
}

tree::TerminalNode* SV3_1aParser::Enum_name_declarationContext::COLON() {
  return getToken(SV3_1aParser::COLON, 0);
}


size_t SV3_1aParser::Enum_name_declarationContext::getRuleIndex() const {
  return SV3_1aParser::RuleEnum_name_declaration;
}

void SV3_1aParser::Enum_name_declarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterEnum_name_declaration(this);
}

void SV3_1aParser::Enum_name_declarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitEnum_name_declaration(this);
}

SV3_1aParser::Enum_name_declarationContext* SV3_1aParser::enum_name_declaration() {
  Enum_name_declarationContext *_localctx = _tracker.createInstance<Enum_name_declarationContext>(_ctx, getState());
  enterRule(_localctx, 258, SV3_1aParser::RuleEnum_name_declaration);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3240);
    identifier();
    setState(3248);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SV3_1aParser::OPEN_BRACKET) {
      setState(3241);
      match(SV3_1aParser::OPEN_BRACKET);
      setState(3242);
      match(SV3_1aParser::Integral_number);
      setState(3245);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == SV3_1aParser::COLON) {
        setState(3243);
        match(SV3_1aParser::COLON);
        setState(3244);
        match(SV3_1aParser::Integral_number);
      }
      setState(3247);
      match(SV3_1aParser::CLOSE_BRACKET);
    }
    setState(3252);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SV3_1aParser::ASSIGN_OP) {
      setState(3250);
      match(SV3_1aParser::ASSIGN_OP);
      setState(3251);
      constant_expression(0);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Class_scopeContext ------------------------------------------------------------------

SV3_1aParser::Class_scopeContext::Class_scopeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::Class_typeContext* SV3_1aParser::Class_scopeContext::class_type() {
  return getRuleContext<SV3_1aParser::Class_typeContext>(0);
}

tree::TerminalNode* SV3_1aParser::Class_scopeContext::COLONCOLON() {
  return getToken(SV3_1aParser::COLONCOLON, 0);
}


size_t SV3_1aParser::Class_scopeContext::getRuleIndex() const {
  return SV3_1aParser::RuleClass_scope;
}

void SV3_1aParser::Class_scopeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterClass_scope(this);
}

void SV3_1aParser::Class_scopeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitClass_scope(this);
}

SV3_1aParser::Class_scopeContext* SV3_1aParser::class_scope() {
  Class_scopeContext *_localctx = _tracker.createInstance<Class_scopeContext>(_ctx, getState());
  enterRule(_localctx, 260, SV3_1aParser::RuleClass_scope);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3254);
    class_type();
    setState(3255);
    match(SV3_1aParser::COLONCOLON);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Class_typeContext ------------------------------------------------------------------

SV3_1aParser::Class_typeContext::Class_typeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Class_typeContext::Simple_identifier() {
  return getToken(SV3_1aParser::Simple_identifier, 0);
}

tree::TerminalNode* SV3_1aParser::Class_typeContext::Escaped_identifier() {
  return getToken(SV3_1aParser::Escaped_identifier, 0);
}

tree::TerminalNode* SV3_1aParser::Class_typeContext::THIS() {
  return getToken(SV3_1aParser::THIS, 0);
}

tree::TerminalNode* SV3_1aParser::Class_typeContext::RANDOMIZE() {
  return getToken(SV3_1aParser::RANDOMIZE, 0);
}

tree::TerminalNode* SV3_1aParser::Class_typeContext::SAMPLE() {
  return getToken(SV3_1aParser::SAMPLE, 0);
}

tree::TerminalNode* SV3_1aParser::Class_typeContext::DOLLAR_UNIT() {
  return getToken(SV3_1aParser::DOLLAR_UNIT, 0);
}

std::vector<SV3_1aParser::Parameter_value_assignmentContext *> SV3_1aParser::Class_typeContext::parameter_value_assignment() {
  return getRuleContexts<SV3_1aParser::Parameter_value_assignmentContext>();
}

SV3_1aParser::Parameter_value_assignmentContext* SV3_1aParser::Class_typeContext::parameter_value_assignment(size_t i) {
  return getRuleContext<SV3_1aParser::Parameter_value_assignmentContext>(i);
}

std::vector<tree::TerminalNode *> SV3_1aParser::Class_typeContext::COLONCOLON() {
  return getTokens(SV3_1aParser::COLONCOLON);
}

tree::TerminalNode* SV3_1aParser::Class_typeContext::COLONCOLON(size_t i) {
  return getToken(SV3_1aParser::COLONCOLON, i);
}

std::vector<SV3_1aParser::IdentifierContext *> SV3_1aParser::Class_typeContext::identifier() {
  return getRuleContexts<SV3_1aParser::IdentifierContext>();
}

SV3_1aParser::IdentifierContext* SV3_1aParser::Class_typeContext::identifier(size_t i) {
  return getRuleContext<SV3_1aParser::IdentifierContext>(i);
}


size_t SV3_1aParser::Class_typeContext::getRuleIndex() const {
  return SV3_1aParser::RuleClass_type;
}

void SV3_1aParser::Class_typeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterClass_type(this);
}

void SV3_1aParser::Class_typeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitClass_type(this);
}

SV3_1aParser::Class_typeContext* SV3_1aParser::class_type() {
  Class_typeContext *_localctx = _tracker.createInstance<Class_typeContext>(_ctx, getState());
  enterRule(_localctx, 262, SV3_1aParser::RuleClass_type);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(3257);
    _la = _input->LA(1);
    if (!(_la == SV3_1aParser::DOLLAR_UNIT || ((((_la - 326) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 326)) & 4672924483589) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(3259);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SV3_1aParser::Pound_delay || _la == SV3_1aParser::POUND) {
      setState(3258);
      parameter_value_assignment();
    }
    setState(3268);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 296, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(3261);
        match(SV3_1aParser::COLONCOLON);
        setState(3262);
        identifier();
        setState(3264);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == SV3_1aParser::Pound_delay || _la == SV3_1aParser::POUND) {
          setState(3263);
          parameter_value_assignment();
        } 
      }
      setState(3270);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 296, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Integer_typeContext ------------------------------------------------------------------

SV3_1aParser::Integer_typeContext::Integer_typeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::Integer_vector_typeContext* SV3_1aParser::Integer_typeContext::integer_vector_type() {
  return getRuleContext<SV3_1aParser::Integer_vector_typeContext>(0);
}

SV3_1aParser::Integer_atom_typeContext* SV3_1aParser::Integer_typeContext::integer_atom_type() {
  return getRuleContext<SV3_1aParser::Integer_atom_typeContext>(0);
}


size_t SV3_1aParser::Integer_typeContext::getRuleIndex() const {
  return SV3_1aParser::RuleInteger_type;
}

void SV3_1aParser::Integer_typeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInteger_type(this);
}

void SV3_1aParser::Integer_typeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInteger_type(this);
}

SV3_1aParser::Integer_typeContext* SV3_1aParser::integer_type() {
  Integer_typeContext *_localctx = _tracker.createInstance<Integer_typeContext>(_ctx, getState());
  enterRule(_localctx, 264, SV3_1aParser::RuleInteger_type);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(3273);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SV3_1aParser::BIT:
      case SV3_1aParser::LOGIC:
      case SV3_1aParser::REG: {
        enterOuterAlt(_localctx, 1);
        setState(3271);
        integer_vector_type();
        break;
      }

      case SV3_1aParser::BYTE:
      case SV3_1aParser::SHORTINT:
      case SV3_1aParser::INT:
      case SV3_1aParser::LONGINT:
      case SV3_1aParser::INTEGER:
      case SV3_1aParser::TIME: {
        enterOuterAlt(_localctx, 2);
        setState(3272);
        integer_atom_type();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Integer_atom_typeContext ------------------------------------------------------------------

SV3_1aParser::Integer_atom_typeContext::Integer_atom_typeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Integer_atom_typeContext::BYTE() {
  return getToken(SV3_1aParser::BYTE, 0);
}

tree::TerminalNode* SV3_1aParser::Integer_atom_typeContext::SHORTINT() {
  return getToken(SV3_1aParser::SHORTINT, 0);
}

tree::TerminalNode* SV3_1aParser::Integer_atom_typeContext::INT() {
  return getToken(SV3_1aParser::INT, 0);
}

tree::TerminalNode* SV3_1aParser::Integer_atom_typeContext::LONGINT() {
  return getToken(SV3_1aParser::LONGINT, 0);
}

tree::TerminalNode* SV3_1aParser::Integer_atom_typeContext::INTEGER() {
  return getToken(SV3_1aParser::INTEGER, 0);
}

tree::TerminalNode* SV3_1aParser::Integer_atom_typeContext::TIME() {
  return getToken(SV3_1aParser::TIME, 0);
}


size_t SV3_1aParser::Integer_atom_typeContext::getRuleIndex() const {
  return SV3_1aParser::RuleInteger_atom_type;
}

void SV3_1aParser::Integer_atom_typeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInteger_atom_type(this);
}

void SV3_1aParser::Integer_atom_typeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInteger_atom_type(this);
}

SV3_1aParser::Integer_atom_typeContext* SV3_1aParser::integer_atom_type() {
  Integer_atom_typeContext *_localctx = _tracker.createInstance<Integer_atom_typeContext>(_ctx, getState());
  enterRule(_localctx, 266, SV3_1aParser::RuleInteger_atom_type);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3275);
    _la = _input->LA(1);
    if (!(((((_la - 112) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 112)) & 63) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Integer_vector_typeContext ------------------------------------------------------------------

SV3_1aParser::Integer_vector_typeContext::Integer_vector_typeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Integer_vector_typeContext::BIT() {
  return getToken(SV3_1aParser::BIT, 0);
}

tree::TerminalNode* SV3_1aParser::Integer_vector_typeContext::LOGIC() {
  return getToken(SV3_1aParser::LOGIC, 0);
}

tree::TerminalNode* SV3_1aParser::Integer_vector_typeContext::REG() {
  return getToken(SV3_1aParser::REG, 0);
}


size_t SV3_1aParser::Integer_vector_typeContext::getRuleIndex() const {
  return SV3_1aParser::RuleInteger_vector_type;
}

void SV3_1aParser::Integer_vector_typeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInteger_vector_type(this);
}

void SV3_1aParser::Integer_vector_typeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInteger_vector_type(this);
}

SV3_1aParser::Integer_vector_typeContext* SV3_1aParser::integer_vector_type() {
  Integer_vector_typeContext *_localctx = _tracker.createInstance<Integer_vector_typeContext>(_ctx, getState());
  enterRule(_localctx, 268, SV3_1aParser::RuleInteger_vector_type);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3277);
    _la = _input->LA(1);
    if (!(((((_la - 118) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 118)) & 7) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Non_integer_typeContext ------------------------------------------------------------------

SV3_1aParser::Non_integer_typeContext::Non_integer_typeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Non_integer_typeContext::SHORTREAL() {
  return getToken(SV3_1aParser::SHORTREAL, 0);
}

tree::TerminalNode* SV3_1aParser::Non_integer_typeContext::REAL() {
  return getToken(SV3_1aParser::REAL, 0);
}

tree::TerminalNode* SV3_1aParser::Non_integer_typeContext::REALTIME() {
  return getToken(SV3_1aParser::REALTIME, 0);
}


size_t SV3_1aParser::Non_integer_typeContext::getRuleIndex() const {
  return SV3_1aParser::RuleNon_integer_type;
}

void SV3_1aParser::Non_integer_typeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNon_integer_type(this);
}

void SV3_1aParser::Non_integer_typeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNon_integer_type(this);
}

SV3_1aParser::Non_integer_typeContext* SV3_1aParser::non_integer_type() {
  Non_integer_typeContext *_localctx = _tracker.createInstance<Non_integer_typeContext>(_ctx, getState());
  enterRule(_localctx, 270, SV3_1aParser::RuleNon_integer_type);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3279);
    _la = _input->LA(1);
    if (!(((((_la - 121) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 121)) & 7) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Net_typeContext ------------------------------------------------------------------

SV3_1aParser::Net_typeContext::Net_typeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Net_typeContext::SUPPLY0() {
  return getToken(SV3_1aParser::SUPPLY0, 0);
}

tree::TerminalNode* SV3_1aParser::Net_typeContext::SUPPLY1() {
  return getToken(SV3_1aParser::SUPPLY1, 0);
}

tree::TerminalNode* SV3_1aParser::Net_typeContext::TRI() {
  return getToken(SV3_1aParser::TRI, 0);
}

tree::TerminalNode* SV3_1aParser::Net_typeContext::TRIAND() {
  return getToken(SV3_1aParser::TRIAND, 0);
}

tree::TerminalNode* SV3_1aParser::Net_typeContext::TRIOR() {
  return getToken(SV3_1aParser::TRIOR, 0);
}

tree::TerminalNode* SV3_1aParser::Net_typeContext::TRIREG() {
  return getToken(SV3_1aParser::TRIREG, 0);
}

tree::TerminalNode* SV3_1aParser::Net_typeContext::TRI0() {
  return getToken(SV3_1aParser::TRI0, 0);
}

tree::TerminalNode* SV3_1aParser::Net_typeContext::TRI1() {
  return getToken(SV3_1aParser::TRI1, 0);
}

tree::TerminalNode* SV3_1aParser::Net_typeContext::UWIRE() {
  return getToken(SV3_1aParser::UWIRE, 0);
}

tree::TerminalNode* SV3_1aParser::Net_typeContext::WIRE() {
  return getToken(SV3_1aParser::WIRE, 0);
}

tree::TerminalNode* SV3_1aParser::Net_typeContext::WAND() {
  return getToken(SV3_1aParser::WAND, 0);
}

tree::TerminalNode* SV3_1aParser::Net_typeContext::WOR() {
  return getToken(SV3_1aParser::WOR, 0);
}


size_t SV3_1aParser::Net_typeContext::getRuleIndex() const {
  return SV3_1aParser::RuleNet_type;
}

void SV3_1aParser::Net_typeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNet_type(this);
}

void SV3_1aParser::Net_typeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNet_type(this);
}

SV3_1aParser::Net_typeContext* SV3_1aParser::net_type() {
  Net_typeContext *_localctx = _tracker.createInstance<Net_typeContext>(_ctx, getState());
  enterRule(_localctx, 272, SV3_1aParser::RuleNet_type);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3281);
    _la = _input->LA(1);
    if (!(((((_la - 135) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 135)) & 4095) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Net_port_typeContext ------------------------------------------------------------------

SV3_1aParser::Net_port_typeContext::Net_port_typeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::Data_type_or_implicitContext* SV3_1aParser::Net_port_typeContext::data_type_or_implicit() {
  return getRuleContext<SV3_1aParser::Data_type_or_implicitContext>(0);
}

SV3_1aParser::Net_typeContext* SV3_1aParser::Net_port_typeContext::net_type() {
  return getRuleContext<SV3_1aParser::Net_typeContext>(0);
}

SV3_1aParser::IdentifierContext* SV3_1aParser::Net_port_typeContext::identifier() {
  return getRuleContext<SV3_1aParser::IdentifierContext>(0);
}

tree::TerminalNode* SV3_1aParser::Net_port_typeContext::INTERCONNECT() {
  return getToken(SV3_1aParser::INTERCONNECT, 0);
}

SV3_1aParser::Implicit_data_typeContext* SV3_1aParser::Net_port_typeContext::implicit_data_type() {
  return getRuleContext<SV3_1aParser::Implicit_data_typeContext>(0);
}


size_t SV3_1aParser::Net_port_typeContext::getRuleIndex() const {
  return SV3_1aParser::RuleNet_port_type;
}

void SV3_1aParser::Net_port_typeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNet_port_type(this);
}

void SV3_1aParser::Net_port_typeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNet_port_type(this);
}

SV3_1aParser::Net_port_typeContext* SV3_1aParser::net_port_type() {
  Net_port_typeContext *_localctx = _tracker.createInstance<Net_port_typeContext>(_ctx, getState());
  enterRule(_localctx, 274, SV3_1aParser::RuleNet_port_type);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(3290);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 299, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(3284);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (((((_la - 135) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 135)) & 4095) != 0)) {
        setState(3283);
        net_type();
      }
      setState(3286);
      data_type_or_implicit();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(3287);
      identifier();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(3288);
      match(SV3_1aParser::INTERCONNECT);
      setState(3289);
      implicit_data_type();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Variable_port_typeContext ------------------------------------------------------------------

SV3_1aParser::Variable_port_typeContext::Variable_port_typeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::Var_data_typeContext* SV3_1aParser::Variable_port_typeContext::var_data_type() {
  return getRuleContext<SV3_1aParser::Var_data_typeContext>(0);
}

tree::TerminalNode* SV3_1aParser::Variable_port_typeContext::OPEN_BRACKET() {
  return getToken(SV3_1aParser::OPEN_BRACKET, 0);
}

SV3_1aParser::Constant_rangeContext* SV3_1aParser::Variable_port_typeContext::constant_range() {
  return getRuleContext<SV3_1aParser::Constant_rangeContext>(0);
}

tree::TerminalNode* SV3_1aParser::Variable_port_typeContext::CLOSE_BRACKET() {
  return getToken(SV3_1aParser::CLOSE_BRACKET, 0);
}


size_t SV3_1aParser::Variable_port_typeContext::getRuleIndex() const {
  return SV3_1aParser::RuleVariable_port_type;
}

void SV3_1aParser::Variable_port_typeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterVariable_port_type(this);
}

void SV3_1aParser::Variable_port_typeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitVariable_port_type(this);
}

SV3_1aParser::Variable_port_typeContext* SV3_1aParser::variable_port_type() {
  Variable_port_typeContext *_localctx = _tracker.createInstance<Variable_port_typeContext>(_ctx, getState());
  enterRule(_localctx, 276, SV3_1aParser::RuleVariable_port_type);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(3297);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SV3_1aParser::VIRTUAL:
      case SV3_1aParser::TYPE:
      case SV3_1aParser::ENUM:
      case SV3_1aParser::STRUCT:
      case SV3_1aParser::UNION:
      case SV3_1aParser::STRING:
      case SV3_1aParser::CHANDLE:
      case SV3_1aParser::EVENT:
      case SV3_1aParser::BYTE:
      case SV3_1aParser::SHORTINT:
      case SV3_1aParser::INT:
      case SV3_1aParser::LONGINT:
      case SV3_1aParser::INTEGER:
      case SV3_1aParser::TIME:
      case SV3_1aParser::BIT:
      case SV3_1aParser::LOGIC:
      case SV3_1aParser::REG:
      case SV3_1aParser::SHORTREAL:
      case SV3_1aParser::REAL:
      case SV3_1aParser::REALTIME:
      case SV3_1aParser::VAR:
      case SV3_1aParser::DOLLAR_UNIT:
      case SV3_1aParser::THIS:
      case SV3_1aParser::RANDOMIZE:
      case SV3_1aParser::SAMPLE:
      case SV3_1aParser::Escaped_identifier:
      case SV3_1aParser::Simple_identifier: {
        enterOuterAlt(_localctx, 1);
        setState(3292);
        var_data_type();
        break;
      }

      case SV3_1aParser::OPEN_BRACKET: {
        enterOuterAlt(_localctx, 2);
        setState(3293);
        match(SV3_1aParser::OPEN_BRACKET);
        setState(3294);
        constant_range();
        setState(3295);
        match(SV3_1aParser::CLOSE_BRACKET);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Var_data_typeContext ------------------------------------------------------------------

SV3_1aParser::Var_data_typeContext::Var_data_typeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::Data_typeContext* SV3_1aParser::Var_data_typeContext::data_type() {
  return getRuleContext<SV3_1aParser::Data_typeContext>(0);
}

SV3_1aParser::Var_typeContext* SV3_1aParser::Var_data_typeContext::var_type() {
  return getRuleContext<SV3_1aParser::Var_typeContext>(0);
}

SV3_1aParser::Data_type_or_implicitContext* SV3_1aParser::Var_data_typeContext::data_type_or_implicit() {
  return getRuleContext<SV3_1aParser::Data_type_or_implicitContext>(0);
}


size_t SV3_1aParser::Var_data_typeContext::getRuleIndex() const {
  return SV3_1aParser::RuleVar_data_type;
}

void SV3_1aParser::Var_data_typeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterVar_data_type(this);
}

void SV3_1aParser::Var_data_typeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitVar_data_type(this);
}

SV3_1aParser::Var_data_typeContext* SV3_1aParser::var_data_type() {
  Var_data_typeContext *_localctx = _tracker.createInstance<Var_data_typeContext>(_ctx, getState());
  enterRule(_localctx, 278, SV3_1aParser::RuleVar_data_type);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(3303);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SV3_1aParser::VIRTUAL:
      case SV3_1aParser::TYPE:
      case SV3_1aParser::ENUM:
      case SV3_1aParser::STRUCT:
      case SV3_1aParser::UNION:
      case SV3_1aParser::STRING:
      case SV3_1aParser::CHANDLE:
      case SV3_1aParser::EVENT:
      case SV3_1aParser::BYTE:
      case SV3_1aParser::SHORTINT:
      case SV3_1aParser::INT:
      case SV3_1aParser::LONGINT:
      case SV3_1aParser::INTEGER:
      case SV3_1aParser::TIME:
      case SV3_1aParser::BIT:
      case SV3_1aParser::LOGIC:
      case SV3_1aParser::REG:
      case SV3_1aParser::SHORTREAL:
      case SV3_1aParser::REAL:
      case SV3_1aParser::REALTIME:
      case SV3_1aParser::DOLLAR_UNIT:
      case SV3_1aParser::THIS:
      case SV3_1aParser::RANDOMIZE:
      case SV3_1aParser::SAMPLE:
      case SV3_1aParser::Escaped_identifier:
      case SV3_1aParser::Simple_identifier: {
        enterOuterAlt(_localctx, 1);
        setState(3299);
        data_type();
        break;
      }

      case SV3_1aParser::VAR: {
        enterOuterAlt(_localctx, 2);
        setState(3300);
        var_type();
        setState(3301);
        data_type_or_implicit();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SigningContext ------------------------------------------------------------------

SV3_1aParser::SigningContext::SigningContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::SigningContext::SIGNED() {
  return getToken(SV3_1aParser::SIGNED, 0);
}

tree::TerminalNode* SV3_1aParser::SigningContext::UNSIGNED() {
  return getToken(SV3_1aParser::UNSIGNED, 0);
}


size_t SV3_1aParser::SigningContext::getRuleIndex() const {
  return SV3_1aParser::RuleSigning;
}

void SV3_1aParser::SigningContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSigning(this);
}

void SV3_1aParser::SigningContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSigning(this);
}

SV3_1aParser::SigningContext* SV3_1aParser::signing() {
  SigningContext *_localctx = _tracker.createInstance<SigningContext>(_ctx, getState());
  enterRule(_localctx, 280, SV3_1aParser::RuleSigning);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3305);
    _la = _input->LA(1);
    if (!(_la == SV3_1aParser::SIGNED

    || _la == SV3_1aParser::UNSIGNED)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Simple_typeContext ------------------------------------------------------------------

SV3_1aParser::Simple_typeContext::Simple_typeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::Integer_typeContext* SV3_1aParser::Simple_typeContext::integer_type() {
  return getRuleContext<SV3_1aParser::Integer_typeContext>(0);
}

SV3_1aParser::Non_integer_typeContext* SV3_1aParser::Simple_typeContext::non_integer_type() {
  return getRuleContext<SV3_1aParser::Non_integer_typeContext>(0);
}

SV3_1aParser::Ps_type_identifierContext* SV3_1aParser::Simple_typeContext::ps_type_identifier() {
  return getRuleContext<SV3_1aParser::Ps_type_identifierContext>(0);
}


size_t SV3_1aParser::Simple_typeContext::getRuleIndex() const {
  return SV3_1aParser::RuleSimple_type;
}

void SV3_1aParser::Simple_typeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSimple_type(this);
}

void SV3_1aParser::Simple_typeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSimple_type(this);
}

SV3_1aParser::Simple_typeContext* SV3_1aParser::simple_type() {
  Simple_typeContext *_localctx = _tracker.createInstance<Simple_typeContext>(_ctx, getState());
  enterRule(_localctx, 282, SV3_1aParser::RuleSimple_type);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(3310);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SV3_1aParser::BYTE:
      case SV3_1aParser::SHORTINT:
      case SV3_1aParser::INT:
      case SV3_1aParser::LONGINT:
      case SV3_1aParser::INTEGER:
      case SV3_1aParser::TIME:
      case SV3_1aParser::BIT:
      case SV3_1aParser::LOGIC:
      case SV3_1aParser::REG: {
        enterOuterAlt(_localctx, 1);
        setState(3307);
        integer_type();
        break;
      }

      case SV3_1aParser::SHORTREAL:
      case SV3_1aParser::REAL:
      case SV3_1aParser::REALTIME: {
        enterOuterAlt(_localctx, 2);
        setState(3308);
        non_integer_type();
        break;
      }

      case SV3_1aParser::LOCAL:
      case SV3_1aParser::DOLLAR_UNIT:
      case SV3_1aParser::THIS:
      case SV3_1aParser::RANDOMIZE:
      case SV3_1aParser::SAMPLE:
      case SV3_1aParser::Escaped_identifier:
      case SV3_1aParser::Simple_identifier: {
        enterOuterAlt(_localctx, 3);
        setState(3309);
        ps_type_identifier();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Random_qualifierContext ------------------------------------------------------------------

SV3_1aParser::Random_qualifierContext::Random_qualifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t SV3_1aParser::Random_qualifierContext::getRuleIndex() const {
  return SV3_1aParser::RuleRandom_qualifier;
}

void SV3_1aParser::Random_qualifierContext::copyFrom(Random_qualifierContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- RandomQualifier_RandCContext ------------------------------------------------------------------

tree::TerminalNode* SV3_1aParser::RandomQualifier_RandCContext::RANDC() {
  return getToken(SV3_1aParser::RANDC, 0);
}

SV3_1aParser::RandomQualifier_RandCContext::RandomQualifier_RandCContext(Random_qualifierContext *ctx) { copyFrom(ctx); }

void SV3_1aParser::RandomQualifier_RandCContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRandomQualifier_RandC(this);
}
void SV3_1aParser::RandomQualifier_RandCContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRandomQualifier_RandC(this);
}
//----------------- RandomQualifier_RandContext ------------------------------------------------------------------

tree::TerminalNode* SV3_1aParser::RandomQualifier_RandContext::RAND() {
  return getToken(SV3_1aParser::RAND, 0);
}

SV3_1aParser::RandomQualifier_RandContext::RandomQualifier_RandContext(Random_qualifierContext *ctx) { copyFrom(ctx); }

void SV3_1aParser::RandomQualifier_RandContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRandomQualifier_Rand(this);
}
void SV3_1aParser::RandomQualifier_RandContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRandomQualifier_Rand(this);
}
SV3_1aParser::Random_qualifierContext* SV3_1aParser::random_qualifier() {
  Random_qualifierContext *_localctx = _tracker.createInstance<Random_qualifierContext>(_ctx, getState());
  enterRule(_localctx, 284, SV3_1aParser::RuleRandom_qualifier);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(3314);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SV3_1aParser::RAND: {
        _localctx = _tracker.createInstance<SV3_1aParser::RandomQualifier_RandContext>(_localctx);
        enterOuterAlt(_localctx, 1);
        setState(3312);
        match(SV3_1aParser::RAND);
        break;
      }

      case SV3_1aParser::RANDC: {
        _localctx = _tracker.createInstance<SV3_1aParser::RandomQualifier_RandCContext>(_localctx);
        enterOuterAlt(_localctx, 2);
        setState(3313);
        match(SV3_1aParser::RANDC);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Struct_union_memberContext ------------------------------------------------------------------

SV3_1aParser::Struct_union_memberContext::Struct_union_memberContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::Data_type_or_voidContext* SV3_1aParser::Struct_union_memberContext::data_type_or_void() {
  return getRuleContext<SV3_1aParser::Data_type_or_voidContext>(0);
}

SV3_1aParser::List_of_variable_decl_assignmentsContext* SV3_1aParser::Struct_union_memberContext::list_of_variable_decl_assignments() {
  return getRuleContext<SV3_1aParser::List_of_variable_decl_assignmentsContext>(0);
}

tree::TerminalNode* SV3_1aParser::Struct_union_memberContext::SEMICOLON() {
  return getToken(SV3_1aParser::SEMICOLON, 0);
}

std::vector<SV3_1aParser::Attribute_instanceContext *> SV3_1aParser::Struct_union_memberContext::attribute_instance() {
  return getRuleContexts<SV3_1aParser::Attribute_instanceContext>();
}

SV3_1aParser::Attribute_instanceContext* SV3_1aParser::Struct_union_memberContext::attribute_instance(size_t i) {
  return getRuleContext<SV3_1aParser::Attribute_instanceContext>(i);
}

SV3_1aParser::Random_qualifierContext* SV3_1aParser::Struct_union_memberContext::random_qualifier() {
  return getRuleContext<SV3_1aParser::Random_qualifierContext>(0);
}


size_t SV3_1aParser::Struct_union_memberContext::getRuleIndex() const {
  return SV3_1aParser::RuleStruct_union_member;
}

void SV3_1aParser::Struct_union_memberContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterStruct_union_member(this);
}

void SV3_1aParser::Struct_union_memberContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitStruct_union_member(this);
}

SV3_1aParser::Struct_union_memberContext* SV3_1aParser::struct_union_member() {
  Struct_union_memberContext *_localctx = _tracker.createInstance<Struct_union_memberContext>(_ctx, getState());
  enterRule(_localctx, 286, SV3_1aParser::RuleStruct_union_member);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3319);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == SV3_1aParser::OPEN_PARENS_STAR) {
      setState(3316);
      attribute_instance();
      setState(3321);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(3323);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SV3_1aParser::RAND

    || _la == SV3_1aParser::RANDC) {
      setState(3322);
      random_qualifier();
    }
    setState(3325);
    data_type_or_void();
    setState(3326);
    list_of_variable_decl_assignments();
    setState(3327);
    match(SV3_1aParser::SEMICOLON);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Data_type_or_voidContext ------------------------------------------------------------------

SV3_1aParser::Data_type_or_voidContext::Data_type_or_voidContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::Data_typeContext* SV3_1aParser::Data_type_or_voidContext::data_type() {
  return getRuleContext<SV3_1aParser::Data_typeContext>(0);
}

tree::TerminalNode* SV3_1aParser::Data_type_or_voidContext::VOID() {
  return getToken(SV3_1aParser::VOID, 0);
}


size_t SV3_1aParser::Data_type_or_voidContext::getRuleIndex() const {
  return SV3_1aParser::RuleData_type_or_void;
}

void SV3_1aParser::Data_type_or_voidContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterData_type_or_void(this);
}

void SV3_1aParser::Data_type_or_voidContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitData_type_or_void(this);
}

SV3_1aParser::Data_type_or_voidContext* SV3_1aParser::data_type_or_void() {
  Data_type_or_voidContext *_localctx = _tracker.createInstance<Data_type_or_voidContext>(_ctx, getState());
  enterRule(_localctx, 288, SV3_1aParser::RuleData_type_or_void);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(3331);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SV3_1aParser::VIRTUAL:
      case SV3_1aParser::TYPE:
      case SV3_1aParser::ENUM:
      case SV3_1aParser::STRUCT:
      case SV3_1aParser::UNION:
      case SV3_1aParser::STRING:
      case SV3_1aParser::CHANDLE:
      case SV3_1aParser::EVENT:
      case SV3_1aParser::BYTE:
      case SV3_1aParser::SHORTINT:
      case SV3_1aParser::INT:
      case SV3_1aParser::LONGINT:
      case SV3_1aParser::INTEGER:
      case SV3_1aParser::TIME:
      case SV3_1aParser::BIT:
      case SV3_1aParser::LOGIC:
      case SV3_1aParser::REG:
      case SV3_1aParser::SHORTREAL:
      case SV3_1aParser::REAL:
      case SV3_1aParser::REALTIME:
      case SV3_1aParser::DOLLAR_UNIT:
      case SV3_1aParser::THIS:
      case SV3_1aParser::RANDOMIZE:
      case SV3_1aParser::SAMPLE:
      case SV3_1aParser::Escaped_identifier:
      case SV3_1aParser::Simple_identifier: {
        enterOuterAlt(_localctx, 1);
        setState(3329);
        data_type();
        break;
      }

      case SV3_1aParser::VOID: {
        enterOuterAlt(_localctx, 2);
        setState(3330);
        match(SV3_1aParser::VOID);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Struct_unionContext ------------------------------------------------------------------

SV3_1aParser::Struct_unionContext::Struct_unionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::Struct_keywordContext* SV3_1aParser::Struct_unionContext::struct_keyword() {
  return getRuleContext<SV3_1aParser::Struct_keywordContext>(0);
}

SV3_1aParser::Union_keywordContext* SV3_1aParser::Struct_unionContext::union_keyword() {
  return getRuleContext<SV3_1aParser::Union_keywordContext>(0);
}

SV3_1aParser::Tagged_keywordContext* SV3_1aParser::Struct_unionContext::tagged_keyword() {
  return getRuleContext<SV3_1aParser::Tagged_keywordContext>(0);
}


size_t SV3_1aParser::Struct_unionContext::getRuleIndex() const {
  return SV3_1aParser::RuleStruct_union;
}

void SV3_1aParser::Struct_unionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterStruct_union(this);
}

void SV3_1aParser::Struct_unionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitStruct_union(this);
}

SV3_1aParser::Struct_unionContext* SV3_1aParser::struct_union() {
  Struct_unionContext *_localctx = _tracker.createInstance<Struct_unionContext>(_ctx, getState());
  enterRule(_localctx, 290, SV3_1aParser::RuleStruct_union);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(3338);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SV3_1aParser::STRUCT: {
        enterOuterAlt(_localctx, 1);
        setState(3333);
        struct_keyword();
        break;
      }

      case SV3_1aParser::UNION: {
        enterOuterAlt(_localctx, 2);
        setState(3334);
        union_keyword();
        setState(3336);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == SV3_1aParser::TAGGED) {
          setState(3335);
          tagged_keyword();
        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Tagged_keywordContext ------------------------------------------------------------------

SV3_1aParser::Tagged_keywordContext::Tagged_keywordContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Tagged_keywordContext::TAGGED() {
  return getToken(SV3_1aParser::TAGGED, 0);
}


size_t SV3_1aParser::Tagged_keywordContext::getRuleIndex() const {
  return SV3_1aParser::RuleTagged_keyword;
}

void SV3_1aParser::Tagged_keywordContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTagged_keyword(this);
}

void SV3_1aParser::Tagged_keywordContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTagged_keyword(this);
}

SV3_1aParser::Tagged_keywordContext* SV3_1aParser::tagged_keyword() {
  Tagged_keywordContext *_localctx = _tracker.createInstance<Tagged_keywordContext>(_ctx, getState());
  enterRule(_localctx, 292, SV3_1aParser::RuleTagged_keyword);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3340);
    match(SV3_1aParser::TAGGED);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Type_referenceContext ------------------------------------------------------------------

SV3_1aParser::Type_referenceContext::Type_referenceContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Type_referenceContext::TYPE() {
  return getToken(SV3_1aParser::TYPE, 0);
}

tree::TerminalNode* SV3_1aParser::Type_referenceContext::OPEN_PARENS() {
  return getToken(SV3_1aParser::OPEN_PARENS, 0);
}

tree::TerminalNode* SV3_1aParser::Type_referenceContext::CLOSE_PARENS() {
  return getToken(SV3_1aParser::CLOSE_PARENS, 0);
}

SV3_1aParser::ExpressionContext* SV3_1aParser::Type_referenceContext::expression() {
  return getRuleContext<SV3_1aParser::ExpressionContext>(0);
}

SV3_1aParser::Data_typeContext* SV3_1aParser::Type_referenceContext::data_type() {
  return getRuleContext<SV3_1aParser::Data_typeContext>(0);
}


size_t SV3_1aParser::Type_referenceContext::getRuleIndex() const {
  return SV3_1aParser::RuleType_reference;
}

void SV3_1aParser::Type_referenceContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterType_reference(this);
}

void SV3_1aParser::Type_referenceContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitType_reference(this);
}

SV3_1aParser::Type_referenceContext* SV3_1aParser::type_reference() {
  Type_referenceContext *_localctx = _tracker.createInstance<Type_referenceContext>(_ctx, getState());
  enterRule(_localctx, 294, SV3_1aParser::RuleType_reference);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3342);
    match(SV3_1aParser::TYPE);
    setState(3343);
    match(SV3_1aParser::OPEN_PARENS);
    setState(3346);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 309, _ctx)) {
    case 1: {
      setState(3344);
      expression(0);
      break;
    }

    case 2: {
      setState(3345);
      data_type();
      break;
    }

    default:
      break;
    }
    setState(3348);
    match(SV3_1aParser::CLOSE_PARENS);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Drive_strengthContext ------------------------------------------------------------------

SV3_1aParser::Drive_strengthContext::Drive_strengthContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Drive_strengthContext::OPEN_PARENS() {
  return getToken(SV3_1aParser::OPEN_PARENS, 0);
}

tree::TerminalNode* SV3_1aParser::Drive_strengthContext::COMMA() {
  return getToken(SV3_1aParser::COMMA, 0);
}

tree::TerminalNode* SV3_1aParser::Drive_strengthContext::CLOSE_PARENS() {
  return getToken(SV3_1aParser::CLOSE_PARENS, 0);
}

tree::TerminalNode* SV3_1aParser::Drive_strengthContext::SUPPLY0() {
  return getToken(SV3_1aParser::SUPPLY0, 0);
}

tree::TerminalNode* SV3_1aParser::Drive_strengthContext::STRONG0() {
  return getToken(SV3_1aParser::STRONG0, 0);
}

tree::TerminalNode* SV3_1aParser::Drive_strengthContext::PULL0() {
  return getToken(SV3_1aParser::PULL0, 0);
}

tree::TerminalNode* SV3_1aParser::Drive_strengthContext::WEAK0() {
  return getToken(SV3_1aParser::WEAK0, 0);
}

tree::TerminalNode* SV3_1aParser::Drive_strengthContext::SUPPLY1() {
  return getToken(SV3_1aParser::SUPPLY1, 0);
}

tree::TerminalNode* SV3_1aParser::Drive_strengthContext::STRONG1() {
  return getToken(SV3_1aParser::STRONG1, 0);
}

tree::TerminalNode* SV3_1aParser::Drive_strengthContext::PULL1() {
  return getToken(SV3_1aParser::PULL1, 0);
}

tree::TerminalNode* SV3_1aParser::Drive_strengthContext::WEAK1() {
  return getToken(SV3_1aParser::WEAK1, 0);
}

tree::TerminalNode* SV3_1aParser::Drive_strengthContext::HIGHZ1() {
  return getToken(SV3_1aParser::HIGHZ1, 0);
}

tree::TerminalNode* SV3_1aParser::Drive_strengthContext::HIGHZ0() {
  return getToken(SV3_1aParser::HIGHZ0, 0);
}


size_t SV3_1aParser::Drive_strengthContext::getRuleIndex() const {
  return SV3_1aParser::RuleDrive_strength;
}

void SV3_1aParser::Drive_strengthContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDrive_strength(this);
}

void SV3_1aParser::Drive_strengthContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDrive_strength(this);
}

SV3_1aParser::Drive_strengthContext* SV3_1aParser::drive_strength() {
  Drive_strengthContext *_localctx = _tracker.createInstance<Drive_strengthContext>(_ctx, getState());
  enterRule(_localctx, 296, SV3_1aParser::RuleDrive_strength);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(3370);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 310, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(3350);
      match(SV3_1aParser::OPEN_PARENS);
      setState(3351);
      _la = _input->LA(1);
      if (!(((((_la - 135) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 135)) & 14680065) != 0))) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(3352);
      match(SV3_1aParser::COMMA);
      setState(3353);
      _la = _input->LA(1);
      if (!(((((_la - 136) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 136)) & 58851329) != 0))) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(3354);
      match(SV3_1aParser::CLOSE_PARENS);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(3355);
      match(SV3_1aParser::OPEN_PARENS);
      setState(3356);
      _la = _input->LA(1);
      if (!(((((_la - 136) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 136)) & 58851329) != 0))) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(3357);
      match(SV3_1aParser::COMMA);
      setState(3358);
      _la = _input->LA(1);
      if (!(((((_la - 135) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 135)) & 14811137) != 0))) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(3359);
      match(SV3_1aParser::CLOSE_PARENS);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(3360);
      match(SV3_1aParser::OPEN_PARENS);
      setState(3361);
      match(SV3_1aParser::HIGHZ0);
      setState(3362);
      match(SV3_1aParser::COMMA);
      setState(3363);
      _la = _input->LA(1);
      if (!(((((_la - 136) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 136)) & 58720257) != 0))) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(3364);
      match(SV3_1aParser::CLOSE_PARENS);
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(3365);
      match(SV3_1aParser::OPEN_PARENS);
      setState(3366);
      match(SV3_1aParser::HIGHZ1);
      setState(3367);
      match(SV3_1aParser::COMMA);
      setState(3368);
      _la = _input->LA(1);
      if (!(((((_la - 135) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 135)) & 14680065) != 0))) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(3369);
      match(SV3_1aParser::CLOSE_PARENS);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Strength0Context ------------------------------------------------------------------

SV3_1aParser::Strength0Context::Strength0Context(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Strength0Context::SUPPLY0() {
  return getToken(SV3_1aParser::SUPPLY0, 0);
}

tree::TerminalNode* SV3_1aParser::Strength0Context::STRONG0() {
  return getToken(SV3_1aParser::STRONG0, 0);
}

tree::TerminalNode* SV3_1aParser::Strength0Context::PULL0() {
  return getToken(SV3_1aParser::PULL0, 0);
}

tree::TerminalNode* SV3_1aParser::Strength0Context::WEAK0() {
  return getToken(SV3_1aParser::WEAK0, 0);
}


size_t SV3_1aParser::Strength0Context::getRuleIndex() const {
  return SV3_1aParser::RuleStrength0;
}

void SV3_1aParser::Strength0Context::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterStrength0(this);
}

void SV3_1aParser::Strength0Context::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitStrength0(this);
}

SV3_1aParser::Strength0Context* SV3_1aParser::strength0() {
  Strength0Context *_localctx = _tracker.createInstance<Strength0Context>(_ctx, getState());
  enterRule(_localctx, 298, SV3_1aParser::RuleStrength0);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3372);
    _la = _input->LA(1);
    if (!(((((_la - 135) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 135)) & 14680065) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Strength1Context ------------------------------------------------------------------

SV3_1aParser::Strength1Context::Strength1Context(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Strength1Context::SUPPLY1() {
  return getToken(SV3_1aParser::SUPPLY1, 0);
}

tree::TerminalNode* SV3_1aParser::Strength1Context::STRONG1() {
  return getToken(SV3_1aParser::STRONG1, 0);
}

tree::TerminalNode* SV3_1aParser::Strength1Context::PULL1() {
  return getToken(SV3_1aParser::PULL1, 0);
}

tree::TerminalNode* SV3_1aParser::Strength1Context::WEAK1() {
  return getToken(SV3_1aParser::WEAK1, 0);
}


size_t SV3_1aParser::Strength1Context::getRuleIndex() const {
  return SV3_1aParser::RuleStrength1;
}

void SV3_1aParser::Strength1Context::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterStrength1(this);
}

void SV3_1aParser::Strength1Context::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitStrength1(this);
}

SV3_1aParser::Strength1Context* SV3_1aParser::strength1() {
  Strength1Context *_localctx = _tracker.createInstance<Strength1Context>(_ctx, getState());
  enterRule(_localctx, 300, SV3_1aParser::RuleStrength1);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3374);
    _la = _input->LA(1);
    if (!(((((_la - 136) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 136)) & 58720257) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Charge_strengthContext ------------------------------------------------------------------

SV3_1aParser::Charge_strengthContext::Charge_strengthContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Charge_strengthContext::SMALL() {
  return getToken(SV3_1aParser::SMALL, 0);
}

tree::TerminalNode* SV3_1aParser::Charge_strengthContext::MEDIUM() {
  return getToken(SV3_1aParser::MEDIUM, 0);
}

tree::TerminalNode* SV3_1aParser::Charge_strengthContext::LARGE() {
  return getToken(SV3_1aParser::LARGE, 0);
}


size_t SV3_1aParser::Charge_strengthContext::getRuleIndex() const {
  return SV3_1aParser::RuleCharge_strength;
}

void SV3_1aParser::Charge_strengthContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCharge_strength(this);
}

void SV3_1aParser::Charge_strengthContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCharge_strength(this);
}

SV3_1aParser::Charge_strengthContext* SV3_1aParser::charge_strength() {
  Charge_strengthContext *_localctx = _tracker.createInstance<Charge_strengthContext>(_ctx, getState());
  enterRule(_localctx, 302, SV3_1aParser::RuleCharge_strength);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3376);
    _la = _input->LA(1);
    if (!(((((_la - 162) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 162)) & 7) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Delay3Context ------------------------------------------------------------------

SV3_1aParser::Delay3Context::Delay3Context(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::Pound_delay_valueContext* SV3_1aParser::Delay3Context::pound_delay_value() {
  return getRuleContext<SV3_1aParser::Pound_delay_valueContext>(0);
}

tree::TerminalNode* SV3_1aParser::Delay3Context::POUND() {
  return getToken(SV3_1aParser::POUND, 0);
}

tree::TerminalNode* SV3_1aParser::Delay3Context::OPEN_PARENS() {
  return getToken(SV3_1aParser::OPEN_PARENS, 0);
}

std::vector<SV3_1aParser::Mintypmax_expressionContext *> SV3_1aParser::Delay3Context::mintypmax_expression() {
  return getRuleContexts<SV3_1aParser::Mintypmax_expressionContext>();
}

SV3_1aParser::Mintypmax_expressionContext* SV3_1aParser::Delay3Context::mintypmax_expression(size_t i) {
  return getRuleContext<SV3_1aParser::Mintypmax_expressionContext>(i);
}

tree::TerminalNode* SV3_1aParser::Delay3Context::CLOSE_PARENS() {
  return getToken(SV3_1aParser::CLOSE_PARENS, 0);
}

std::vector<tree::TerminalNode *> SV3_1aParser::Delay3Context::COMMA() {
  return getTokens(SV3_1aParser::COMMA);
}

tree::TerminalNode* SV3_1aParser::Delay3Context::COMMA(size_t i) {
  return getToken(SV3_1aParser::COMMA, i);
}


size_t SV3_1aParser::Delay3Context::getRuleIndex() const {
  return SV3_1aParser::RuleDelay3;
}

void SV3_1aParser::Delay3Context::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDelay3(this);
}

void SV3_1aParser::Delay3Context::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDelay3(this);
}

SV3_1aParser::Delay3Context* SV3_1aParser::delay3() {
  Delay3Context *_localctx = _tracker.createInstance<Delay3Context>(_ctx, getState());
  enterRule(_localctx, 304, SV3_1aParser::RuleDelay3);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(3392);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 313, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(3378);
      pound_delay_value();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(3379);
      match(SV3_1aParser::POUND);
      setState(3380);
      match(SV3_1aParser::OPEN_PARENS);
      setState(3381);
      mintypmax_expression();
      setState(3388);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == SV3_1aParser::COMMA) {
        setState(3382);
        match(SV3_1aParser::COMMA);
        setState(3383);
        mintypmax_expression();
        setState(3386);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == SV3_1aParser::COMMA) {
          setState(3384);
          match(SV3_1aParser::COMMA);
          setState(3385);
          mintypmax_expression();
        }
      }
      setState(3390);
      match(SV3_1aParser::CLOSE_PARENS);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Delay2Context ------------------------------------------------------------------

SV3_1aParser::Delay2Context::Delay2Context(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::Pound_delay_valueContext* SV3_1aParser::Delay2Context::pound_delay_value() {
  return getRuleContext<SV3_1aParser::Pound_delay_valueContext>(0);
}

tree::TerminalNode* SV3_1aParser::Delay2Context::POUND() {
  return getToken(SV3_1aParser::POUND, 0);
}

tree::TerminalNode* SV3_1aParser::Delay2Context::OPEN_PARENS() {
  return getToken(SV3_1aParser::OPEN_PARENS, 0);
}

std::vector<SV3_1aParser::Mintypmax_expressionContext *> SV3_1aParser::Delay2Context::mintypmax_expression() {
  return getRuleContexts<SV3_1aParser::Mintypmax_expressionContext>();
}

SV3_1aParser::Mintypmax_expressionContext* SV3_1aParser::Delay2Context::mintypmax_expression(size_t i) {
  return getRuleContext<SV3_1aParser::Mintypmax_expressionContext>(i);
}

tree::TerminalNode* SV3_1aParser::Delay2Context::CLOSE_PARENS() {
  return getToken(SV3_1aParser::CLOSE_PARENS, 0);
}

tree::TerminalNode* SV3_1aParser::Delay2Context::COMMA() {
  return getToken(SV3_1aParser::COMMA, 0);
}


size_t SV3_1aParser::Delay2Context::getRuleIndex() const {
  return SV3_1aParser::RuleDelay2;
}

void SV3_1aParser::Delay2Context::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDelay2(this);
}

void SV3_1aParser::Delay2Context::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDelay2(this);
}

SV3_1aParser::Delay2Context* SV3_1aParser::delay2() {
  Delay2Context *_localctx = _tracker.createInstance<Delay2Context>(_ctx, getState());
  enterRule(_localctx, 306, SV3_1aParser::RuleDelay2);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(3404);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 315, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(3394);
      pound_delay_value();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(3395);
      match(SV3_1aParser::POUND);
      setState(3396);
      match(SV3_1aParser::OPEN_PARENS);
      setState(3397);
      mintypmax_expression();
      setState(3400);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == SV3_1aParser::COMMA) {
        setState(3398);
        match(SV3_1aParser::COMMA);
        setState(3399);
        mintypmax_expression();
      }
      setState(3402);
      match(SV3_1aParser::CLOSE_PARENS);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Pound_delay_valueContext ------------------------------------------------------------------

SV3_1aParser::Pound_delay_valueContext::Pound_delay_valueContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Pound_delay_valueContext::Pound_Pound_delay() {
  return getToken(SV3_1aParser::Pound_Pound_delay, 0);
}

SV3_1aParser::Time_unitContext* SV3_1aParser::Pound_delay_valueContext::time_unit() {
  return getRuleContext<SV3_1aParser::Time_unitContext>(0);
}

tree::TerminalNode* SV3_1aParser::Pound_delay_valueContext::Pound_delay() {
  return getToken(SV3_1aParser::Pound_delay, 0);
}

tree::TerminalNode* SV3_1aParser::Pound_delay_valueContext::POUND() {
  return getToken(SV3_1aParser::POUND, 0);
}

SV3_1aParser::Delay_valueContext* SV3_1aParser::Pound_delay_valueContext::delay_value() {
  return getRuleContext<SV3_1aParser::Delay_valueContext>(0);
}


size_t SV3_1aParser::Pound_delay_valueContext::getRuleIndex() const {
  return SV3_1aParser::RulePound_delay_value;
}

void SV3_1aParser::Pound_delay_valueContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPound_delay_value(this);
}

void SV3_1aParser::Pound_delay_valueContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPound_delay_value(this);
}

SV3_1aParser::Pound_delay_valueContext* SV3_1aParser::pound_delay_value() {
  Pound_delay_valueContext *_localctx = _tracker.createInstance<Pound_delay_valueContext>(_ctx, getState());
  enterRule(_localctx, 308, SV3_1aParser::RulePound_delay_value);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(3416);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SV3_1aParser::Pound_Pound_delay: {
        enterOuterAlt(_localctx, 1);
        setState(3406);
        match(SV3_1aParser::Pound_Pound_delay);
        setState(3408);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 316, _ctx)) {
        case 1: {
          setState(3407);
          time_unit();
          break;
        }

        default:
          break;
        }
        break;
      }

      case SV3_1aParser::Pound_delay: {
        enterOuterAlt(_localctx, 2);
        setState(3410);
        match(SV3_1aParser::Pound_delay);
        setState(3412);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 317, _ctx)) {
        case 1: {
          setState(3411);
          time_unit();
          break;
        }

        default:
          break;
        }
        break;
      }

      case SV3_1aParser::POUND: {
        enterOuterAlt(_localctx, 3);
        setState(3414);
        match(SV3_1aParser::POUND);
        setState(3415);
        delay_value();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Delay_valueContext ------------------------------------------------------------------

SV3_1aParser::Delay_valueContext::Delay_valueContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Delay_valueContext::Integral_number() {
  return getToken(SV3_1aParser::Integral_number, 0);
}

tree::TerminalNode* SV3_1aParser::Delay_valueContext::Real_number() {
  return getToken(SV3_1aParser::Real_number, 0);
}

SV3_1aParser::Ps_identifierContext* SV3_1aParser::Delay_valueContext::ps_identifier() {
  return getRuleContext<SV3_1aParser::Ps_identifierContext>(0);
}

SV3_1aParser::Time_literalContext* SV3_1aParser::Delay_valueContext::time_literal() {
  return getRuleContext<SV3_1aParser::Time_literalContext>(0);
}

tree::TerminalNode* SV3_1aParser::Delay_valueContext::ONESTEP() {
  return getToken(SV3_1aParser::ONESTEP, 0);
}

SV3_1aParser::Ps_or_hierarchical_identifierContext* SV3_1aParser::Delay_valueContext::ps_or_hierarchical_identifier() {
  return getRuleContext<SV3_1aParser::Ps_or_hierarchical_identifierContext>(0);
}


size_t SV3_1aParser::Delay_valueContext::getRuleIndex() const {
  return SV3_1aParser::RuleDelay_value;
}

void SV3_1aParser::Delay_valueContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDelay_value(this);
}

void SV3_1aParser::Delay_valueContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDelay_value(this);
}

SV3_1aParser::Delay_valueContext* SV3_1aParser::delay_value() {
  Delay_valueContext *_localctx = _tracker.createInstance<Delay_valueContext>(_ctx, getState());
  enterRule(_localctx, 310, SV3_1aParser::RuleDelay_value);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(3424);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 319, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(3418);
      match(SV3_1aParser::Integral_number);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(3419);
      match(SV3_1aParser::Real_number);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(3420);
      ps_identifier();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(3421);
      time_literal();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(3422);
      match(SV3_1aParser::ONESTEP);
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(3423);
      ps_or_hierarchical_identifier();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- List_of_defparam_assignmentsContext ------------------------------------------------------------------

SV3_1aParser::List_of_defparam_assignmentsContext::List_of_defparam_assignmentsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<SV3_1aParser::Defparam_assignmentContext *> SV3_1aParser::List_of_defparam_assignmentsContext::defparam_assignment() {
  return getRuleContexts<SV3_1aParser::Defparam_assignmentContext>();
}

SV3_1aParser::Defparam_assignmentContext* SV3_1aParser::List_of_defparam_assignmentsContext::defparam_assignment(size_t i) {
  return getRuleContext<SV3_1aParser::Defparam_assignmentContext>(i);
}

std::vector<tree::TerminalNode *> SV3_1aParser::List_of_defparam_assignmentsContext::COMMA() {
  return getTokens(SV3_1aParser::COMMA);
}

tree::TerminalNode* SV3_1aParser::List_of_defparam_assignmentsContext::COMMA(size_t i) {
  return getToken(SV3_1aParser::COMMA, i);
}


size_t SV3_1aParser::List_of_defparam_assignmentsContext::getRuleIndex() const {
  return SV3_1aParser::RuleList_of_defparam_assignments;
}

void SV3_1aParser::List_of_defparam_assignmentsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterList_of_defparam_assignments(this);
}

void SV3_1aParser::List_of_defparam_assignmentsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitList_of_defparam_assignments(this);
}

SV3_1aParser::List_of_defparam_assignmentsContext* SV3_1aParser::list_of_defparam_assignments() {
  List_of_defparam_assignmentsContext *_localctx = _tracker.createInstance<List_of_defparam_assignmentsContext>(_ctx, getState());
  enterRule(_localctx, 312, SV3_1aParser::RuleList_of_defparam_assignments);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3426);
    defparam_assignment();
    setState(3431);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == SV3_1aParser::COMMA) {
      setState(3427);
      match(SV3_1aParser::COMMA);
      setState(3428);
      defparam_assignment();
      setState(3433);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- List_of_interface_identifiersContext ------------------------------------------------------------------

SV3_1aParser::List_of_interface_identifiersContext::List_of_interface_identifiersContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<SV3_1aParser::Interface_identifierContext *> SV3_1aParser::List_of_interface_identifiersContext::interface_identifier() {
  return getRuleContexts<SV3_1aParser::Interface_identifierContext>();
}

SV3_1aParser::Interface_identifierContext* SV3_1aParser::List_of_interface_identifiersContext::interface_identifier(size_t i) {
  return getRuleContext<SV3_1aParser::Interface_identifierContext>(i);
}

std::vector<SV3_1aParser::Unpacked_dimensionContext *> SV3_1aParser::List_of_interface_identifiersContext::unpacked_dimension() {
  return getRuleContexts<SV3_1aParser::Unpacked_dimensionContext>();
}

SV3_1aParser::Unpacked_dimensionContext* SV3_1aParser::List_of_interface_identifiersContext::unpacked_dimension(size_t i) {
  return getRuleContext<SV3_1aParser::Unpacked_dimensionContext>(i);
}

std::vector<tree::TerminalNode *> SV3_1aParser::List_of_interface_identifiersContext::COMMA() {
  return getTokens(SV3_1aParser::COMMA);
}

tree::TerminalNode* SV3_1aParser::List_of_interface_identifiersContext::COMMA(size_t i) {
  return getToken(SV3_1aParser::COMMA, i);
}


size_t SV3_1aParser::List_of_interface_identifiersContext::getRuleIndex() const {
  return SV3_1aParser::RuleList_of_interface_identifiers;
}

void SV3_1aParser::List_of_interface_identifiersContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterList_of_interface_identifiers(this);
}

void SV3_1aParser::List_of_interface_identifiersContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitList_of_interface_identifiers(this);
}

SV3_1aParser::List_of_interface_identifiersContext* SV3_1aParser::list_of_interface_identifiers() {
  List_of_interface_identifiersContext *_localctx = _tracker.createInstance<List_of_interface_identifiersContext>(_ctx, getState());
  enterRule(_localctx, 314, SV3_1aParser::RuleList_of_interface_identifiers);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3434);
    interface_identifier();
    setState(3438);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == SV3_1aParser::OPEN_BRACKET) {
      setState(3435);
      unpacked_dimension();
      setState(3440);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(3451);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == SV3_1aParser::COMMA) {
      setState(3441);
      match(SV3_1aParser::COMMA);
      setState(3442);
      interface_identifier();
      setState(3446);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == SV3_1aParser::OPEN_BRACKET) {
        setState(3443);
        unpacked_dimension();
        setState(3448);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(3453);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- List_of_net_decl_assignmentsContext ------------------------------------------------------------------

SV3_1aParser::List_of_net_decl_assignmentsContext::List_of_net_decl_assignmentsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<SV3_1aParser::Net_decl_assignmentContext *> SV3_1aParser::List_of_net_decl_assignmentsContext::net_decl_assignment() {
  return getRuleContexts<SV3_1aParser::Net_decl_assignmentContext>();
}

SV3_1aParser::Net_decl_assignmentContext* SV3_1aParser::List_of_net_decl_assignmentsContext::net_decl_assignment(size_t i) {
  return getRuleContext<SV3_1aParser::Net_decl_assignmentContext>(i);
}

std::vector<tree::TerminalNode *> SV3_1aParser::List_of_net_decl_assignmentsContext::COMMA() {
  return getTokens(SV3_1aParser::COMMA);
}

tree::TerminalNode* SV3_1aParser::List_of_net_decl_assignmentsContext::COMMA(size_t i) {
  return getToken(SV3_1aParser::COMMA, i);
}


size_t SV3_1aParser::List_of_net_decl_assignmentsContext::getRuleIndex() const {
  return SV3_1aParser::RuleList_of_net_decl_assignments;
}

void SV3_1aParser::List_of_net_decl_assignmentsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterList_of_net_decl_assignments(this);
}

void SV3_1aParser::List_of_net_decl_assignmentsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitList_of_net_decl_assignments(this);
}

SV3_1aParser::List_of_net_decl_assignmentsContext* SV3_1aParser::list_of_net_decl_assignments() {
  List_of_net_decl_assignmentsContext *_localctx = _tracker.createInstance<List_of_net_decl_assignmentsContext>(_ctx, getState());
  enterRule(_localctx, 316, SV3_1aParser::RuleList_of_net_decl_assignments);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3454);
    net_decl_assignment();
    setState(3459);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == SV3_1aParser::COMMA) {
      setState(3455);
      match(SV3_1aParser::COMMA);
      setState(3456);
      net_decl_assignment();
      setState(3461);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- List_of_param_assignmentsContext ------------------------------------------------------------------

SV3_1aParser::List_of_param_assignmentsContext::List_of_param_assignmentsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<SV3_1aParser::Param_assignmentContext *> SV3_1aParser::List_of_param_assignmentsContext::param_assignment() {
  return getRuleContexts<SV3_1aParser::Param_assignmentContext>();
}

SV3_1aParser::Param_assignmentContext* SV3_1aParser::List_of_param_assignmentsContext::param_assignment(size_t i) {
  return getRuleContext<SV3_1aParser::Param_assignmentContext>(i);
}

std::vector<tree::TerminalNode *> SV3_1aParser::List_of_param_assignmentsContext::COMMA() {
  return getTokens(SV3_1aParser::COMMA);
}

tree::TerminalNode* SV3_1aParser::List_of_param_assignmentsContext::COMMA(size_t i) {
  return getToken(SV3_1aParser::COMMA, i);
}


size_t SV3_1aParser::List_of_param_assignmentsContext::getRuleIndex() const {
  return SV3_1aParser::RuleList_of_param_assignments;
}

void SV3_1aParser::List_of_param_assignmentsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterList_of_param_assignments(this);
}

void SV3_1aParser::List_of_param_assignmentsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitList_of_param_assignments(this);
}

SV3_1aParser::List_of_param_assignmentsContext* SV3_1aParser::list_of_param_assignments() {
  List_of_param_assignmentsContext *_localctx = _tracker.createInstance<List_of_param_assignmentsContext>(_ctx, getState());
  enterRule(_localctx, 318, SV3_1aParser::RuleList_of_param_assignments);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(3462);
    param_assignment();
    setState(3467);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 325, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(3463);
        match(SV3_1aParser::COMMA);
        setState(3464);
        param_assignment(); 
      }
      setState(3469);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 325, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- List_of_port_identifiersContext ------------------------------------------------------------------

SV3_1aParser::List_of_port_identifiersContext::List_of_port_identifiersContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<SV3_1aParser::IdentifierContext *> SV3_1aParser::List_of_port_identifiersContext::identifier() {
  return getRuleContexts<SV3_1aParser::IdentifierContext>();
}

SV3_1aParser::IdentifierContext* SV3_1aParser::List_of_port_identifiersContext::identifier(size_t i) {
  return getRuleContext<SV3_1aParser::IdentifierContext>(i);
}

std::vector<SV3_1aParser::Unpacked_dimensionContext *> SV3_1aParser::List_of_port_identifiersContext::unpacked_dimension() {
  return getRuleContexts<SV3_1aParser::Unpacked_dimensionContext>();
}

SV3_1aParser::Unpacked_dimensionContext* SV3_1aParser::List_of_port_identifiersContext::unpacked_dimension(size_t i) {
  return getRuleContext<SV3_1aParser::Unpacked_dimensionContext>(i);
}

std::vector<tree::TerminalNode *> SV3_1aParser::List_of_port_identifiersContext::COMMA() {
  return getTokens(SV3_1aParser::COMMA);
}

tree::TerminalNode* SV3_1aParser::List_of_port_identifiersContext::COMMA(size_t i) {
  return getToken(SV3_1aParser::COMMA, i);
}


size_t SV3_1aParser::List_of_port_identifiersContext::getRuleIndex() const {
  return SV3_1aParser::RuleList_of_port_identifiers;
}

void SV3_1aParser::List_of_port_identifiersContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterList_of_port_identifiers(this);
}

void SV3_1aParser::List_of_port_identifiersContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitList_of_port_identifiers(this);
}

SV3_1aParser::List_of_port_identifiersContext* SV3_1aParser::list_of_port_identifiers() {
  List_of_port_identifiersContext *_localctx = _tracker.createInstance<List_of_port_identifiersContext>(_ctx, getState());
  enterRule(_localctx, 320, SV3_1aParser::RuleList_of_port_identifiers);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3470);
    identifier();
    setState(3474);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == SV3_1aParser::OPEN_BRACKET) {
      setState(3471);
      unpacked_dimension();
      setState(3476);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(3487);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == SV3_1aParser::COMMA) {
      setState(3477);
      match(SV3_1aParser::COMMA);
      setState(3478);
      identifier();
      setState(3482);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == SV3_1aParser::OPEN_BRACKET) {
        setState(3479);
        unpacked_dimension();
        setState(3484);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(3489);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- List_of_specparam_assignmentsContext ------------------------------------------------------------------

SV3_1aParser::List_of_specparam_assignmentsContext::List_of_specparam_assignmentsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<SV3_1aParser::Specparam_assignmentContext *> SV3_1aParser::List_of_specparam_assignmentsContext::specparam_assignment() {
  return getRuleContexts<SV3_1aParser::Specparam_assignmentContext>();
}

SV3_1aParser::Specparam_assignmentContext* SV3_1aParser::List_of_specparam_assignmentsContext::specparam_assignment(size_t i) {
  return getRuleContext<SV3_1aParser::Specparam_assignmentContext>(i);
}

std::vector<tree::TerminalNode *> SV3_1aParser::List_of_specparam_assignmentsContext::COMMA() {
  return getTokens(SV3_1aParser::COMMA);
}

tree::TerminalNode* SV3_1aParser::List_of_specparam_assignmentsContext::COMMA(size_t i) {
  return getToken(SV3_1aParser::COMMA, i);
}


size_t SV3_1aParser::List_of_specparam_assignmentsContext::getRuleIndex() const {
  return SV3_1aParser::RuleList_of_specparam_assignments;
}

void SV3_1aParser::List_of_specparam_assignmentsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterList_of_specparam_assignments(this);
}

void SV3_1aParser::List_of_specparam_assignmentsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitList_of_specparam_assignments(this);
}

SV3_1aParser::List_of_specparam_assignmentsContext* SV3_1aParser::list_of_specparam_assignments() {
  List_of_specparam_assignmentsContext *_localctx = _tracker.createInstance<List_of_specparam_assignmentsContext>(_ctx, getState());
  enterRule(_localctx, 322, SV3_1aParser::RuleList_of_specparam_assignments);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3490);
    specparam_assignment();
    setState(3495);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == SV3_1aParser::COMMA) {
      setState(3491);
      match(SV3_1aParser::COMMA);
      setState(3492);
      specparam_assignment();
      setState(3497);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- List_of_tf_variable_identifiersContext ------------------------------------------------------------------

SV3_1aParser::List_of_tf_variable_identifiersContext::List_of_tf_variable_identifiersContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<SV3_1aParser::IdentifierContext *> SV3_1aParser::List_of_tf_variable_identifiersContext::identifier() {
  return getRuleContexts<SV3_1aParser::IdentifierContext>();
}

SV3_1aParser::IdentifierContext* SV3_1aParser::List_of_tf_variable_identifiersContext::identifier(size_t i) {
  return getRuleContext<SV3_1aParser::IdentifierContext>(i);
}

std::vector<SV3_1aParser::Variable_dimensionContext *> SV3_1aParser::List_of_tf_variable_identifiersContext::variable_dimension() {
  return getRuleContexts<SV3_1aParser::Variable_dimensionContext>();
}

SV3_1aParser::Variable_dimensionContext* SV3_1aParser::List_of_tf_variable_identifiersContext::variable_dimension(size_t i) {
  return getRuleContext<SV3_1aParser::Variable_dimensionContext>(i);
}

std::vector<tree::TerminalNode *> SV3_1aParser::List_of_tf_variable_identifiersContext::ASSIGN_OP() {
  return getTokens(SV3_1aParser::ASSIGN_OP);
}

tree::TerminalNode* SV3_1aParser::List_of_tf_variable_identifiersContext::ASSIGN_OP(size_t i) {
  return getToken(SV3_1aParser::ASSIGN_OP, i);
}

std::vector<SV3_1aParser::ExpressionContext *> SV3_1aParser::List_of_tf_variable_identifiersContext::expression() {
  return getRuleContexts<SV3_1aParser::ExpressionContext>();
}

SV3_1aParser::ExpressionContext* SV3_1aParser::List_of_tf_variable_identifiersContext::expression(size_t i) {
  return getRuleContext<SV3_1aParser::ExpressionContext>(i);
}

std::vector<tree::TerminalNode *> SV3_1aParser::List_of_tf_variable_identifiersContext::COMMA() {
  return getTokens(SV3_1aParser::COMMA);
}

tree::TerminalNode* SV3_1aParser::List_of_tf_variable_identifiersContext::COMMA(size_t i) {
  return getToken(SV3_1aParser::COMMA, i);
}


size_t SV3_1aParser::List_of_tf_variable_identifiersContext::getRuleIndex() const {
  return SV3_1aParser::RuleList_of_tf_variable_identifiers;
}

void SV3_1aParser::List_of_tf_variable_identifiersContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterList_of_tf_variable_identifiers(this);
}

void SV3_1aParser::List_of_tf_variable_identifiersContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitList_of_tf_variable_identifiers(this);
}

SV3_1aParser::List_of_tf_variable_identifiersContext* SV3_1aParser::list_of_tf_variable_identifiers() {
  List_of_tf_variable_identifiersContext *_localctx = _tracker.createInstance<List_of_tf_variable_identifiersContext>(_ctx, getState());
  enterRule(_localctx, 324, SV3_1aParser::RuleList_of_tf_variable_identifiers);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3498);
    identifier();
    setState(3502);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == SV3_1aParser::ASSOCIATIVE_UNSPECIFIED || _la == SV3_1aParser::OPEN_BRACKET) {
      setState(3499);
      variable_dimension();
      setState(3504);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(3507);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SV3_1aParser::ASSIGN_OP) {
      setState(3505);
      match(SV3_1aParser::ASSIGN_OP);
      setState(3506);
      expression(0);
    }
    setState(3523);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == SV3_1aParser::COMMA) {
      setState(3509);
      match(SV3_1aParser::COMMA);
      setState(3510);
      identifier();
      setState(3514);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == SV3_1aParser::ASSOCIATIVE_UNSPECIFIED || _la == SV3_1aParser::OPEN_BRACKET) {
        setState(3511);
        variable_dimension();
        setState(3516);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(3519);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == SV3_1aParser::ASSIGN_OP) {
        setState(3517);
        match(SV3_1aParser::ASSIGN_OP);
        setState(3518);
        expression(0);
      }
      setState(3525);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- List_of_type_assignmentsContext ------------------------------------------------------------------

SV3_1aParser::List_of_type_assignmentsContext::List_of_type_assignmentsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<SV3_1aParser::IdentifierContext *> SV3_1aParser::List_of_type_assignmentsContext::identifier() {
  return getRuleContexts<SV3_1aParser::IdentifierContext>();
}

SV3_1aParser::IdentifierContext* SV3_1aParser::List_of_type_assignmentsContext::identifier(size_t i) {
  return getRuleContext<SV3_1aParser::IdentifierContext>(i);
}

std::vector<tree::TerminalNode *> SV3_1aParser::List_of_type_assignmentsContext::COMMA() {
  return getTokens(SV3_1aParser::COMMA);
}

tree::TerminalNode* SV3_1aParser::List_of_type_assignmentsContext::COMMA(size_t i) {
  return getToken(SV3_1aParser::COMMA, i);
}

std::vector<tree::TerminalNode *> SV3_1aParser::List_of_type_assignmentsContext::ASSIGN_OP() {
  return getTokens(SV3_1aParser::ASSIGN_OP);
}

tree::TerminalNode* SV3_1aParser::List_of_type_assignmentsContext::ASSIGN_OP(size_t i) {
  return getToken(SV3_1aParser::ASSIGN_OP, i);
}

std::vector<SV3_1aParser::Data_typeContext *> SV3_1aParser::List_of_type_assignmentsContext::data_type() {
  return getRuleContexts<SV3_1aParser::Data_typeContext>();
}

SV3_1aParser::Data_typeContext* SV3_1aParser::List_of_type_assignmentsContext::data_type(size_t i) {
  return getRuleContext<SV3_1aParser::Data_typeContext>(i);
}


size_t SV3_1aParser::List_of_type_assignmentsContext::getRuleIndex() const {
  return SV3_1aParser::RuleList_of_type_assignments;
}

void SV3_1aParser::List_of_type_assignmentsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterList_of_type_assignments(this);
}

void SV3_1aParser::List_of_type_assignmentsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitList_of_type_assignments(this);
}

SV3_1aParser::List_of_type_assignmentsContext* SV3_1aParser::list_of_type_assignments() {
  List_of_type_assignmentsContext *_localctx = _tracker.createInstance<List_of_type_assignmentsContext>(_ctx, getState());
  enterRule(_localctx, 326, SV3_1aParser::RuleList_of_type_assignments);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(3526);
    identifier();
    setState(3529);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SV3_1aParser::ASSIGN_OP) {
      setState(3527);
      match(SV3_1aParser::ASSIGN_OP);
      setState(3528);
      data_type();
    }
    setState(3539);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 337, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(3531);
        match(SV3_1aParser::COMMA);

        setState(3532);
        identifier();
        setState(3535);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == SV3_1aParser::ASSIGN_OP) {
          setState(3533);
          match(SV3_1aParser::ASSIGN_OP);
          setState(3534);
          data_type();
        } 
      }
      setState(3541);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 337, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- List_of_variable_decl_assignmentsContext ------------------------------------------------------------------

SV3_1aParser::List_of_variable_decl_assignmentsContext::List_of_variable_decl_assignmentsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<SV3_1aParser::Variable_decl_assignmentContext *> SV3_1aParser::List_of_variable_decl_assignmentsContext::variable_decl_assignment() {
  return getRuleContexts<SV3_1aParser::Variable_decl_assignmentContext>();
}

SV3_1aParser::Variable_decl_assignmentContext* SV3_1aParser::List_of_variable_decl_assignmentsContext::variable_decl_assignment(size_t i) {
  return getRuleContext<SV3_1aParser::Variable_decl_assignmentContext>(i);
}

std::vector<tree::TerminalNode *> SV3_1aParser::List_of_variable_decl_assignmentsContext::COMMA() {
  return getTokens(SV3_1aParser::COMMA);
}

tree::TerminalNode* SV3_1aParser::List_of_variable_decl_assignmentsContext::COMMA(size_t i) {
  return getToken(SV3_1aParser::COMMA, i);
}


size_t SV3_1aParser::List_of_variable_decl_assignmentsContext::getRuleIndex() const {
  return SV3_1aParser::RuleList_of_variable_decl_assignments;
}

void SV3_1aParser::List_of_variable_decl_assignmentsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterList_of_variable_decl_assignments(this);
}

void SV3_1aParser::List_of_variable_decl_assignmentsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitList_of_variable_decl_assignments(this);
}

SV3_1aParser::List_of_variable_decl_assignmentsContext* SV3_1aParser::list_of_variable_decl_assignments() {
  List_of_variable_decl_assignmentsContext *_localctx = _tracker.createInstance<List_of_variable_decl_assignmentsContext>(_ctx, getState());
  enterRule(_localctx, 328, SV3_1aParser::RuleList_of_variable_decl_assignments);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3542);
    variable_decl_assignment();
    setState(3547);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == SV3_1aParser::COMMA) {
      setState(3543);
      match(SV3_1aParser::COMMA);
      setState(3544);
      variable_decl_assignment();
      setState(3549);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- List_of_variable_identifiersContext ------------------------------------------------------------------

SV3_1aParser::List_of_variable_identifiersContext::List_of_variable_identifiersContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<SV3_1aParser::IdentifierContext *> SV3_1aParser::List_of_variable_identifiersContext::identifier() {
  return getRuleContexts<SV3_1aParser::IdentifierContext>();
}

SV3_1aParser::IdentifierContext* SV3_1aParser::List_of_variable_identifiersContext::identifier(size_t i) {
  return getRuleContext<SV3_1aParser::IdentifierContext>(i);
}

std::vector<SV3_1aParser::Variable_dimensionContext *> SV3_1aParser::List_of_variable_identifiersContext::variable_dimension() {
  return getRuleContexts<SV3_1aParser::Variable_dimensionContext>();
}

SV3_1aParser::Variable_dimensionContext* SV3_1aParser::List_of_variable_identifiersContext::variable_dimension(size_t i) {
  return getRuleContext<SV3_1aParser::Variable_dimensionContext>(i);
}

std::vector<tree::TerminalNode *> SV3_1aParser::List_of_variable_identifiersContext::COMMA() {
  return getTokens(SV3_1aParser::COMMA);
}

tree::TerminalNode* SV3_1aParser::List_of_variable_identifiersContext::COMMA(size_t i) {
  return getToken(SV3_1aParser::COMMA, i);
}


size_t SV3_1aParser::List_of_variable_identifiersContext::getRuleIndex() const {
  return SV3_1aParser::RuleList_of_variable_identifiers;
}

void SV3_1aParser::List_of_variable_identifiersContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterList_of_variable_identifiers(this);
}

void SV3_1aParser::List_of_variable_identifiersContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitList_of_variable_identifiers(this);
}

SV3_1aParser::List_of_variable_identifiersContext* SV3_1aParser::list_of_variable_identifiers() {
  List_of_variable_identifiersContext *_localctx = _tracker.createInstance<List_of_variable_identifiersContext>(_ctx, getState());
  enterRule(_localctx, 330, SV3_1aParser::RuleList_of_variable_identifiers);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3550);
    identifier();
    setState(3554);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == SV3_1aParser::ASSOCIATIVE_UNSPECIFIED || _la == SV3_1aParser::OPEN_BRACKET) {
      setState(3551);
      variable_dimension();
      setState(3556);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(3567);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == SV3_1aParser::COMMA) {
      setState(3557);
      match(SV3_1aParser::COMMA);
      setState(3558);
      identifier();
      setState(3562);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == SV3_1aParser::ASSOCIATIVE_UNSPECIFIED || _la == SV3_1aParser::OPEN_BRACKET) {
        setState(3559);
        variable_dimension();
        setState(3564);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(3569);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- List_of_variable_port_identifiersContext ------------------------------------------------------------------

SV3_1aParser::List_of_variable_port_identifiersContext::List_of_variable_port_identifiersContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<SV3_1aParser::IdentifierContext *> SV3_1aParser::List_of_variable_port_identifiersContext::identifier() {
  return getRuleContexts<SV3_1aParser::IdentifierContext>();
}

SV3_1aParser::IdentifierContext* SV3_1aParser::List_of_variable_port_identifiersContext::identifier(size_t i) {
  return getRuleContext<SV3_1aParser::IdentifierContext>(i);
}

std::vector<SV3_1aParser::Variable_dimensionContext *> SV3_1aParser::List_of_variable_port_identifiersContext::variable_dimension() {
  return getRuleContexts<SV3_1aParser::Variable_dimensionContext>();
}

SV3_1aParser::Variable_dimensionContext* SV3_1aParser::List_of_variable_port_identifiersContext::variable_dimension(size_t i) {
  return getRuleContext<SV3_1aParser::Variable_dimensionContext>(i);
}

std::vector<tree::TerminalNode *> SV3_1aParser::List_of_variable_port_identifiersContext::ASSIGN_OP() {
  return getTokens(SV3_1aParser::ASSIGN_OP);
}

tree::TerminalNode* SV3_1aParser::List_of_variable_port_identifiersContext::ASSIGN_OP(size_t i) {
  return getToken(SV3_1aParser::ASSIGN_OP, i);
}

std::vector<SV3_1aParser::Constant_expressionContext *> SV3_1aParser::List_of_variable_port_identifiersContext::constant_expression() {
  return getRuleContexts<SV3_1aParser::Constant_expressionContext>();
}

SV3_1aParser::Constant_expressionContext* SV3_1aParser::List_of_variable_port_identifiersContext::constant_expression(size_t i) {
  return getRuleContext<SV3_1aParser::Constant_expressionContext>(i);
}

std::vector<tree::TerminalNode *> SV3_1aParser::List_of_variable_port_identifiersContext::COMMA() {
  return getTokens(SV3_1aParser::COMMA);
}

tree::TerminalNode* SV3_1aParser::List_of_variable_port_identifiersContext::COMMA(size_t i) {
  return getToken(SV3_1aParser::COMMA, i);
}


size_t SV3_1aParser::List_of_variable_port_identifiersContext::getRuleIndex() const {
  return SV3_1aParser::RuleList_of_variable_port_identifiers;
}

void SV3_1aParser::List_of_variable_port_identifiersContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterList_of_variable_port_identifiers(this);
}

void SV3_1aParser::List_of_variable_port_identifiersContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitList_of_variable_port_identifiers(this);
}

SV3_1aParser::List_of_variable_port_identifiersContext* SV3_1aParser::list_of_variable_port_identifiers() {
  List_of_variable_port_identifiersContext *_localctx = _tracker.createInstance<List_of_variable_port_identifiersContext>(_ctx, getState());
  enterRule(_localctx, 332, SV3_1aParser::RuleList_of_variable_port_identifiers);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3570);
    identifier();
    setState(3574);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == SV3_1aParser::ASSOCIATIVE_UNSPECIFIED || _la == SV3_1aParser::OPEN_BRACKET) {
      setState(3571);
      variable_dimension();
      setState(3576);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(3579);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SV3_1aParser::ASSIGN_OP) {
      setState(3577);
      match(SV3_1aParser::ASSIGN_OP);
      setState(3578);
      constant_expression(0);
    }
    setState(3595);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == SV3_1aParser::COMMA) {
      setState(3581);
      match(SV3_1aParser::COMMA);
      setState(3582);
      identifier();
      setState(3586);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == SV3_1aParser::ASSOCIATIVE_UNSPECIFIED || _la == SV3_1aParser::OPEN_BRACKET) {
        setState(3583);
        variable_dimension();
        setState(3588);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(3591);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == SV3_1aParser::ASSIGN_OP) {
        setState(3589);
        match(SV3_1aParser::ASSIGN_OP);
        setState(3590);
        constant_expression(0);
      }
      setState(3597);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- List_of_virtual_interface_declContext ------------------------------------------------------------------

SV3_1aParser::List_of_virtual_interface_declContext::List_of_virtual_interface_declContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<SV3_1aParser::IdentifierContext *> SV3_1aParser::List_of_virtual_interface_declContext::identifier() {
  return getRuleContexts<SV3_1aParser::IdentifierContext>();
}

SV3_1aParser::IdentifierContext* SV3_1aParser::List_of_virtual_interface_declContext::identifier(size_t i) {
  return getRuleContext<SV3_1aParser::IdentifierContext>(i);
}

std::vector<tree::TerminalNode *> SV3_1aParser::List_of_virtual_interface_declContext::ASSIGN_OP() {
  return getTokens(SV3_1aParser::ASSIGN_OP);
}

tree::TerminalNode* SV3_1aParser::List_of_virtual_interface_declContext::ASSIGN_OP(size_t i) {
  return getToken(SV3_1aParser::ASSIGN_OP, i);
}

std::vector<tree::TerminalNode *> SV3_1aParser::List_of_virtual_interface_declContext::COMMA() {
  return getTokens(SV3_1aParser::COMMA);
}

tree::TerminalNode* SV3_1aParser::List_of_virtual_interface_declContext::COMMA(size_t i) {
  return getToken(SV3_1aParser::COMMA, i);
}


size_t SV3_1aParser::List_of_virtual_interface_declContext::getRuleIndex() const {
  return SV3_1aParser::RuleList_of_virtual_interface_decl;
}

void SV3_1aParser::List_of_virtual_interface_declContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterList_of_virtual_interface_decl(this);
}

void SV3_1aParser::List_of_virtual_interface_declContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitList_of_virtual_interface_decl(this);
}

SV3_1aParser::List_of_virtual_interface_declContext* SV3_1aParser::list_of_virtual_interface_decl() {
  List_of_virtual_interface_declContext *_localctx = _tracker.createInstance<List_of_virtual_interface_declContext>(_ctx, getState());
  enterRule(_localctx, 334, SV3_1aParser::RuleList_of_virtual_interface_decl);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3598);
    identifier();
    setState(3601);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SV3_1aParser::ASSIGN_OP) {
      setState(3599);
      match(SV3_1aParser::ASSIGN_OP);
      setState(3600);
      identifier();
    }
    setState(3611);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == SV3_1aParser::COMMA) {
      setState(3603);
      match(SV3_1aParser::COMMA);
      setState(3604);
      identifier();
      setState(3607);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == SV3_1aParser::ASSIGN_OP) {
        setState(3605);
        match(SV3_1aParser::ASSIGN_OP);
        setState(3606);
        identifier();
      }
      setState(3613);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Defparam_assignmentContext ------------------------------------------------------------------

SV3_1aParser::Defparam_assignmentContext::Defparam_assignmentContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Defparam_assignmentContext::ASSIGN_OP() {
  return getToken(SV3_1aParser::ASSIGN_OP, 0);
}

SV3_1aParser::Constant_mintypmax_expressionContext* SV3_1aParser::Defparam_assignmentContext::constant_mintypmax_expression() {
  return getRuleContext<SV3_1aParser::Constant_mintypmax_expressionContext>(0);
}

SV3_1aParser::IdentifierContext* SV3_1aParser::Defparam_assignmentContext::identifier() {
  return getRuleContext<SV3_1aParser::IdentifierContext>(0);
}

SV3_1aParser::Hierarchical_identifierContext* SV3_1aParser::Defparam_assignmentContext::hierarchical_identifier() {
  return getRuleContext<SV3_1aParser::Hierarchical_identifierContext>(0);
}


size_t SV3_1aParser::Defparam_assignmentContext::getRuleIndex() const {
  return SV3_1aParser::RuleDefparam_assignment;
}

void SV3_1aParser::Defparam_assignmentContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDefparam_assignment(this);
}

void SV3_1aParser::Defparam_assignmentContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDefparam_assignment(this);
}

SV3_1aParser::Defparam_assignmentContext* SV3_1aParser::defparam_assignment() {
  Defparam_assignmentContext *_localctx = _tracker.createInstance<Defparam_assignmentContext>(_ctx, getState());
  enterRule(_localctx, 336, SV3_1aParser::RuleDefparam_assignment);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3616);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 350, _ctx)) {
    case 1: {
      setState(3614);
      identifier();
      break;
    }

    case 2: {
      setState(3615);
      hierarchical_identifier();
      break;
    }

    default:
      break;
    }
    setState(3618);
    match(SV3_1aParser::ASSIGN_OP);
    setState(3619);
    constant_mintypmax_expression();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Net_decl_assignmentContext ------------------------------------------------------------------

SV3_1aParser::Net_decl_assignmentContext::Net_decl_assignmentContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::IdentifierContext* SV3_1aParser::Net_decl_assignmentContext::identifier() {
  return getRuleContext<SV3_1aParser::IdentifierContext>(0);
}

std::vector<SV3_1aParser::Unpacked_dimensionContext *> SV3_1aParser::Net_decl_assignmentContext::unpacked_dimension() {
  return getRuleContexts<SV3_1aParser::Unpacked_dimensionContext>();
}

SV3_1aParser::Unpacked_dimensionContext* SV3_1aParser::Net_decl_assignmentContext::unpacked_dimension(size_t i) {
  return getRuleContext<SV3_1aParser::Unpacked_dimensionContext>(i);
}

tree::TerminalNode* SV3_1aParser::Net_decl_assignmentContext::ASSIGN_OP() {
  return getToken(SV3_1aParser::ASSIGN_OP, 0);
}

SV3_1aParser::ExpressionContext* SV3_1aParser::Net_decl_assignmentContext::expression() {
  return getRuleContext<SV3_1aParser::ExpressionContext>(0);
}


size_t SV3_1aParser::Net_decl_assignmentContext::getRuleIndex() const {
  return SV3_1aParser::RuleNet_decl_assignment;
}

void SV3_1aParser::Net_decl_assignmentContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNet_decl_assignment(this);
}

void SV3_1aParser::Net_decl_assignmentContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNet_decl_assignment(this);
}

SV3_1aParser::Net_decl_assignmentContext* SV3_1aParser::net_decl_assignment() {
  Net_decl_assignmentContext *_localctx = _tracker.createInstance<Net_decl_assignmentContext>(_ctx, getState());
  enterRule(_localctx, 338, SV3_1aParser::RuleNet_decl_assignment);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3621);
    identifier();
    setState(3625);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == SV3_1aParser::OPEN_BRACKET) {
      setState(3622);
      unpacked_dimension();
      setState(3627);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(3630);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SV3_1aParser::ASSIGN_OP) {
      setState(3628);
      match(SV3_1aParser::ASSIGN_OP);
      setState(3629);
      expression(0);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Param_assignmentContext ------------------------------------------------------------------

SV3_1aParser::Param_assignmentContext::Param_assignmentContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::IdentifierContext* SV3_1aParser::Param_assignmentContext::identifier() {
  return getRuleContext<SV3_1aParser::IdentifierContext>(0);
}

std::vector<SV3_1aParser::Unpacked_dimensionContext *> SV3_1aParser::Param_assignmentContext::unpacked_dimension() {
  return getRuleContexts<SV3_1aParser::Unpacked_dimensionContext>();
}

SV3_1aParser::Unpacked_dimensionContext* SV3_1aParser::Param_assignmentContext::unpacked_dimension(size_t i) {
  return getRuleContext<SV3_1aParser::Unpacked_dimensionContext>(i);
}

tree::TerminalNode* SV3_1aParser::Param_assignmentContext::ASSIGN_OP() {
  return getToken(SV3_1aParser::ASSIGN_OP, 0);
}

SV3_1aParser::Constant_param_expressionContext* SV3_1aParser::Param_assignmentContext::constant_param_expression() {
  return getRuleContext<SV3_1aParser::Constant_param_expressionContext>(0);
}


size_t SV3_1aParser::Param_assignmentContext::getRuleIndex() const {
  return SV3_1aParser::RuleParam_assignment;
}

void SV3_1aParser::Param_assignmentContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterParam_assignment(this);
}

void SV3_1aParser::Param_assignmentContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitParam_assignment(this);
}

SV3_1aParser::Param_assignmentContext* SV3_1aParser::param_assignment() {
  Param_assignmentContext *_localctx = _tracker.createInstance<Param_assignmentContext>(_ctx, getState());
  enterRule(_localctx, 340, SV3_1aParser::RuleParam_assignment);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3632);
    identifier();
    setState(3636);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == SV3_1aParser::OPEN_BRACKET) {
      setState(3633);
      unpacked_dimension();
      setState(3638);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(3641);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SV3_1aParser::ASSIGN_OP) {
      setState(3639);
      match(SV3_1aParser::ASSIGN_OP);
      setState(3640);
      constant_param_expression();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Specparam_assignmentContext ------------------------------------------------------------------

SV3_1aParser::Specparam_assignmentContext::Specparam_assignmentContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::IdentifierContext* SV3_1aParser::Specparam_assignmentContext::identifier() {
  return getRuleContext<SV3_1aParser::IdentifierContext>(0);
}

tree::TerminalNode* SV3_1aParser::Specparam_assignmentContext::ASSIGN_OP() {
  return getToken(SV3_1aParser::ASSIGN_OP, 0);
}

SV3_1aParser::Constant_mintypmax_expressionContext* SV3_1aParser::Specparam_assignmentContext::constant_mintypmax_expression() {
  return getRuleContext<SV3_1aParser::Constant_mintypmax_expressionContext>(0);
}

SV3_1aParser::Pulse_control_specparamContext* SV3_1aParser::Specparam_assignmentContext::pulse_control_specparam() {
  return getRuleContext<SV3_1aParser::Pulse_control_specparamContext>(0);
}


size_t SV3_1aParser::Specparam_assignmentContext::getRuleIndex() const {
  return SV3_1aParser::RuleSpecparam_assignment;
}

void SV3_1aParser::Specparam_assignmentContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSpecparam_assignment(this);
}

void SV3_1aParser::Specparam_assignmentContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSpecparam_assignment(this);
}

SV3_1aParser::Specparam_assignmentContext* SV3_1aParser::specparam_assignment() {
  Specparam_assignmentContext *_localctx = _tracker.createInstance<Specparam_assignmentContext>(_ctx, getState());
  enterRule(_localctx, 342, SV3_1aParser::RuleSpecparam_assignment);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(3648);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SV3_1aParser::THIS:
      case SV3_1aParser::RANDOMIZE:
      case SV3_1aParser::SAMPLE:
      case SV3_1aParser::Escaped_identifier:
      case SV3_1aParser::Simple_identifier: {
        enterOuterAlt(_localctx, 1);
        setState(3643);
        identifier();
        setState(3644);
        match(SV3_1aParser::ASSIGN_OP);
        setState(3645);
        constant_mintypmax_expression();
        break;
      }

      case SV3_1aParser::PATHPULSE: {
        enterOuterAlt(_localctx, 2);
        setState(3647);
        pulse_control_specparam();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Pulse_control_specparamContext ------------------------------------------------------------------

SV3_1aParser::Pulse_control_specparamContext::Pulse_control_specparamContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Pulse_control_specparamContext::PATHPULSE() {
  return getToken(SV3_1aParser::PATHPULSE, 0);
}

std::vector<tree::TerminalNode *> SV3_1aParser::Pulse_control_specparamContext::DOLLAR() {
  return getTokens(SV3_1aParser::DOLLAR);
}

tree::TerminalNode* SV3_1aParser::Pulse_control_specparamContext::DOLLAR(size_t i) {
  return getToken(SV3_1aParser::DOLLAR, i);
}

tree::TerminalNode* SV3_1aParser::Pulse_control_specparamContext::ASSIGN_OP() {
  return getToken(SV3_1aParser::ASSIGN_OP, 0);
}

tree::TerminalNode* SV3_1aParser::Pulse_control_specparamContext::OPEN_PARENS() {
  return getToken(SV3_1aParser::OPEN_PARENS, 0);
}

std::vector<SV3_1aParser::Constant_mintypmax_expressionContext *> SV3_1aParser::Pulse_control_specparamContext::constant_mintypmax_expression() {
  return getRuleContexts<SV3_1aParser::Constant_mintypmax_expressionContext>();
}

SV3_1aParser::Constant_mintypmax_expressionContext* SV3_1aParser::Pulse_control_specparamContext::constant_mintypmax_expression(size_t i) {
  return getRuleContext<SV3_1aParser::Constant_mintypmax_expressionContext>(i);
}

tree::TerminalNode* SV3_1aParser::Pulse_control_specparamContext::CLOSE_PARENS() {
  return getToken(SV3_1aParser::CLOSE_PARENS, 0);
}

tree::TerminalNode* SV3_1aParser::Pulse_control_specparamContext::SEMICOLON() {
  return getToken(SV3_1aParser::SEMICOLON, 0);
}

tree::TerminalNode* SV3_1aParser::Pulse_control_specparamContext::COMMA() {
  return getToken(SV3_1aParser::COMMA, 0);
}

SV3_1aParser::Specify_input_terminal_descriptorContext* SV3_1aParser::Pulse_control_specparamContext::specify_input_terminal_descriptor() {
  return getRuleContext<SV3_1aParser::Specify_input_terminal_descriptorContext>(0);
}

SV3_1aParser::Specify_output_terminal_descriptorContext* SV3_1aParser::Pulse_control_specparamContext::specify_output_terminal_descriptor() {
  return getRuleContext<SV3_1aParser::Specify_output_terminal_descriptorContext>(0);
}


size_t SV3_1aParser::Pulse_control_specparamContext::getRuleIndex() const {
  return SV3_1aParser::RulePulse_control_specparam;
}

void SV3_1aParser::Pulse_control_specparamContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPulse_control_specparam(this);
}

void SV3_1aParser::Pulse_control_specparamContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPulse_control_specparam(this);
}

SV3_1aParser::Pulse_control_specparamContext* SV3_1aParser::pulse_control_specparam() {
  Pulse_control_specparamContext *_localctx = _tracker.createInstance<Pulse_control_specparamContext>(_ctx, getState());
  enterRule(_localctx, 344, SV3_1aParser::RulePulse_control_specparam);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(3677);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 358, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(3650);
      match(SV3_1aParser::PATHPULSE);
      setState(3651);
      match(SV3_1aParser::DOLLAR);
      setState(3652);
      match(SV3_1aParser::ASSIGN_OP);
      setState(3653);
      match(SV3_1aParser::OPEN_PARENS);
      setState(3654);
      constant_mintypmax_expression();
      setState(3657);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == SV3_1aParser::COMMA) {
        setState(3655);
        match(SV3_1aParser::COMMA);
        setState(3656);
        constant_mintypmax_expression();
      }
      setState(3659);
      match(SV3_1aParser::CLOSE_PARENS);
      setState(3660);
      match(SV3_1aParser::SEMICOLON);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(3662);
      match(SV3_1aParser::PATHPULSE);
      setState(3663);
      match(SV3_1aParser::DOLLAR);
      setState(3664);
      specify_input_terminal_descriptor();
      setState(3665);
      match(SV3_1aParser::DOLLAR);
      setState(3666);
      specify_output_terminal_descriptor();
      setState(3667);
      match(SV3_1aParser::ASSIGN_OP);
      setState(3668);
      match(SV3_1aParser::OPEN_PARENS);
      setState(3669);
      constant_mintypmax_expression();
      setState(3672);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == SV3_1aParser::COMMA) {
        setState(3670);
        match(SV3_1aParser::COMMA);
        setState(3671);
        constant_mintypmax_expression();
      }
      setState(3674);
      match(SV3_1aParser::CLOSE_PARENS);
      setState(3675);
      match(SV3_1aParser::SEMICOLON);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Variable_decl_assignmentContext ------------------------------------------------------------------

SV3_1aParser::Variable_decl_assignmentContext::Variable_decl_assignmentContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::IdentifierContext* SV3_1aParser::Variable_decl_assignmentContext::identifier() {
  return getRuleContext<SV3_1aParser::IdentifierContext>(0);
}

tree::TerminalNode* SV3_1aParser::Variable_decl_assignmentContext::ASSIGN_OP() {
  return getToken(SV3_1aParser::ASSIGN_OP, 0);
}

SV3_1aParser::Class_newContext* SV3_1aParser::Variable_decl_assignmentContext::class_new() {
  return getRuleContext<SV3_1aParser::Class_newContext>(0);
}

SV3_1aParser::Unsized_dimensionContext* SV3_1aParser::Variable_decl_assignmentContext::unsized_dimension() {
  return getRuleContext<SV3_1aParser::Unsized_dimensionContext>(0);
}

tree::TerminalNode* SV3_1aParser::Variable_decl_assignmentContext::NEW() {
  return getToken(SV3_1aParser::NEW, 0);
}

std::vector<SV3_1aParser::Variable_dimensionContext *> SV3_1aParser::Variable_decl_assignmentContext::variable_dimension() {
  return getRuleContexts<SV3_1aParser::Variable_dimensionContext>();
}

SV3_1aParser::Variable_dimensionContext* SV3_1aParser::Variable_decl_assignmentContext::variable_dimension(size_t i) {
  return getRuleContext<SV3_1aParser::Variable_dimensionContext>(i);
}

SV3_1aParser::Dynamic_array_newContext* SV3_1aParser::Variable_decl_assignmentContext::dynamic_array_new() {
  return getRuleContext<SV3_1aParser::Dynamic_array_newContext>(0);
}

tree::TerminalNode* SV3_1aParser::Variable_decl_assignmentContext::OPEN_PARENS() {
  return getToken(SV3_1aParser::OPEN_PARENS, 0);
}

SV3_1aParser::List_of_argumentsContext* SV3_1aParser::Variable_decl_assignmentContext::list_of_arguments() {
  return getRuleContext<SV3_1aParser::List_of_argumentsContext>(0);
}

tree::TerminalNode* SV3_1aParser::Variable_decl_assignmentContext::CLOSE_PARENS() {
  return getToken(SV3_1aParser::CLOSE_PARENS, 0);
}

SV3_1aParser::ExpressionContext* SV3_1aParser::Variable_decl_assignmentContext::expression() {
  return getRuleContext<SV3_1aParser::ExpressionContext>(0);
}


size_t SV3_1aParser::Variable_decl_assignmentContext::getRuleIndex() const {
  return SV3_1aParser::RuleVariable_decl_assignment;
}

void SV3_1aParser::Variable_decl_assignmentContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterVariable_decl_assignment(this);
}

void SV3_1aParser::Variable_decl_assignmentContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitVariable_decl_assignment(this);
}

SV3_1aParser::Variable_decl_assignmentContext* SV3_1aParser::variable_decl_assignment() {
  Variable_decl_assignmentContext *_localctx = _tracker.createInstance<Variable_decl_assignmentContext>(_ctx, getState());
  enterRule(_localctx, 346, SV3_1aParser::RuleVariable_decl_assignment);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3679);
    identifier();
    setState(3711);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 364, _ctx)) {
    case 1: {
      setState(3680);
      match(SV3_1aParser::ASSIGN_OP);
      setState(3681);
      class_new();
      break;
    }

    case 2: {
      setState(3682);
      unsized_dimension();
      setState(3686);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == SV3_1aParser::ASSOCIATIVE_UNSPECIFIED || _la == SV3_1aParser::OPEN_BRACKET) {
        setState(3683);
        variable_dimension();
        setState(3688);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(3691);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == SV3_1aParser::ASSIGN_OP) {
        setState(3689);
        match(SV3_1aParser::ASSIGN_OP);
        setState(3690);
        dynamic_array_new();
      }
      break;
    }

    case 3: {
      setState(3693);
      match(SV3_1aParser::ASSIGN_OP);
      setState(3694);
      match(SV3_1aParser::NEW);
      setState(3699);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == SV3_1aParser::OPEN_PARENS) {
        setState(3695);
        match(SV3_1aParser::OPEN_PARENS);
        setState(3696);
        list_of_arguments();
        setState(3697);
        match(SV3_1aParser::CLOSE_PARENS);
      }
      break;
    }

    case 4: {
      setState(3704);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == SV3_1aParser::ASSOCIATIVE_UNSPECIFIED || _la == SV3_1aParser::OPEN_BRACKET) {
        setState(3701);
        variable_dimension();
        setState(3706);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(3709);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == SV3_1aParser::ASSIGN_OP) {
        setState(3707);
        match(SV3_1aParser::ASSIGN_OP);
        setState(3708);
        expression(0);
      }
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Class_newContext ------------------------------------------------------------------

SV3_1aParser::Class_newContext::Class_newContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Class_newContext::NEW() {
  return getToken(SV3_1aParser::NEW, 0);
}

SV3_1aParser::Class_scopeContext* SV3_1aParser::Class_newContext::class_scope() {
  return getRuleContext<SV3_1aParser::Class_scopeContext>(0);
}

tree::TerminalNode* SV3_1aParser::Class_newContext::OPEN_PARENS() {
  return getToken(SV3_1aParser::OPEN_PARENS, 0);
}

SV3_1aParser::List_of_argumentsContext* SV3_1aParser::Class_newContext::list_of_arguments() {
  return getRuleContext<SV3_1aParser::List_of_argumentsContext>(0);
}

tree::TerminalNode* SV3_1aParser::Class_newContext::CLOSE_PARENS() {
  return getToken(SV3_1aParser::CLOSE_PARENS, 0);
}

SV3_1aParser::ExpressionContext* SV3_1aParser::Class_newContext::expression() {
  return getRuleContext<SV3_1aParser::ExpressionContext>(0);
}


size_t SV3_1aParser::Class_newContext::getRuleIndex() const {
  return SV3_1aParser::RuleClass_new;
}

void SV3_1aParser::Class_newContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterClass_new(this);
}

void SV3_1aParser::Class_newContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitClass_new(this);
}

SV3_1aParser::Class_newContext* SV3_1aParser::class_new() {
  Class_newContext *_localctx = _tracker.createInstance<Class_newContext>(_ctx, getState());
  enterRule(_localctx, 348, SV3_1aParser::RuleClass_new);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3714);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SV3_1aParser::DOLLAR_UNIT || ((((_la - 326) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 326)) & 4672924483589) != 0)) {
      setState(3713);
      class_scope();
    }
    setState(3716);
    match(SV3_1aParser::NEW);
    setState(3722);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 366, _ctx)) {
    case 1: {
      setState(3717);
      match(SV3_1aParser::OPEN_PARENS);
      setState(3718);
      list_of_arguments();
      setState(3719);
      match(SV3_1aParser::CLOSE_PARENS);
      break;
    }

    case 2: {
      setState(3721);
      expression(0);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Dynamic_array_newContext ------------------------------------------------------------------

SV3_1aParser::Dynamic_array_newContext::Dynamic_array_newContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Dynamic_array_newContext::NEW() {
  return getToken(SV3_1aParser::NEW, 0);
}

tree::TerminalNode* SV3_1aParser::Dynamic_array_newContext::OPEN_BRACKET() {
  return getToken(SV3_1aParser::OPEN_BRACKET, 0);
}

std::vector<SV3_1aParser::ExpressionContext *> SV3_1aParser::Dynamic_array_newContext::expression() {
  return getRuleContexts<SV3_1aParser::ExpressionContext>();
}

SV3_1aParser::ExpressionContext* SV3_1aParser::Dynamic_array_newContext::expression(size_t i) {
  return getRuleContext<SV3_1aParser::ExpressionContext>(i);
}

tree::TerminalNode* SV3_1aParser::Dynamic_array_newContext::CLOSE_BRACKET() {
  return getToken(SV3_1aParser::CLOSE_BRACKET, 0);
}

tree::TerminalNode* SV3_1aParser::Dynamic_array_newContext::OPEN_PARENS() {
  return getToken(SV3_1aParser::OPEN_PARENS, 0);
}

tree::TerminalNode* SV3_1aParser::Dynamic_array_newContext::CLOSE_PARENS() {
  return getToken(SV3_1aParser::CLOSE_PARENS, 0);
}


size_t SV3_1aParser::Dynamic_array_newContext::getRuleIndex() const {
  return SV3_1aParser::RuleDynamic_array_new;
}

void SV3_1aParser::Dynamic_array_newContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDynamic_array_new(this);
}

void SV3_1aParser::Dynamic_array_newContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDynamic_array_new(this);
}

SV3_1aParser::Dynamic_array_newContext* SV3_1aParser::dynamic_array_new() {
  Dynamic_array_newContext *_localctx = _tracker.createInstance<Dynamic_array_newContext>(_ctx, getState());
  enterRule(_localctx, 350, SV3_1aParser::RuleDynamic_array_new);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3724);
    match(SV3_1aParser::NEW);
    setState(3725);
    match(SV3_1aParser::OPEN_BRACKET);
    setState(3726);
    expression(0);
    setState(3727);
    match(SV3_1aParser::CLOSE_BRACKET);
    setState(3732);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SV3_1aParser::OPEN_PARENS) {
      setState(3728);
      match(SV3_1aParser::OPEN_PARENS);
      setState(3729);
      expression(0);
      setState(3730);
      match(SV3_1aParser::CLOSE_PARENS);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Unpacked_dimensionContext ------------------------------------------------------------------

SV3_1aParser::Unpacked_dimensionContext::Unpacked_dimensionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Unpacked_dimensionContext::OPEN_BRACKET() {
  return getToken(SV3_1aParser::OPEN_BRACKET, 0);
}

SV3_1aParser::Constant_rangeContext* SV3_1aParser::Unpacked_dimensionContext::constant_range() {
  return getRuleContext<SV3_1aParser::Constant_rangeContext>(0);
}

tree::TerminalNode* SV3_1aParser::Unpacked_dimensionContext::CLOSE_BRACKET() {
  return getToken(SV3_1aParser::CLOSE_BRACKET, 0);
}

SV3_1aParser::Constant_expressionContext* SV3_1aParser::Unpacked_dimensionContext::constant_expression() {
  return getRuleContext<SV3_1aParser::Constant_expressionContext>(0);
}

SV3_1aParser::Unsized_dimensionContext* SV3_1aParser::Unpacked_dimensionContext::unsized_dimension() {
  return getRuleContext<SV3_1aParser::Unsized_dimensionContext>(0);
}


size_t SV3_1aParser::Unpacked_dimensionContext::getRuleIndex() const {
  return SV3_1aParser::RuleUnpacked_dimension;
}

void SV3_1aParser::Unpacked_dimensionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUnpacked_dimension(this);
}

void SV3_1aParser::Unpacked_dimensionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUnpacked_dimension(this);
}

SV3_1aParser::Unpacked_dimensionContext* SV3_1aParser::unpacked_dimension() {
  Unpacked_dimensionContext *_localctx = _tracker.createInstance<Unpacked_dimensionContext>(_ctx, getState());
  enterRule(_localctx, 352, SV3_1aParser::RuleUnpacked_dimension);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(3743);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 368, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(3734);
      match(SV3_1aParser::OPEN_BRACKET);
      setState(3735);
      constant_range();
      setState(3736);
      match(SV3_1aParser::CLOSE_BRACKET);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(3738);
      match(SV3_1aParser::OPEN_BRACKET);
      setState(3739);
      constant_expression(0);
      setState(3740);
      match(SV3_1aParser::CLOSE_BRACKET);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(3742);
      unsized_dimension();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Packed_dimensionContext ------------------------------------------------------------------

SV3_1aParser::Packed_dimensionContext::Packed_dimensionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Packed_dimensionContext::OPEN_BRACKET() {
  return getToken(SV3_1aParser::OPEN_BRACKET, 0);
}

SV3_1aParser::Constant_rangeContext* SV3_1aParser::Packed_dimensionContext::constant_range() {
  return getRuleContext<SV3_1aParser::Constant_rangeContext>(0);
}

tree::TerminalNode* SV3_1aParser::Packed_dimensionContext::CLOSE_BRACKET() {
  return getToken(SV3_1aParser::CLOSE_BRACKET, 0);
}

SV3_1aParser::Unsized_dimensionContext* SV3_1aParser::Packed_dimensionContext::unsized_dimension() {
  return getRuleContext<SV3_1aParser::Unsized_dimensionContext>(0);
}


size_t SV3_1aParser::Packed_dimensionContext::getRuleIndex() const {
  return SV3_1aParser::RulePacked_dimension;
}

void SV3_1aParser::Packed_dimensionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPacked_dimension(this);
}

void SV3_1aParser::Packed_dimensionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPacked_dimension(this);
}

SV3_1aParser::Packed_dimensionContext* SV3_1aParser::packed_dimension() {
  Packed_dimensionContext *_localctx = _tracker.createInstance<Packed_dimensionContext>(_ctx, getState());
  enterRule(_localctx, 354, SV3_1aParser::RulePacked_dimension);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(3750);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 369, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(3745);
      match(SV3_1aParser::OPEN_BRACKET);
      setState(3746);
      constant_range();
      setState(3747);
      match(SV3_1aParser::CLOSE_BRACKET);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(3749);
      unsized_dimension();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Associative_dimensionContext ------------------------------------------------------------------

SV3_1aParser::Associative_dimensionContext::Associative_dimensionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Associative_dimensionContext::OPEN_BRACKET() {
  return getToken(SV3_1aParser::OPEN_BRACKET, 0);
}

SV3_1aParser::Data_typeContext* SV3_1aParser::Associative_dimensionContext::data_type() {
  return getRuleContext<SV3_1aParser::Data_typeContext>(0);
}

tree::TerminalNode* SV3_1aParser::Associative_dimensionContext::CLOSE_BRACKET() {
  return getToken(SV3_1aParser::CLOSE_BRACKET, 0);
}

tree::TerminalNode* SV3_1aParser::Associative_dimensionContext::ASSOCIATIVE_UNSPECIFIED() {
  return getToken(SV3_1aParser::ASSOCIATIVE_UNSPECIFIED, 0);
}


size_t SV3_1aParser::Associative_dimensionContext::getRuleIndex() const {
  return SV3_1aParser::RuleAssociative_dimension;
}

void SV3_1aParser::Associative_dimensionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAssociative_dimension(this);
}

void SV3_1aParser::Associative_dimensionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAssociative_dimension(this);
}

SV3_1aParser::Associative_dimensionContext* SV3_1aParser::associative_dimension() {
  Associative_dimensionContext *_localctx = _tracker.createInstance<Associative_dimensionContext>(_ctx, getState());
  enterRule(_localctx, 356, SV3_1aParser::RuleAssociative_dimension);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(3757);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SV3_1aParser::OPEN_BRACKET: {
        enterOuterAlt(_localctx, 1);
        setState(3752);
        match(SV3_1aParser::OPEN_BRACKET);
        setState(3753);
        data_type();
        setState(3754);
        match(SV3_1aParser::CLOSE_BRACKET);
        break;
      }

      case SV3_1aParser::ASSOCIATIVE_UNSPECIFIED: {
        enterOuterAlt(_localctx, 2);
        setState(3756);
        match(SV3_1aParser::ASSOCIATIVE_UNSPECIFIED);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Variable_dimensionContext ------------------------------------------------------------------

SV3_1aParser::Variable_dimensionContext::Variable_dimensionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::Unsized_dimensionContext* SV3_1aParser::Variable_dimensionContext::unsized_dimension() {
  return getRuleContext<SV3_1aParser::Unsized_dimensionContext>(0);
}

SV3_1aParser::Unpacked_dimensionContext* SV3_1aParser::Variable_dimensionContext::unpacked_dimension() {
  return getRuleContext<SV3_1aParser::Unpacked_dimensionContext>(0);
}

SV3_1aParser::Associative_dimensionContext* SV3_1aParser::Variable_dimensionContext::associative_dimension() {
  return getRuleContext<SV3_1aParser::Associative_dimensionContext>(0);
}

SV3_1aParser::Queue_dimensionContext* SV3_1aParser::Variable_dimensionContext::queue_dimension() {
  return getRuleContext<SV3_1aParser::Queue_dimensionContext>(0);
}


size_t SV3_1aParser::Variable_dimensionContext::getRuleIndex() const {
  return SV3_1aParser::RuleVariable_dimension;
}

void SV3_1aParser::Variable_dimensionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterVariable_dimension(this);
}

void SV3_1aParser::Variable_dimensionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitVariable_dimension(this);
}

SV3_1aParser::Variable_dimensionContext* SV3_1aParser::variable_dimension() {
  Variable_dimensionContext *_localctx = _tracker.createInstance<Variable_dimensionContext>(_ctx, getState());
  enterRule(_localctx, 358, SV3_1aParser::RuleVariable_dimension);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(3763);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 371, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(3759);
      unsized_dimension();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(3760);
      unpacked_dimension();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(3761);
      associative_dimension();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(3762);
      queue_dimension();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Queue_dimensionContext ------------------------------------------------------------------

SV3_1aParser::Queue_dimensionContext::Queue_dimensionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Queue_dimensionContext::OPEN_BRACKET() {
  return getToken(SV3_1aParser::OPEN_BRACKET, 0);
}

tree::TerminalNode* SV3_1aParser::Queue_dimensionContext::DOLLAR() {
  return getToken(SV3_1aParser::DOLLAR, 0);
}

tree::TerminalNode* SV3_1aParser::Queue_dimensionContext::CLOSE_BRACKET() {
  return getToken(SV3_1aParser::CLOSE_BRACKET, 0);
}

tree::TerminalNode* SV3_1aParser::Queue_dimensionContext::COLON() {
  return getToken(SV3_1aParser::COLON, 0);
}

SV3_1aParser::Constant_expressionContext* SV3_1aParser::Queue_dimensionContext::constant_expression() {
  return getRuleContext<SV3_1aParser::Constant_expressionContext>(0);
}


size_t SV3_1aParser::Queue_dimensionContext::getRuleIndex() const {
  return SV3_1aParser::RuleQueue_dimension;
}

void SV3_1aParser::Queue_dimensionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterQueue_dimension(this);
}

void SV3_1aParser::Queue_dimensionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitQueue_dimension(this);
}

SV3_1aParser::Queue_dimensionContext* SV3_1aParser::queue_dimension() {
  Queue_dimensionContext *_localctx = _tracker.createInstance<Queue_dimensionContext>(_ctx, getState());
  enterRule(_localctx, 360, SV3_1aParser::RuleQueue_dimension);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3765);
    match(SV3_1aParser::OPEN_BRACKET);
    setState(3766);
    match(SV3_1aParser::DOLLAR);
    setState(3769);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SV3_1aParser::COLON) {
      setState(3767);
      match(SV3_1aParser::COLON);
      setState(3768);
      constant_expression(0);
    }
    setState(3771);
    match(SV3_1aParser::CLOSE_BRACKET);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Unsized_dimensionContext ------------------------------------------------------------------

SV3_1aParser::Unsized_dimensionContext::Unsized_dimensionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Unsized_dimensionContext::OPEN_BRACKET() {
  return getToken(SV3_1aParser::OPEN_BRACKET, 0);
}

tree::TerminalNode* SV3_1aParser::Unsized_dimensionContext::CLOSE_BRACKET() {
  return getToken(SV3_1aParser::CLOSE_BRACKET, 0);
}


size_t SV3_1aParser::Unsized_dimensionContext::getRuleIndex() const {
  return SV3_1aParser::RuleUnsized_dimension;
}

void SV3_1aParser::Unsized_dimensionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUnsized_dimension(this);
}

void SV3_1aParser::Unsized_dimensionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUnsized_dimension(this);
}

SV3_1aParser::Unsized_dimensionContext* SV3_1aParser::unsized_dimension() {
  Unsized_dimensionContext *_localctx = _tracker.createInstance<Unsized_dimensionContext>(_ctx, getState());
  enterRule(_localctx, 362, SV3_1aParser::RuleUnsized_dimension);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3773);
    match(SV3_1aParser::OPEN_BRACKET);
    setState(3774);
    match(SV3_1aParser::CLOSE_BRACKET);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Function_data_typeContext ------------------------------------------------------------------

SV3_1aParser::Function_data_typeContext::Function_data_typeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::Data_typeContext* SV3_1aParser::Function_data_typeContext::data_type() {
  return getRuleContext<SV3_1aParser::Data_typeContext>(0);
}

tree::TerminalNode* SV3_1aParser::Function_data_typeContext::VOID() {
  return getToken(SV3_1aParser::VOID, 0);
}


size_t SV3_1aParser::Function_data_typeContext::getRuleIndex() const {
  return SV3_1aParser::RuleFunction_data_type;
}

void SV3_1aParser::Function_data_typeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFunction_data_type(this);
}

void SV3_1aParser::Function_data_typeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFunction_data_type(this);
}

SV3_1aParser::Function_data_typeContext* SV3_1aParser::function_data_type() {
  Function_data_typeContext *_localctx = _tracker.createInstance<Function_data_typeContext>(_ctx, getState());
  enterRule(_localctx, 364, SV3_1aParser::RuleFunction_data_type);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(3778);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SV3_1aParser::VIRTUAL:
      case SV3_1aParser::TYPE:
      case SV3_1aParser::ENUM:
      case SV3_1aParser::STRUCT:
      case SV3_1aParser::UNION:
      case SV3_1aParser::STRING:
      case SV3_1aParser::CHANDLE:
      case SV3_1aParser::EVENT:
      case SV3_1aParser::BYTE:
      case SV3_1aParser::SHORTINT:
      case SV3_1aParser::INT:
      case SV3_1aParser::LONGINT:
      case SV3_1aParser::INTEGER:
      case SV3_1aParser::TIME:
      case SV3_1aParser::BIT:
      case SV3_1aParser::LOGIC:
      case SV3_1aParser::REG:
      case SV3_1aParser::SHORTREAL:
      case SV3_1aParser::REAL:
      case SV3_1aParser::REALTIME:
      case SV3_1aParser::DOLLAR_UNIT:
      case SV3_1aParser::THIS:
      case SV3_1aParser::RANDOMIZE:
      case SV3_1aParser::SAMPLE:
      case SV3_1aParser::Escaped_identifier:
      case SV3_1aParser::Simple_identifier: {
        enterOuterAlt(_localctx, 1);
        setState(3776);
        data_type();
        break;
      }

      case SV3_1aParser::VOID: {
        enterOuterAlt(_localctx, 2);
        setState(3777);
        match(SV3_1aParser::VOID);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Function_data_type_or_implicitContext ------------------------------------------------------------------

SV3_1aParser::Function_data_type_or_implicitContext::Function_data_type_or_implicitContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::Function_data_typeContext* SV3_1aParser::Function_data_type_or_implicitContext::function_data_type() {
  return getRuleContext<SV3_1aParser::Function_data_typeContext>(0);
}

SV3_1aParser::SigningContext* SV3_1aParser::Function_data_type_or_implicitContext::signing() {
  return getRuleContext<SV3_1aParser::SigningContext>(0);
}

std::vector<SV3_1aParser::Packed_dimensionContext *> SV3_1aParser::Function_data_type_or_implicitContext::packed_dimension() {
  return getRuleContexts<SV3_1aParser::Packed_dimensionContext>();
}

SV3_1aParser::Packed_dimensionContext* SV3_1aParser::Function_data_type_or_implicitContext::packed_dimension(size_t i) {
  return getRuleContext<SV3_1aParser::Packed_dimensionContext>(i);
}


size_t SV3_1aParser::Function_data_type_or_implicitContext::getRuleIndex() const {
  return SV3_1aParser::RuleFunction_data_type_or_implicit;
}

void SV3_1aParser::Function_data_type_or_implicitContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFunction_data_type_or_implicit(this);
}

void SV3_1aParser::Function_data_type_or_implicitContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFunction_data_type_or_implicit(this);
}

SV3_1aParser::Function_data_type_or_implicitContext* SV3_1aParser::function_data_type_or_implicit() {
  Function_data_type_or_implicitContext *_localctx = _tracker.createInstance<Function_data_type_or_implicitContext>(_ctx, getState());
  enterRule(_localctx, 366, SV3_1aParser::RuleFunction_data_type_or_implicit);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(3790);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 376, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(3780);
      function_data_type();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(3782);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == SV3_1aParser::SIGNED

      || _la == SV3_1aParser::UNSIGNED) {
        setState(3781);
        signing();
      }
      setState(3787);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == SV3_1aParser::OPEN_BRACKET) {
        setState(3784);
        packed_dimension();
        setState(3789);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Function_declarationContext ------------------------------------------------------------------

SV3_1aParser::Function_declarationContext::Function_declarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Function_declarationContext::FUNCTION() {
  return getToken(SV3_1aParser::FUNCTION, 0);
}

SV3_1aParser::Function_body_declarationContext* SV3_1aParser::Function_declarationContext::function_body_declaration() {
  return getRuleContext<SV3_1aParser::Function_body_declarationContext>(0);
}

SV3_1aParser::LifetimeContext* SV3_1aParser::Function_declarationContext::lifetime() {
  return getRuleContext<SV3_1aParser::LifetimeContext>(0);
}


size_t SV3_1aParser::Function_declarationContext::getRuleIndex() const {
  return SV3_1aParser::RuleFunction_declaration;
}

void SV3_1aParser::Function_declarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFunction_declaration(this);
}

void SV3_1aParser::Function_declarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFunction_declaration(this);
}

SV3_1aParser::Function_declarationContext* SV3_1aParser::function_declaration() {
  Function_declarationContext *_localctx = _tracker.createInstance<Function_declarationContext>(_ctx, getState());
  enterRule(_localctx, 368, SV3_1aParser::RuleFunction_declaration);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3792);
    match(SV3_1aParser::FUNCTION);
    setState(3794);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SV3_1aParser::STATIC

    || _la == SV3_1aParser::AUTOMATIC) {
      setState(3793);
      lifetime();
    }
    setState(3796);
    function_body_declaration();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Function_body_declarationContext ------------------------------------------------------------------

SV3_1aParser::Function_body_declarationContext::Function_body_declarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::Function_data_type_or_implicitContext* SV3_1aParser::Function_body_declarationContext::function_data_type_or_implicit() {
  return getRuleContext<SV3_1aParser::Function_data_type_or_implicitContext>(0);
}

std::vector<SV3_1aParser::IdentifierContext *> SV3_1aParser::Function_body_declarationContext::identifier() {
  return getRuleContexts<SV3_1aParser::IdentifierContext>();
}

SV3_1aParser::IdentifierContext* SV3_1aParser::Function_body_declarationContext::identifier(size_t i) {
  return getRuleContext<SV3_1aParser::IdentifierContext>(i);
}

tree::TerminalNode* SV3_1aParser::Function_body_declarationContext::SEMICOLON() {
  return getToken(SV3_1aParser::SEMICOLON, 0);
}

tree::TerminalNode* SV3_1aParser::Function_body_declarationContext::ENDFUNCTION() {
  return getToken(SV3_1aParser::ENDFUNCTION, 0);
}

SV3_1aParser::Interface_identifierContext* SV3_1aParser::Function_body_declarationContext::interface_identifier() {
  return getRuleContext<SV3_1aParser::Interface_identifierContext>(0);
}

tree::TerminalNode* SV3_1aParser::Function_body_declarationContext::DOT() {
  return getToken(SV3_1aParser::DOT, 0);
}

SV3_1aParser::Class_scopeContext* SV3_1aParser::Function_body_declarationContext::class_scope() {
  return getRuleContext<SV3_1aParser::Class_scopeContext>(0);
}

std::vector<SV3_1aParser::Tf_item_declarationContext *> SV3_1aParser::Function_body_declarationContext::tf_item_declaration() {
  return getRuleContexts<SV3_1aParser::Tf_item_declarationContext>();
}

SV3_1aParser::Tf_item_declarationContext* SV3_1aParser::Function_body_declarationContext::tf_item_declaration(size_t i) {
  return getRuleContext<SV3_1aParser::Tf_item_declarationContext>(i);
}

std::vector<SV3_1aParser::Function_statement_or_nullContext *> SV3_1aParser::Function_body_declarationContext::function_statement_or_null() {
  return getRuleContexts<SV3_1aParser::Function_statement_or_nullContext>();
}

SV3_1aParser::Function_statement_or_nullContext* SV3_1aParser::Function_body_declarationContext::function_statement_or_null(size_t i) {
  return getRuleContext<SV3_1aParser::Function_statement_or_nullContext>(i);
}

tree::TerminalNode* SV3_1aParser::Function_body_declarationContext::COLON() {
  return getToken(SV3_1aParser::COLON, 0);
}

tree::TerminalNode* SV3_1aParser::Function_body_declarationContext::OPEN_PARENS() {
  return getToken(SV3_1aParser::OPEN_PARENS, 0);
}

tree::TerminalNode* SV3_1aParser::Function_body_declarationContext::CLOSE_PARENS() {
  return getToken(SV3_1aParser::CLOSE_PARENS, 0);
}

SV3_1aParser::Tf_port_listContext* SV3_1aParser::Function_body_declarationContext::tf_port_list() {
  return getRuleContext<SV3_1aParser::Tf_port_listContext>(0);
}

std::vector<SV3_1aParser::Block_item_declarationContext *> SV3_1aParser::Function_body_declarationContext::block_item_declaration() {
  return getRuleContexts<SV3_1aParser::Block_item_declarationContext>();
}

SV3_1aParser::Block_item_declarationContext* SV3_1aParser::Function_body_declarationContext::block_item_declaration(size_t i) {
  return getRuleContext<SV3_1aParser::Block_item_declarationContext>(i);
}


size_t SV3_1aParser::Function_body_declarationContext::getRuleIndex() const {
  return SV3_1aParser::RuleFunction_body_declaration;
}

void SV3_1aParser::Function_body_declarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFunction_body_declaration(this);
}

void SV3_1aParser::Function_body_declarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFunction_body_declaration(this);
}

SV3_1aParser::Function_body_declarationContext* SV3_1aParser::function_body_declaration() {
  Function_body_declarationContext *_localctx = _tracker.createInstance<Function_body_declarationContext>(_ctx, getState());
  enterRule(_localctx, 370, SV3_1aParser::RuleFunction_body_declaration);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    setState(3855);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 387, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(3798);
      function_data_type_or_implicit();
      setState(3803);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 378, _ctx)) {
      case 1: {
        setState(3799);
        interface_identifier();
        setState(3800);
        match(SV3_1aParser::DOT);
        break;
      }

      case 2: {
        setState(3802);
        class_scope();
        break;
      }

      default:
        break;
      }
      setState(3805);
      identifier();
      setState(3806);
      match(SV3_1aParser::SEMICOLON);
      setState(3810);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 379, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(3807);
          tf_item_declaration(); 
        }
        setState(3812);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 379, _ctx);
      }
      setState(3816);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while ((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & 2198011904) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 64)) & 17732923904262145) != 0) || ((((_la - 151) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 151)) & 5188249437639573505) != 0) || ((((_la - 223) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 223)) & 1136895023120385) != 0) || ((((_la - 289) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 289)) & 45036959082348431) != 0) || ((((_la - 364) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 364)) & 8796093022225) != 0)) {
        setState(3813);
        function_statement_or_null();
        setState(3818);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(3819);
      match(SV3_1aParser::ENDFUNCTION);
      setState(3822);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 381, _ctx)) {
      case 1: {
        setState(3820);
        match(SV3_1aParser::COLON);
        setState(3821);
        identifier();
        break;
      }

      default:
        break;
      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(3824);
      function_data_type_or_implicit();
      setState(3829);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 382, _ctx)) {
      case 1: {
        setState(3825);
        interface_identifier();
        setState(3826);
        match(SV3_1aParser::DOT);
        break;
      }

      case 2: {
        setState(3828);
        class_scope();
        break;
      }

      default:
        break;
      }
      setState(3831);
      identifier();
      setState(3832);
      match(SV3_1aParser::OPEN_PARENS);
      setState(3834);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == SV3_1aParser::VIRTUAL || ((((_la - 64) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 64)) & 1152775819316167741) != 0) || ((((_la - 147) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 147)) & 6597069766667) != 0) || ((((_la - 326) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 326)) & 4672924483589) != 0)) {
        setState(3833);
        tf_port_list();
      }
      setState(3836);
      match(SV3_1aParser::CLOSE_PARENS);
      setState(3837);
      match(SV3_1aParser::SEMICOLON);
      setState(3841);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 384, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(3838);
          block_item_declaration(); 
        }
        setState(3843);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 384, _ctx);
      }
      setState(3847);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while ((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & 2198011904) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 64)) & 17732923904262145) != 0) || ((((_la - 151) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 151)) & 5188249437639573505) != 0) || ((((_la - 223) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 223)) & 1136895023120385) != 0) || ((((_la - 289) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 289)) & 45036959082348431) != 0) || ((((_la - 364) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 364)) & 8796093022225) != 0)) {
        setState(3844);
        function_statement_or_null();
        setState(3849);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(3850);
      match(SV3_1aParser::ENDFUNCTION);
      setState(3853);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 386, _ctx)) {
      case 1: {
        setState(3851);
        match(SV3_1aParser::COLON);
        setState(3852);
        identifier();
        break;
      }

      default:
        break;
      }
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Function_prototypeContext ------------------------------------------------------------------

SV3_1aParser::Function_prototypeContext::Function_prototypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Function_prototypeContext::FUNCTION() {
  return getToken(SV3_1aParser::FUNCTION, 0);
}

SV3_1aParser::Function_data_type_or_implicitContext* SV3_1aParser::Function_prototypeContext::function_data_type_or_implicit() {
  return getRuleContext<SV3_1aParser::Function_data_type_or_implicitContext>(0);
}

SV3_1aParser::IdentifierContext* SV3_1aParser::Function_prototypeContext::identifier() {
  return getRuleContext<SV3_1aParser::IdentifierContext>(0);
}

tree::TerminalNode* SV3_1aParser::Function_prototypeContext::OPEN_PARENS() {
  return getToken(SV3_1aParser::OPEN_PARENS, 0);
}

tree::TerminalNode* SV3_1aParser::Function_prototypeContext::CLOSE_PARENS() {
  return getToken(SV3_1aParser::CLOSE_PARENS, 0);
}

SV3_1aParser::Tf_port_listContext* SV3_1aParser::Function_prototypeContext::tf_port_list() {
  return getRuleContext<SV3_1aParser::Tf_port_listContext>(0);
}


size_t SV3_1aParser::Function_prototypeContext::getRuleIndex() const {
  return SV3_1aParser::RuleFunction_prototype;
}

void SV3_1aParser::Function_prototypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFunction_prototype(this);
}

void SV3_1aParser::Function_prototypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFunction_prototype(this);
}

SV3_1aParser::Function_prototypeContext* SV3_1aParser::function_prototype() {
  Function_prototypeContext *_localctx = _tracker.createInstance<Function_prototypeContext>(_ctx, getState());
  enterRule(_localctx, 372, SV3_1aParser::RuleFunction_prototype);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3857);
    match(SV3_1aParser::FUNCTION);
    setState(3858);
    function_data_type_or_implicit();
    setState(3859);
    identifier();
    setState(3865);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SV3_1aParser::OPEN_PARENS) {
      setState(3860);
      match(SV3_1aParser::OPEN_PARENS);
      setState(3862);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == SV3_1aParser::VIRTUAL || ((((_la - 64) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 64)) & 1152775819316167741) != 0) || ((((_la - 147) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 147)) & 6597069766667) != 0) || ((((_la - 326) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 326)) & 4672924483589) != 0)) {
        setState(3861);
        tf_port_list();
      }
      setState(3864);
      match(SV3_1aParser::CLOSE_PARENS);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Dpi_import_exportContext ------------------------------------------------------------------

SV3_1aParser::Dpi_import_exportContext::Dpi_import_exportContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Dpi_import_exportContext::IMPORT() {
  return getToken(SV3_1aParser::IMPORT, 0);
}

SV3_1aParser::String_valueContext* SV3_1aParser::Dpi_import_exportContext::string_value() {
  return getRuleContext<SV3_1aParser::String_valueContext>(0);
}

SV3_1aParser::Function_prototypeContext* SV3_1aParser::Dpi_import_exportContext::function_prototype() {
  return getRuleContext<SV3_1aParser::Function_prototypeContext>(0);
}

tree::TerminalNode* SV3_1aParser::Dpi_import_exportContext::SEMICOLON() {
  return getToken(SV3_1aParser::SEMICOLON, 0);
}

SV3_1aParser::Context_keywordContext* SV3_1aParser::Dpi_import_exportContext::context_keyword() {
  return getRuleContext<SV3_1aParser::Context_keywordContext>(0);
}

SV3_1aParser::Pure_keywordContext* SV3_1aParser::Dpi_import_exportContext::pure_keyword() {
  return getRuleContext<SV3_1aParser::Pure_keywordContext>(0);
}

tree::TerminalNode* SV3_1aParser::Dpi_import_exportContext::Simple_identifier() {
  return getToken(SV3_1aParser::Simple_identifier, 0);
}

tree::TerminalNode* SV3_1aParser::Dpi_import_exportContext::ASSIGN_OP() {
  return getToken(SV3_1aParser::ASSIGN_OP, 0);
}

SV3_1aParser::Task_prototypeContext* SV3_1aParser::Dpi_import_exportContext::task_prototype() {
  return getRuleContext<SV3_1aParser::Task_prototypeContext>(0);
}

tree::TerminalNode* SV3_1aParser::Dpi_import_exportContext::EXPORT() {
  return getToken(SV3_1aParser::EXPORT, 0);
}

SV3_1aParser::Function_name_declContext* SV3_1aParser::Dpi_import_exportContext::function_name_decl() {
  return getRuleContext<SV3_1aParser::Function_name_declContext>(0);
}

SV3_1aParser::Task_name_declContext* SV3_1aParser::Dpi_import_exportContext::task_name_decl() {
  return getRuleContext<SV3_1aParser::Task_name_declContext>(0);
}


size_t SV3_1aParser::Dpi_import_exportContext::getRuleIndex() const {
  return SV3_1aParser::RuleDpi_import_export;
}

void SV3_1aParser::Dpi_import_exportContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDpi_import_export(this);
}

void SV3_1aParser::Dpi_import_exportContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDpi_import_export(this);
}

SV3_1aParser::Dpi_import_exportContext* SV3_1aParser::dpi_import_export() {
  Dpi_import_exportContext *_localctx = _tracker.createInstance<Dpi_import_exportContext>(_ctx, getState());
  enterRule(_localctx, 374, SV3_1aParser::RuleDpi_import_export);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(3904);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 396, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(3867);
      match(SV3_1aParser::IMPORT);
      setState(3868);
      string_value();
      setState(3871);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case SV3_1aParser::CONTEXT: {
          setState(3869);
          context_keyword();
          break;
        }

        case SV3_1aParser::PURE: {
          setState(3870);
          pure_keyword();
          break;
        }

        case SV3_1aParser::FUNCTION:
        case SV3_1aParser::Simple_identifier: {
          break;
        }

      default:
        break;
      }
      setState(3875);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == SV3_1aParser::Simple_identifier) {
        setState(3873);
        match(SV3_1aParser::Simple_identifier);
        setState(3874);
        match(SV3_1aParser::ASSIGN_OP);
      }
      setState(3877);
      function_prototype();
      setState(3878);
      match(SV3_1aParser::SEMICOLON);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(3880);
      match(SV3_1aParser::IMPORT);
      setState(3881);
      string_value();
      setState(3883);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == SV3_1aParser::CONTEXT) {
        setState(3882);
        context_keyword();
      }
      setState(3887);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == SV3_1aParser::Simple_identifier) {
        setState(3885);
        match(SV3_1aParser::Simple_identifier);
        setState(3886);
        match(SV3_1aParser::ASSIGN_OP);
      }
      setState(3889);
      task_prototype();
      setState(3890);
      match(SV3_1aParser::SEMICOLON);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(3892);
      match(SV3_1aParser::EXPORT);
      setState(3893);
      string_value();
      setState(3896);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == SV3_1aParser::Simple_identifier) {
        setState(3894);
        match(SV3_1aParser::Simple_identifier);
        setState(3895);
        match(SV3_1aParser::ASSIGN_OP);
      }
      setState(3900);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case SV3_1aParser::FUNCTION: {
          setState(3898);
          function_name_decl();
          break;
        }

        case SV3_1aParser::TASK: {
          setState(3899);
          task_name_decl();
          break;
        }

      default:
        throw NoViableAltException(this);
      }
      setState(3902);
      match(SV3_1aParser::SEMICOLON);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Context_keywordContext ------------------------------------------------------------------

SV3_1aParser::Context_keywordContext::Context_keywordContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Context_keywordContext::CONTEXT() {
  return getToken(SV3_1aParser::CONTEXT, 0);
}


size_t SV3_1aParser::Context_keywordContext::getRuleIndex() const {
  return SV3_1aParser::RuleContext_keyword;
}

void SV3_1aParser::Context_keywordContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterContext_keyword(this);
}

void SV3_1aParser::Context_keywordContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitContext_keyword(this);
}

SV3_1aParser::Context_keywordContext* SV3_1aParser::context_keyword() {
  Context_keywordContext *_localctx = _tracker.createInstance<Context_keywordContext>(_ctx, getState());
  enterRule(_localctx, 376, SV3_1aParser::RuleContext_keyword);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3906);
    match(SV3_1aParser::CONTEXT);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Function_name_declContext ------------------------------------------------------------------

SV3_1aParser::Function_name_declContext::Function_name_declContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Function_name_declContext::FUNCTION() {
  return getToken(SV3_1aParser::FUNCTION, 0);
}

SV3_1aParser::IdentifierContext* SV3_1aParser::Function_name_declContext::identifier() {
  return getRuleContext<SV3_1aParser::IdentifierContext>(0);
}


size_t SV3_1aParser::Function_name_declContext::getRuleIndex() const {
  return SV3_1aParser::RuleFunction_name_decl;
}

void SV3_1aParser::Function_name_declContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFunction_name_decl(this);
}

void SV3_1aParser::Function_name_declContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFunction_name_decl(this);
}

SV3_1aParser::Function_name_declContext* SV3_1aParser::function_name_decl() {
  Function_name_declContext *_localctx = _tracker.createInstance<Function_name_declContext>(_ctx, getState());
  enterRule(_localctx, 378, SV3_1aParser::RuleFunction_name_decl);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3908);
    match(SV3_1aParser::FUNCTION);
    setState(3909);
    identifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Task_name_declContext ------------------------------------------------------------------

SV3_1aParser::Task_name_declContext::Task_name_declContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Task_name_declContext::TASK() {
  return getToken(SV3_1aParser::TASK, 0);
}

SV3_1aParser::IdentifierContext* SV3_1aParser::Task_name_declContext::identifier() {
  return getRuleContext<SV3_1aParser::IdentifierContext>(0);
}


size_t SV3_1aParser::Task_name_declContext::getRuleIndex() const {
  return SV3_1aParser::RuleTask_name_decl;
}

void SV3_1aParser::Task_name_declContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTask_name_decl(this);
}

void SV3_1aParser::Task_name_declContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTask_name_decl(this);
}

SV3_1aParser::Task_name_declContext* SV3_1aParser::task_name_decl() {
  Task_name_declContext *_localctx = _tracker.createInstance<Task_name_declContext>(_ctx, getState());
  enterRule(_localctx, 380, SV3_1aParser::RuleTask_name_decl);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3911);
    match(SV3_1aParser::TASK);
    setState(3912);
    identifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Pure_keywordContext ------------------------------------------------------------------

SV3_1aParser::Pure_keywordContext::Pure_keywordContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Pure_keywordContext::PURE() {
  return getToken(SV3_1aParser::PURE, 0);
}


size_t SV3_1aParser::Pure_keywordContext::getRuleIndex() const {
  return SV3_1aParser::RulePure_keyword;
}

void SV3_1aParser::Pure_keywordContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPure_keyword(this);
}

void SV3_1aParser::Pure_keywordContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPure_keyword(this);
}

SV3_1aParser::Pure_keywordContext* SV3_1aParser::pure_keyword() {
  Pure_keywordContext *_localctx = _tracker.createInstance<Pure_keywordContext>(_ctx, getState());
  enterRule(_localctx, 382, SV3_1aParser::RulePure_keyword);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3914);
    match(SV3_1aParser::PURE);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Task_declarationContext ------------------------------------------------------------------

SV3_1aParser::Task_declarationContext::Task_declarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Task_declarationContext::TASK() {
  return getToken(SV3_1aParser::TASK, 0);
}

SV3_1aParser::Task_body_declarationContext* SV3_1aParser::Task_declarationContext::task_body_declaration() {
  return getRuleContext<SV3_1aParser::Task_body_declarationContext>(0);
}

SV3_1aParser::LifetimeContext* SV3_1aParser::Task_declarationContext::lifetime() {
  return getRuleContext<SV3_1aParser::LifetimeContext>(0);
}


size_t SV3_1aParser::Task_declarationContext::getRuleIndex() const {
  return SV3_1aParser::RuleTask_declaration;
}

void SV3_1aParser::Task_declarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTask_declaration(this);
}

void SV3_1aParser::Task_declarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTask_declaration(this);
}

SV3_1aParser::Task_declarationContext* SV3_1aParser::task_declaration() {
  Task_declarationContext *_localctx = _tracker.createInstance<Task_declarationContext>(_ctx, getState());
  enterRule(_localctx, 384, SV3_1aParser::RuleTask_declaration);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3916);
    match(SV3_1aParser::TASK);
    setState(3918);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SV3_1aParser::STATIC

    || _la == SV3_1aParser::AUTOMATIC) {
      setState(3917);
      lifetime();
    }
    setState(3920);
    task_body_declaration();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Task_body_declarationContext ------------------------------------------------------------------

SV3_1aParser::Task_body_declarationContext::Task_body_declarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<SV3_1aParser::IdentifierContext *> SV3_1aParser::Task_body_declarationContext::identifier() {
  return getRuleContexts<SV3_1aParser::IdentifierContext>();
}

SV3_1aParser::IdentifierContext* SV3_1aParser::Task_body_declarationContext::identifier(size_t i) {
  return getRuleContext<SV3_1aParser::IdentifierContext>(i);
}

tree::TerminalNode* SV3_1aParser::Task_body_declarationContext::SEMICOLON() {
  return getToken(SV3_1aParser::SEMICOLON, 0);
}

tree::TerminalNode* SV3_1aParser::Task_body_declarationContext::ENDTASK() {
  return getToken(SV3_1aParser::ENDTASK, 0);
}

SV3_1aParser::Interface_identifierContext* SV3_1aParser::Task_body_declarationContext::interface_identifier() {
  return getRuleContext<SV3_1aParser::Interface_identifierContext>(0);
}

tree::TerminalNode* SV3_1aParser::Task_body_declarationContext::DOT() {
  return getToken(SV3_1aParser::DOT, 0);
}

SV3_1aParser::Class_scopeContext* SV3_1aParser::Task_body_declarationContext::class_scope() {
  return getRuleContext<SV3_1aParser::Class_scopeContext>(0);
}

std::vector<SV3_1aParser::Tf_item_declarationContext *> SV3_1aParser::Task_body_declarationContext::tf_item_declaration() {
  return getRuleContexts<SV3_1aParser::Tf_item_declarationContext>();
}

SV3_1aParser::Tf_item_declarationContext* SV3_1aParser::Task_body_declarationContext::tf_item_declaration(size_t i) {
  return getRuleContext<SV3_1aParser::Tf_item_declarationContext>(i);
}

std::vector<SV3_1aParser::Statement_or_nullContext *> SV3_1aParser::Task_body_declarationContext::statement_or_null() {
  return getRuleContexts<SV3_1aParser::Statement_or_nullContext>();
}

SV3_1aParser::Statement_or_nullContext* SV3_1aParser::Task_body_declarationContext::statement_or_null(size_t i) {
  return getRuleContext<SV3_1aParser::Statement_or_nullContext>(i);
}

tree::TerminalNode* SV3_1aParser::Task_body_declarationContext::COLON() {
  return getToken(SV3_1aParser::COLON, 0);
}

tree::TerminalNode* SV3_1aParser::Task_body_declarationContext::OPEN_PARENS() {
  return getToken(SV3_1aParser::OPEN_PARENS, 0);
}

tree::TerminalNode* SV3_1aParser::Task_body_declarationContext::CLOSE_PARENS() {
  return getToken(SV3_1aParser::CLOSE_PARENS, 0);
}

SV3_1aParser::Tf_port_listContext* SV3_1aParser::Task_body_declarationContext::tf_port_list() {
  return getRuleContext<SV3_1aParser::Tf_port_listContext>(0);
}

std::vector<SV3_1aParser::Block_item_declarationContext *> SV3_1aParser::Task_body_declarationContext::block_item_declaration() {
  return getRuleContexts<SV3_1aParser::Block_item_declarationContext>();
}

SV3_1aParser::Block_item_declarationContext* SV3_1aParser::Task_body_declarationContext::block_item_declaration(size_t i) {
  return getRuleContext<SV3_1aParser::Block_item_declarationContext>(i);
}


size_t SV3_1aParser::Task_body_declarationContext::getRuleIndex() const {
  return SV3_1aParser::RuleTask_body_declaration;
}

void SV3_1aParser::Task_body_declarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTask_body_declaration(this);
}

void SV3_1aParser::Task_body_declarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTask_body_declaration(this);
}

SV3_1aParser::Task_body_declarationContext* SV3_1aParser::task_body_declaration() {
  Task_body_declarationContext *_localctx = _tracker.createInstance<Task_body_declarationContext>(_ctx, getState());
  enterRule(_localctx, 386, SV3_1aParser::RuleTask_body_declaration);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    setState(3977);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 407, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(3926);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 398, _ctx)) {
      case 1: {
        setState(3922);
        interface_identifier();
        setState(3923);
        match(SV3_1aParser::DOT);
        break;
      }

      case 2: {
        setState(3925);
        class_scope();
        break;
      }

      default:
        break;
      }
      setState(3928);
      identifier();
      setState(3929);
      match(SV3_1aParser::SEMICOLON);
      setState(3933);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 399, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(3930);
          tf_item_declaration(); 
        }
        setState(3935);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 399, _ctx);
      }
      setState(3939);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while ((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & 2198011904) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 64)) & 17732923904262145) != 0) || ((((_la - 151) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 151)) & 5188249437639573505) != 0) || ((((_la - 223) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 223)) & 1136895023120385) != 0) || ((((_la - 289) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 289)) & 45036959082348431) != 0) || ((((_la - 364) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 364)) & 8796093022225) != 0)) {
        setState(3936);
        statement_or_null();
        setState(3941);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(3942);
      match(SV3_1aParser::ENDTASK);
      setState(3945);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 401, _ctx)) {
      case 1: {
        setState(3943);
        match(SV3_1aParser::COLON);
        setState(3944);
        identifier();
        break;
      }

      default:
        break;
      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(3951);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 402, _ctx)) {
      case 1: {
        setState(3947);
        interface_identifier();
        setState(3948);
        match(SV3_1aParser::DOT);
        break;
      }

      case 2: {
        setState(3950);
        class_scope();
        break;
      }

      default:
        break;
      }
      setState(3953);
      identifier();
      setState(3954);
      match(SV3_1aParser::OPEN_PARENS);
      setState(3956);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == SV3_1aParser::VIRTUAL || ((((_la - 64) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 64)) & 1152775819316167741) != 0) || ((((_la - 147) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 147)) & 6597069766667) != 0) || ((((_la - 326) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 326)) & 4672924483589) != 0)) {
        setState(3955);
        tf_port_list();
      }
      setState(3958);
      match(SV3_1aParser::CLOSE_PARENS);
      setState(3959);
      match(SV3_1aParser::SEMICOLON);
      setState(3963);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 404, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(3960);
          block_item_declaration(); 
        }
        setState(3965);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 404, _ctx);
      }
      setState(3969);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while ((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & 2198011904) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 64)) & 17732923904262145) != 0) || ((((_la - 151) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 151)) & 5188249437639573505) != 0) || ((((_la - 223) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 223)) & 1136895023120385) != 0) || ((((_la - 289) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 289)) & 45036959082348431) != 0) || ((((_la - 364) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 364)) & 8796093022225) != 0)) {
        setState(3966);
        statement_or_null();
        setState(3971);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(3972);
      match(SV3_1aParser::ENDTASK);
      setState(3975);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 406, _ctx)) {
      case 1: {
        setState(3973);
        match(SV3_1aParser::COLON);
        setState(3974);
        identifier();
        break;
      }

      default:
        break;
      }
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Tf_item_declarationContext ------------------------------------------------------------------

SV3_1aParser::Tf_item_declarationContext::Tf_item_declarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::Block_item_declarationContext* SV3_1aParser::Tf_item_declarationContext::block_item_declaration() {
  return getRuleContext<SV3_1aParser::Block_item_declarationContext>(0);
}

SV3_1aParser::Tf_port_declarationContext* SV3_1aParser::Tf_item_declarationContext::tf_port_declaration() {
  return getRuleContext<SV3_1aParser::Tf_port_declarationContext>(0);
}


size_t SV3_1aParser::Tf_item_declarationContext::getRuleIndex() const {
  return SV3_1aParser::RuleTf_item_declaration;
}

void SV3_1aParser::Tf_item_declarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTf_item_declaration(this);
}

void SV3_1aParser::Tf_item_declarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTf_item_declaration(this);
}

SV3_1aParser::Tf_item_declarationContext* SV3_1aParser::tf_item_declaration() {
  Tf_item_declarationContext *_localctx = _tracker.createInstance<Tf_item_declarationContext>(_ctx, getState());
  enterRule(_localctx, 388, SV3_1aParser::RuleTf_item_declaration);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(3981);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 408, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(3979);
      block_item_declaration();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(3980);
      tf_port_declaration();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Tf_port_listContext ------------------------------------------------------------------

SV3_1aParser::Tf_port_listContext::Tf_port_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<SV3_1aParser::Tf_port_itemContext *> SV3_1aParser::Tf_port_listContext::tf_port_item() {
  return getRuleContexts<SV3_1aParser::Tf_port_itemContext>();
}

SV3_1aParser::Tf_port_itemContext* SV3_1aParser::Tf_port_listContext::tf_port_item(size_t i) {
  return getRuleContext<SV3_1aParser::Tf_port_itemContext>(i);
}

std::vector<tree::TerminalNode *> SV3_1aParser::Tf_port_listContext::COMMA() {
  return getTokens(SV3_1aParser::COMMA);
}

tree::TerminalNode* SV3_1aParser::Tf_port_listContext::COMMA(size_t i) {
  return getToken(SV3_1aParser::COMMA, i);
}


size_t SV3_1aParser::Tf_port_listContext::getRuleIndex() const {
  return SV3_1aParser::RuleTf_port_list;
}

void SV3_1aParser::Tf_port_listContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTf_port_list(this);
}

void SV3_1aParser::Tf_port_listContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTf_port_list(this);
}

SV3_1aParser::Tf_port_listContext* SV3_1aParser::tf_port_list() {
  Tf_port_listContext *_localctx = _tracker.createInstance<Tf_port_listContext>(_ctx, getState());
  enterRule(_localctx, 390, SV3_1aParser::RuleTf_port_list);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3983);
    tf_port_item();
    setState(3988);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == SV3_1aParser::COMMA) {
      setState(3984);
      match(SV3_1aParser::COMMA);
      setState(3985);
      tf_port_item();
      setState(3990);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Tf_port_itemContext ------------------------------------------------------------------

SV3_1aParser::Tf_port_itemContext::Tf_port_itemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::Data_type_or_implicitContext* SV3_1aParser::Tf_port_itemContext::data_type_or_implicit() {
  return getRuleContext<SV3_1aParser::Data_type_or_implicitContext>(0);
}

SV3_1aParser::IdentifierContext* SV3_1aParser::Tf_port_itemContext::identifier() {
  return getRuleContext<SV3_1aParser::IdentifierContext>(0);
}

std::vector<SV3_1aParser::Attribute_instanceContext *> SV3_1aParser::Tf_port_itemContext::attribute_instance() {
  return getRuleContexts<SV3_1aParser::Attribute_instanceContext>();
}

SV3_1aParser::Attribute_instanceContext* SV3_1aParser::Tf_port_itemContext::attribute_instance(size_t i) {
  return getRuleContext<SV3_1aParser::Attribute_instanceContext>(i);
}

SV3_1aParser::Tf_port_directionContext* SV3_1aParser::Tf_port_itemContext::tf_port_direction() {
  return getRuleContext<SV3_1aParser::Tf_port_directionContext>(0);
}

SV3_1aParser::Var_typeContext* SV3_1aParser::Tf_port_itemContext::var_type() {
  return getRuleContext<SV3_1aParser::Var_typeContext>(0);
}

std::vector<SV3_1aParser::Variable_dimensionContext *> SV3_1aParser::Tf_port_itemContext::variable_dimension() {
  return getRuleContexts<SV3_1aParser::Variable_dimensionContext>();
}

SV3_1aParser::Variable_dimensionContext* SV3_1aParser::Tf_port_itemContext::variable_dimension(size_t i) {
  return getRuleContext<SV3_1aParser::Variable_dimensionContext>(i);
}

tree::TerminalNode* SV3_1aParser::Tf_port_itemContext::ASSIGN_OP() {
  return getToken(SV3_1aParser::ASSIGN_OP, 0);
}

SV3_1aParser::ExpressionContext* SV3_1aParser::Tf_port_itemContext::expression() {
  return getRuleContext<SV3_1aParser::ExpressionContext>(0);
}


size_t SV3_1aParser::Tf_port_itemContext::getRuleIndex() const {
  return SV3_1aParser::RuleTf_port_item;
}

void SV3_1aParser::Tf_port_itemContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTf_port_item(this);
}

void SV3_1aParser::Tf_port_itemContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTf_port_item(this);
}

SV3_1aParser::Tf_port_itemContext* SV3_1aParser::tf_port_item() {
  Tf_port_itemContext *_localctx = _tracker.createInstance<Tf_port_itemContext>(_ctx, getState());
  enterRule(_localctx, 392, SV3_1aParser::RuleTf_port_item);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3994);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == SV3_1aParser::OPEN_PARENS_STAR) {
      setState(3991);
      attribute_instance();
      setState(3996);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(3998);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (((((_la - 66) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 66)) & 271) != 0)) {
      setState(3997);
      tf_port_direction();
    }
    setState(4001);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SV3_1aParser::VAR) {
      setState(4000);
      var_type();
    }
    setState(4003);
    data_type_or_implicit();
    setState(4004);
    identifier();
    setState(4008);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == SV3_1aParser::ASSOCIATIVE_UNSPECIFIED || _la == SV3_1aParser::OPEN_BRACKET) {
      setState(4005);
      variable_dimension();
      setState(4010);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(4013);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SV3_1aParser::ASSIGN_OP) {
      setState(4011);
      match(SV3_1aParser::ASSIGN_OP);
      setState(4012);
      expression(0);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Tf_port_directionContext ------------------------------------------------------------------

SV3_1aParser::Tf_port_directionContext::Tf_port_directionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Tf_port_directionContext::INPUT() {
  return getToken(SV3_1aParser::INPUT, 0);
}

tree::TerminalNode* SV3_1aParser::Tf_port_directionContext::OUTPUT() {
  return getToken(SV3_1aParser::OUTPUT, 0);
}

tree::TerminalNode* SV3_1aParser::Tf_port_directionContext::INOUT() {
  return getToken(SV3_1aParser::INOUT, 0);
}

tree::TerminalNode* SV3_1aParser::Tf_port_directionContext::REF() {
  return getToken(SV3_1aParser::REF, 0);
}

tree::TerminalNode* SV3_1aParser::Tf_port_directionContext::CONST() {
  return getToken(SV3_1aParser::CONST, 0);
}


size_t SV3_1aParser::Tf_port_directionContext::getRuleIndex() const {
  return SV3_1aParser::RuleTf_port_direction;
}

void SV3_1aParser::Tf_port_directionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTf_port_direction(this);
}

void SV3_1aParser::Tf_port_directionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTf_port_direction(this);
}

SV3_1aParser::Tf_port_directionContext* SV3_1aParser::tf_port_direction() {
  Tf_port_directionContext *_localctx = _tracker.createInstance<Tf_port_directionContext>(_ctx, getState());
  enterRule(_localctx, 394, SV3_1aParser::RuleTf_port_direction);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(4021);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SV3_1aParser::INPUT: {
        enterOuterAlt(_localctx, 1);
        setState(4015);
        match(SV3_1aParser::INPUT);
        break;
      }

      case SV3_1aParser::OUTPUT: {
        enterOuterAlt(_localctx, 2);
        setState(4016);
        match(SV3_1aParser::OUTPUT);
        break;
      }

      case SV3_1aParser::INOUT: {
        enterOuterAlt(_localctx, 3);
        setState(4017);
        match(SV3_1aParser::INOUT);
        break;
      }

      case SV3_1aParser::REF: {
        enterOuterAlt(_localctx, 4);
        setState(4018);
        match(SV3_1aParser::REF);
        break;
      }

      case SV3_1aParser::CONST: {
        enterOuterAlt(_localctx, 5);
        setState(4019);
        match(SV3_1aParser::CONST);
        setState(4020);
        match(SV3_1aParser::REF);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Tf_port_declarationContext ------------------------------------------------------------------

SV3_1aParser::Tf_port_declarationContext::Tf_port_declarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::Tf_port_directionContext* SV3_1aParser::Tf_port_declarationContext::tf_port_direction() {
  return getRuleContext<SV3_1aParser::Tf_port_directionContext>(0);
}

SV3_1aParser::Data_type_or_implicitContext* SV3_1aParser::Tf_port_declarationContext::data_type_or_implicit() {
  return getRuleContext<SV3_1aParser::Data_type_or_implicitContext>(0);
}

SV3_1aParser::List_of_tf_variable_identifiersContext* SV3_1aParser::Tf_port_declarationContext::list_of_tf_variable_identifiers() {
  return getRuleContext<SV3_1aParser::List_of_tf_variable_identifiersContext>(0);
}

tree::TerminalNode* SV3_1aParser::Tf_port_declarationContext::SEMICOLON() {
  return getToken(SV3_1aParser::SEMICOLON, 0);
}

std::vector<SV3_1aParser::Attribute_instanceContext *> SV3_1aParser::Tf_port_declarationContext::attribute_instance() {
  return getRuleContexts<SV3_1aParser::Attribute_instanceContext>();
}

SV3_1aParser::Attribute_instanceContext* SV3_1aParser::Tf_port_declarationContext::attribute_instance(size_t i) {
  return getRuleContext<SV3_1aParser::Attribute_instanceContext>(i);
}

SV3_1aParser::Var_typeContext* SV3_1aParser::Tf_port_declarationContext::var_type() {
  return getRuleContext<SV3_1aParser::Var_typeContext>(0);
}


size_t SV3_1aParser::Tf_port_declarationContext::getRuleIndex() const {
  return SV3_1aParser::RuleTf_port_declaration;
}

void SV3_1aParser::Tf_port_declarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTf_port_declaration(this);
}

void SV3_1aParser::Tf_port_declarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTf_port_declaration(this);
}

SV3_1aParser::Tf_port_declarationContext* SV3_1aParser::tf_port_declaration() {
  Tf_port_declarationContext *_localctx = _tracker.createInstance<Tf_port_declarationContext>(_ctx, getState());
  enterRule(_localctx, 396, SV3_1aParser::RuleTf_port_declaration);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4026);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == SV3_1aParser::OPEN_PARENS_STAR) {
      setState(4023);
      attribute_instance();
      setState(4028);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(4029);
    tf_port_direction();
    setState(4031);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SV3_1aParser::VAR) {
      setState(4030);
      var_type();
    }
    setState(4033);
    data_type_or_implicit();
    setState(4034);
    list_of_tf_variable_identifiers();
    setState(4035);
    match(SV3_1aParser::SEMICOLON);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Task_prototypeContext ------------------------------------------------------------------

SV3_1aParser::Task_prototypeContext::Task_prototypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Task_prototypeContext::TASK() {
  return getToken(SV3_1aParser::TASK, 0);
}

SV3_1aParser::IdentifierContext* SV3_1aParser::Task_prototypeContext::identifier() {
  return getRuleContext<SV3_1aParser::IdentifierContext>(0);
}

tree::TerminalNode* SV3_1aParser::Task_prototypeContext::OPEN_PARENS() {
  return getToken(SV3_1aParser::OPEN_PARENS, 0);
}

tree::TerminalNode* SV3_1aParser::Task_prototypeContext::CLOSE_PARENS() {
  return getToken(SV3_1aParser::CLOSE_PARENS, 0);
}

SV3_1aParser::Tf_port_listContext* SV3_1aParser::Task_prototypeContext::tf_port_list() {
  return getRuleContext<SV3_1aParser::Tf_port_listContext>(0);
}


size_t SV3_1aParser::Task_prototypeContext::getRuleIndex() const {
  return SV3_1aParser::RuleTask_prototype;
}

void SV3_1aParser::Task_prototypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTask_prototype(this);
}

void SV3_1aParser::Task_prototypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTask_prototype(this);
}

SV3_1aParser::Task_prototypeContext* SV3_1aParser::task_prototype() {
  Task_prototypeContext *_localctx = _tracker.createInstance<Task_prototypeContext>(_ctx, getState());
  enterRule(_localctx, 398, SV3_1aParser::RuleTask_prototype);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4037);
    match(SV3_1aParser::TASK);
    setState(4038);
    identifier();
    setState(4044);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SV3_1aParser::OPEN_PARENS) {
      setState(4039);
      match(SV3_1aParser::OPEN_PARENS);
      setState(4041);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == SV3_1aParser::VIRTUAL || ((((_la - 64) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 64)) & 1152775819316167741) != 0) || ((((_la - 147) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 147)) & 6597069766667) != 0) || ((((_la - 326) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 326)) & 4672924483589) != 0)) {
        setState(4040);
        tf_port_list();
      }
      setState(4043);
      match(SV3_1aParser::CLOSE_PARENS);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Block_item_declarationContext ------------------------------------------------------------------

SV3_1aParser::Block_item_declarationContext::Block_item_declarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::Data_declarationContext* SV3_1aParser::Block_item_declarationContext::data_declaration() {
  return getRuleContext<SV3_1aParser::Data_declarationContext>(0);
}

SV3_1aParser::Local_parameter_declarationContext* SV3_1aParser::Block_item_declarationContext::local_parameter_declaration() {
  return getRuleContext<SV3_1aParser::Local_parameter_declarationContext>(0);
}

tree::TerminalNode* SV3_1aParser::Block_item_declarationContext::SEMICOLON() {
  return getToken(SV3_1aParser::SEMICOLON, 0);
}

SV3_1aParser::Parameter_declarationContext* SV3_1aParser::Block_item_declarationContext::parameter_declaration() {
  return getRuleContext<SV3_1aParser::Parameter_declarationContext>(0);
}

SV3_1aParser::Overload_declarationContext* SV3_1aParser::Block_item_declarationContext::overload_declaration() {
  return getRuleContext<SV3_1aParser::Overload_declarationContext>(0);
}

SV3_1aParser::Let_declarationContext* SV3_1aParser::Block_item_declarationContext::let_declaration() {
  return getRuleContext<SV3_1aParser::Let_declarationContext>(0);
}

std::vector<SV3_1aParser::Attribute_instanceContext *> SV3_1aParser::Block_item_declarationContext::attribute_instance() {
  return getRuleContexts<SV3_1aParser::Attribute_instanceContext>();
}

SV3_1aParser::Attribute_instanceContext* SV3_1aParser::Block_item_declarationContext::attribute_instance(size_t i) {
  return getRuleContext<SV3_1aParser::Attribute_instanceContext>(i);
}


size_t SV3_1aParser::Block_item_declarationContext::getRuleIndex() const {
  return SV3_1aParser::RuleBlock_item_declaration;
}

void SV3_1aParser::Block_item_declarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBlock_item_declaration(this);
}

void SV3_1aParser::Block_item_declarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBlock_item_declaration(this);
}

SV3_1aParser::Block_item_declarationContext* SV3_1aParser::block_item_declaration() {
  Block_item_declarationContext *_localctx = _tracker.createInstance<Block_item_declarationContext>(_ctx, getState());
  enterRule(_localctx, 400, SV3_1aParser::RuleBlock_item_declaration);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4049);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == SV3_1aParser::OPEN_PARENS_STAR) {
      setState(4046);
      attribute_instance();
      setState(4051);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(4061);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SV3_1aParser::VIRTUAL:
      case SV3_1aParser::TYPE:
      case SV3_1aParser::CONST:
      case SV3_1aParser::STATIC:
      case SV3_1aParser::AUTOMATIC:
      case SV3_1aParser::IMPORT:
      case SV3_1aParser::TYPEDEF:
      case SV3_1aParser::ENUM:
      case SV3_1aParser::STRUCT:
      case SV3_1aParser::UNION:
      case SV3_1aParser::STRING:
      case SV3_1aParser::CHANDLE:
      case SV3_1aParser::EVENT:
      case SV3_1aParser::OPEN_BRACKET:
      case SV3_1aParser::BYTE:
      case SV3_1aParser::SHORTINT:
      case SV3_1aParser::INT:
      case SV3_1aParser::LONGINT:
      case SV3_1aParser::INTEGER:
      case SV3_1aParser::TIME:
      case SV3_1aParser::BIT:
      case SV3_1aParser::LOGIC:
      case SV3_1aParser::REG:
      case SV3_1aParser::SHORTREAL:
      case SV3_1aParser::REAL:
      case SV3_1aParser::REALTIME:
      case SV3_1aParser::SIGNED:
      case SV3_1aParser::UNSIGNED:
      case SV3_1aParser::VAR:
      case SV3_1aParser::DOLLAR_UNIT:
      case SV3_1aParser::THIS:
      case SV3_1aParser::RANDOMIZE:
      case SV3_1aParser::SAMPLE:
      case SV3_1aParser::NETTYPE:
      case SV3_1aParser::Escaped_identifier:
      case SV3_1aParser::Simple_identifier: {
        setState(4052);
        data_declaration();
        break;
      }

      case SV3_1aParser::LOCALPARAM: {
        setState(4053);
        local_parameter_declaration();
        setState(4054);
        match(SV3_1aParser::SEMICOLON);
        break;
      }

      case SV3_1aParser::PARAMETER: {
        setState(4056);
        parameter_declaration();
        setState(4057);
        match(SV3_1aParser::SEMICOLON);
        break;
      }

      case SV3_1aParser::BIND: {
        setState(4059);
        overload_declaration();
        break;
      }

      case SV3_1aParser::LET: {
        setState(4060);
        let_declaration();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Overload_declarationContext ------------------------------------------------------------------

SV3_1aParser::Overload_declarationContext::Overload_declarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Overload_declarationContext::BIND() {
  return getToken(SV3_1aParser::BIND, 0);
}

SV3_1aParser::Overload_operatorContext* SV3_1aParser::Overload_declarationContext::overload_operator() {
  return getRuleContext<SV3_1aParser::Overload_operatorContext>(0);
}

tree::TerminalNode* SV3_1aParser::Overload_declarationContext::FUNCTION() {
  return getToken(SV3_1aParser::FUNCTION, 0);
}

SV3_1aParser::Data_typeContext* SV3_1aParser::Overload_declarationContext::data_type() {
  return getRuleContext<SV3_1aParser::Data_typeContext>(0);
}

SV3_1aParser::IdentifierContext* SV3_1aParser::Overload_declarationContext::identifier() {
  return getRuleContext<SV3_1aParser::IdentifierContext>(0);
}

tree::TerminalNode* SV3_1aParser::Overload_declarationContext::OPEN_PARENS() {
  return getToken(SV3_1aParser::OPEN_PARENS, 0);
}

SV3_1aParser::Overload_proto_formalsContext* SV3_1aParser::Overload_declarationContext::overload_proto_formals() {
  return getRuleContext<SV3_1aParser::Overload_proto_formalsContext>(0);
}

tree::TerminalNode* SV3_1aParser::Overload_declarationContext::CLOSE_PARENS() {
  return getToken(SV3_1aParser::CLOSE_PARENS, 0);
}

tree::TerminalNode* SV3_1aParser::Overload_declarationContext::SEMICOLON() {
  return getToken(SV3_1aParser::SEMICOLON, 0);
}


size_t SV3_1aParser::Overload_declarationContext::getRuleIndex() const {
  return SV3_1aParser::RuleOverload_declaration;
}

void SV3_1aParser::Overload_declarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOverload_declaration(this);
}

void SV3_1aParser::Overload_declarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOverload_declaration(this);
}

SV3_1aParser::Overload_declarationContext* SV3_1aParser::overload_declaration() {
  Overload_declarationContext *_localctx = _tracker.createInstance<Overload_declarationContext>(_ctx, getState());
  enterRule(_localctx, 402, SV3_1aParser::RuleOverload_declaration);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4063);
    match(SV3_1aParser::BIND);
    setState(4064);
    overload_operator();
    setState(4065);
    match(SV3_1aParser::FUNCTION);
    setState(4066);
    data_type();
    setState(4067);
    identifier();
    setState(4068);
    match(SV3_1aParser::OPEN_PARENS);
    setState(4069);
    overload_proto_formals();
    setState(4070);
    match(SV3_1aParser::CLOSE_PARENS);
    setState(4071);
    match(SV3_1aParser::SEMICOLON);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Overload_operatorContext ------------------------------------------------------------------

SV3_1aParser::Overload_operatorContext::Overload_operatorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t SV3_1aParser::Overload_operatorContext::getRuleIndex() const {
  return SV3_1aParser::RuleOverload_operator;
}

void SV3_1aParser::Overload_operatorContext::copyFrom(Overload_operatorContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- OverloadOp_MinusContext ------------------------------------------------------------------

tree::TerminalNode* SV3_1aParser::OverloadOp_MinusContext::MINUS() {
  return getToken(SV3_1aParser::MINUS, 0);
}

SV3_1aParser::OverloadOp_MinusContext::OverloadOp_MinusContext(Overload_operatorContext *ctx) { copyFrom(ctx); }

void SV3_1aParser::OverloadOp_MinusContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOverloadOp_Minus(this);
}
void SV3_1aParser::OverloadOp_MinusContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOverloadOp_Minus(this);
}
//----------------- OverloadOp_GreaterEqualContext ------------------------------------------------------------------

tree::TerminalNode* SV3_1aParser::OverloadOp_GreaterEqualContext::GREATER_EQUAL() {
  return getToken(SV3_1aParser::GREATER_EQUAL, 0);
}

SV3_1aParser::OverloadOp_GreaterEqualContext::OverloadOp_GreaterEqualContext(Overload_operatorContext *ctx) { copyFrom(ctx); }

void SV3_1aParser::OverloadOp_GreaterEqualContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOverloadOp_GreaterEqual(this);
}
void SV3_1aParser::OverloadOp_GreaterEqualContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOverloadOp_GreaterEqual(this);
}
//----------------- OverloadOp_LessContext ------------------------------------------------------------------

tree::TerminalNode* SV3_1aParser::OverloadOp_LessContext::LESS() {
  return getToken(SV3_1aParser::LESS, 0);
}

SV3_1aParser::OverloadOp_LessContext::OverloadOp_LessContext(Overload_operatorContext *ctx) { copyFrom(ctx); }

void SV3_1aParser::OverloadOp_LessContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOverloadOp_Less(this);
}
void SV3_1aParser::OverloadOp_LessContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOverloadOp_Less(this);
}
//----------------- OverloadOp_PercentContext ------------------------------------------------------------------

tree::TerminalNode* SV3_1aParser::OverloadOp_PercentContext::PERCENT() {
  return getToken(SV3_1aParser::PERCENT, 0);
}

SV3_1aParser::OverloadOp_PercentContext::OverloadOp_PercentContext(Overload_operatorContext *ctx) { copyFrom(ctx); }

void SV3_1aParser::OverloadOp_PercentContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOverloadOp_Percent(this);
}
void SV3_1aParser::OverloadOp_PercentContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOverloadOp_Percent(this);
}
//----------------- OverloadOp_NotEqualContext ------------------------------------------------------------------

tree::TerminalNode* SV3_1aParser::OverloadOp_NotEqualContext::NOTEQUAL() {
  return getToken(SV3_1aParser::NOTEQUAL, 0);
}

SV3_1aParser::OverloadOp_NotEqualContext::OverloadOp_NotEqualContext(Overload_operatorContext *ctx) { copyFrom(ctx); }

void SV3_1aParser::OverloadOp_NotEqualContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOverloadOp_NotEqual(this);
}
void SV3_1aParser::OverloadOp_NotEqualContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOverloadOp_NotEqual(this);
}
//----------------- OverloadOp_MultContext ------------------------------------------------------------------

tree::TerminalNode* SV3_1aParser::OverloadOp_MultContext::STAR() {
  return getToken(SV3_1aParser::STAR, 0);
}

SV3_1aParser::OverloadOp_MultContext::OverloadOp_MultContext(Overload_operatorContext *ctx) { copyFrom(ctx); }

void SV3_1aParser::OverloadOp_MultContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOverloadOp_Mult(this);
}
void SV3_1aParser::OverloadOp_MultContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOverloadOp_Mult(this);
}
//----------------- OverloadOp_EquivContext ------------------------------------------------------------------

tree::TerminalNode* SV3_1aParser::OverloadOp_EquivContext::EQUIV() {
  return getToken(SV3_1aParser::EQUIV, 0);
}

SV3_1aParser::OverloadOp_EquivContext::OverloadOp_EquivContext(Overload_operatorContext *ctx) { copyFrom(ctx); }

void SV3_1aParser::OverloadOp_EquivContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOverloadOp_Equiv(this);
}
void SV3_1aParser::OverloadOp_EquivContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOverloadOp_Equiv(this);
}
//----------------- OverloadOp_EqualContext ------------------------------------------------------------------

tree::TerminalNode* SV3_1aParser::OverloadOp_EqualContext::ASSIGN_OP() {
  return getToken(SV3_1aParser::ASSIGN_OP, 0);
}

SV3_1aParser::OverloadOp_EqualContext::OverloadOp_EqualContext(Overload_operatorContext *ctx) { copyFrom(ctx); }

void SV3_1aParser::OverloadOp_EqualContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOverloadOp_Equal(this);
}
void SV3_1aParser::OverloadOp_EqualContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOverloadOp_Equal(this);
}
//----------------- OverloadOp_LessEqualContext ------------------------------------------------------------------

tree::TerminalNode* SV3_1aParser::OverloadOp_LessEqualContext::LESS_EQUAL() {
  return getToken(SV3_1aParser::LESS_EQUAL, 0);
}

SV3_1aParser::OverloadOp_LessEqualContext::OverloadOp_LessEqualContext(Overload_operatorContext *ctx) { copyFrom(ctx); }

void SV3_1aParser::OverloadOp_LessEqualContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOverloadOp_LessEqual(this);
}
void SV3_1aParser::OverloadOp_LessEqualContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOverloadOp_LessEqual(this);
}
//----------------- OverloadOp_PlusPlusContext ------------------------------------------------------------------

tree::TerminalNode* SV3_1aParser::OverloadOp_PlusPlusContext::PLUSPLUS() {
  return getToken(SV3_1aParser::PLUSPLUS, 0);
}

SV3_1aParser::OverloadOp_PlusPlusContext::OverloadOp_PlusPlusContext(Overload_operatorContext *ctx) { copyFrom(ctx); }

void SV3_1aParser::OverloadOp_PlusPlusContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOverloadOp_PlusPlus(this);
}
void SV3_1aParser::OverloadOp_PlusPlusContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOverloadOp_PlusPlus(this);
}
//----------------- OverloadOp_GreaterContext ------------------------------------------------------------------

tree::TerminalNode* SV3_1aParser::OverloadOp_GreaterContext::GREATER() {
  return getToken(SV3_1aParser::GREATER, 0);
}

SV3_1aParser::OverloadOp_GreaterContext::OverloadOp_GreaterContext(Overload_operatorContext *ctx) { copyFrom(ctx); }

void SV3_1aParser::OverloadOp_GreaterContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOverloadOp_Greater(this);
}
void SV3_1aParser::OverloadOp_GreaterContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOverloadOp_Greater(this);
}
//----------------- OverloadOp_MinusMinusContext ------------------------------------------------------------------

tree::TerminalNode* SV3_1aParser::OverloadOp_MinusMinusContext::MINUSMINUS() {
  return getToken(SV3_1aParser::MINUSMINUS, 0);
}

SV3_1aParser::OverloadOp_MinusMinusContext::OverloadOp_MinusMinusContext(Overload_operatorContext *ctx) { copyFrom(ctx); }

void SV3_1aParser::OverloadOp_MinusMinusContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOverloadOp_MinusMinus(this);
}
void SV3_1aParser::OverloadOp_MinusMinusContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOverloadOp_MinusMinus(this);
}
//----------------- OverloadOp_StarStarContext ------------------------------------------------------------------

tree::TerminalNode* SV3_1aParser::OverloadOp_StarStarContext::STARSTAR() {
  return getToken(SV3_1aParser::STARSTAR, 0);
}

SV3_1aParser::OverloadOp_StarStarContext::OverloadOp_StarStarContext(Overload_operatorContext *ctx) { copyFrom(ctx); }

void SV3_1aParser::OverloadOp_StarStarContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOverloadOp_StarStar(this);
}
void SV3_1aParser::OverloadOp_StarStarContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOverloadOp_StarStar(this);
}
//----------------- OverloadOp_PlusContext ------------------------------------------------------------------

tree::TerminalNode* SV3_1aParser::OverloadOp_PlusContext::PLUS() {
  return getToken(SV3_1aParser::PLUS, 0);
}

SV3_1aParser::OverloadOp_PlusContext::OverloadOp_PlusContext(Overload_operatorContext *ctx) { copyFrom(ctx); }

void SV3_1aParser::OverloadOp_PlusContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOverloadOp_Plus(this);
}
void SV3_1aParser::OverloadOp_PlusContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOverloadOp_Plus(this);
}
//----------------- OverloadOp_DivContext ------------------------------------------------------------------

tree::TerminalNode* SV3_1aParser::OverloadOp_DivContext::DIV() {
  return getToken(SV3_1aParser::DIV, 0);
}

SV3_1aParser::OverloadOp_DivContext::OverloadOp_DivContext(Overload_operatorContext *ctx) { copyFrom(ctx); }

void SV3_1aParser::OverloadOp_DivContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOverloadOp_Div(this);
}
void SV3_1aParser::OverloadOp_DivContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOverloadOp_Div(this);
}
SV3_1aParser::Overload_operatorContext* SV3_1aParser::overload_operator() {
  Overload_operatorContext *_localctx = _tracker.createInstance<Overload_operatorContext>(_ctx, getState());
  enterRule(_localctx, 404, SV3_1aParser::RuleOverload_operator);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(4088);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SV3_1aParser::PLUS: {
        _localctx = _tracker.createInstance<SV3_1aParser::OverloadOp_PlusContext>(_localctx);
        enterOuterAlt(_localctx, 1);
        setState(4073);
        match(SV3_1aParser::PLUS);
        break;
      }

      case SV3_1aParser::PLUSPLUS: {
        _localctx = _tracker.createInstance<SV3_1aParser::OverloadOp_PlusPlusContext>(_localctx);
        enterOuterAlt(_localctx, 2);
        setState(4074);
        match(SV3_1aParser::PLUSPLUS);
        break;
      }

      case SV3_1aParser::MINUS: {
        _localctx = _tracker.createInstance<SV3_1aParser::OverloadOp_MinusContext>(_localctx);
        enterOuterAlt(_localctx, 3);
        setState(4075);
        match(SV3_1aParser::MINUS);
        break;
      }

      case SV3_1aParser::MINUSMINUS: {
        _localctx = _tracker.createInstance<SV3_1aParser::OverloadOp_MinusMinusContext>(_localctx);
        enterOuterAlt(_localctx, 4);
        setState(4076);
        match(SV3_1aParser::MINUSMINUS);
        break;
      }

      case SV3_1aParser::STAR: {
        _localctx = _tracker.createInstance<SV3_1aParser::OverloadOp_MultContext>(_localctx);
        enterOuterAlt(_localctx, 5);
        setState(4077);
        match(SV3_1aParser::STAR);
        break;
      }

      case SV3_1aParser::STARSTAR: {
        _localctx = _tracker.createInstance<SV3_1aParser::OverloadOp_StarStarContext>(_localctx);
        enterOuterAlt(_localctx, 6);
        setState(4078);
        match(SV3_1aParser::STARSTAR);
        break;
      }

      case SV3_1aParser::DIV: {
        _localctx = _tracker.createInstance<SV3_1aParser::OverloadOp_DivContext>(_localctx);
        enterOuterAlt(_localctx, 7);
        setState(4079);
        match(SV3_1aParser::DIV);
        break;
      }

      case SV3_1aParser::PERCENT: {
        _localctx = _tracker.createInstance<SV3_1aParser::OverloadOp_PercentContext>(_localctx);
        enterOuterAlt(_localctx, 8);
        setState(4080);
        match(SV3_1aParser::PERCENT);
        break;
      }

      case SV3_1aParser::EQUIV: {
        _localctx = _tracker.createInstance<SV3_1aParser::OverloadOp_EquivContext>(_localctx);
        enterOuterAlt(_localctx, 9);
        setState(4081);
        match(SV3_1aParser::EQUIV);
        break;
      }

      case SV3_1aParser::NOTEQUAL: {
        _localctx = _tracker.createInstance<SV3_1aParser::OverloadOp_NotEqualContext>(_localctx);
        enterOuterAlt(_localctx, 10);
        setState(4082);
        match(SV3_1aParser::NOTEQUAL);
        break;
      }

      case SV3_1aParser::LESS: {
        _localctx = _tracker.createInstance<SV3_1aParser::OverloadOp_LessContext>(_localctx);
        enterOuterAlt(_localctx, 11);
        setState(4083);
        match(SV3_1aParser::LESS);
        break;
      }

      case SV3_1aParser::LESS_EQUAL: {
        _localctx = _tracker.createInstance<SV3_1aParser::OverloadOp_LessEqualContext>(_localctx);
        enterOuterAlt(_localctx, 12);
        setState(4084);
        match(SV3_1aParser::LESS_EQUAL);
        break;
      }

      case SV3_1aParser::GREATER: {
        _localctx = _tracker.createInstance<SV3_1aParser::OverloadOp_GreaterContext>(_localctx);
        enterOuterAlt(_localctx, 13);
        setState(4085);
        match(SV3_1aParser::GREATER);
        break;
      }

      case SV3_1aParser::GREATER_EQUAL: {
        _localctx = _tracker.createInstance<SV3_1aParser::OverloadOp_GreaterEqualContext>(_localctx);
        enterOuterAlt(_localctx, 14);
        setState(4086);
        match(SV3_1aParser::GREATER_EQUAL);
        break;
      }

      case SV3_1aParser::ASSIGN_OP: {
        _localctx = _tracker.createInstance<SV3_1aParser::OverloadOp_EqualContext>(_localctx);
        enterOuterAlt(_localctx, 15);
        setState(4087);
        match(SV3_1aParser::ASSIGN_OP);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Overload_proto_formalsContext ------------------------------------------------------------------

SV3_1aParser::Overload_proto_formalsContext::Overload_proto_formalsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<SV3_1aParser::Data_typeContext *> SV3_1aParser::Overload_proto_formalsContext::data_type() {
  return getRuleContexts<SV3_1aParser::Data_typeContext>();
}

SV3_1aParser::Data_typeContext* SV3_1aParser::Overload_proto_formalsContext::data_type(size_t i) {
  return getRuleContext<SV3_1aParser::Data_typeContext>(i);
}

std::vector<tree::TerminalNode *> SV3_1aParser::Overload_proto_formalsContext::COMMA() {
  return getTokens(SV3_1aParser::COMMA);
}

tree::TerminalNode* SV3_1aParser::Overload_proto_formalsContext::COMMA(size_t i) {
  return getToken(SV3_1aParser::COMMA, i);
}


size_t SV3_1aParser::Overload_proto_formalsContext::getRuleIndex() const {
  return SV3_1aParser::RuleOverload_proto_formals;
}

void SV3_1aParser::Overload_proto_formalsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOverload_proto_formals(this);
}

void SV3_1aParser::Overload_proto_formalsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOverload_proto_formals(this);
}

SV3_1aParser::Overload_proto_formalsContext* SV3_1aParser::overload_proto_formals() {
  Overload_proto_formalsContext *_localctx = _tracker.createInstance<Overload_proto_formalsContext>(_ctx, getState());
  enterRule(_localctx, 406, SV3_1aParser::RuleOverload_proto_formals);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4090);
    data_type();
    setState(4095);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == SV3_1aParser::COMMA) {
      setState(4091);
      match(SV3_1aParser::COMMA);
      setState(4092);
      data_type();
      setState(4097);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Virtual_interface_declarationContext ------------------------------------------------------------------

SV3_1aParser::Virtual_interface_declarationContext::Virtual_interface_declarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Virtual_interface_declarationContext::VIRTUAL() {
  return getToken(SV3_1aParser::VIRTUAL, 0);
}

SV3_1aParser::Interface_identifierContext* SV3_1aParser::Virtual_interface_declarationContext::interface_identifier() {
  return getRuleContext<SV3_1aParser::Interface_identifierContext>(0);
}

SV3_1aParser::List_of_virtual_interface_declContext* SV3_1aParser::Virtual_interface_declarationContext::list_of_virtual_interface_decl() {
  return getRuleContext<SV3_1aParser::List_of_virtual_interface_declContext>(0);
}

tree::TerminalNode* SV3_1aParser::Virtual_interface_declarationContext::SEMICOLON() {
  return getToken(SV3_1aParser::SEMICOLON, 0);
}

tree::TerminalNode* SV3_1aParser::Virtual_interface_declarationContext::INTERFACE() {
  return getToken(SV3_1aParser::INTERFACE, 0);
}


size_t SV3_1aParser::Virtual_interface_declarationContext::getRuleIndex() const {
  return SV3_1aParser::RuleVirtual_interface_declaration;
}

void SV3_1aParser::Virtual_interface_declarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterVirtual_interface_declaration(this);
}

void SV3_1aParser::Virtual_interface_declarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitVirtual_interface_declaration(this);
}

SV3_1aParser::Virtual_interface_declarationContext* SV3_1aParser::virtual_interface_declaration() {
  Virtual_interface_declarationContext *_localctx = _tracker.createInstance<Virtual_interface_declarationContext>(_ctx, getState());
  enterRule(_localctx, 408, SV3_1aParser::RuleVirtual_interface_declaration);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4098);
    match(SV3_1aParser::VIRTUAL);
    setState(4100);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SV3_1aParser::INTERFACE) {
      setState(4099);
      match(SV3_1aParser::INTERFACE);
    }
    setState(4102);
    interface_identifier();
    setState(4103);
    list_of_virtual_interface_decl();
    setState(4104);
    match(SV3_1aParser::SEMICOLON);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Modport_itemContext ------------------------------------------------------------------

SV3_1aParser::Modport_itemContext::Modport_itemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::IdentifierContext* SV3_1aParser::Modport_itemContext::identifier() {
  return getRuleContext<SV3_1aParser::IdentifierContext>(0);
}

tree::TerminalNode* SV3_1aParser::Modport_itemContext::OPEN_PARENS() {
  return getToken(SV3_1aParser::OPEN_PARENS, 0);
}

std::vector<SV3_1aParser::Modport_ports_declarationContext *> SV3_1aParser::Modport_itemContext::modport_ports_declaration() {
  return getRuleContexts<SV3_1aParser::Modport_ports_declarationContext>();
}

SV3_1aParser::Modport_ports_declarationContext* SV3_1aParser::Modport_itemContext::modport_ports_declaration(size_t i) {
  return getRuleContext<SV3_1aParser::Modport_ports_declarationContext>(i);
}

tree::TerminalNode* SV3_1aParser::Modport_itemContext::CLOSE_PARENS() {
  return getToken(SV3_1aParser::CLOSE_PARENS, 0);
}

std::vector<tree::TerminalNode *> SV3_1aParser::Modport_itemContext::COMMA() {
  return getTokens(SV3_1aParser::COMMA);
}

tree::TerminalNode* SV3_1aParser::Modport_itemContext::COMMA(size_t i) {
  return getToken(SV3_1aParser::COMMA, i);
}


size_t SV3_1aParser::Modport_itemContext::getRuleIndex() const {
  return SV3_1aParser::RuleModport_item;
}

void SV3_1aParser::Modport_itemContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterModport_item(this);
}

void SV3_1aParser::Modport_itemContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitModport_item(this);
}

SV3_1aParser::Modport_itemContext* SV3_1aParser::modport_item() {
  Modport_itemContext *_localctx = _tracker.createInstance<Modport_itemContext>(_ctx, getState());
  enterRule(_localctx, 410, SV3_1aParser::RuleModport_item);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4106);
    identifier();
    setState(4107);
    match(SV3_1aParser::OPEN_PARENS);
    setState(4108);
    modport_ports_declaration();
    setState(4113);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == SV3_1aParser::COMMA) {
      setState(4109);
      match(SV3_1aParser::COMMA);
      setState(4110);
      modport_ports_declaration();
      setState(4115);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(4116);
    match(SV3_1aParser::CLOSE_PARENS);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Modport_ports_declarationContext ------------------------------------------------------------------

SV3_1aParser::Modport_ports_declarationContext::Modport_ports_declarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::Modport_simple_ports_declarationContext* SV3_1aParser::Modport_ports_declarationContext::modport_simple_ports_declaration() {
  return getRuleContext<SV3_1aParser::Modport_simple_ports_declarationContext>(0);
}

SV3_1aParser::Modport_hierarchical_ports_declarationContext* SV3_1aParser::Modport_ports_declarationContext::modport_hierarchical_ports_declaration() {
  return getRuleContext<SV3_1aParser::Modport_hierarchical_ports_declarationContext>(0);
}

SV3_1aParser::Modport_tf_ports_declarationContext* SV3_1aParser::Modport_ports_declarationContext::modport_tf_ports_declaration() {
  return getRuleContext<SV3_1aParser::Modport_tf_ports_declarationContext>(0);
}

tree::TerminalNode* SV3_1aParser::Modport_ports_declarationContext::CLOCKING() {
  return getToken(SV3_1aParser::CLOCKING, 0);
}

SV3_1aParser::IdentifierContext* SV3_1aParser::Modport_ports_declarationContext::identifier() {
  return getRuleContext<SV3_1aParser::IdentifierContext>(0);
}

std::vector<SV3_1aParser::Attribute_instanceContext *> SV3_1aParser::Modport_ports_declarationContext::attribute_instance() {
  return getRuleContexts<SV3_1aParser::Attribute_instanceContext>();
}

SV3_1aParser::Attribute_instanceContext* SV3_1aParser::Modport_ports_declarationContext::attribute_instance(size_t i) {
  return getRuleContext<SV3_1aParser::Attribute_instanceContext>(i);
}


size_t SV3_1aParser::Modport_ports_declarationContext::getRuleIndex() const {
  return SV3_1aParser::RuleModport_ports_declaration;
}

void SV3_1aParser::Modport_ports_declarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterModport_ports_declaration(this);
}

void SV3_1aParser::Modport_ports_declarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitModport_ports_declaration(this);
}

SV3_1aParser::Modport_ports_declarationContext* SV3_1aParser::modport_ports_declaration() {
  Modport_ports_declarationContext *_localctx = _tracker.createInstance<Modport_ports_declarationContext>(_ctx, getState());
  enterRule(_localctx, 412, SV3_1aParser::RuleModport_ports_declaration);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4121);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == SV3_1aParser::OPEN_PARENS_STAR) {
      setState(4118);
      attribute_instance();
      setState(4123);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(4129);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SV3_1aParser::INPUT:
      case SV3_1aParser::OUTPUT:
      case SV3_1aParser::INOUT:
      case SV3_1aParser::REF: {
        setState(4124);
        modport_simple_ports_declaration();
        break;
      }

      case SV3_1aParser::THIS:
      case SV3_1aParser::RANDOMIZE:
      case SV3_1aParser::SAMPLE:
      case SV3_1aParser::Escaped_identifier:
      case SV3_1aParser::Simple_identifier: {
        setState(4125);
        modport_hierarchical_ports_declaration();
        break;
      }

      case SV3_1aParser::IMPORT:
      case SV3_1aParser::EXPORT: {
        setState(4126);
        modport_tf_ports_declaration();
        break;
      }

      case SV3_1aParser::CLOCKING: {
        setState(4127);
        match(SV3_1aParser::CLOCKING);
        setState(4128);
        identifier();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Modport_simple_ports_declarationContext ------------------------------------------------------------------

SV3_1aParser::Modport_simple_ports_declarationContext::Modport_simple_ports_declarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::Port_directionContext* SV3_1aParser::Modport_simple_ports_declarationContext::port_direction() {
  return getRuleContext<SV3_1aParser::Port_directionContext>(0);
}

std::vector<SV3_1aParser::Modport_simple_portContext *> SV3_1aParser::Modport_simple_ports_declarationContext::modport_simple_port() {
  return getRuleContexts<SV3_1aParser::Modport_simple_portContext>();
}

SV3_1aParser::Modport_simple_portContext* SV3_1aParser::Modport_simple_ports_declarationContext::modport_simple_port(size_t i) {
  return getRuleContext<SV3_1aParser::Modport_simple_portContext>(i);
}

std::vector<tree::TerminalNode *> SV3_1aParser::Modport_simple_ports_declarationContext::COMMA() {
  return getTokens(SV3_1aParser::COMMA);
}

tree::TerminalNode* SV3_1aParser::Modport_simple_ports_declarationContext::COMMA(size_t i) {
  return getToken(SV3_1aParser::COMMA, i);
}


size_t SV3_1aParser::Modport_simple_ports_declarationContext::getRuleIndex() const {
  return SV3_1aParser::RuleModport_simple_ports_declaration;
}

void SV3_1aParser::Modport_simple_ports_declarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterModport_simple_ports_declaration(this);
}

void SV3_1aParser::Modport_simple_ports_declarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitModport_simple_ports_declaration(this);
}

SV3_1aParser::Modport_simple_ports_declarationContext* SV3_1aParser::modport_simple_ports_declaration() {
  Modport_simple_ports_declarationContext *_localctx = _tracker.createInstance<Modport_simple_ports_declarationContext>(_ctx, getState());
  enterRule(_localctx, 414, SV3_1aParser::RuleModport_simple_ports_declaration);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(4131);
    port_direction();
    setState(4132);
    modport_simple_port();
    setState(4137);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 428, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(4133);
        match(SV3_1aParser::COMMA);
        setState(4134);
        modport_simple_port(); 
      }
      setState(4139);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 428, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Modport_simple_portContext ------------------------------------------------------------------

SV3_1aParser::Modport_simple_portContext::Modport_simple_portContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::IdentifierContext* SV3_1aParser::Modport_simple_portContext::identifier() {
  return getRuleContext<SV3_1aParser::IdentifierContext>(0);
}

tree::TerminalNode* SV3_1aParser::Modport_simple_portContext::DOT() {
  return getToken(SV3_1aParser::DOT, 0);
}

tree::TerminalNode* SV3_1aParser::Modport_simple_portContext::OPEN_PARENS() {
  return getToken(SV3_1aParser::OPEN_PARENS, 0);
}

tree::TerminalNode* SV3_1aParser::Modport_simple_portContext::CLOSE_PARENS() {
  return getToken(SV3_1aParser::CLOSE_PARENS, 0);
}

std::vector<SV3_1aParser::ExpressionContext *> SV3_1aParser::Modport_simple_portContext::expression() {
  return getRuleContexts<SV3_1aParser::ExpressionContext>();
}

SV3_1aParser::ExpressionContext* SV3_1aParser::Modport_simple_portContext::expression(size_t i) {
  return getRuleContext<SV3_1aParser::ExpressionContext>(i);
}


size_t SV3_1aParser::Modport_simple_portContext::getRuleIndex() const {
  return SV3_1aParser::RuleModport_simple_port;
}

void SV3_1aParser::Modport_simple_portContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterModport_simple_port(this);
}

void SV3_1aParser::Modport_simple_portContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitModport_simple_port(this);
}

SV3_1aParser::Modport_simple_portContext* SV3_1aParser::modport_simple_port() {
  Modport_simple_portContext *_localctx = _tracker.createInstance<Modport_simple_portContext>(_ctx, getState());
  enterRule(_localctx, 416, SV3_1aParser::RuleModport_simple_port);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(4152);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SV3_1aParser::THIS:
      case SV3_1aParser::RANDOMIZE:
      case SV3_1aParser::SAMPLE:
      case SV3_1aParser::Escaped_identifier:
      case SV3_1aParser::Simple_identifier: {
        enterOuterAlt(_localctx, 1);
        setState(4140);
        identifier();
        break;
      }

      case SV3_1aParser::DOT: {
        enterOuterAlt(_localctx, 2);
        setState(4141);
        match(SV3_1aParser::DOT);
        setState(4142);
        identifier();
        setState(4143);
        match(SV3_1aParser::OPEN_PARENS);
        setState(4147);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while ((((_la & ~ 0x3fULL) == 0) &&
          ((1ULL << _la) & 8796094922748) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 64)) & 1152648825725551617) != 0) || ((((_la - 147) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 147)) & 2199527096323) != 0) || _la == SV3_1aParser::BANG || ((((_la - 310) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 310)) & 559537073624154177) != 0)) {
          setState(4144);
          expression(0);
          setState(4149);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(4150);
        match(SV3_1aParser::CLOSE_PARENS);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Modport_hierarchical_ports_declarationContext ------------------------------------------------------------------

SV3_1aParser::Modport_hierarchical_ports_declarationContext::Modport_hierarchical_ports_declarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<SV3_1aParser::IdentifierContext *> SV3_1aParser::Modport_hierarchical_ports_declarationContext::identifier() {
  return getRuleContexts<SV3_1aParser::IdentifierContext>();
}

SV3_1aParser::IdentifierContext* SV3_1aParser::Modport_hierarchical_ports_declarationContext::identifier(size_t i) {
  return getRuleContext<SV3_1aParser::IdentifierContext>(i);
}

tree::TerminalNode* SV3_1aParser::Modport_hierarchical_ports_declarationContext::DOT() {
  return getToken(SV3_1aParser::DOT, 0);
}

tree::TerminalNode* SV3_1aParser::Modport_hierarchical_ports_declarationContext::OPEN_BRACKET() {
  return getToken(SV3_1aParser::OPEN_BRACKET, 0);
}

SV3_1aParser::Constant_expressionContext* SV3_1aParser::Modport_hierarchical_ports_declarationContext::constant_expression() {
  return getRuleContext<SV3_1aParser::Constant_expressionContext>(0);
}

tree::TerminalNode* SV3_1aParser::Modport_hierarchical_ports_declarationContext::CLOSE_BRACKET() {
  return getToken(SV3_1aParser::CLOSE_BRACKET, 0);
}


size_t SV3_1aParser::Modport_hierarchical_ports_declarationContext::getRuleIndex() const {
  return SV3_1aParser::RuleModport_hierarchical_ports_declaration;
}

void SV3_1aParser::Modport_hierarchical_ports_declarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterModport_hierarchical_ports_declaration(this);
}

void SV3_1aParser::Modport_hierarchical_ports_declarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitModport_hierarchical_ports_declaration(this);
}

SV3_1aParser::Modport_hierarchical_ports_declarationContext* SV3_1aParser::modport_hierarchical_ports_declaration() {
  Modport_hierarchical_ports_declarationContext *_localctx = _tracker.createInstance<Modport_hierarchical_ports_declarationContext>(_ctx, getState());
  enterRule(_localctx, 418, SV3_1aParser::RuleModport_hierarchical_ports_declaration);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4154);
    identifier();
    setState(4159);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SV3_1aParser::OPEN_BRACKET) {
      setState(4155);
      match(SV3_1aParser::OPEN_BRACKET);
      setState(4156);
      constant_expression(0);
      setState(4157);
      match(SV3_1aParser::CLOSE_BRACKET);
    }
    setState(4161);
    match(SV3_1aParser::DOT);
    setState(4162);
    identifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Modport_tf_ports_declarationContext ------------------------------------------------------------------

SV3_1aParser::Modport_tf_ports_declarationContext::Modport_tf_ports_declarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<SV3_1aParser::Modport_tf_portContext *> SV3_1aParser::Modport_tf_ports_declarationContext::modport_tf_port() {
  return getRuleContexts<SV3_1aParser::Modport_tf_portContext>();
}

SV3_1aParser::Modport_tf_portContext* SV3_1aParser::Modport_tf_ports_declarationContext::modport_tf_port(size_t i) {
  return getRuleContext<SV3_1aParser::Modport_tf_portContext>(i);
}

tree::TerminalNode* SV3_1aParser::Modport_tf_ports_declarationContext::IMPORT() {
  return getToken(SV3_1aParser::IMPORT, 0);
}

tree::TerminalNode* SV3_1aParser::Modport_tf_ports_declarationContext::EXPORT() {
  return getToken(SV3_1aParser::EXPORT, 0);
}

std::vector<tree::TerminalNode *> SV3_1aParser::Modport_tf_ports_declarationContext::COMMA() {
  return getTokens(SV3_1aParser::COMMA);
}

tree::TerminalNode* SV3_1aParser::Modport_tf_ports_declarationContext::COMMA(size_t i) {
  return getToken(SV3_1aParser::COMMA, i);
}


size_t SV3_1aParser::Modport_tf_ports_declarationContext::getRuleIndex() const {
  return SV3_1aParser::RuleModport_tf_ports_declaration;
}

void SV3_1aParser::Modport_tf_ports_declarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterModport_tf_ports_declaration(this);
}

void SV3_1aParser::Modport_tf_ports_declarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitModport_tf_ports_declaration(this);
}

SV3_1aParser::Modport_tf_ports_declarationContext* SV3_1aParser::modport_tf_ports_declaration() {
  Modport_tf_ports_declarationContext *_localctx = _tracker.createInstance<Modport_tf_ports_declarationContext>(_ctx, getState());
  enterRule(_localctx, 420, SV3_1aParser::RuleModport_tf_ports_declaration);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(4164);
    _la = _input->LA(1);
    if (!(_la == SV3_1aParser::IMPORT || _la == SV3_1aParser::EXPORT)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(4165);
    modport_tf_port();
    setState(4170);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 432, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(4166);
        match(SV3_1aParser::COMMA);
        setState(4167);
        modport_tf_port(); 
      }
      setState(4172);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 432, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Modport_tf_portContext ------------------------------------------------------------------

SV3_1aParser::Modport_tf_portContext::Modport_tf_portContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::Method_prototypeContext* SV3_1aParser::Modport_tf_portContext::method_prototype() {
  return getRuleContext<SV3_1aParser::Method_prototypeContext>(0);
}

SV3_1aParser::IdentifierContext* SV3_1aParser::Modport_tf_portContext::identifier() {
  return getRuleContext<SV3_1aParser::IdentifierContext>(0);
}


size_t SV3_1aParser::Modport_tf_portContext::getRuleIndex() const {
  return SV3_1aParser::RuleModport_tf_port;
}

void SV3_1aParser::Modport_tf_portContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterModport_tf_port(this);
}

void SV3_1aParser::Modport_tf_portContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitModport_tf_port(this);
}

SV3_1aParser::Modport_tf_portContext* SV3_1aParser::modport_tf_port() {
  Modport_tf_portContext *_localctx = _tracker.createInstance<Modport_tf_portContext>(_ctx, getState());
  enterRule(_localctx, 422, SV3_1aParser::RuleModport_tf_port);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(4175);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SV3_1aParser::FUNCTION:
      case SV3_1aParser::TASK: {
        enterOuterAlt(_localctx, 1);
        setState(4173);
        method_prototype();
        break;
      }

      case SV3_1aParser::THIS:
      case SV3_1aParser::RANDOMIZE:
      case SV3_1aParser::SAMPLE:
      case SV3_1aParser::Escaped_identifier:
      case SV3_1aParser::Simple_identifier: {
        enterOuterAlt(_localctx, 2);
        setState(4174);
        identifier();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Concurrent_assertion_itemContext ------------------------------------------------------------------

SV3_1aParser::Concurrent_assertion_itemContext::Concurrent_assertion_itemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::Concurrent_assertion_statementContext* SV3_1aParser::Concurrent_assertion_itemContext::concurrent_assertion_statement() {
  return getRuleContext<SV3_1aParser::Concurrent_assertion_statementContext>(0);
}

SV3_1aParser::IdentifierContext* SV3_1aParser::Concurrent_assertion_itemContext::identifier() {
  return getRuleContext<SV3_1aParser::IdentifierContext>(0);
}

tree::TerminalNode* SV3_1aParser::Concurrent_assertion_itemContext::COLON() {
  return getToken(SV3_1aParser::COLON, 0);
}

SV3_1aParser::Checker_instantiationContext* SV3_1aParser::Concurrent_assertion_itemContext::checker_instantiation() {
  return getRuleContext<SV3_1aParser::Checker_instantiationContext>(0);
}


size_t SV3_1aParser::Concurrent_assertion_itemContext::getRuleIndex() const {
  return SV3_1aParser::RuleConcurrent_assertion_item;
}

void SV3_1aParser::Concurrent_assertion_itemContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterConcurrent_assertion_item(this);
}

void SV3_1aParser::Concurrent_assertion_itemContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitConcurrent_assertion_item(this);
}

SV3_1aParser::Concurrent_assertion_itemContext* SV3_1aParser::concurrent_assertion_item() {
  Concurrent_assertion_itemContext *_localctx = _tracker.createInstance<Concurrent_assertion_itemContext>(_ctx, getState());
  enterRule(_localctx, 424, SV3_1aParser::RuleConcurrent_assertion_item);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(4184);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 435, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(4180);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (((((_la - 326) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 326)) & 4672924483589) != 0)) {
        setState(4177);
        identifier();
        setState(4178);
        match(SV3_1aParser::COLON);
      }
      setState(4182);
      concurrent_assertion_statement();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(4183);
      checker_instantiation();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Concurrent_assertion_statementContext ------------------------------------------------------------------

SV3_1aParser::Concurrent_assertion_statementContext::Concurrent_assertion_statementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::Assert_property_statementContext* SV3_1aParser::Concurrent_assertion_statementContext::assert_property_statement() {
  return getRuleContext<SV3_1aParser::Assert_property_statementContext>(0);
}

SV3_1aParser::Assume_property_statementContext* SV3_1aParser::Concurrent_assertion_statementContext::assume_property_statement() {
  return getRuleContext<SV3_1aParser::Assume_property_statementContext>(0);
}

SV3_1aParser::Cover_property_statementContext* SV3_1aParser::Concurrent_assertion_statementContext::cover_property_statement() {
  return getRuleContext<SV3_1aParser::Cover_property_statementContext>(0);
}

SV3_1aParser::Cover_sequence_statementContext* SV3_1aParser::Concurrent_assertion_statementContext::cover_sequence_statement() {
  return getRuleContext<SV3_1aParser::Cover_sequence_statementContext>(0);
}

SV3_1aParser::Restrict_property_statementContext* SV3_1aParser::Concurrent_assertion_statementContext::restrict_property_statement() {
  return getRuleContext<SV3_1aParser::Restrict_property_statementContext>(0);
}


size_t SV3_1aParser::Concurrent_assertion_statementContext::getRuleIndex() const {
  return SV3_1aParser::RuleConcurrent_assertion_statement;
}

void SV3_1aParser::Concurrent_assertion_statementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterConcurrent_assertion_statement(this);
}

void SV3_1aParser::Concurrent_assertion_statementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitConcurrent_assertion_statement(this);
}

SV3_1aParser::Concurrent_assertion_statementContext* SV3_1aParser::concurrent_assertion_statement() {
  Concurrent_assertion_statementContext *_localctx = _tracker.createInstance<Concurrent_assertion_statementContext>(_ctx, getState());
  enterRule(_localctx, 426, SV3_1aParser::RuleConcurrent_assertion_statement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(4191);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 436, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(4186);
      assert_property_statement();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(4187);
      assume_property_statement();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(4188);
      cover_property_statement();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(4189);
      cover_sequence_statement();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(4190);
      restrict_property_statement();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Assert_property_statementContext ------------------------------------------------------------------

SV3_1aParser::Assert_property_statementContext::Assert_property_statementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Assert_property_statementContext::ASSERT() {
  return getToken(SV3_1aParser::ASSERT, 0);
}

tree::TerminalNode* SV3_1aParser::Assert_property_statementContext::PROPERTY() {
  return getToken(SV3_1aParser::PROPERTY, 0);
}

tree::TerminalNode* SV3_1aParser::Assert_property_statementContext::OPEN_PARENS() {
  return getToken(SV3_1aParser::OPEN_PARENS, 0);
}

SV3_1aParser::Property_specContext* SV3_1aParser::Assert_property_statementContext::property_spec() {
  return getRuleContext<SV3_1aParser::Property_specContext>(0);
}

tree::TerminalNode* SV3_1aParser::Assert_property_statementContext::CLOSE_PARENS() {
  return getToken(SV3_1aParser::CLOSE_PARENS, 0);
}

SV3_1aParser::Action_blockContext* SV3_1aParser::Assert_property_statementContext::action_block() {
  return getRuleContext<SV3_1aParser::Action_blockContext>(0);
}


size_t SV3_1aParser::Assert_property_statementContext::getRuleIndex() const {
  return SV3_1aParser::RuleAssert_property_statement;
}

void SV3_1aParser::Assert_property_statementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAssert_property_statement(this);
}

void SV3_1aParser::Assert_property_statementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAssert_property_statement(this);
}

SV3_1aParser::Assert_property_statementContext* SV3_1aParser::assert_property_statement() {
  Assert_property_statementContext *_localctx = _tracker.createInstance<Assert_property_statementContext>(_ctx, getState());
  enterRule(_localctx, 428, SV3_1aParser::RuleAssert_property_statement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4193);
    match(SV3_1aParser::ASSERT);
    setState(4194);
    match(SV3_1aParser::PROPERTY);
    setState(4195);
    match(SV3_1aParser::OPEN_PARENS);
    setState(4196);
    property_spec();
    setState(4197);
    match(SV3_1aParser::CLOSE_PARENS);
    setState(4198);
    action_block();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Assume_property_statementContext ------------------------------------------------------------------

SV3_1aParser::Assume_property_statementContext::Assume_property_statementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Assume_property_statementContext::ASSUME() {
  return getToken(SV3_1aParser::ASSUME, 0);
}

tree::TerminalNode* SV3_1aParser::Assume_property_statementContext::PROPERTY() {
  return getToken(SV3_1aParser::PROPERTY, 0);
}

tree::TerminalNode* SV3_1aParser::Assume_property_statementContext::OPEN_PARENS() {
  return getToken(SV3_1aParser::OPEN_PARENS, 0);
}

SV3_1aParser::Property_specContext* SV3_1aParser::Assume_property_statementContext::property_spec() {
  return getRuleContext<SV3_1aParser::Property_specContext>(0);
}

tree::TerminalNode* SV3_1aParser::Assume_property_statementContext::CLOSE_PARENS() {
  return getToken(SV3_1aParser::CLOSE_PARENS, 0);
}

SV3_1aParser::Action_blockContext* SV3_1aParser::Assume_property_statementContext::action_block() {
  return getRuleContext<SV3_1aParser::Action_blockContext>(0);
}


size_t SV3_1aParser::Assume_property_statementContext::getRuleIndex() const {
  return SV3_1aParser::RuleAssume_property_statement;
}

void SV3_1aParser::Assume_property_statementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAssume_property_statement(this);
}

void SV3_1aParser::Assume_property_statementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAssume_property_statement(this);
}

SV3_1aParser::Assume_property_statementContext* SV3_1aParser::assume_property_statement() {
  Assume_property_statementContext *_localctx = _tracker.createInstance<Assume_property_statementContext>(_ctx, getState());
  enterRule(_localctx, 430, SV3_1aParser::RuleAssume_property_statement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4200);
    match(SV3_1aParser::ASSUME);
    setState(4201);
    match(SV3_1aParser::PROPERTY);
    setState(4202);
    match(SV3_1aParser::OPEN_PARENS);
    setState(4203);
    property_spec();
    setState(4204);
    match(SV3_1aParser::CLOSE_PARENS);
    setState(4205);
    action_block();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Cover_property_statementContext ------------------------------------------------------------------

SV3_1aParser::Cover_property_statementContext::Cover_property_statementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Cover_property_statementContext::COVER() {
  return getToken(SV3_1aParser::COVER, 0);
}

tree::TerminalNode* SV3_1aParser::Cover_property_statementContext::PROPERTY() {
  return getToken(SV3_1aParser::PROPERTY, 0);
}

tree::TerminalNode* SV3_1aParser::Cover_property_statementContext::OPEN_PARENS() {
  return getToken(SV3_1aParser::OPEN_PARENS, 0);
}

SV3_1aParser::Property_specContext* SV3_1aParser::Cover_property_statementContext::property_spec() {
  return getRuleContext<SV3_1aParser::Property_specContext>(0);
}

tree::TerminalNode* SV3_1aParser::Cover_property_statementContext::CLOSE_PARENS() {
  return getToken(SV3_1aParser::CLOSE_PARENS, 0);
}

SV3_1aParser::Statement_or_nullContext* SV3_1aParser::Cover_property_statementContext::statement_or_null() {
  return getRuleContext<SV3_1aParser::Statement_or_nullContext>(0);
}


size_t SV3_1aParser::Cover_property_statementContext::getRuleIndex() const {
  return SV3_1aParser::RuleCover_property_statement;
}

void SV3_1aParser::Cover_property_statementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCover_property_statement(this);
}

void SV3_1aParser::Cover_property_statementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCover_property_statement(this);
}

SV3_1aParser::Cover_property_statementContext* SV3_1aParser::cover_property_statement() {
  Cover_property_statementContext *_localctx = _tracker.createInstance<Cover_property_statementContext>(_ctx, getState());
  enterRule(_localctx, 432, SV3_1aParser::RuleCover_property_statement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4207);
    match(SV3_1aParser::COVER);
    setState(4208);
    match(SV3_1aParser::PROPERTY);
    setState(4209);
    match(SV3_1aParser::OPEN_PARENS);
    setState(4210);
    property_spec();
    setState(4211);
    match(SV3_1aParser::CLOSE_PARENS);
    setState(4212);
    statement_or_null();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Expect_property_statementContext ------------------------------------------------------------------

SV3_1aParser::Expect_property_statementContext::Expect_property_statementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Expect_property_statementContext::EXPECT() {
  return getToken(SV3_1aParser::EXPECT, 0);
}

tree::TerminalNode* SV3_1aParser::Expect_property_statementContext::OPEN_PARENS() {
  return getToken(SV3_1aParser::OPEN_PARENS, 0);
}

SV3_1aParser::Property_specContext* SV3_1aParser::Expect_property_statementContext::property_spec() {
  return getRuleContext<SV3_1aParser::Property_specContext>(0);
}

tree::TerminalNode* SV3_1aParser::Expect_property_statementContext::CLOSE_PARENS() {
  return getToken(SV3_1aParser::CLOSE_PARENS, 0);
}

SV3_1aParser::Action_blockContext* SV3_1aParser::Expect_property_statementContext::action_block() {
  return getRuleContext<SV3_1aParser::Action_blockContext>(0);
}


size_t SV3_1aParser::Expect_property_statementContext::getRuleIndex() const {
  return SV3_1aParser::RuleExpect_property_statement;
}

void SV3_1aParser::Expect_property_statementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExpect_property_statement(this);
}

void SV3_1aParser::Expect_property_statementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExpect_property_statement(this);
}

SV3_1aParser::Expect_property_statementContext* SV3_1aParser::expect_property_statement() {
  Expect_property_statementContext *_localctx = _tracker.createInstance<Expect_property_statementContext>(_ctx, getState());
  enterRule(_localctx, 434, SV3_1aParser::RuleExpect_property_statement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4214);
    match(SV3_1aParser::EXPECT);
    setState(4215);
    match(SV3_1aParser::OPEN_PARENS);
    setState(4216);
    property_spec();
    setState(4217);
    match(SV3_1aParser::CLOSE_PARENS);
    setState(4218);
    action_block();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Cover_sequence_statementContext ------------------------------------------------------------------

SV3_1aParser::Cover_sequence_statementContext::Cover_sequence_statementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Cover_sequence_statementContext::COVER() {
  return getToken(SV3_1aParser::COVER, 0);
}

tree::TerminalNode* SV3_1aParser::Cover_sequence_statementContext::SEQUENCE() {
  return getToken(SV3_1aParser::SEQUENCE, 0);
}

std::vector<tree::TerminalNode *> SV3_1aParser::Cover_sequence_statementContext::OPEN_PARENS() {
  return getTokens(SV3_1aParser::OPEN_PARENS);
}

tree::TerminalNode* SV3_1aParser::Cover_sequence_statementContext::OPEN_PARENS(size_t i) {
  return getToken(SV3_1aParser::OPEN_PARENS, i);
}

SV3_1aParser::Sequence_exprContext* SV3_1aParser::Cover_sequence_statementContext::sequence_expr() {
  return getRuleContext<SV3_1aParser::Sequence_exprContext>(0);
}

std::vector<tree::TerminalNode *> SV3_1aParser::Cover_sequence_statementContext::CLOSE_PARENS() {
  return getTokens(SV3_1aParser::CLOSE_PARENS);
}

tree::TerminalNode* SV3_1aParser::Cover_sequence_statementContext::CLOSE_PARENS(size_t i) {
  return getToken(SV3_1aParser::CLOSE_PARENS, i);
}

SV3_1aParser::Statement_or_nullContext* SV3_1aParser::Cover_sequence_statementContext::statement_or_null() {
  return getRuleContext<SV3_1aParser::Statement_or_nullContext>(0);
}

SV3_1aParser::Clocking_eventContext* SV3_1aParser::Cover_sequence_statementContext::clocking_event() {
  return getRuleContext<SV3_1aParser::Clocking_eventContext>(0);
}

tree::TerminalNode* SV3_1aParser::Cover_sequence_statementContext::DISABLE() {
  return getToken(SV3_1aParser::DISABLE, 0);
}

tree::TerminalNode* SV3_1aParser::Cover_sequence_statementContext::IFF() {
  return getToken(SV3_1aParser::IFF, 0);
}

SV3_1aParser::Expression_or_distContext* SV3_1aParser::Cover_sequence_statementContext::expression_or_dist() {
  return getRuleContext<SV3_1aParser::Expression_or_distContext>(0);
}


size_t SV3_1aParser::Cover_sequence_statementContext::getRuleIndex() const {
  return SV3_1aParser::RuleCover_sequence_statement;
}

void SV3_1aParser::Cover_sequence_statementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCover_sequence_statement(this);
}

void SV3_1aParser::Cover_sequence_statementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCover_sequence_statement(this);
}

SV3_1aParser::Cover_sequence_statementContext* SV3_1aParser::cover_sequence_statement() {
  Cover_sequence_statementContext *_localctx = _tracker.createInstance<Cover_sequence_statementContext>(_ctx, getState());
  enterRule(_localctx, 436, SV3_1aParser::RuleCover_sequence_statement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4220);
    match(SV3_1aParser::COVER);
    setState(4221);
    match(SV3_1aParser::SEQUENCE);
    setState(4222);
    match(SV3_1aParser::OPEN_PARENS);
    setState(4224);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 437, _ctx)) {
    case 1: {
      setState(4223);
      clocking_event();
      break;
    }

    default:
      break;
    }
    setState(4232);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SV3_1aParser::DISABLE) {
      setState(4226);
      match(SV3_1aParser::DISABLE);
      setState(4227);
      match(SV3_1aParser::IFF);
      setState(4228);
      match(SV3_1aParser::OPEN_PARENS);
      setState(4229);
      expression_or_dist();
      setState(4230);
      match(SV3_1aParser::CLOSE_PARENS);
    }
    setState(4234);
    sequence_expr(0);
    setState(4235);
    match(SV3_1aParser::CLOSE_PARENS);
    setState(4236);
    statement_or_null();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Restrict_property_statementContext ------------------------------------------------------------------

SV3_1aParser::Restrict_property_statementContext::Restrict_property_statementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Restrict_property_statementContext::RESTRICT() {
  return getToken(SV3_1aParser::RESTRICT, 0);
}

tree::TerminalNode* SV3_1aParser::Restrict_property_statementContext::PROPERTY() {
  return getToken(SV3_1aParser::PROPERTY, 0);
}

tree::TerminalNode* SV3_1aParser::Restrict_property_statementContext::OPEN_PARENS() {
  return getToken(SV3_1aParser::OPEN_PARENS, 0);
}

SV3_1aParser::Property_specContext* SV3_1aParser::Restrict_property_statementContext::property_spec() {
  return getRuleContext<SV3_1aParser::Property_specContext>(0);
}

tree::TerminalNode* SV3_1aParser::Restrict_property_statementContext::CLOSE_PARENS() {
  return getToken(SV3_1aParser::CLOSE_PARENS, 0);
}

tree::TerminalNode* SV3_1aParser::Restrict_property_statementContext::SEMICOLON() {
  return getToken(SV3_1aParser::SEMICOLON, 0);
}


size_t SV3_1aParser::Restrict_property_statementContext::getRuleIndex() const {
  return SV3_1aParser::RuleRestrict_property_statement;
}

void SV3_1aParser::Restrict_property_statementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRestrict_property_statement(this);
}

void SV3_1aParser::Restrict_property_statementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRestrict_property_statement(this);
}

SV3_1aParser::Restrict_property_statementContext* SV3_1aParser::restrict_property_statement() {
  Restrict_property_statementContext *_localctx = _tracker.createInstance<Restrict_property_statementContext>(_ctx, getState());
  enterRule(_localctx, 438, SV3_1aParser::RuleRestrict_property_statement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4238);
    match(SV3_1aParser::RESTRICT);
    setState(4239);
    match(SV3_1aParser::PROPERTY);
    setState(4240);
    match(SV3_1aParser::OPEN_PARENS);
    setState(4241);
    property_spec();
    setState(4242);
    match(SV3_1aParser::CLOSE_PARENS);
    setState(4243);
    match(SV3_1aParser::SEMICOLON);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Property_instanceContext ------------------------------------------------------------------

SV3_1aParser::Property_instanceContext::Property_instanceContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::Ps_or_hierarchical_sequence_identifierContext* SV3_1aParser::Property_instanceContext::ps_or_hierarchical_sequence_identifier() {
  return getRuleContext<SV3_1aParser::Ps_or_hierarchical_sequence_identifierContext>(0);
}

tree::TerminalNode* SV3_1aParser::Property_instanceContext::OPEN_PARENS() {
  return getToken(SV3_1aParser::OPEN_PARENS, 0);
}

tree::TerminalNode* SV3_1aParser::Property_instanceContext::CLOSE_PARENS() {
  return getToken(SV3_1aParser::CLOSE_PARENS, 0);
}

SV3_1aParser::Actual_arg_listContext* SV3_1aParser::Property_instanceContext::actual_arg_list() {
  return getRuleContext<SV3_1aParser::Actual_arg_listContext>(0);
}


size_t SV3_1aParser::Property_instanceContext::getRuleIndex() const {
  return SV3_1aParser::RuleProperty_instance;
}

void SV3_1aParser::Property_instanceContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterProperty_instance(this);
}

void SV3_1aParser::Property_instanceContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitProperty_instance(this);
}

SV3_1aParser::Property_instanceContext* SV3_1aParser::property_instance() {
  Property_instanceContext *_localctx = _tracker.createInstance<Property_instanceContext>(_ctx, getState());
  enterRule(_localctx, 440, SV3_1aParser::RuleProperty_instance);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4245);
    ps_or_hierarchical_sequence_identifier();
    setState(4251);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 440, _ctx)) {
    case 1: {
      setState(4246);
      match(SV3_1aParser::OPEN_PARENS);
      setState(4248);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if ((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & 8830454661116) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 64)) & 1152648825725551617) != 0) || ((((_la - 147) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 147)) & 2199527096323) != 0) || _la == SV3_1aParser::BANG || ((((_la - 310) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 310)) & 559537082239254593) != 0)) {
        setState(4247);
        actual_arg_list();
      }
      setState(4250);
      match(SV3_1aParser::CLOSE_PARENS);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Property_actual_argContext ------------------------------------------------------------------

SV3_1aParser::Property_actual_argContext::Property_actual_argContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::Property_exprContext* SV3_1aParser::Property_actual_argContext::property_expr() {
  return getRuleContext<SV3_1aParser::Property_exprContext>(0);
}

SV3_1aParser::Sequence_actual_argContext* SV3_1aParser::Property_actual_argContext::sequence_actual_arg() {
  return getRuleContext<SV3_1aParser::Sequence_actual_argContext>(0);
}


size_t SV3_1aParser::Property_actual_argContext::getRuleIndex() const {
  return SV3_1aParser::RuleProperty_actual_arg;
}

void SV3_1aParser::Property_actual_argContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterProperty_actual_arg(this);
}

void SV3_1aParser::Property_actual_argContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitProperty_actual_arg(this);
}

SV3_1aParser::Property_actual_argContext* SV3_1aParser::property_actual_arg() {
  Property_actual_argContext *_localctx = _tracker.createInstance<Property_actual_argContext>(_ctx, getState());
  enterRule(_localctx, 442, SV3_1aParser::RuleProperty_actual_arg);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(4255);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 441, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(4253);
      property_expr(0);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(4254);
      sequence_actual_arg();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Concurrent_assertion_item_declarationContext ------------------------------------------------------------------

SV3_1aParser::Concurrent_assertion_item_declarationContext::Concurrent_assertion_item_declarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::Property_declarationContext* SV3_1aParser::Concurrent_assertion_item_declarationContext::property_declaration() {
  return getRuleContext<SV3_1aParser::Property_declarationContext>(0);
}

SV3_1aParser::Sequence_declarationContext* SV3_1aParser::Concurrent_assertion_item_declarationContext::sequence_declaration() {
  return getRuleContext<SV3_1aParser::Sequence_declarationContext>(0);
}


size_t SV3_1aParser::Concurrent_assertion_item_declarationContext::getRuleIndex() const {
  return SV3_1aParser::RuleConcurrent_assertion_item_declaration;
}

void SV3_1aParser::Concurrent_assertion_item_declarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterConcurrent_assertion_item_declaration(this);
}

void SV3_1aParser::Concurrent_assertion_item_declarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitConcurrent_assertion_item_declaration(this);
}

SV3_1aParser::Concurrent_assertion_item_declarationContext* SV3_1aParser::concurrent_assertion_item_declaration() {
  Concurrent_assertion_item_declarationContext *_localctx = _tracker.createInstance<Concurrent_assertion_item_declarationContext>(_ctx, getState());
  enterRule(_localctx, 444, SV3_1aParser::RuleConcurrent_assertion_item_declaration);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(4259);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SV3_1aParser::PROPERTY: {
        enterOuterAlt(_localctx, 1);
        setState(4257);
        property_declaration();
        break;
      }

      case SV3_1aParser::SEQUENCE: {
        enterOuterAlt(_localctx, 2);
        setState(4258);
        sequence_declaration();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Assertion_item_declarationContext ------------------------------------------------------------------

SV3_1aParser::Assertion_item_declarationContext::Assertion_item_declarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::Property_declarationContext* SV3_1aParser::Assertion_item_declarationContext::property_declaration() {
  return getRuleContext<SV3_1aParser::Property_declarationContext>(0);
}

SV3_1aParser::Sequence_declarationContext* SV3_1aParser::Assertion_item_declarationContext::sequence_declaration() {
  return getRuleContext<SV3_1aParser::Sequence_declarationContext>(0);
}

SV3_1aParser::Let_declarationContext* SV3_1aParser::Assertion_item_declarationContext::let_declaration() {
  return getRuleContext<SV3_1aParser::Let_declarationContext>(0);
}


size_t SV3_1aParser::Assertion_item_declarationContext::getRuleIndex() const {
  return SV3_1aParser::RuleAssertion_item_declaration;
}

void SV3_1aParser::Assertion_item_declarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAssertion_item_declaration(this);
}

void SV3_1aParser::Assertion_item_declarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAssertion_item_declaration(this);
}

SV3_1aParser::Assertion_item_declarationContext* SV3_1aParser::assertion_item_declaration() {
  Assertion_item_declarationContext *_localctx = _tracker.createInstance<Assertion_item_declarationContext>(_ctx, getState());
  enterRule(_localctx, 446, SV3_1aParser::RuleAssertion_item_declaration);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(4264);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SV3_1aParser::PROPERTY: {
        enterOuterAlt(_localctx, 1);
        setState(4261);
        property_declaration();
        break;
      }

      case SV3_1aParser::SEQUENCE: {
        enterOuterAlt(_localctx, 2);
        setState(4262);
        sequence_declaration();
        break;
      }

      case SV3_1aParser::LET: {
        enterOuterAlt(_localctx, 3);
        setState(4263);
        let_declaration();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Property_declarationContext ------------------------------------------------------------------

SV3_1aParser::Property_declarationContext::Property_declarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Property_declarationContext::PROPERTY() {
  return getToken(SV3_1aParser::PROPERTY, 0);
}

std::vector<SV3_1aParser::IdentifierContext *> SV3_1aParser::Property_declarationContext::identifier() {
  return getRuleContexts<SV3_1aParser::IdentifierContext>();
}

SV3_1aParser::IdentifierContext* SV3_1aParser::Property_declarationContext::identifier(size_t i) {
  return getRuleContext<SV3_1aParser::IdentifierContext>(i);
}

std::vector<tree::TerminalNode *> SV3_1aParser::Property_declarationContext::SEMICOLON() {
  return getTokens(SV3_1aParser::SEMICOLON);
}

tree::TerminalNode* SV3_1aParser::Property_declarationContext::SEMICOLON(size_t i) {
  return getToken(SV3_1aParser::SEMICOLON, i);
}

SV3_1aParser::Property_specContext* SV3_1aParser::Property_declarationContext::property_spec() {
  return getRuleContext<SV3_1aParser::Property_specContext>(0);
}

tree::TerminalNode* SV3_1aParser::Property_declarationContext::ENDPROPERTY() {
  return getToken(SV3_1aParser::ENDPROPERTY, 0);
}

tree::TerminalNode* SV3_1aParser::Property_declarationContext::OPEN_PARENS() {
  return getToken(SV3_1aParser::OPEN_PARENS, 0);
}

tree::TerminalNode* SV3_1aParser::Property_declarationContext::CLOSE_PARENS() {
  return getToken(SV3_1aParser::CLOSE_PARENS, 0);
}

std::vector<SV3_1aParser::Assertion_variable_declarationContext *> SV3_1aParser::Property_declarationContext::assertion_variable_declaration() {
  return getRuleContexts<SV3_1aParser::Assertion_variable_declarationContext>();
}

SV3_1aParser::Assertion_variable_declarationContext* SV3_1aParser::Property_declarationContext::assertion_variable_declaration(size_t i) {
  return getRuleContext<SV3_1aParser::Assertion_variable_declarationContext>(i);
}

tree::TerminalNode* SV3_1aParser::Property_declarationContext::COLON() {
  return getToken(SV3_1aParser::COLON, 0);
}

SV3_1aParser::Property_port_listContext* SV3_1aParser::Property_declarationContext::property_port_list() {
  return getRuleContext<SV3_1aParser::Property_port_listContext>(0);
}


size_t SV3_1aParser::Property_declarationContext::getRuleIndex() const {
  return SV3_1aParser::RuleProperty_declaration;
}

void SV3_1aParser::Property_declarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterProperty_declaration(this);
}

void SV3_1aParser::Property_declarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitProperty_declaration(this);
}

SV3_1aParser::Property_declarationContext* SV3_1aParser::property_declaration() {
  Property_declarationContext *_localctx = _tracker.createInstance<Property_declarationContext>(_ctx, getState());
  enterRule(_localctx, 448, SV3_1aParser::RuleProperty_declaration);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(4266);
    match(SV3_1aParser::PROPERTY);
    setState(4267);
    identifier();
    setState(4273);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SV3_1aParser::OPEN_PARENS) {
      setState(4268);
      match(SV3_1aParser::OPEN_PARENS);
      setState(4270);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == SV3_1aParser::VIRTUAL || ((((_la - 64) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 64)) & 1152775819316199427) != 0) || ((((_la - 147) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 147)) & 144156969517711363) != 0) || ((((_la - 326) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 326)) & 4672924483589) != 0)) {
        setState(4269);
        property_port_list();
      }
      setState(4272);
      match(SV3_1aParser::CLOSE_PARENS);
    }
    setState(4275);
    match(SV3_1aParser::SEMICOLON);
    setState(4279);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 446, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(4276);
        assertion_variable_declaration(); 
      }
      setState(4281);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 446, _ctx);
    }
    setState(4282);
    property_spec();
    setState(4284);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SV3_1aParser::SEMICOLON) {
      setState(4283);
      match(SV3_1aParser::SEMICOLON);
    }
    setState(4286);
    match(SV3_1aParser::ENDPROPERTY);
    setState(4289);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 448, _ctx)) {
    case 1: {
      setState(4287);
      match(SV3_1aParser::COLON);
      setState(4288);
      identifier();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Property_port_listContext ------------------------------------------------------------------

SV3_1aParser::Property_port_listContext::Property_port_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<SV3_1aParser::Property_port_itemContext *> SV3_1aParser::Property_port_listContext::property_port_item() {
  return getRuleContexts<SV3_1aParser::Property_port_itemContext>();
}

SV3_1aParser::Property_port_itemContext* SV3_1aParser::Property_port_listContext::property_port_item(size_t i) {
  return getRuleContext<SV3_1aParser::Property_port_itemContext>(i);
}

std::vector<tree::TerminalNode *> SV3_1aParser::Property_port_listContext::COMMA() {
  return getTokens(SV3_1aParser::COMMA);
}

tree::TerminalNode* SV3_1aParser::Property_port_listContext::COMMA(size_t i) {
  return getToken(SV3_1aParser::COMMA, i);
}


size_t SV3_1aParser::Property_port_listContext::getRuleIndex() const {
  return SV3_1aParser::RuleProperty_port_list;
}

void SV3_1aParser::Property_port_listContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterProperty_port_list(this);
}

void SV3_1aParser::Property_port_listContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitProperty_port_list(this);
}

SV3_1aParser::Property_port_listContext* SV3_1aParser::property_port_list() {
  Property_port_listContext *_localctx = _tracker.createInstance<Property_port_listContext>(_ctx, getState());
  enterRule(_localctx, 450, SV3_1aParser::RuleProperty_port_list);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4291);
    property_port_item();
    setState(4296);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == SV3_1aParser::COMMA) {
      setState(4292);
      match(SV3_1aParser::COMMA);
      setState(4293);
      property_port_item();
      setState(4298);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Property_port_itemContext ------------------------------------------------------------------

SV3_1aParser::Property_port_itemContext::Property_port_itemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::Property_formal_typeContext* SV3_1aParser::Property_port_itemContext::property_formal_type() {
  return getRuleContext<SV3_1aParser::Property_formal_typeContext>(0);
}

SV3_1aParser::IdentifierContext* SV3_1aParser::Property_port_itemContext::identifier() {
  return getRuleContext<SV3_1aParser::IdentifierContext>(0);
}

std::vector<SV3_1aParser::Attribute_instanceContext *> SV3_1aParser::Property_port_itemContext::attribute_instance() {
  return getRuleContexts<SV3_1aParser::Attribute_instanceContext>();
}

SV3_1aParser::Attribute_instanceContext* SV3_1aParser::Property_port_itemContext::attribute_instance(size_t i) {
  return getRuleContext<SV3_1aParser::Attribute_instanceContext>(i);
}

tree::TerminalNode* SV3_1aParser::Property_port_itemContext::LOCAL() {
  return getToken(SV3_1aParser::LOCAL, 0);
}

std::vector<SV3_1aParser::Variable_dimensionContext *> SV3_1aParser::Property_port_itemContext::variable_dimension() {
  return getRuleContexts<SV3_1aParser::Variable_dimensionContext>();
}

SV3_1aParser::Variable_dimensionContext* SV3_1aParser::Property_port_itemContext::variable_dimension(size_t i) {
  return getRuleContext<SV3_1aParser::Variable_dimensionContext>(i);
}

tree::TerminalNode* SV3_1aParser::Property_port_itemContext::ASSIGN_OP() {
  return getToken(SV3_1aParser::ASSIGN_OP, 0);
}

SV3_1aParser::Property_actual_argContext* SV3_1aParser::Property_port_itemContext::property_actual_arg() {
  return getRuleContext<SV3_1aParser::Property_actual_argContext>(0);
}

SV3_1aParser::Property_lvar_port_directionContext* SV3_1aParser::Property_port_itemContext::property_lvar_port_direction() {
  return getRuleContext<SV3_1aParser::Property_lvar_port_directionContext>(0);
}


size_t SV3_1aParser::Property_port_itemContext::getRuleIndex() const {
  return SV3_1aParser::RuleProperty_port_item;
}

void SV3_1aParser::Property_port_itemContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterProperty_port_item(this);
}

void SV3_1aParser::Property_port_itemContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitProperty_port_item(this);
}

SV3_1aParser::Property_port_itemContext* SV3_1aParser::property_port_item() {
  Property_port_itemContext *_localctx = _tracker.createInstance<Property_port_itemContext>(_ctx, getState());
  enterRule(_localctx, 452, SV3_1aParser::RuleProperty_port_item);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4302);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == SV3_1aParser::OPEN_PARENS_STAR) {
      setState(4299);
      attribute_instance();
      setState(4304);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(4309);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SV3_1aParser::LOCAL) {
      setState(4305);
      match(SV3_1aParser::LOCAL);
      setState(4307);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == SV3_1aParser::INPUT) {
        setState(4306);
        property_lvar_port_direction();
      }
    }
    setState(4311);
    property_formal_type();
    setState(4312);
    identifier();
    setState(4316);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == SV3_1aParser::ASSOCIATIVE_UNSPECIFIED || _la == SV3_1aParser::OPEN_BRACKET) {
      setState(4313);
      variable_dimension();
      setState(4318);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(4321);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SV3_1aParser::ASSIGN_OP) {
      setState(4319);
      match(SV3_1aParser::ASSIGN_OP);
      setState(4320);
      property_actual_arg();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Property_lvar_port_directionContext ------------------------------------------------------------------

SV3_1aParser::Property_lvar_port_directionContext::Property_lvar_port_directionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Property_lvar_port_directionContext::INPUT() {
  return getToken(SV3_1aParser::INPUT, 0);
}


size_t SV3_1aParser::Property_lvar_port_directionContext::getRuleIndex() const {
  return SV3_1aParser::RuleProperty_lvar_port_direction;
}

void SV3_1aParser::Property_lvar_port_directionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterProperty_lvar_port_direction(this);
}

void SV3_1aParser::Property_lvar_port_directionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitProperty_lvar_port_direction(this);
}

SV3_1aParser::Property_lvar_port_directionContext* SV3_1aParser::property_lvar_port_direction() {
  Property_lvar_port_directionContext *_localctx = _tracker.createInstance<Property_lvar_port_directionContext>(_ctx, getState());
  enterRule(_localctx, 454, SV3_1aParser::RuleProperty_lvar_port_direction);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4323);
    match(SV3_1aParser::INPUT);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Property_formal_typeContext ------------------------------------------------------------------

SV3_1aParser::Property_formal_typeContext::Property_formal_typeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::Sequence_formal_typeContext* SV3_1aParser::Property_formal_typeContext::sequence_formal_type() {
  return getRuleContext<SV3_1aParser::Sequence_formal_typeContext>(0);
}

tree::TerminalNode* SV3_1aParser::Property_formal_typeContext::PROPERTY() {
  return getToken(SV3_1aParser::PROPERTY, 0);
}


size_t SV3_1aParser::Property_formal_typeContext::getRuleIndex() const {
  return SV3_1aParser::RuleProperty_formal_type;
}

void SV3_1aParser::Property_formal_typeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterProperty_formal_type(this);
}

void SV3_1aParser::Property_formal_typeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitProperty_formal_type(this);
}

SV3_1aParser::Property_formal_typeContext* SV3_1aParser::property_formal_type() {
  Property_formal_typeContext *_localctx = _tracker.createInstance<Property_formal_typeContext>(_ctx, getState());
  enterRule(_localctx, 456, SV3_1aParser::RuleProperty_formal_type);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(4327);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SV3_1aParser::VIRTUAL:
      case SV3_1aParser::TYPE:
      case SV3_1aParser::UNTYPED:
      case SV3_1aParser::ENUM:
      case SV3_1aParser::STRUCT:
      case SV3_1aParser::UNION:
      case SV3_1aParser::STRING:
      case SV3_1aParser::CHANDLE:
      case SV3_1aParser::EVENT:
      case SV3_1aParser::OPEN_BRACKET:
      case SV3_1aParser::BYTE:
      case SV3_1aParser::SHORTINT:
      case SV3_1aParser::INT:
      case SV3_1aParser::LONGINT:
      case SV3_1aParser::INTEGER:
      case SV3_1aParser::TIME:
      case SV3_1aParser::BIT:
      case SV3_1aParser::LOGIC:
      case SV3_1aParser::REG:
      case SV3_1aParser::SHORTREAL:
      case SV3_1aParser::REAL:
      case SV3_1aParser::REALTIME:
      case SV3_1aParser::SIGNED:
      case SV3_1aParser::UNSIGNED:
      case SV3_1aParser::DOLLAR_UNIT:
      case SV3_1aParser::SEQUENCE:
      case SV3_1aParser::THIS:
      case SV3_1aParser::RANDOMIZE:
      case SV3_1aParser::SAMPLE:
      case SV3_1aParser::Escaped_identifier:
      case SV3_1aParser::Simple_identifier: {
        enterOuterAlt(_localctx, 1);
        setState(4325);
        sequence_formal_type();
        break;
      }

      case SV3_1aParser::PROPERTY: {
        enterOuterAlt(_localctx, 2);
        setState(4326);
        match(SV3_1aParser::PROPERTY);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Property_specContext ------------------------------------------------------------------

SV3_1aParser::Property_specContext::Property_specContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::Property_exprContext* SV3_1aParser::Property_specContext::property_expr() {
  return getRuleContext<SV3_1aParser::Property_exprContext>(0);
}

SV3_1aParser::Clocking_eventContext* SV3_1aParser::Property_specContext::clocking_event() {
  return getRuleContext<SV3_1aParser::Clocking_eventContext>(0);
}

tree::TerminalNode* SV3_1aParser::Property_specContext::DISABLE() {
  return getToken(SV3_1aParser::DISABLE, 0);
}

tree::TerminalNode* SV3_1aParser::Property_specContext::IFF() {
  return getToken(SV3_1aParser::IFF, 0);
}

tree::TerminalNode* SV3_1aParser::Property_specContext::OPEN_PARENS() {
  return getToken(SV3_1aParser::OPEN_PARENS, 0);
}

SV3_1aParser::Expression_or_distContext* SV3_1aParser::Property_specContext::expression_or_dist() {
  return getRuleContext<SV3_1aParser::Expression_or_distContext>(0);
}

tree::TerminalNode* SV3_1aParser::Property_specContext::CLOSE_PARENS() {
  return getToken(SV3_1aParser::CLOSE_PARENS, 0);
}


size_t SV3_1aParser::Property_specContext::getRuleIndex() const {
  return SV3_1aParser::RuleProperty_spec;
}

void SV3_1aParser::Property_specContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterProperty_spec(this);
}

void SV3_1aParser::Property_specContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitProperty_spec(this);
}

SV3_1aParser::Property_specContext* SV3_1aParser::property_spec() {
  Property_specContext *_localctx = _tracker.createInstance<Property_specContext>(_ctx, getState());
  enterRule(_localctx, 458, SV3_1aParser::RuleProperty_spec);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4330);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 456, _ctx)) {
    case 1: {
      setState(4329);
      clocking_event();
      break;
    }

    default:
      break;
    }
    setState(4338);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SV3_1aParser::DISABLE) {
      setState(4332);
      match(SV3_1aParser::DISABLE);
      setState(4333);
      match(SV3_1aParser::IFF);
      setState(4334);
      match(SV3_1aParser::OPEN_PARENS);
      setState(4335);
      expression_or_dist();
      setState(4336);
      match(SV3_1aParser::CLOSE_PARENS);
    }
    setState(4340);
    property_expr(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Property_exprContext ------------------------------------------------------------------

SV3_1aParser::Property_exprContext::Property_exprContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::Sequence_exprContext* SV3_1aParser::Property_exprContext::sequence_expr() {
  return getRuleContext<SV3_1aParser::Sequence_exprContext>(0);
}

tree::TerminalNode* SV3_1aParser::Property_exprContext::STRONG() {
  return getToken(SV3_1aParser::STRONG, 0);
}

tree::TerminalNode* SV3_1aParser::Property_exprContext::OPEN_PARENS() {
  return getToken(SV3_1aParser::OPEN_PARENS, 0);
}

tree::TerminalNode* SV3_1aParser::Property_exprContext::CLOSE_PARENS() {
  return getToken(SV3_1aParser::CLOSE_PARENS, 0);
}

tree::TerminalNode* SV3_1aParser::Property_exprContext::WEAK() {
  return getToken(SV3_1aParser::WEAK, 0);
}

std::vector<SV3_1aParser::Property_exprContext *> SV3_1aParser::Property_exprContext::property_expr() {
  return getRuleContexts<SV3_1aParser::Property_exprContext>();
}

SV3_1aParser::Property_exprContext* SV3_1aParser::Property_exprContext::property_expr(size_t i) {
  return getRuleContext<SV3_1aParser::Property_exprContext>(i);
}

tree::TerminalNode* SV3_1aParser::Property_exprContext::NOT() {
  return getToken(SV3_1aParser::NOT, 0);
}

tree::TerminalNode* SV3_1aParser::Property_exprContext::OVERLAP_IMPLY() {
  return getToken(SV3_1aParser::OVERLAP_IMPLY, 0);
}

tree::TerminalNode* SV3_1aParser::Property_exprContext::NON_OVERLAP_IMPLY() {
  return getToken(SV3_1aParser::NON_OVERLAP_IMPLY, 0);
}

tree::TerminalNode* SV3_1aParser::Property_exprContext::IF() {
  return getToken(SV3_1aParser::IF, 0);
}

SV3_1aParser::Expression_or_distContext* SV3_1aParser::Property_exprContext::expression_or_dist() {
  return getRuleContext<SV3_1aParser::Expression_or_distContext>(0);
}

tree::TerminalNode* SV3_1aParser::Property_exprContext::ELSE() {
  return getToken(SV3_1aParser::ELSE, 0);
}

tree::TerminalNode* SV3_1aParser::Property_exprContext::CASE() {
  return getToken(SV3_1aParser::CASE, 0);
}

std::vector<SV3_1aParser::Property_case_itemContext *> SV3_1aParser::Property_exprContext::property_case_item() {
  return getRuleContexts<SV3_1aParser::Property_case_itemContext>();
}

SV3_1aParser::Property_case_itemContext* SV3_1aParser::Property_exprContext::property_case_item(size_t i) {
  return getRuleContext<SV3_1aParser::Property_case_itemContext>(i);
}

tree::TerminalNode* SV3_1aParser::Property_exprContext::ENDCASE() {
  return getToken(SV3_1aParser::ENDCASE, 0);
}

tree::TerminalNode* SV3_1aParser::Property_exprContext::OVERLAPPED() {
  return getToken(SV3_1aParser::OVERLAPPED, 0);
}

tree::TerminalNode* SV3_1aParser::Property_exprContext::NONOVERLAPPED() {
  return getToken(SV3_1aParser::NONOVERLAPPED, 0);
}

tree::TerminalNode* SV3_1aParser::Property_exprContext::NEXTTIME() {
  return getToken(SV3_1aParser::NEXTTIME, 0);
}

tree::TerminalNode* SV3_1aParser::Property_exprContext::OPEN_BRACKET() {
  return getToken(SV3_1aParser::OPEN_BRACKET, 0);
}

SV3_1aParser::Constant_expressionContext* SV3_1aParser::Property_exprContext::constant_expression() {
  return getRuleContext<SV3_1aParser::Constant_expressionContext>(0);
}

tree::TerminalNode* SV3_1aParser::Property_exprContext::CLOSE_BRACKET() {
  return getToken(SV3_1aParser::CLOSE_BRACKET, 0);
}

tree::TerminalNode* SV3_1aParser::Property_exprContext::S_NEXTTIME() {
  return getToken(SV3_1aParser::S_NEXTTIME, 0);
}

tree::TerminalNode* SV3_1aParser::Property_exprContext::ALWAYS() {
  return getToken(SV3_1aParser::ALWAYS, 0);
}

SV3_1aParser::Cycle_delay_const_range_expressionContext* SV3_1aParser::Property_exprContext::cycle_delay_const_range_expression() {
  return getRuleContext<SV3_1aParser::Cycle_delay_const_range_expressionContext>(0);
}

tree::TerminalNode* SV3_1aParser::Property_exprContext::S_ALWAYS() {
  return getToken(SV3_1aParser::S_ALWAYS, 0);
}

SV3_1aParser::Constant_rangeContext* SV3_1aParser::Property_exprContext::constant_range() {
  return getRuleContext<SV3_1aParser::Constant_rangeContext>(0);
}

tree::TerminalNode* SV3_1aParser::Property_exprContext::S_EVENTUALLY() {
  return getToken(SV3_1aParser::S_EVENTUALLY, 0);
}

tree::TerminalNode* SV3_1aParser::Property_exprContext::EVENTUALLY() {
  return getToken(SV3_1aParser::EVENTUALLY, 0);
}

tree::TerminalNode* SV3_1aParser::Property_exprContext::ACCEPT_ON() {
  return getToken(SV3_1aParser::ACCEPT_ON, 0);
}

tree::TerminalNode* SV3_1aParser::Property_exprContext::REJECT_ON() {
  return getToken(SV3_1aParser::REJECT_ON, 0);
}

tree::TerminalNode* SV3_1aParser::Property_exprContext::SYNC_ACCEPT_ON() {
  return getToken(SV3_1aParser::SYNC_ACCEPT_ON, 0);
}

tree::TerminalNode* SV3_1aParser::Property_exprContext::SYNC_REJECT_ON() {
  return getToken(SV3_1aParser::SYNC_REJECT_ON, 0);
}

SV3_1aParser::Property_instanceContext* SV3_1aParser::Property_exprContext::property_instance() {
  return getRuleContext<SV3_1aParser::Property_instanceContext>(0);
}

SV3_1aParser::Clocking_eventContext* SV3_1aParser::Property_exprContext::clocking_event() {
  return getRuleContext<SV3_1aParser::Clocking_eventContext>(0);
}

tree::TerminalNode* SV3_1aParser::Property_exprContext::OR() {
  return getToken(SV3_1aParser::OR, 0);
}

tree::TerminalNode* SV3_1aParser::Property_exprContext::AND() {
  return getToken(SV3_1aParser::AND, 0);
}

tree::TerminalNode* SV3_1aParser::Property_exprContext::UNTIL() {
  return getToken(SV3_1aParser::UNTIL, 0);
}

tree::TerminalNode* SV3_1aParser::Property_exprContext::S_UNTIL() {
  return getToken(SV3_1aParser::S_UNTIL, 0);
}

tree::TerminalNode* SV3_1aParser::Property_exprContext::UNTIL_WITH() {
  return getToken(SV3_1aParser::UNTIL_WITH, 0);
}

tree::TerminalNode* SV3_1aParser::Property_exprContext::S_UNTIL_WITH() {
  return getToken(SV3_1aParser::S_UNTIL_WITH, 0);
}

tree::TerminalNode* SV3_1aParser::Property_exprContext::IMPLIES() {
  return getToken(SV3_1aParser::IMPLIES, 0);
}

tree::TerminalNode* SV3_1aParser::Property_exprContext::IFF() {
  return getToken(SV3_1aParser::IFF, 0);
}


size_t SV3_1aParser::Property_exprContext::getRuleIndex() const {
  return SV3_1aParser::RuleProperty_expr;
}

void SV3_1aParser::Property_exprContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterProperty_expr(this);
}

void SV3_1aParser::Property_exprContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitProperty_expr(this);
}


SV3_1aParser::Property_exprContext* SV3_1aParser::property_expr() {
   return property_expr(0);
}

SV3_1aParser::Property_exprContext* SV3_1aParser::property_expr(int precedence) {
  ParserRuleContext *parentContext = _ctx;
  size_t parentState = getState();
  SV3_1aParser::Property_exprContext *_localctx = _tracker.createInstance<Property_exprContext>(_ctx, parentState);
  SV3_1aParser::Property_exprContext *previousContext = _localctx;
  (void)previousContext; // Silence compiler, in case the context is not used by generated code.
  size_t startState = 460;
  enterRecursionRule(_localctx, 460, SV3_1aParser::RuleProperty_expr, precedence);

    size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    unrollRecursionContexts(parentContext);
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(4470);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 460, _ctx)) {
    case 1: {
      setState(4343);
      sequence_expr(0);
      break;
    }

    case 2: {
      setState(4344);
      match(SV3_1aParser::STRONG);
      setState(4345);
      match(SV3_1aParser::OPEN_PARENS);
      setState(4346);
      sequence_expr(0);
      setState(4347);
      match(SV3_1aParser::CLOSE_PARENS);
      break;
    }

    case 3: {
      setState(4349);
      match(SV3_1aParser::WEAK);
      setState(4350);
      match(SV3_1aParser::OPEN_PARENS);
      setState(4351);
      sequence_expr(0);
      setState(4352);
      match(SV3_1aParser::CLOSE_PARENS);
      break;
    }

    case 4: {
      setState(4354);
      match(SV3_1aParser::OPEN_PARENS);
      setState(4355);
      property_expr(0);
      setState(4356);
      match(SV3_1aParser::CLOSE_PARENS);
      break;
    }

    case 5: {
      setState(4358);
      match(SV3_1aParser::NOT);
      setState(4359);
      property_expr(31);
      break;
    }

    case 6: {
      setState(4360);
      sequence_expr(0);
      setState(4361);
      match(SV3_1aParser::OVERLAP_IMPLY);
      setState(4362);
      property_expr(28);
      break;
    }

    case 7: {
      setState(4364);
      sequence_expr(0);
      setState(4365);
      match(SV3_1aParser::NON_OVERLAP_IMPLY);
      setState(4366);
      property_expr(27);
      break;
    }

    case 8: {
      setState(4368);
      match(SV3_1aParser::IF);
      setState(4369);
      match(SV3_1aParser::OPEN_PARENS);
      setState(4370);
      expression_or_dist();
      setState(4371);
      match(SV3_1aParser::CLOSE_PARENS);
      setState(4372);
      property_expr(0);
      setState(4375);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 458, _ctx)) {
      case 1: {
        setState(4373);
        match(SV3_1aParser::ELSE);
        setState(4374);
        property_expr(0);
        break;
      }

      default:
        break;
      }
      break;
    }

    case 9: {
      setState(4377);
      match(SV3_1aParser::CASE);
      setState(4378);
      match(SV3_1aParser::OPEN_PARENS);
      setState(4379);
      expression_or_dist();
      setState(4380);
      match(SV3_1aParser::CLOSE_PARENS);
      setState(4381);
      property_case_item();
      setState(4385);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while ((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & 8864814399484) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 64)) & 1152648825725551617) != 0) || ((((_la - 147) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 147)) & 2199527096323) != 0) || _la == SV3_1aParser::BANG || ((((_la - 310) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 310)) & 559537073624154177) != 0)) {
        setState(4382);
        property_case_item();
        setState(4387);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(4388);
      match(SV3_1aParser::ENDCASE);
      break;
    }

    case 10: {
      setState(4390);
      sequence_expr(0);
      setState(4391);
      match(SV3_1aParser::OVERLAPPED);
      setState(4392);
      property_expr(24);
      break;
    }

    case 11: {
      setState(4394);
      sequence_expr(0);
      setState(4395);
      match(SV3_1aParser::NONOVERLAPPED);
      setState(4396);
      property_expr(23);
      break;
    }

    case 12: {
      setState(4398);
      match(SV3_1aParser::NEXTTIME);
      setState(4399);
      property_expr(22);
      break;
    }

    case 13: {
      setState(4400);
      match(SV3_1aParser::NEXTTIME);
      setState(4401);
      match(SV3_1aParser::OPEN_BRACKET);
      setState(4402);
      constant_expression(0);
      setState(4403);
      match(SV3_1aParser::CLOSE_BRACKET);
      setState(4404);
      property_expr(21);
      break;
    }

    case 14: {
      setState(4406);
      match(SV3_1aParser::S_NEXTTIME);
      setState(4407);
      property_expr(20);
      break;
    }

    case 15: {
      setState(4408);
      match(SV3_1aParser::S_NEXTTIME);
      setState(4409);
      match(SV3_1aParser::OPEN_BRACKET);
      setState(4410);
      constant_expression(0);
      setState(4411);
      match(SV3_1aParser::CLOSE_BRACKET);
      setState(4412);
      property_expr(19);
      break;
    }

    case 16: {
      setState(4414);
      match(SV3_1aParser::ALWAYS);
      setState(4415);
      property_expr(18);
      break;
    }

    case 17: {
      setState(4416);
      match(SV3_1aParser::ALWAYS);
      setState(4417);
      match(SV3_1aParser::OPEN_BRACKET);
      setState(4418);
      cycle_delay_const_range_expression();
      setState(4419);
      match(SV3_1aParser::CLOSE_BRACKET);
      setState(4420);
      property_expr(17);
      break;
    }

    case 18: {
      setState(4422);
      match(SV3_1aParser::S_ALWAYS);
      setState(4423);
      match(SV3_1aParser::OPEN_BRACKET);
      setState(4424);
      constant_range();
      setState(4425);
      match(SV3_1aParser::CLOSE_BRACKET);
      setState(4426);
      property_expr(16);
      break;
    }

    case 19: {
      setState(4428);
      match(SV3_1aParser::S_EVENTUALLY);
      setState(4429);
      property_expr(15);
      break;
    }

    case 20: {
      setState(4430);
      match(SV3_1aParser::EVENTUALLY);
      setState(4431);
      match(SV3_1aParser::OPEN_BRACKET);
      setState(4432);
      constant_range();
      setState(4433);
      match(SV3_1aParser::CLOSE_BRACKET);
      setState(4434);
      property_expr(14);
      break;
    }

    case 21: {
      setState(4436);
      match(SV3_1aParser::S_EVENTUALLY);
      setState(4437);
      match(SV3_1aParser::OPEN_BRACKET);
      setState(4438);
      cycle_delay_const_range_expression();
      setState(4439);
      match(SV3_1aParser::CLOSE_BRACKET);
      setState(4440);
      property_expr(13);
      break;
    }

    case 22: {
      setState(4442);
      match(SV3_1aParser::ACCEPT_ON);
      setState(4443);
      match(SV3_1aParser::OPEN_PARENS);
      setState(4444);
      expression_or_dist();
      setState(4445);
      match(SV3_1aParser::CLOSE_PARENS);
      setState(4446);
      property_expr(6);
      break;
    }

    case 23: {
      setState(4448);
      match(SV3_1aParser::REJECT_ON);
      setState(4449);
      match(SV3_1aParser::OPEN_PARENS);
      setState(4450);
      expression_or_dist();
      setState(4451);
      match(SV3_1aParser::CLOSE_PARENS);
      setState(4452);
      property_expr(5);
      break;
    }

    case 24: {
      setState(4454);
      match(SV3_1aParser::SYNC_ACCEPT_ON);
      setState(4455);
      match(SV3_1aParser::OPEN_PARENS);
      setState(4456);
      expression_or_dist();
      setState(4457);
      match(SV3_1aParser::CLOSE_PARENS);
      setState(4458);
      property_expr(4);
      break;
    }

    case 25: {
      setState(4460);
      match(SV3_1aParser::SYNC_REJECT_ON);
      setState(4461);
      match(SV3_1aParser::OPEN_PARENS);
      setState(4462);
      expression_or_dist();
      setState(4463);
      match(SV3_1aParser::CLOSE_PARENS);
      setState(4464);
      property_expr(3);
      break;
    }

    case 26: {
      setState(4466);
      property_instance();
      break;
    }

    case 27: {
      setState(4467);
      clocking_event();
      setState(4468);
      property_expr(1);
      break;
    }

    default:
      break;
    }
    _ctx->stop = _input->LT(-1);
    setState(4498);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 462, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        if (!_parseListeners.empty())
          triggerExitRuleEvent();
        previousContext = _localctx;
        setState(4496);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 461, _ctx)) {
        case 1: {
          _localctx = _tracker.createInstance<Property_exprContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleProperty_expr);
          setState(4472);

          if (!(precpred(_ctx, 30))) throw FailedPredicateException(this, "precpred(_ctx, 30)");
          setState(4473);
          match(SV3_1aParser::OR);
          setState(4474);
          property_expr(31);
          break;
        }

        case 2: {
          _localctx = _tracker.createInstance<Property_exprContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleProperty_expr);
          setState(4475);

          if (!(precpred(_ctx, 29))) throw FailedPredicateException(this, "precpred(_ctx, 29)");
          setState(4476);
          match(SV3_1aParser::AND);
          setState(4477);
          property_expr(30);
          break;
        }

        case 3: {
          _localctx = _tracker.createInstance<Property_exprContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleProperty_expr);
          setState(4478);

          if (!(precpred(_ctx, 12))) throw FailedPredicateException(this, "precpred(_ctx, 12)");
          setState(4479);
          match(SV3_1aParser::UNTIL);
          setState(4480);
          property_expr(13);
          break;
        }

        case 4: {
          _localctx = _tracker.createInstance<Property_exprContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleProperty_expr);
          setState(4481);

          if (!(precpred(_ctx, 11))) throw FailedPredicateException(this, "precpred(_ctx, 11)");
          setState(4482);
          match(SV3_1aParser::S_UNTIL);
          setState(4483);
          property_expr(12);
          break;
        }

        case 5: {
          _localctx = _tracker.createInstance<Property_exprContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleProperty_expr);
          setState(4484);

          if (!(precpred(_ctx, 10))) throw FailedPredicateException(this, "precpred(_ctx, 10)");
          setState(4485);
          match(SV3_1aParser::UNTIL_WITH);
          setState(4486);
          property_expr(11);
          break;
        }

        case 6: {
          _localctx = _tracker.createInstance<Property_exprContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleProperty_expr);
          setState(4487);

          if (!(precpred(_ctx, 9))) throw FailedPredicateException(this, "precpred(_ctx, 9)");
          setState(4488);
          match(SV3_1aParser::S_UNTIL_WITH);
          setState(4489);
          property_expr(10);
          break;
        }

        case 7: {
          _localctx = _tracker.createInstance<Property_exprContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleProperty_expr);
          setState(4490);

          if (!(precpred(_ctx, 8))) throw FailedPredicateException(this, "precpred(_ctx, 8)");
          setState(4491);
          match(SV3_1aParser::IMPLIES);
          setState(4492);
          property_expr(9);
          break;
        }

        case 8: {
          _localctx = _tracker.createInstance<Property_exprContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleProperty_expr);
          setState(4493);

          if (!(precpred(_ctx, 7))) throw FailedPredicateException(this, "precpred(_ctx, 7)");
          setState(4494);
          match(SV3_1aParser::IFF);
          setState(4495);
          property_expr(8);
          break;
        }

        default:
          break;
        } 
      }
      setState(4500);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 462, _ctx);
    }
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }
  return _localctx;
}

//----------------- Property_case_itemContext ------------------------------------------------------------------

SV3_1aParser::Property_case_itemContext::Property_case_itemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<SV3_1aParser::Expression_or_distContext *> SV3_1aParser::Property_case_itemContext::expression_or_dist() {
  return getRuleContexts<SV3_1aParser::Expression_or_distContext>();
}

SV3_1aParser::Expression_or_distContext* SV3_1aParser::Property_case_itemContext::expression_or_dist(size_t i) {
  return getRuleContext<SV3_1aParser::Expression_or_distContext>(i);
}

tree::TerminalNode* SV3_1aParser::Property_case_itemContext::COLON() {
  return getToken(SV3_1aParser::COLON, 0);
}

SV3_1aParser::Property_exprContext* SV3_1aParser::Property_case_itemContext::property_expr() {
  return getRuleContext<SV3_1aParser::Property_exprContext>(0);
}

std::vector<tree::TerminalNode *> SV3_1aParser::Property_case_itemContext::COMMA() {
  return getTokens(SV3_1aParser::COMMA);
}

tree::TerminalNode* SV3_1aParser::Property_case_itemContext::COMMA(size_t i) {
  return getToken(SV3_1aParser::COMMA, i);
}

tree::TerminalNode* SV3_1aParser::Property_case_itemContext::SEMICOLON() {
  return getToken(SV3_1aParser::SEMICOLON, 0);
}

tree::TerminalNode* SV3_1aParser::Property_case_itemContext::DEFAULT() {
  return getToken(SV3_1aParser::DEFAULT, 0);
}


size_t SV3_1aParser::Property_case_itemContext::getRuleIndex() const {
  return SV3_1aParser::RuleProperty_case_item;
}

void SV3_1aParser::Property_case_itemContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterProperty_case_item(this);
}

void SV3_1aParser::Property_case_itemContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitProperty_case_item(this);
}

SV3_1aParser::Property_case_itemContext* SV3_1aParser::property_case_item() {
  Property_case_itemContext *_localctx = _tracker.createInstance<Property_case_itemContext>(_ctx, getState());
  enterRule(_localctx, 462, SV3_1aParser::RuleProperty_case_item);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(4522);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SV3_1aParser::TICK_b0:
      case SV3_1aParser::TICK_b1:
      case SV3_1aParser::TICK_B0:
      case SV3_1aParser::TICK_B1:
      case SV3_1aParser::TICK_0:
      case SV3_1aParser::TICK_1:
      case SV3_1aParser::ONE_TICK_b0:
      case SV3_1aParser::ONE_TICK_b1:
      case SV3_1aParser::ONE_TICK_bx:
      case SV3_1aParser::ONE_TICK_bX:
      case SV3_1aParser::ONE_TICK_B0:
      case SV3_1aParser::ONE_TICK_B1:
      case SV3_1aParser::ONE_TICK_Bx:
      case SV3_1aParser::ONE_TICK_BX:
      case SV3_1aParser::Integral_number:
      case SV3_1aParser::Real_number:
      case SV3_1aParser::String:
      case SV3_1aParser::OPEN_PARENS:
      case SV3_1aParser::TYPE:
      case SV3_1aParser::CONST:
      case SV3_1aParser::LOCAL:
      case SV3_1aParser::SUPER:
      case SV3_1aParser::OPEN_CURLY:
      case SV3_1aParser::STRING:
      case SV3_1aParser::BYTE:
      case SV3_1aParser::SHORTINT:
      case SV3_1aParser::INT:
      case SV3_1aParser::LONGINT:
      case SV3_1aParser::INTEGER:
      case SV3_1aParser::TIME:
      case SV3_1aParser::BIT:
      case SV3_1aParser::LOGIC:
      case SV3_1aParser::REG:
      case SV3_1aParser::SHORTREAL:
      case SV3_1aParser::REAL:
      case SV3_1aParser::REALTIME:
      case SV3_1aParser::SIGNED:
      case SV3_1aParser::UNSIGNED:
      case SV3_1aParser::DOLLAR:
      case SV3_1aParser::PLUSPLUS:
      case SV3_1aParser::PLUS:
      case SV3_1aParser::MINUSMINUS:
      case SV3_1aParser::MINUS:
      case SV3_1aParser::DOLLAR_UNIT:
      case SV3_1aParser::BANG:
      case SV3_1aParser::TAGGED:
      case SV3_1aParser::TICK:
      case SV3_1aParser::NULL_KEYWORD:
      case SV3_1aParser::THIS:
      case SV3_1aParser::DOLLAR_ROOT:
      case SV3_1aParser::RANDOMIZE:
      case SV3_1aParser::SAMPLE:
      case SV3_1aParser::BITW_AND:
      case SV3_1aParser::BITW_OR:
      case SV3_1aParser::REDUCTION_NOR:
      case SV3_1aParser::REDUCTION_NAND:
      case SV3_1aParser::REDUCTION_XNOR1:
      case SV3_1aParser::Escaped_identifier:
      case SV3_1aParser::TILDA:
      case SV3_1aParser::BITW_XOR:
      case SV3_1aParser::REDUCTION_XNOR2:
      case SV3_1aParser::Simple_identifier: {
        enterOuterAlt(_localctx, 1);
        setState(4501);
        expression_or_dist();
        setState(4506);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == SV3_1aParser::COMMA) {
          setState(4502);
          match(SV3_1aParser::COMMA);
          setState(4503);
          expression_or_dist();
          setState(4508);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(4509);
        match(SV3_1aParser::COLON);
        setState(4510);
        property_expr(0);
        setState(4512);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == SV3_1aParser::SEMICOLON) {
          setState(4511);
          match(SV3_1aParser::SEMICOLON);
        }
        break;
      }

      case SV3_1aParser::DEFAULT: {
        enterOuterAlt(_localctx, 2);
        setState(4514);
        match(SV3_1aParser::DEFAULT);
        setState(4516);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == SV3_1aParser::COLON) {
          setState(4515);
          match(SV3_1aParser::COLON);
        }
        setState(4518);
        property_expr(0);
        setState(4520);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == SV3_1aParser::SEMICOLON) {
          setState(4519);
          match(SV3_1aParser::SEMICOLON);
        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Sequence_declarationContext ------------------------------------------------------------------

SV3_1aParser::Sequence_declarationContext::Sequence_declarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Sequence_declarationContext::SEQUENCE() {
  return getToken(SV3_1aParser::SEQUENCE, 0);
}

std::vector<SV3_1aParser::IdentifierContext *> SV3_1aParser::Sequence_declarationContext::identifier() {
  return getRuleContexts<SV3_1aParser::IdentifierContext>();
}

SV3_1aParser::IdentifierContext* SV3_1aParser::Sequence_declarationContext::identifier(size_t i) {
  return getRuleContext<SV3_1aParser::IdentifierContext>(i);
}

std::vector<tree::TerminalNode *> SV3_1aParser::Sequence_declarationContext::SEMICOLON() {
  return getTokens(SV3_1aParser::SEMICOLON);
}

tree::TerminalNode* SV3_1aParser::Sequence_declarationContext::SEMICOLON(size_t i) {
  return getToken(SV3_1aParser::SEMICOLON, i);
}

SV3_1aParser::Sequence_exprContext* SV3_1aParser::Sequence_declarationContext::sequence_expr() {
  return getRuleContext<SV3_1aParser::Sequence_exprContext>(0);
}

tree::TerminalNode* SV3_1aParser::Sequence_declarationContext::ENDSEQUENCE() {
  return getToken(SV3_1aParser::ENDSEQUENCE, 0);
}

tree::TerminalNode* SV3_1aParser::Sequence_declarationContext::OPEN_PARENS() {
  return getToken(SV3_1aParser::OPEN_PARENS, 0);
}

tree::TerminalNode* SV3_1aParser::Sequence_declarationContext::CLOSE_PARENS() {
  return getToken(SV3_1aParser::CLOSE_PARENS, 0);
}

std::vector<SV3_1aParser::Assertion_variable_declarationContext *> SV3_1aParser::Sequence_declarationContext::assertion_variable_declaration() {
  return getRuleContexts<SV3_1aParser::Assertion_variable_declarationContext>();
}

SV3_1aParser::Assertion_variable_declarationContext* SV3_1aParser::Sequence_declarationContext::assertion_variable_declaration(size_t i) {
  return getRuleContext<SV3_1aParser::Assertion_variable_declarationContext>(i);
}

tree::TerminalNode* SV3_1aParser::Sequence_declarationContext::COLON() {
  return getToken(SV3_1aParser::COLON, 0);
}

SV3_1aParser::Sequence_port_listContext* SV3_1aParser::Sequence_declarationContext::sequence_port_list() {
  return getRuleContext<SV3_1aParser::Sequence_port_listContext>(0);
}


size_t SV3_1aParser::Sequence_declarationContext::getRuleIndex() const {
  return SV3_1aParser::RuleSequence_declaration;
}

void SV3_1aParser::Sequence_declarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSequence_declaration(this);
}

void SV3_1aParser::Sequence_declarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSequence_declaration(this);
}

SV3_1aParser::Sequence_declarationContext* SV3_1aParser::sequence_declaration() {
  Sequence_declarationContext *_localctx = _tracker.createInstance<Sequence_declarationContext>(_ctx, getState());
  enterRule(_localctx, 464, SV3_1aParser::RuleSequence_declaration);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(4524);
    match(SV3_1aParser::SEQUENCE);
    setState(4525);
    identifier();
    setState(4531);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SV3_1aParser::OPEN_PARENS) {
      setState(4526);
      match(SV3_1aParser::OPEN_PARENS);
      setState(4528);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == SV3_1aParser::VIRTUAL || ((((_la - 64) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 64)) & 1152775819316199427) != 0) || ((((_la - 147) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 147)) & 144121785145622531) != 0) || ((((_la - 326) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 326)) & 4672924483589) != 0)) {
        setState(4527);
        sequence_port_list();
      }
      setState(4530);
      match(SV3_1aParser::CLOSE_PARENS);
    }
    setState(4533);
    match(SV3_1aParser::SEMICOLON);
    setState(4537);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 470, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(4534);
        assertion_variable_declaration(); 
      }
      setState(4539);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 470, _ctx);
    }
    setState(4540);
    sequence_expr(0);
    setState(4542);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SV3_1aParser::SEMICOLON) {
      setState(4541);
      match(SV3_1aParser::SEMICOLON);
    }
    setState(4544);
    match(SV3_1aParser::ENDSEQUENCE);
    setState(4547);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 472, _ctx)) {
    case 1: {
      setState(4545);
      match(SV3_1aParser::COLON);
      setState(4546);
      identifier();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Sequence_exprContext ------------------------------------------------------------------

SV3_1aParser::Sequence_exprContext::Sequence_exprContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<SV3_1aParser::Cycle_delay_rangeContext *> SV3_1aParser::Sequence_exprContext::cycle_delay_range() {
  return getRuleContexts<SV3_1aParser::Cycle_delay_rangeContext>();
}

SV3_1aParser::Cycle_delay_rangeContext* SV3_1aParser::Sequence_exprContext::cycle_delay_range(size_t i) {
  return getRuleContext<SV3_1aParser::Cycle_delay_rangeContext>(i);
}

std::vector<SV3_1aParser::Sequence_exprContext *> SV3_1aParser::Sequence_exprContext::sequence_expr() {
  return getRuleContexts<SV3_1aParser::Sequence_exprContext>();
}

SV3_1aParser::Sequence_exprContext* SV3_1aParser::Sequence_exprContext::sequence_expr(size_t i) {
  return getRuleContext<SV3_1aParser::Sequence_exprContext>(i);
}

SV3_1aParser::Expression_or_distContext* SV3_1aParser::Sequence_exprContext::expression_or_dist() {
  return getRuleContext<SV3_1aParser::Expression_or_distContext>(0);
}

SV3_1aParser::Boolean_abbrevContext* SV3_1aParser::Sequence_exprContext::boolean_abbrev() {
  return getRuleContext<SV3_1aParser::Boolean_abbrevContext>(0);
}

tree::TerminalNode* SV3_1aParser::Sequence_exprContext::OPEN_PARENS() {
  return getToken(SV3_1aParser::OPEN_PARENS, 0);
}

tree::TerminalNode* SV3_1aParser::Sequence_exprContext::CLOSE_PARENS() {
  return getToken(SV3_1aParser::CLOSE_PARENS, 0);
}

std::vector<tree::TerminalNode *> SV3_1aParser::Sequence_exprContext::COMMA() {
  return getTokens(SV3_1aParser::COMMA);
}

tree::TerminalNode* SV3_1aParser::Sequence_exprContext::COMMA(size_t i) {
  return getToken(SV3_1aParser::COMMA, i);
}

std::vector<SV3_1aParser::Sequence_match_itemContext *> SV3_1aParser::Sequence_exprContext::sequence_match_item() {
  return getRuleContexts<SV3_1aParser::Sequence_match_itemContext>();
}

SV3_1aParser::Sequence_match_itemContext* SV3_1aParser::Sequence_exprContext::sequence_match_item(size_t i) {
  return getRuleContext<SV3_1aParser::Sequence_match_itemContext>(i);
}

SV3_1aParser::Sequence_instanceContext* SV3_1aParser::Sequence_exprContext::sequence_instance() {
  return getRuleContext<SV3_1aParser::Sequence_instanceContext>(0);
}

SV3_1aParser::Consecutive_repetitionContext* SV3_1aParser::Sequence_exprContext::consecutive_repetition() {
  return getRuleContext<SV3_1aParser::Consecutive_repetitionContext>(0);
}

tree::TerminalNode* SV3_1aParser::Sequence_exprContext::FIRST_MATCH() {
  return getToken(SV3_1aParser::FIRST_MATCH, 0);
}

tree::TerminalNode* SV3_1aParser::Sequence_exprContext::THROUGHOUT() {
  return getToken(SV3_1aParser::THROUGHOUT, 0);
}

SV3_1aParser::Clocking_eventContext* SV3_1aParser::Sequence_exprContext::clocking_event() {
  return getRuleContext<SV3_1aParser::Clocking_eventContext>(0);
}

tree::TerminalNode* SV3_1aParser::Sequence_exprContext::AND() {
  return getToken(SV3_1aParser::AND, 0);
}

tree::TerminalNode* SV3_1aParser::Sequence_exprContext::INTERSECT() {
  return getToken(SV3_1aParser::INTERSECT, 0);
}

tree::TerminalNode* SV3_1aParser::Sequence_exprContext::OR() {
  return getToken(SV3_1aParser::OR, 0);
}

tree::TerminalNode* SV3_1aParser::Sequence_exprContext::WITHIN() {
  return getToken(SV3_1aParser::WITHIN, 0);
}


size_t SV3_1aParser::Sequence_exprContext::getRuleIndex() const {
  return SV3_1aParser::RuleSequence_expr;
}

void SV3_1aParser::Sequence_exprContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSequence_expr(this);
}

void SV3_1aParser::Sequence_exprContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSequence_expr(this);
}


SV3_1aParser::Sequence_exprContext* SV3_1aParser::sequence_expr() {
   return sequence_expr(0);
}

SV3_1aParser::Sequence_exprContext* SV3_1aParser::sequence_expr(int precedence) {
  ParserRuleContext *parentContext = _ctx;
  size_t parentState = getState();
  SV3_1aParser::Sequence_exprContext *_localctx = _tracker.createInstance<Sequence_exprContext>(_ctx, parentState);
  SV3_1aParser::Sequence_exprContext *previousContext = _localctx;
  (void)previousContext; // Silence compiler, in case the context is not used by generated code.
  size_t startState = 466;
  enterRecursionRule(_localctx, 466, SV3_1aParser::RuleSequence_expr, precedence);

    size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    unrollRecursionContexts(parentContext);
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(4613);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 481, _ctx)) {
    case 1: {
      setState(4550);
      cycle_delay_range();
      setState(4551);
      sequence_expr(0);
      setState(4557);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 473, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(4552);
          cycle_delay_range();
          setState(4553);
          sequence_expr(0); 
        }
        setState(4559);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 473, _ctx);
      }
      break;
    }

    case 2: {
      setState(4560);
      expression_or_dist();
      setState(4562);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 474, _ctx)) {
      case 1: {
        setState(4561);
        boolean_abbrev();
        break;
      }

      default:
        break;
      }
      break;
    }

    case 3: {
      setState(4564);
      match(SV3_1aParser::OPEN_PARENS);
      setState(4565);
      expression_or_dist();
      setState(4570);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == SV3_1aParser::COMMA) {
        setState(4566);
        match(SV3_1aParser::COMMA);
        setState(4567);
        sequence_match_item();
        setState(4572);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(4573);
      match(SV3_1aParser::CLOSE_PARENS);
      setState(4575);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 476, _ctx)) {
      case 1: {
        setState(4574);
        boolean_abbrev();
        break;
      }

      default:
        break;
      }
      break;
    }

    case 4: {
      setState(4577);
      sequence_instance();
      setState(4579);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 477, _ctx)) {
      case 1: {
        setState(4578);
        consecutive_repetition();
        break;
      }

      default:
        break;
      }
      break;
    }

    case 5: {
      setState(4581);
      match(SV3_1aParser::OPEN_PARENS);
      setState(4582);
      sequence_expr(0);
      setState(4587);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == SV3_1aParser::COMMA) {
        setState(4583);
        match(SV3_1aParser::COMMA);
        setState(4584);
        sequence_match_item();
        setState(4589);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(4590);
      match(SV3_1aParser::CLOSE_PARENS);
      setState(4592);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 479, _ctx)) {
      case 1: {
        setState(4591);
        consecutive_repetition();
        break;
      }

      default:
        break;
      }
      break;
    }

    case 6: {
      setState(4594);
      match(SV3_1aParser::FIRST_MATCH);
      setState(4595);
      match(SV3_1aParser::OPEN_PARENS);
      setState(4596);
      sequence_expr(0);
      setState(4601);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == SV3_1aParser::COMMA) {
        setState(4597);
        match(SV3_1aParser::COMMA);
        setState(4598);
        sequence_match_item();
        setState(4603);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(4604);
      match(SV3_1aParser::CLOSE_PARENS);
      break;
    }

    case 7: {
      setState(4606);
      expression_or_dist();
      setState(4607);
      match(SV3_1aParser::THROUGHOUT);
      setState(4608);
      sequence_expr(3);
      break;
    }

    case 8: {
      setState(4610);
      clocking_event();
      setState(4611);
      sequence_expr(1);
      break;
    }

    default:
      break;
    }
    _ctx->stop = _input->LT(-1);
    setState(4640);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 484, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        if (!_parseListeners.empty())
          triggerExitRuleEvent();
        previousContext = _localctx;
        setState(4638);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 483, _ctx)) {
        case 1: {
          _localctx = _tracker.createInstance<Sequence_exprContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleSequence_expr);
          setState(4615);

          if (!(precpred(_ctx, 7))) throw FailedPredicateException(this, "precpred(_ctx, 7)");
          setState(4616);
          match(SV3_1aParser::AND);
          setState(4617);
          sequence_expr(8);
          break;
        }

        case 2: {
          _localctx = _tracker.createInstance<Sequence_exprContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleSequence_expr);
          setState(4618);

          if (!(precpred(_ctx, 6))) throw FailedPredicateException(this, "precpred(_ctx, 6)");
          setState(4619);
          match(SV3_1aParser::INTERSECT);
          setState(4620);
          sequence_expr(7);
          break;
        }

        case 3: {
          _localctx = _tracker.createInstance<Sequence_exprContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleSequence_expr);
          setState(4621);

          if (!(precpred(_ctx, 5))) throw FailedPredicateException(this, "precpred(_ctx, 5)");
          setState(4622);
          match(SV3_1aParser::OR);
          setState(4623);
          sequence_expr(6);
          break;
        }

        case 4: {
          _localctx = _tracker.createInstance<Sequence_exprContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleSequence_expr);
          setState(4624);

          if (!(precpred(_ctx, 2))) throw FailedPredicateException(this, "precpred(_ctx, 2)");
          setState(4625);
          match(SV3_1aParser::WITHIN);
          setState(4626);
          sequence_expr(3);
          break;
        }

        case 5: {
          _localctx = _tracker.createInstance<Sequence_exprContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleSequence_expr);
          setState(4627);

          if (!(precpred(_ctx, 12))) throw FailedPredicateException(this, "precpred(_ctx, 12)");
          setState(4628);
          cycle_delay_range();
          setState(4629);
          sequence_expr(0);
          setState(4635);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 482, _ctx);
          while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
            if (alt == 1) {
              setState(4630);
              cycle_delay_range();
              setState(4631);
              sequence_expr(0); 
            }
            setState(4637);
            _errHandler->sync(this);
            alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 482, _ctx);
          }
          break;
        }

        default:
          break;
        } 
      }
      setState(4642);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 484, _ctx);
    }
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }
  return _localctx;
}

//----------------- Cycle_delay_rangeContext ------------------------------------------------------------------

SV3_1aParser::Cycle_delay_rangeContext::Cycle_delay_rangeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Cycle_delay_rangeContext::POUNDPOUND() {
  return getToken(SV3_1aParser::POUNDPOUND, 0);
}

SV3_1aParser::Constant_primaryContext* SV3_1aParser::Cycle_delay_rangeContext::constant_primary() {
  return getRuleContext<SV3_1aParser::Constant_primaryContext>(0);
}

tree::TerminalNode* SV3_1aParser::Cycle_delay_rangeContext::Pound_Pound_delay() {
  return getToken(SV3_1aParser::Pound_Pound_delay, 0);
}

tree::TerminalNode* SV3_1aParser::Cycle_delay_rangeContext::OPEN_BRACKET() {
  return getToken(SV3_1aParser::OPEN_BRACKET, 0);
}

SV3_1aParser::Cycle_delay_const_range_expressionContext* SV3_1aParser::Cycle_delay_rangeContext::cycle_delay_const_range_expression() {
  return getRuleContext<SV3_1aParser::Cycle_delay_const_range_expressionContext>(0);
}

tree::TerminalNode* SV3_1aParser::Cycle_delay_rangeContext::CLOSE_BRACKET() {
  return getToken(SV3_1aParser::CLOSE_BRACKET, 0);
}

tree::TerminalNode* SV3_1aParser::Cycle_delay_rangeContext::ASSOCIATIVE_UNSPECIFIED() {
  return getToken(SV3_1aParser::ASSOCIATIVE_UNSPECIFIED, 0);
}

tree::TerminalNode* SV3_1aParser::Cycle_delay_rangeContext::PLUS() {
  return getToken(SV3_1aParser::PLUS, 0);
}


size_t SV3_1aParser::Cycle_delay_rangeContext::getRuleIndex() const {
  return SV3_1aParser::RuleCycle_delay_range;
}

void SV3_1aParser::Cycle_delay_rangeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCycle_delay_range(this);
}

void SV3_1aParser::Cycle_delay_rangeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCycle_delay_range(this);
}

SV3_1aParser::Cycle_delay_rangeContext* SV3_1aParser::cycle_delay_range() {
  Cycle_delay_rangeContext *_localctx = _tracker.createInstance<Cycle_delay_rangeContext>(_ctx, getState());
  enterRule(_localctx, 468, SV3_1aParser::RuleCycle_delay_range);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(4657);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 485, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(4643);
      match(SV3_1aParser::POUNDPOUND);
      setState(4644);
      constant_primary();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(4645);
      match(SV3_1aParser::Pound_Pound_delay);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(4646);
      match(SV3_1aParser::POUNDPOUND);
      setState(4647);
      match(SV3_1aParser::OPEN_BRACKET);
      setState(4648);
      cycle_delay_const_range_expression();
      setState(4649);
      match(SV3_1aParser::CLOSE_BRACKET);
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(4651);
      match(SV3_1aParser::POUNDPOUND);
      setState(4652);
      match(SV3_1aParser::ASSOCIATIVE_UNSPECIFIED);
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(4653);
      match(SV3_1aParser::POUNDPOUND);
      setState(4654);
      match(SV3_1aParser::OPEN_BRACKET);
      setState(4655);
      match(SV3_1aParser::PLUS);
      setState(4656);
      match(SV3_1aParser::CLOSE_BRACKET);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Sequence_method_callContext ------------------------------------------------------------------

SV3_1aParser::Sequence_method_callContext::Sequence_method_callContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::Sequence_instanceContext* SV3_1aParser::Sequence_method_callContext::sequence_instance() {
  return getRuleContext<SV3_1aParser::Sequence_instanceContext>(0);
}

tree::TerminalNode* SV3_1aParser::Sequence_method_callContext::DOT() {
  return getToken(SV3_1aParser::DOT, 0);
}

SV3_1aParser::IdentifierContext* SV3_1aParser::Sequence_method_callContext::identifier() {
  return getRuleContext<SV3_1aParser::IdentifierContext>(0);
}


size_t SV3_1aParser::Sequence_method_callContext::getRuleIndex() const {
  return SV3_1aParser::RuleSequence_method_call;
}

void SV3_1aParser::Sequence_method_callContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSequence_method_call(this);
}

void SV3_1aParser::Sequence_method_callContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSequence_method_call(this);
}

SV3_1aParser::Sequence_method_callContext* SV3_1aParser::sequence_method_call() {
  Sequence_method_callContext *_localctx = _tracker.createInstance<Sequence_method_callContext>(_ctx, getState());
  enterRule(_localctx, 470, SV3_1aParser::RuleSequence_method_call);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4659);
    sequence_instance();
    setState(4660);
    match(SV3_1aParser::DOT);
    setState(4661);
    identifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Sequence_match_itemContext ------------------------------------------------------------------

SV3_1aParser::Sequence_match_itemContext::Sequence_match_itemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::Operator_assignmentContext* SV3_1aParser::Sequence_match_itemContext::operator_assignment() {
  return getRuleContext<SV3_1aParser::Operator_assignmentContext>(0);
}

SV3_1aParser::Inc_or_dec_expressionContext* SV3_1aParser::Sequence_match_itemContext::inc_or_dec_expression() {
  return getRuleContext<SV3_1aParser::Inc_or_dec_expressionContext>(0);
}

SV3_1aParser::Subroutine_callContext* SV3_1aParser::Sequence_match_itemContext::subroutine_call() {
  return getRuleContext<SV3_1aParser::Subroutine_callContext>(0);
}


size_t SV3_1aParser::Sequence_match_itemContext::getRuleIndex() const {
  return SV3_1aParser::RuleSequence_match_item;
}

void SV3_1aParser::Sequence_match_itemContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSequence_match_item(this);
}

void SV3_1aParser::Sequence_match_itemContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSequence_match_item(this);
}

SV3_1aParser::Sequence_match_itemContext* SV3_1aParser::sequence_match_item() {
  Sequence_match_itemContext *_localctx = _tracker.createInstance<Sequence_match_itemContext>(_ctx, getState());
  enterRule(_localctx, 472, SV3_1aParser::RuleSequence_match_item);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(4666);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 486, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(4663);
      operator_assignment();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(4664);
      inc_or_dec_expression();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(4665);
      subroutine_call();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Sequence_port_listContext ------------------------------------------------------------------

SV3_1aParser::Sequence_port_listContext::Sequence_port_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<SV3_1aParser::Sequence_port_itemContext *> SV3_1aParser::Sequence_port_listContext::sequence_port_item() {
  return getRuleContexts<SV3_1aParser::Sequence_port_itemContext>();
}

SV3_1aParser::Sequence_port_itemContext* SV3_1aParser::Sequence_port_listContext::sequence_port_item(size_t i) {
  return getRuleContext<SV3_1aParser::Sequence_port_itemContext>(i);
}

std::vector<tree::TerminalNode *> SV3_1aParser::Sequence_port_listContext::COMMA() {
  return getTokens(SV3_1aParser::COMMA);
}

tree::TerminalNode* SV3_1aParser::Sequence_port_listContext::COMMA(size_t i) {
  return getToken(SV3_1aParser::COMMA, i);
}


size_t SV3_1aParser::Sequence_port_listContext::getRuleIndex() const {
  return SV3_1aParser::RuleSequence_port_list;
}

void SV3_1aParser::Sequence_port_listContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSequence_port_list(this);
}

void SV3_1aParser::Sequence_port_listContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSequence_port_list(this);
}

SV3_1aParser::Sequence_port_listContext* SV3_1aParser::sequence_port_list() {
  Sequence_port_listContext *_localctx = _tracker.createInstance<Sequence_port_listContext>(_ctx, getState());
  enterRule(_localctx, 474, SV3_1aParser::RuleSequence_port_list);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4668);
    sequence_port_item();
    setState(4673);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == SV3_1aParser::COMMA) {
      setState(4669);
      match(SV3_1aParser::COMMA);
      setState(4670);
      sequence_port_item();
      setState(4675);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Sequence_port_itemContext ------------------------------------------------------------------

SV3_1aParser::Sequence_port_itemContext::Sequence_port_itemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::Sequence_formal_typeContext* SV3_1aParser::Sequence_port_itemContext::sequence_formal_type() {
  return getRuleContext<SV3_1aParser::Sequence_formal_typeContext>(0);
}

SV3_1aParser::IdentifierContext* SV3_1aParser::Sequence_port_itemContext::identifier() {
  return getRuleContext<SV3_1aParser::IdentifierContext>(0);
}

std::vector<SV3_1aParser::Attribute_instanceContext *> SV3_1aParser::Sequence_port_itemContext::attribute_instance() {
  return getRuleContexts<SV3_1aParser::Attribute_instanceContext>();
}

SV3_1aParser::Attribute_instanceContext* SV3_1aParser::Sequence_port_itemContext::attribute_instance(size_t i) {
  return getRuleContext<SV3_1aParser::Attribute_instanceContext>(i);
}

tree::TerminalNode* SV3_1aParser::Sequence_port_itemContext::LOCAL() {
  return getToken(SV3_1aParser::LOCAL, 0);
}

std::vector<SV3_1aParser::Variable_dimensionContext *> SV3_1aParser::Sequence_port_itemContext::variable_dimension() {
  return getRuleContexts<SV3_1aParser::Variable_dimensionContext>();
}

SV3_1aParser::Variable_dimensionContext* SV3_1aParser::Sequence_port_itemContext::variable_dimension(size_t i) {
  return getRuleContext<SV3_1aParser::Variable_dimensionContext>(i);
}

tree::TerminalNode* SV3_1aParser::Sequence_port_itemContext::ASSIGN_OP() {
  return getToken(SV3_1aParser::ASSIGN_OP, 0);
}

SV3_1aParser::Sequence_actual_argContext* SV3_1aParser::Sequence_port_itemContext::sequence_actual_arg() {
  return getRuleContext<SV3_1aParser::Sequence_actual_argContext>(0);
}

SV3_1aParser::Sequence_lvar_port_directionContext* SV3_1aParser::Sequence_port_itemContext::sequence_lvar_port_direction() {
  return getRuleContext<SV3_1aParser::Sequence_lvar_port_directionContext>(0);
}


size_t SV3_1aParser::Sequence_port_itemContext::getRuleIndex() const {
  return SV3_1aParser::RuleSequence_port_item;
}

void SV3_1aParser::Sequence_port_itemContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSequence_port_item(this);
}

void SV3_1aParser::Sequence_port_itemContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSequence_port_item(this);
}

SV3_1aParser::Sequence_port_itemContext* SV3_1aParser::sequence_port_item() {
  Sequence_port_itemContext *_localctx = _tracker.createInstance<Sequence_port_itemContext>(_ctx, getState());
  enterRule(_localctx, 476, SV3_1aParser::RuleSequence_port_item);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4679);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == SV3_1aParser::OPEN_PARENS_STAR) {
      setState(4676);
      attribute_instance();
      setState(4681);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(4686);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SV3_1aParser::LOCAL) {
      setState(4682);
      match(SV3_1aParser::LOCAL);
      setState(4684);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (((((_la - 66) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 66)) & 7) != 0)) {
        setState(4683);
        sequence_lvar_port_direction();
      }
    }
    setState(4688);
    sequence_formal_type();
    setState(4689);
    identifier();
    setState(4693);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == SV3_1aParser::ASSOCIATIVE_UNSPECIFIED || _la == SV3_1aParser::OPEN_BRACKET) {
      setState(4690);
      variable_dimension();
      setState(4695);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(4698);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SV3_1aParser::ASSIGN_OP) {
      setState(4696);
      match(SV3_1aParser::ASSIGN_OP);
      setState(4697);
      sequence_actual_arg();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Sequence_lvar_port_directionContext ------------------------------------------------------------------

SV3_1aParser::Sequence_lvar_port_directionContext::Sequence_lvar_port_directionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t SV3_1aParser::Sequence_lvar_port_directionContext::getRuleIndex() const {
  return SV3_1aParser::RuleSequence_lvar_port_direction;
}

void SV3_1aParser::Sequence_lvar_port_directionContext::copyFrom(Sequence_lvar_port_directionContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- SeqLvarPortDir_OutputContext ------------------------------------------------------------------

tree::TerminalNode* SV3_1aParser::SeqLvarPortDir_OutputContext::OUTPUT() {
  return getToken(SV3_1aParser::OUTPUT, 0);
}

SV3_1aParser::SeqLvarPortDir_OutputContext::SeqLvarPortDir_OutputContext(Sequence_lvar_port_directionContext *ctx) { copyFrom(ctx); }

void SV3_1aParser::SeqLvarPortDir_OutputContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSeqLvarPortDir_Output(this);
}
void SV3_1aParser::SeqLvarPortDir_OutputContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSeqLvarPortDir_Output(this);
}
//----------------- SeqLvarPortDir_InoutContext ------------------------------------------------------------------

tree::TerminalNode* SV3_1aParser::SeqLvarPortDir_InoutContext::INOUT() {
  return getToken(SV3_1aParser::INOUT, 0);
}

SV3_1aParser::SeqLvarPortDir_InoutContext::SeqLvarPortDir_InoutContext(Sequence_lvar_port_directionContext *ctx) { copyFrom(ctx); }

void SV3_1aParser::SeqLvarPortDir_InoutContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSeqLvarPortDir_Inout(this);
}
void SV3_1aParser::SeqLvarPortDir_InoutContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSeqLvarPortDir_Inout(this);
}
//----------------- SeqLvarPortDir_InputContext ------------------------------------------------------------------

tree::TerminalNode* SV3_1aParser::SeqLvarPortDir_InputContext::INPUT() {
  return getToken(SV3_1aParser::INPUT, 0);
}

SV3_1aParser::SeqLvarPortDir_InputContext::SeqLvarPortDir_InputContext(Sequence_lvar_port_directionContext *ctx) { copyFrom(ctx); }

void SV3_1aParser::SeqLvarPortDir_InputContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSeqLvarPortDir_Input(this);
}
void SV3_1aParser::SeqLvarPortDir_InputContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSeqLvarPortDir_Input(this);
}
SV3_1aParser::Sequence_lvar_port_directionContext* SV3_1aParser::sequence_lvar_port_direction() {
  Sequence_lvar_port_directionContext *_localctx = _tracker.createInstance<Sequence_lvar_port_directionContext>(_ctx, getState());
  enterRule(_localctx, 478, SV3_1aParser::RuleSequence_lvar_port_direction);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(4703);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SV3_1aParser::INPUT: {
        _localctx = _tracker.createInstance<SV3_1aParser::SeqLvarPortDir_InputContext>(_localctx);
        enterOuterAlt(_localctx, 1);
        setState(4700);
        match(SV3_1aParser::INPUT);
        break;
      }

      case SV3_1aParser::INOUT: {
        _localctx = _tracker.createInstance<SV3_1aParser::SeqLvarPortDir_InoutContext>(_localctx);
        enterOuterAlt(_localctx, 2);
        setState(4701);
        match(SV3_1aParser::INOUT);
        break;
      }

      case SV3_1aParser::OUTPUT: {
        _localctx = _tracker.createInstance<SV3_1aParser::SeqLvarPortDir_OutputContext>(_localctx);
        enterOuterAlt(_localctx, 3);
        setState(4702);
        match(SV3_1aParser::OUTPUT);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Sequence_formal_typeContext ------------------------------------------------------------------

SV3_1aParser::Sequence_formal_typeContext::Sequence_formal_typeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t SV3_1aParser::Sequence_formal_typeContext::getRuleIndex() const {
  return SV3_1aParser::RuleSequence_formal_type;
}

void SV3_1aParser::Sequence_formal_typeContext::copyFrom(Sequence_formal_typeContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- SeqFormatType_DataContext ------------------------------------------------------------------

SV3_1aParser::Data_type_or_implicitContext* SV3_1aParser::SeqFormatType_DataContext::data_type_or_implicit() {
  return getRuleContext<SV3_1aParser::Data_type_or_implicitContext>(0);
}

SV3_1aParser::SeqFormatType_DataContext::SeqFormatType_DataContext(Sequence_formal_typeContext *ctx) { copyFrom(ctx); }

void SV3_1aParser::SeqFormatType_DataContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSeqFormatType_Data(this);
}
void SV3_1aParser::SeqFormatType_DataContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSeqFormatType_Data(this);
}
//----------------- SeqFormatType_UntypedContext ------------------------------------------------------------------

tree::TerminalNode* SV3_1aParser::SeqFormatType_UntypedContext::UNTYPED() {
  return getToken(SV3_1aParser::UNTYPED, 0);
}

SV3_1aParser::SeqFormatType_UntypedContext::SeqFormatType_UntypedContext(Sequence_formal_typeContext *ctx) { copyFrom(ctx); }

void SV3_1aParser::SeqFormatType_UntypedContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSeqFormatType_Untyped(this);
}
void SV3_1aParser::SeqFormatType_UntypedContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSeqFormatType_Untyped(this);
}
//----------------- SeqFormatType_SequenceContext ------------------------------------------------------------------

tree::TerminalNode* SV3_1aParser::SeqFormatType_SequenceContext::SEQUENCE() {
  return getToken(SV3_1aParser::SEQUENCE, 0);
}

SV3_1aParser::SeqFormatType_SequenceContext::SeqFormatType_SequenceContext(Sequence_formal_typeContext *ctx) { copyFrom(ctx); }

void SV3_1aParser::SeqFormatType_SequenceContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSeqFormatType_Sequence(this);
}
void SV3_1aParser::SeqFormatType_SequenceContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSeqFormatType_Sequence(this);
}
SV3_1aParser::Sequence_formal_typeContext* SV3_1aParser::sequence_formal_type() {
  Sequence_formal_typeContext *_localctx = _tracker.createInstance<Sequence_formal_typeContext>(_ctx, getState());
  enterRule(_localctx, 480, SV3_1aParser::RuleSequence_formal_type);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(4708);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SV3_1aParser::VIRTUAL:
      case SV3_1aParser::TYPE:
      case SV3_1aParser::ENUM:
      case SV3_1aParser::STRUCT:
      case SV3_1aParser::UNION:
      case SV3_1aParser::STRING:
      case SV3_1aParser::CHANDLE:
      case SV3_1aParser::EVENT:
      case SV3_1aParser::OPEN_BRACKET:
      case SV3_1aParser::BYTE:
      case SV3_1aParser::SHORTINT:
      case SV3_1aParser::INT:
      case SV3_1aParser::LONGINT:
      case SV3_1aParser::INTEGER:
      case SV3_1aParser::TIME:
      case SV3_1aParser::BIT:
      case SV3_1aParser::LOGIC:
      case SV3_1aParser::REG:
      case SV3_1aParser::SHORTREAL:
      case SV3_1aParser::REAL:
      case SV3_1aParser::REALTIME:
      case SV3_1aParser::SIGNED:
      case SV3_1aParser::UNSIGNED:
      case SV3_1aParser::DOLLAR_UNIT:
      case SV3_1aParser::THIS:
      case SV3_1aParser::RANDOMIZE:
      case SV3_1aParser::SAMPLE:
      case SV3_1aParser::Escaped_identifier:
      case SV3_1aParser::Simple_identifier: {
        _localctx = _tracker.createInstance<SV3_1aParser::SeqFormatType_DataContext>(_localctx);
        enterOuterAlt(_localctx, 1);
        setState(4705);
        data_type_or_implicit();
        break;
      }

      case SV3_1aParser::SEQUENCE: {
        _localctx = _tracker.createInstance<SV3_1aParser::SeqFormatType_SequenceContext>(_localctx);
        enterOuterAlt(_localctx, 2);
        setState(4706);
        match(SV3_1aParser::SEQUENCE);
        break;
      }

      case SV3_1aParser::UNTYPED: {
        _localctx = _tracker.createInstance<SV3_1aParser::SeqFormatType_UntypedContext>(_localctx);
        enterOuterAlt(_localctx, 3);
        setState(4707);
        match(SV3_1aParser::UNTYPED);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Sequence_instanceContext ------------------------------------------------------------------

SV3_1aParser::Sequence_instanceContext::Sequence_instanceContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::Ps_or_hierarchical_sequence_identifierContext* SV3_1aParser::Sequence_instanceContext::ps_or_hierarchical_sequence_identifier() {
  return getRuleContext<SV3_1aParser::Ps_or_hierarchical_sequence_identifierContext>(0);
}

tree::TerminalNode* SV3_1aParser::Sequence_instanceContext::OPEN_PARENS() {
  return getToken(SV3_1aParser::OPEN_PARENS, 0);
}

SV3_1aParser::Sequence_list_of_argumentsContext* SV3_1aParser::Sequence_instanceContext::sequence_list_of_arguments() {
  return getRuleContext<SV3_1aParser::Sequence_list_of_argumentsContext>(0);
}

tree::TerminalNode* SV3_1aParser::Sequence_instanceContext::CLOSE_PARENS() {
  return getToken(SV3_1aParser::CLOSE_PARENS, 0);
}


size_t SV3_1aParser::Sequence_instanceContext::getRuleIndex() const {
  return SV3_1aParser::RuleSequence_instance;
}

void SV3_1aParser::Sequence_instanceContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSequence_instance(this);
}

void SV3_1aParser::Sequence_instanceContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSequence_instance(this);
}

SV3_1aParser::Sequence_instanceContext* SV3_1aParser::sequence_instance() {
  Sequence_instanceContext *_localctx = _tracker.createInstance<Sequence_instanceContext>(_ctx, getState());
  enterRule(_localctx, 482, SV3_1aParser::RuleSequence_instance);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4710);
    ps_or_hierarchical_sequence_identifier();
    setState(4715);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 495, _ctx)) {
    case 1: {
      setState(4711);
      match(SV3_1aParser::OPEN_PARENS);
      setState(4712);
      sequence_list_of_arguments();
      setState(4713);
      match(SV3_1aParser::CLOSE_PARENS);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Sequence_argContext ------------------------------------------------------------------

SV3_1aParser::Sequence_argContext::Sequence_argContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::Sequence_actual_argContext* SV3_1aParser::Sequence_argContext::sequence_actual_arg() {
  return getRuleContext<SV3_1aParser::Sequence_actual_argContext>(0);
}


size_t SV3_1aParser::Sequence_argContext::getRuleIndex() const {
  return SV3_1aParser::RuleSequence_arg;
}

void SV3_1aParser::Sequence_argContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSequence_arg(this);
}

void SV3_1aParser::Sequence_argContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSequence_arg(this);
}

SV3_1aParser::Sequence_argContext* SV3_1aParser::sequence_arg() {
  Sequence_argContext *_localctx = _tracker.createInstance<Sequence_argContext>(_ctx, getState());
  enterRule(_localctx, 484, SV3_1aParser::RuleSequence_arg);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4718);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 8796094988284) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 64)) & 1152648825725551617) != 0) || ((((_la - 147) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 147)) & -8070448332720832509) != 0) || _la == SV3_1aParser::BANG || ((((_la - 297) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 297)) & 8935247424004825089) != 0) || ((((_la - 364) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 364)) & 31) != 0)) {
      setState(4717);
      sequence_actual_arg();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Sequence_list_of_argumentsContext ------------------------------------------------------------------

SV3_1aParser::Sequence_list_of_argumentsContext::Sequence_list_of_argumentsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<SV3_1aParser::Sequence_actual_argContext *> SV3_1aParser::Sequence_list_of_argumentsContext::sequence_actual_arg() {
  return getRuleContexts<SV3_1aParser::Sequence_actual_argContext>();
}

SV3_1aParser::Sequence_actual_argContext* SV3_1aParser::Sequence_list_of_argumentsContext::sequence_actual_arg(size_t i) {
  return getRuleContext<SV3_1aParser::Sequence_actual_argContext>(i);
}

std::vector<tree::TerminalNode *> SV3_1aParser::Sequence_list_of_argumentsContext::COMMA() {
  return getTokens(SV3_1aParser::COMMA);
}

tree::TerminalNode* SV3_1aParser::Sequence_list_of_argumentsContext::COMMA(size_t i) {
  return getToken(SV3_1aParser::COMMA, i);
}

std::vector<SV3_1aParser::Sequence_argContext *> SV3_1aParser::Sequence_list_of_argumentsContext::sequence_arg() {
  return getRuleContexts<SV3_1aParser::Sequence_argContext>();
}

SV3_1aParser::Sequence_argContext* SV3_1aParser::Sequence_list_of_argumentsContext::sequence_arg(size_t i) {
  return getRuleContext<SV3_1aParser::Sequence_argContext>(i);
}

std::vector<tree::TerminalNode *> SV3_1aParser::Sequence_list_of_argumentsContext::DOT() {
  return getTokens(SV3_1aParser::DOT);
}

tree::TerminalNode* SV3_1aParser::Sequence_list_of_argumentsContext::DOT(size_t i) {
  return getToken(SV3_1aParser::DOT, i);
}

std::vector<SV3_1aParser::IdentifierContext *> SV3_1aParser::Sequence_list_of_argumentsContext::identifier() {
  return getRuleContexts<SV3_1aParser::IdentifierContext>();
}

SV3_1aParser::IdentifierContext* SV3_1aParser::Sequence_list_of_argumentsContext::identifier(size_t i) {
  return getRuleContext<SV3_1aParser::IdentifierContext>(i);
}

std::vector<tree::TerminalNode *> SV3_1aParser::Sequence_list_of_argumentsContext::OPEN_PARENS() {
  return getTokens(SV3_1aParser::OPEN_PARENS);
}

tree::TerminalNode* SV3_1aParser::Sequence_list_of_argumentsContext::OPEN_PARENS(size_t i) {
  return getToken(SV3_1aParser::OPEN_PARENS, i);
}

std::vector<tree::TerminalNode *> SV3_1aParser::Sequence_list_of_argumentsContext::CLOSE_PARENS() {
  return getTokens(SV3_1aParser::CLOSE_PARENS);
}

tree::TerminalNode* SV3_1aParser::Sequence_list_of_argumentsContext::CLOSE_PARENS(size_t i) {
  return getToken(SV3_1aParser::CLOSE_PARENS, i);
}


size_t SV3_1aParser::Sequence_list_of_argumentsContext::getRuleIndex() const {
  return SV3_1aParser::RuleSequence_list_of_arguments;
}

void SV3_1aParser::Sequence_list_of_argumentsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSequence_list_of_arguments(this);
}

void SV3_1aParser::Sequence_list_of_argumentsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSequence_list_of_arguments(this);
}

SV3_1aParser::Sequence_list_of_argumentsContext* SV3_1aParser::sequence_list_of_arguments() {
  Sequence_list_of_argumentsContext *_localctx = _tracker.createInstance<Sequence_list_of_argumentsContext>(_ctx, getState());
  enterRule(_localctx, 486, SV3_1aParser::RuleSequence_list_of_arguments);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    setState(4765);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SV3_1aParser::TICK_b0:
      case SV3_1aParser::TICK_b1:
      case SV3_1aParser::TICK_B0:
      case SV3_1aParser::TICK_B1:
      case SV3_1aParser::TICK_0:
      case SV3_1aParser::TICK_1:
      case SV3_1aParser::ONE_TICK_b0:
      case SV3_1aParser::ONE_TICK_b1:
      case SV3_1aParser::ONE_TICK_bx:
      case SV3_1aParser::ONE_TICK_bX:
      case SV3_1aParser::ONE_TICK_B0:
      case SV3_1aParser::ONE_TICK_B1:
      case SV3_1aParser::ONE_TICK_Bx:
      case SV3_1aParser::ONE_TICK_BX:
      case SV3_1aParser::Pound_Pound_delay:
      case SV3_1aParser::Integral_number:
      case SV3_1aParser::Real_number:
      case SV3_1aParser::String:
      case SV3_1aParser::COMMA:
      case SV3_1aParser::OPEN_PARENS:
      case SV3_1aParser::CLOSE_PARENS:
      case SV3_1aParser::TYPE:
      case SV3_1aParser::CONST:
      case SV3_1aParser::LOCAL:
      case SV3_1aParser::SUPER:
      case SV3_1aParser::OPEN_CURLY:
      case SV3_1aParser::STRING:
      case SV3_1aParser::BYTE:
      case SV3_1aParser::SHORTINT:
      case SV3_1aParser::INT:
      case SV3_1aParser::LONGINT:
      case SV3_1aParser::INTEGER:
      case SV3_1aParser::TIME:
      case SV3_1aParser::BIT:
      case SV3_1aParser::LOGIC:
      case SV3_1aParser::REG:
      case SV3_1aParser::SHORTREAL:
      case SV3_1aParser::REAL:
      case SV3_1aParser::REALTIME:
      case SV3_1aParser::SIGNED:
      case SV3_1aParser::UNSIGNED:
      case SV3_1aParser::DOLLAR:
      case SV3_1aParser::PLUSPLUS:
      case SV3_1aParser::PLUS:
      case SV3_1aParser::MINUSMINUS:
      case SV3_1aParser::MINUS:
      case SV3_1aParser::DOLLAR_UNIT:
      case SV3_1aParser::FIRST_MATCH:
      case SV3_1aParser::POUNDPOUND:
      case SV3_1aParser::BANG:
      case SV3_1aParser::AT:
      case SV3_1aParser::TAGGED:
      case SV3_1aParser::TICK:
      case SV3_1aParser::NULL_KEYWORD:
      case SV3_1aParser::THIS:
      case SV3_1aParser::DOLLAR_ROOT:
      case SV3_1aParser::RANDOMIZE:
      case SV3_1aParser::POSEDGE:
      case SV3_1aParser::NEGEDGE:
      case SV3_1aParser::SAMPLE:
      case SV3_1aParser::EDGE:
      case SV3_1aParser::BITW_AND:
      case SV3_1aParser::BITW_OR:
      case SV3_1aParser::REDUCTION_NOR:
      case SV3_1aParser::REDUCTION_NAND:
      case SV3_1aParser::REDUCTION_XNOR1:
      case SV3_1aParser::Escaped_identifier:
      case SV3_1aParser::TILDA:
      case SV3_1aParser::BITW_XOR:
      case SV3_1aParser::REDUCTION_XNOR2:
      case SV3_1aParser::Simple_identifier: {
        enterOuterAlt(_localctx, 1);
        setState(4721);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if ((((_la & ~ 0x3fULL) == 0) &&
          ((1ULL << _la) & 8796094988284) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 64)) & 1152648825725551617) != 0) || ((((_la - 147) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 147)) & -8070448332720832509) != 0) || _la == SV3_1aParser::BANG || ((((_la - 297) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 297)) & 8935247424004825089) != 0) || ((((_la - 364) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 364)) & 31) != 0)) {
          setState(4720);
          sequence_actual_arg();
        }
        setState(4727);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 498, _ctx);
        while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
          if (alt == 1) {
            setState(4723);
            match(SV3_1aParser::COMMA);
            setState(4724);
            sequence_arg(); 
          }
          setState(4729);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 498, _ctx);
        }
        setState(4741);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == SV3_1aParser::COMMA) {
          setState(4730);
          match(SV3_1aParser::COMMA);
          setState(4731);
          match(SV3_1aParser::DOT);
          setState(4732);
          identifier();
          setState(4733);
          match(SV3_1aParser::OPEN_PARENS);
          setState(4735);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if ((((_la & ~ 0x3fULL) == 0) &&
            ((1ULL << _la) & 8796094988284) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
            ((1ULL << (_la - 64)) & 1152648825725551617) != 0) || ((((_la - 147) & ~ 0x3fULL) == 0) &&
            ((1ULL << (_la - 147)) & -8070448332720832509) != 0) || _la == SV3_1aParser::BANG || ((((_la - 297) & ~ 0x3fULL) == 0) &&
            ((1ULL << (_la - 297)) & 8935247424004825089) != 0) || ((((_la - 364) & ~ 0x3fULL) == 0) &&
            ((1ULL << (_la - 364)) & 31) != 0)) {
            setState(4734);
            sequence_actual_arg();
          }
          setState(4737);
          match(SV3_1aParser::CLOSE_PARENS);
          setState(4743);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        break;
      }

      case SV3_1aParser::DOT: {
        enterOuterAlt(_localctx, 2);
        setState(4744);
        match(SV3_1aParser::DOT);
        setState(4745);
        identifier();
        setState(4746);
        match(SV3_1aParser::OPEN_PARENS);
        setState(4748);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if ((((_la & ~ 0x3fULL) == 0) &&
          ((1ULL << _la) & 8796094988284) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 64)) & 1152648825725551617) != 0) || ((((_la - 147) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 147)) & -8070448332720832509) != 0) || _la == SV3_1aParser::BANG || ((((_la - 297) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 297)) & 8935247424004825089) != 0) || ((((_la - 364) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 364)) & 31) != 0)) {
          setState(4747);
          sequence_actual_arg();
        }
        setState(4750);
        match(SV3_1aParser::CLOSE_PARENS);
        setState(4762);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == SV3_1aParser::COMMA) {
          setState(4751);
          match(SV3_1aParser::COMMA);
          setState(4752);
          match(SV3_1aParser::DOT);
          setState(4753);
          identifier();
          setState(4754);
          match(SV3_1aParser::OPEN_PARENS);
          setState(4756);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if ((((_la & ~ 0x3fULL) == 0) &&
            ((1ULL << _la) & 8796094988284) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
            ((1ULL << (_la - 64)) & 1152648825725551617) != 0) || ((((_la - 147) & ~ 0x3fULL) == 0) &&
            ((1ULL << (_la - 147)) & -8070448332720832509) != 0) || _la == SV3_1aParser::BANG || ((((_la - 297) & ~ 0x3fULL) == 0) &&
            ((1ULL << (_la - 297)) & 8935247424004825089) != 0) || ((((_la - 364) & ~ 0x3fULL) == 0) &&
            ((1ULL << (_la - 364)) & 31) != 0)) {
            setState(4755);
            sequence_actual_arg();
          }
          setState(4758);
          match(SV3_1aParser::CLOSE_PARENS);
          setState(4764);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Sequence_actual_argContext ------------------------------------------------------------------

SV3_1aParser::Sequence_actual_argContext::Sequence_actual_argContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::Event_expressionContext* SV3_1aParser::Sequence_actual_argContext::event_expression() {
  return getRuleContext<SV3_1aParser::Event_expressionContext>(0);
}

SV3_1aParser::Sequence_exprContext* SV3_1aParser::Sequence_actual_argContext::sequence_expr() {
  return getRuleContext<SV3_1aParser::Sequence_exprContext>(0);
}


size_t SV3_1aParser::Sequence_actual_argContext::getRuleIndex() const {
  return SV3_1aParser::RuleSequence_actual_arg;
}

void SV3_1aParser::Sequence_actual_argContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSequence_actual_arg(this);
}

void SV3_1aParser::Sequence_actual_argContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSequence_actual_arg(this);
}

SV3_1aParser::Sequence_actual_argContext* SV3_1aParser::sequence_actual_arg() {
  Sequence_actual_argContext *_localctx = _tracker.createInstance<Sequence_actual_argContext>(_ctx, getState());
  enterRule(_localctx, 488, SV3_1aParser::RuleSequence_actual_arg);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(4769);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 505, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(4767);
      event_expression(0);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(4768);
      sequence_expr(0);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Actual_arg_listContext ------------------------------------------------------------------

SV3_1aParser::Actual_arg_listContext::Actual_arg_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<SV3_1aParser::Actual_arg_exprContext *> SV3_1aParser::Actual_arg_listContext::actual_arg_expr() {
  return getRuleContexts<SV3_1aParser::Actual_arg_exprContext>();
}

SV3_1aParser::Actual_arg_exprContext* SV3_1aParser::Actual_arg_listContext::actual_arg_expr(size_t i) {
  return getRuleContext<SV3_1aParser::Actual_arg_exprContext>(i);
}

std::vector<tree::TerminalNode *> SV3_1aParser::Actual_arg_listContext::COMMA() {
  return getTokens(SV3_1aParser::COMMA);
}

tree::TerminalNode* SV3_1aParser::Actual_arg_listContext::COMMA(size_t i) {
  return getToken(SV3_1aParser::COMMA, i);
}

std::vector<tree::TerminalNode *> SV3_1aParser::Actual_arg_listContext::DOT() {
  return getTokens(SV3_1aParser::DOT);
}

tree::TerminalNode* SV3_1aParser::Actual_arg_listContext::DOT(size_t i) {
  return getToken(SV3_1aParser::DOT, i);
}

std::vector<SV3_1aParser::IdentifierContext *> SV3_1aParser::Actual_arg_listContext::identifier() {
  return getRuleContexts<SV3_1aParser::IdentifierContext>();
}

SV3_1aParser::IdentifierContext* SV3_1aParser::Actual_arg_listContext::identifier(size_t i) {
  return getRuleContext<SV3_1aParser::IdentifierContext>(i);
}

std::vector<tree::TerminalNode *> SV3_1aParser::Actual_arg_listContext::OPEN_PARENS() {
  return getTokens(SV3_1aParser::OPEN_PARENS);
}

tree::TerminalNode* SV3_1aParser::Actual_arg_listContext::OPEN_PARENS(size_t i) {
  return getToken(SV3_1aParser::OPEN_PARENS, i);
}

std::vector<tree::TerminalNode *> SV3_1aParser::Actual_arg_listContext::CLOSE_PARENS() {
  return getTokens(SV3_1aParser::CLOSE_PARENS);
}

tree::TerminalNode* SV3_1aParser::Actual_arg_listContext::CLOSE_PARENS(size_t i) {
  return getToken(SV3_1aParser::CLOSE_PARENS, i);
}


size_t SV3_1aParser::Actual_arg_listContext::getRuleIndex() const {
  return SV3_1aParser::RuleActual_arg_list;
}

void SV3_1aParser::Actual_arg_listContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterActual_arg_list(this);
}

void SV3_1aParser::Actual_arg_listContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitActual_arg_list(this);
}

SV3_1aParser::Actual_arg_listContext* SV3_1aParser::actual_arg_list() {
  Actual_arg_listContext *_localctx = _tracker.createInstance<Actual_arg_listContext>(_ctx, getState());
  enterRule(_localctx, 490, SV3_1aParser::RuleActual_arg_list);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(4796);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SV3_1aParser::TICK_b0:
      case SV3_1aParser::TICK_b1:
      case SV3_1aParser::TICK_B0:
      case SV3_1aParser::TICK_B1:
      case SV3_1aParser::TICK_0:
      case SV3_1aParser::TICK_1:
      case SV3_1aParser::ONE_TICK_b0:
      case SV3_1aParser::ONE_TICK_b1:
      case SV3_1aParser::ONE_TICK_bx:
      case SV3_1aParser::ONE_TICK_bX:
      case SV3_1aParser::ONE_TICK_B0:
      case SV3_1aParser::ONE_TICK_B1:
      case SV3_1aParser::ONE_TICK_Bx:
      case SV3_1aParser::ONE_TICK_BX:
      case SV3_1aParser::Integral_number:
      case SV3_1aParser::Real_number:
      case SV3_1aParser::String:
      case SV3_1aParser::OPEN_PARENS:
      case SV3_1aParser::TYPE:
      case SV3_1aParser::CONST:
      case SV3_1aParser::LOCAL:
      case SV3_1aParser::SUPER:
      case SV3_1aParser::OPEN_CURLY:
      case SV3_1aParser::STRING:
      case SV3_1aParser::BYTE:
      case SV3_1aParser::SHORTINT:
      case SV3_1aParser::INT:
      case SV3_1aParser::LONGINT:
      case SV3_1aParser::INTEGER:
      case SV3_1aParser::TIME:
      case SV3_1aParser::BIT:
      case SV3_1aParser::LOGIC:
      case SV3_1aParser::REG:
      case SV3_1aParser::SHORTREAL:
      case SV3_1aParser::REAL:
      case SV3_1aParser::REALTIME:
      case SV3_1aParser::SIGNED:
      case SV3_1aParser::UNSIGNED:
      case SV3_1aParser::DOLLAR:
      case SV3_1aParser::PLUSPLUS:
      case SV3_1aParser::PLUS:
      case SV3_1aParser::MINUSMINUS:
      case SV3_1aParser::MINUS:
      case SV3_1aParser::DOLLAR_UNIT:
      case SV3_1aParser::BANG:
      case SV3_1aParser::TAGGED:
      case SV3_1aParser::TICK:
      case SV3_1aParser::NULL_KEYWORD:
      case SV3_1aParser::THIS:
      case SV3_1aParser::DOLLAR_ROOT:
      case SV3_1aParser::RANDOMIZE:
      case SV3_1aParser::POSEDGE:
      case SV3_1aParser::NEGEDGE:
      case SV3_1aParser::SAMPLE:
      case SV3_1aParser::EDGE:
      case SV3_1aParser::BITW_AND:
      case SV3_1aParser::BITW_OR:
      case SV3_1aParser::REDUCTION_NOR:
      case SV3_1aParser::REDUCTION_NAND:
      case SV3_1aParser::REDUCTION_XNOR1:
      case SV3_1aParser::Escaped_identifier:
      case SV3_1aParser::TILDA:
      case SV3_1aParser::BITW_XOR:
      case SV3_1aParser::REDUCTION_XNOR2:
      case SV3_1aParser::Simple_identifier: {
        enterOuterAlt(_localctx, 1);
        setState(4771);
        actual_arg_expr();
        setState(4776);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == SV3_1aParser::COMMA) {
          setState(4772);
          match(SV3_1aParser::COMMA);
          setState(4773);
          actual_arg_expr();
          setState(4778);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        break;
      }

      case SV3_1aParser::DOT: {
        enterOuterAlt(_localctx, 2);
        setState(4779);
        match(SV3_1aParser::DOT);
        setState(4780);
        identifier();
        setState(4781);
        match(SV3_1aParser::OPEN_PARENS);
        setState(4782);
        actual_arg_expr();
        setState(4783);
        match(SV3_1aParser::CLOSE_PARENS);
        setState(4793);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == SV3_1aParser::COMMA) {
          setState(4784);
          match(SV3_1aParser::COMMA);
          setState(4785);
          match(SV3_1aParser::DOT);
          setState(4786);
          identifier();
          setState(4787);
          match(SV3_1aParser::OPEN_PARENS);
          setState(4788);
          actual_arg_expr();
          setState(4789);
          match(SV3_1aParser::CLOSE_PARENS);
          setState(4795);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Actual_arg_exprContext ------------------------------------------------------------------

SV3_1aParser::Actual_arg_exprContext::Actual_arg_exprContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::Event_expressionContext* SV3_1aParser::Actual_arg_exprContext::event_expression() {
  return getRuleContext<SV3_1aParser::Event_expressionContext>(0);
}

SV3_1aParser::Dollar_keywordContext* SV3_1aParser::Actual_arg_exprContext::dollar_keyword() {
  return getRuleContext<SV3_1aParser::Dollar_keywordContext>(0);
}


size_t SV3_1aParser::Actual_arg_exprContext::getRuleIndex() const {
  return SV3_1aParser::RuleActual_arg_expr;
}

void SV3_1aParser::Actual_arg_exprContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterActual_arg_expr(this);
}

void SV3_1aParser::Actual_arg_exprContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitActual_arg_expr(this);
}

SV3_1aParser::Actual_arg_exprContext* SV3_1aParser::actual_arg_expr() {
  Actual_arg_exprContext *_localctx = _tracker.createInstance<Actual_arg_exprContext>(_ctx, getState());
  enterRule(_localctx, 492, SV3_1aParser::RuleActual_arg_expr);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(4800);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 509, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(4798);
      event_expression(0);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(4799);
      dollar_keyword();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Boolean_abbrevContext ------------------------------------------------------------------

SV3_1aParser::Boolean_abbrevContext::Boolean_abbrevContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::Consecutive_repetitionContext* SV3_1aParser::Boolean_abbrevContext::consecutive_repetition() {
  return getRuleContext<SV3_1aParser::Consecutive_repetitionContext>(0);
}

SV3_1aParser::Non_consecutive_repetitionContext* SV3_1aParser::Boolean_abbrevContext::non_consecutive_repetition() {
  return getRuleContext<SV3_1aParser::Non_consecutive_repetitionContext>(0);
}

SV3_1aParser::Goto_repetitionContext* SV3_1aParser::Boolean_abbrevContext::goto_repetition() {
  return getRuleContext<SV3_1aParser::Goto_repetitionContext>(0);
}


size_t SV3_1aParser::Boolean_abbrevContext::getRuleIndex() const {
  return SV3_1aParser::RuleBoolean_abbrev;
}

void SV3_1aParser::Boolean_abbrevContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBoolean_abbrev(this);
}

void SV3_1aParser::Boolean_abbrevContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBoolean_abbrev(this);
}

SV3_1aParser::Boolean_abbrevContext* SV3_1aParser::boolean_abbrev() {
  Boolean_abbrevContext *_localctx = _tracker.createInstance<Boolean_abbrevContext>(_ctx, getState());
  enterRule(_localctx, 494, SV3_1aParser::RuleBoolean_abbrev);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(4805);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SV3_1aParser::ASSOCIATIVE_UNSPECIFIED:
      case SV3_1aParser::OPEN_BRACKET:
      case SV3_1aParser::CONSECUTIVE_REP: {
        enterOuterAlt(_localctx, 1);
        setState(4802);
        consecutive_repetition();
        break;
      }

      case SV3_1aParser::NON_CONSECUTIVE_REP: {
        enterOuterAlt(_localctx, 2);
        setState(4803);
        non_consecutive_repetition();
        break;
      }

      case SV3_1aParser::GOTO_REP: {
        enterOuterAlt(_localctx, 3);
        setState(4804);
        goto_repetition();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Consecutive_repetitionContext ------------------------------------------------------------------

SV3_1aParser::Consecutive_repetitionContext::Consecutive_repetitionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Consecutive_repetitionContext::CONSECUTIVE_REP() {
  return getToken(SV3_1aParser::CONSECUTIVE_REP, 0);
}

SV3_1aParser::Const_or_range_expressionContext* SV3_1aParser::Consecutive_repetitionContext::const_or_range_expression() {
  return getRuleContext<SV3_1aParser::Const_or_range_expressionContext>(0);
}

tree::TerminalNode* SV3_1aParser::Consecutive_repetitionContext::CLOSE_BRACKET() {
  return getToken(SV3_1aParser::CLOSE_BRACKET, 0);
}

tree::TerminalNode* SV3_1aParser::Consecutive_repetitionContext::ASSOCIATIVE_UNSPECIFIED() {
  return getToken(SV3_1aParser::ASSOCIATIVE_UNSPECIFIED, 0);
}

tree::TerminalNode* SV3_1aParser::Consecutive_repetitionContext::OPEN_BRACKET() {
  return getToken(SV3_1aParser::OPEN_BRACKET, 0);
}

tree::TerminalNode* SV3_1aParser::Consecutive_repetitionContext::PLUS() {
  return getToken(SV3_1aParser::PLUS, 0);
}


size_t SV3_1aParser::Consecutive_repetitionContext::getRuleIndex() const {
  return SV3_1aParser::RuleConsecutive_repetition;
}

void SV3_1aParser::Consecutive_repetitionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterConsecutive_repetition(this);
}

void SV3_1aParser::Consecutive_repetitionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitConsecutive_repetition(this);
}

SV3_1aParser::Consecutive_repetitionContext* SV3_1aParser::consecutive_repetition() {
  Consecutive_repetitionContext *_localctx = _tracker.createInstance<Consecutive_repetitionContext>(_ctx, getState());
  enterRule(_localctx, 496, SV3_1aParser::RuleConsecutive_repetition);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(4815);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SV3_1aParser::CONSECUTIVE_REP: {
        enterOuterAlt(_localctx, 1);
        setState(4807);
        match(SV3_1aParser::CONSECUTIVE_REP);
        setState(4808);
        const_or_range_expression();
        setState(4809);
        match(SV3_1aParser::CLOSE_BRACKET);
        break;
      }

      case SV3_1aParser::ASSOCIATIVE_UNSPECIFIED: {
        enterOuterAlt(_localctx, 2);
        setState(4811);
        match(SV3_1aParser::ASSOCIATIVE_UNSPECIFIED);
        break;
      }

      case SV3_1aParser::OPEN_BRACKET: {
        enterOuterAlt(_localctx, 3);
        setState(4812);
        match(SV3_1aParser::OPEN_BRACKET);
        setState(4813);
        match(SV3_1aParser::PLUS);
        setState(4814);
        match(SV3_1aParser::CLOSE_BRACKET);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Non_consecutive_repetitionContext ------------------------------------------------------------------

SV3_1aParser::Non_consecutive_repetitionContext::Non_consecutive_repetitionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Non_consecutive_repetitionContext::NON_CONSECUTIVE_REP() {
  return getToken(SV3_1aParser::NON_CONSECUTIVE_REP, 0);
}

SV3_1aParser::Const_or_range_expressionContext* SV3_1aParser::Non_consecutive_repetitionContext::const_or_range_expression() {
  return getRuleContext<SV3_1aParser::Const_or_range_expressionContext>(0);
}

tree::TerminalNode* SV3_1aParser::Non_consecutive_repetitionContext::CLOSE_BRACKET() {
  return getToken(SV3_1aParser::CLOSE_BRACKET, 0);
}


size_t SV3_1aParser::Non_consecutive_repetitionContext::getRuleIndex() const {
  return SV3_1aParser::RuleNon_consecutive_repetition;
}

void SV3_1aParser::Non_consecutive_repetitionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNon_consecutive_repetition(this);
}

void SV3_1aParser::Non_consecutive_repetitionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNon_consecutive_repetition(this);
}

SV3_1aParser::Non_consecutive_repetitionContext* SV3_1aParser::non_consecutive_repetition() {
  Non_consecutive_repetitionContext *_localctx = _tracker.createInstance<Non_consecutive_repetitionContext>(_ctx, getState());
  enterRule(_localctx, 498, SV3_1aParser::RuleNon_consecutive_repetition);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4817);
    match(SV3_1aParser::NON_CONSECUTIVE_REP);
    setState(4818);
    const_or_range_expression();
    setState(4819);
    match(SV3_1aParser::CLOSE_BRACKET);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Goto_repetitionContext ------------------------------------------------------------------

SV3_1aParser::Goto_repetitionContext::Goto_repetitionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Goto_repetitionContext::GOTO_REP() {
  return getToken(SV3_1aParser::GOTO_REP, 0);
}

SV3_1aParser::Const_or_range_expressionContext* SV3_1aParser::Goto_repetitionContext::const_or_range_expression() {
  return getRuleContext<SV3_1aParser::Const_or_range_expressionContext>(0);
}

tree::TerminalNode* SV3_1aParser::Goto_repetitionContext::CLOSE_BRACKET() {
  return getToken(SV3_1aParser::CLOSE_BRACKET, 0);
}


size_t SV3_1aParser::Goto_repetitionContext::getRuleIndex() const {
  return SV3_1aParser::RuleGoto_repetition;
}

void SV3_1aParser::Goto_repetitionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGoto_repetition(this);
}

void SV3_1aParser::Goto_repetitionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGoto_repetition(this);
}

SV3_1aParser::Goto_repetitionContext* SV3_1aParser::goto_repetition() {
  Goto_repetitionContext *_localctx = _tracker.createInstance<Goto_repetitionContext>(_ctx, getState());
  enterRule(_localctx, 500, SV3_1aParser::RuleGoto_repetition);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4821);
    match(SV3_1aParser::GOTO_REP);
    setState(4822);
    const_or_range_expression();
    setState(4823);
    match(SV3_1aParser::CLOSE_BRACKET);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Const_or_range_expressionContext ------------------------------------------------------------------

SV3_1aParser::Const_or_range_expressionContext::Const_or_range_expressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::Constant_expressionContext* SV3_1aParser::Const_or_range_expressionContext::constant_expression() {
  return getRuleContext<SV3_1aParser::Constant_expressionContext>(0);
}

SV3_1aParser::Cycle_delay_const_range_expressionContext* SV3_1aParser::Const_or_range_expressionContext::cycle_delay_const_range_expression() {
  return getRuleContext<SV3_1aParser::Cycle_delay_const_range_expressionContext>(0);
}


size_t SV3_1aParser::Const_or_range_expressionContext::getRuleIndex() const {
  return SV3_1aParser::RuleConst_or_range_expression;
}

void SV3_1aParser::Const_or_range_expressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterConst_or_range_expression(this);
}

void SV3_1aParser::Const_or_range_expressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitConst_or_range_expression(this);
}

SV3_1aParser::Const_or_range_expressionContext* SV3_1aParser::const_or_range_expression() {
  Const_or_range_expressionContext *_localctx = _tracker.createInstance<Const_or_range_expressionContext>(_ctx, getState());
  enterRule(_localctx, 502, SV3_1aParser::RuleConst_or_range_expression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(4827);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 512, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(4825);
      constant_expression(0);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(4826);
      cycle_delay_const_range_expression();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Cycle_delay_const_range_expressionContext ------------------------------------------------------------------

SV3_1aParser::Cycle_delay_const_range_expressionContext::Cycle_delay_const_range_expressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<SV3_1aParser::Constant_expressionContext *> SV3_1aParser::Cycle_delay_const_range_expressionContext::constant_expression() {
  return getRuleContexts<SV3_1aParser::Constant_expressionContext>();
}

SV3_1aParser::Constant_expressionContext* SV3_1aParser::Cycle_delay_const_range_expressionContext::constant_expression(size_t i) {
  return getRuleContext<SV3_1aParser::Constant_expressionContext>(i);
}

tree::TerminalNode* SV3_1aParser::Cycle_delay_const_range_expressionContext::COLON() {
  return getToken(SV3_1aParser::COLON, 0);
}

tree::TerminalNode* SV3_1aParser::Cycle_delay_const_range_expressionContext::DOLLAR() {
  return getToken(SV3_1aParser::DOLLAR, 0);
}


size_t SV3_1aParser::Cycle_delay_const_range_expressionContext::getRuleIndex() const {
  return SV3_1aParser::RuleCycle_delay_const_range_expression;
}

void SV3_1aParser::Cycle_delay_const_range_expressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCycle_delay_const_range_expression(this);
}

void SV3_1aParser::Cycle_delay_const_range_expressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCycle_delay_const_range_expression(this);
}

SV3_1aParser::Cycle_delay_const_range_expressionContext* SV3_1aParser::cycle_delay_const_range_expression() {
  Cycle_delay_const_range_expressionContext *_localctx = _tracker.createInstance<Cycle_delay_const_range_expressionContext>(_ctx, getState());
  enterRule(_localctx, 504, SV3_1aParser::RuleCycle_delay_const_range_expression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(4837);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 513, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(4829);
      constant_expression(0);
      setState(4830);
      match(SV3_1aParser::COLON);
      setState(4831);
      constant_expression(0);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(4833);
      constant_expression(0);
      setState(4834);
      match(SV3_1aParser::COLON);
      setState(4835);
      match(SV3_1aParser::DOLLAR);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Expression_or_distContext ------------------------------------------------------------------

SV3_1aParser::Expression_or_distContext::Expression_or_distContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::ExpressionContext* SV3_1aParser::Expression_or_distContext::expression() {
  return getRuleContext<SV3_1aParser::ExpressionContext>(0);
}

tree::TerminalNode* SV3_1aParser::Expression_or_distContext::DIST() {
  return getToken(SV3_1aParser::DIST, 0);
}

tree::TerminalNode* SV3_1aParser::Expression_or_distContext::OPEN_CURLY() {
  return getToken(SV3_1aParser::OPEN_CURLY, 0);
}

SV3_1aParser::Dist_listContext* SV3_1aParser::Expression_or_distContext::dist_list() {
  return getRuleContext<SV3_1aParser::Dist_listContext>(0);
}

tree::TerminalNode* SV3_1aParser::Expression_or_distContext::CLOSE_CURLY() {
  return getToken(SV3_1aParser::CLOSE_CURLY, 0);
}


size_t SV3_1aParser::Expression_or_distContext::getRuleIndex() const {
  return SV3_1aParser::RuleExpression_or_dist;
}

void SV3_1aParser::Expression_or_distContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExpression_or_dist(this);
}

void SV3_1aParser::Expression_or_distContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExpression_or_dist(this);
}

SV3_1aParser::Expression_or_distContext* SV3_1aParser::expression_or_dist() {
  Expression_or_distContext *_localctx = _tracker.createInstance<Expression_or_distContext>(_ctx, getState());
  enterRule(_localctx, 506, SV3_1aParser::RuleExpression_or_dist);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4839);
    expression(0);
    setState(4845);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 514, _ctx)) {
    case 1: {
      setState(4840);
      match(SV3_1aParser::DIST);
      setState(4841);
      match(SV3_1aParser::OPEN_CURLY);
      setState(4842);
      dist_list();
      setState(4843);
      match(SV3_1aParser::CLOSE_CURLY);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Assertion_variable_declarationContext ------------------------------------------------------------------

SV3_1aParser::Assertion_variable_declarationContext::Assertion_variable_declarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::Data_typeContext* SV3_1aParser::Assertion_variable_declarationContext::data_type() {
  return getRuleContext<SV3_1aParser::Data_typeContext>(0);
}

SV3_1aParser::List_of_variable_identifiersContext* SV3_1aParser::Assertion_variable_declarationContext::list_of_variable_identifiers() {
  return getRuleContext<SV3_1aParser::List_of_variable_identifiersContext>(0);
}

tree::TerminalNode* SV3_1aParser::Assertion_variable_declarationContext::SEMICOLON() {
  return getToken(SV3_1aParser::SEMICOLON, 0);
}


size_t SV3_1aParser::Assertion_variable_declarationContext::getRuleIndex() const {
  return SV3_1aParser::RuleAssertion_variable_declaration;
}

void SV3_1aParser::Assertion_variable_declarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAssertion_variable_declaration(this);
}

void SV3_1aParser::Assertion_variable_declarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAssertion_variable_declaration(this);
}

SV3_1aParser::Assertion_variable_declarationContext* SV3_1aParser::assertion_variable_declaration() {
  Assertion_variable_declarationContext *_localctx = _tracker.createInstance<Assertion_variable_declarationContext>(_ctx, getState());
  enterRule(_localctx, 508, SV3_1aParser::RuleAssertion_variable_declaration);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4847);
    data_type();
    setState(4848);
    list_of_variable_identifiers();
    setState(4849);
    match(SV3_1aParser::SEMICOLON);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Let_declarationContext ------------------------------------------------------------------

SV3_1aParser::Let_declarationContext::Let_declarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Let_declarationContext::LET() {
  return getToken(SV3_1aParser::LET, 0);
}

SV3_1aParser::IdentifierContext* SV3_1aParser::Let_declarationContext::identifier() {
  return getRuleContext<SV3_1aParser::IdentifierContext>(0);
}

tree::TerminalNode* SV3_1aParser::Let_declarationContext::ASSIGN_OP() {
  return getToken(SV3_1aParser::ASSIGN_OP, 0);
}

SV3_1aParser::ExpressionContext* SV3_1aParser::Let_declarationContext::expression() {
  return getRuleContext<SV3_1aParser::ExpressionContext>(0);
}

tree::TerminalNode* SV3_1aParser::Let_declarationContext::SEMICOLON() {
  return getToken(SV3_1aParser::SEMICOLON, 0);
}

tree::TerminalNode* SV3_1aParser::Let_declarationContext::OPEN_PARENS() {
  return getToken(SV3_1aParser::OPEN_PARENS, 0);
}

tree::TerminalNode* SV3_1aParser::Let_declarationContext::CLOSE_PARENS() {
  return getToken(SV3_1aParser::CLOSE_PARENS, 0);
}

SV3_1aParser::Let_port_listContext* SV3_1aParser::Let_declarationContext::let_port_list() {
  return getRuleContext<SV3_1aParser::Let_port_listContext>(0);
}


size_t SV3_1aParser::Let_declarationContext::getRuleIndex() const {
  return SV3_1aParser::RuleLet_declaration;
}

void SV3_1aParser::Let_declarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLet_declaration(this);
}

void SV3_1aParser::Let_declarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLet_declaration(this);
}

SV3_1aParser::Let_declarationContext* SV3_1aParser::let_declaration() {
  Let_declarationContext *_localctx = _tracker.createInstance<Let_declarationContext>(_ctx, getState());
  enterRule(_localctx, 510, SV3_1aParser::RuleLet_declaration);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4851);
    match(SV3_1aParser::LET);
    setState(4852);
    identifier();
    setState(4858);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SV3_1aParser::OPEN_PARENS) {
      setState(4853);
      match(SV3_1aParser::OPEN_PARENS);
      setState(4855);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == SV3_1aParser::VIRTUAL || ((((_la - 64) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 64)) & 1152775819316166659) != 0) || ((((_la - 147) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 147)) & 6597069766659) != 0) || ((((_la - 326) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 326)) & 4672924483589) != 0)) {
        setState(4854);
        let_port_list();
      }
      setState(4857);
      match(SV3_1aParser::CLOSE_PARENS);
    }
    setState(4860);
    match(SV3_1aParser::ASSIGN_OP);
    setState(4861);
    expression(0);
    setState(4862);
    match(SV3_1aParser::SEMICOLON);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Let_port_listContext ------------------------------------------------------------------

SV3_1aParser::Let_port_listContext::Let_port_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<SV3_1aParser::Let_port_itemContext *> SV3_1aParser::Let_port_listContext::let_port_item() {
  return getRuleContexts<SV3_1aParser::Let_port_itemContext>();
}

SV3_1aParser::Let_port_itemContext* SV3_1aParser::Let_port_listContext::let_port_item(size_t i) {
  return getRuleContext<SV3_1aParser::Let_port_itemContext>(i);
}

std::vector<tree::TerminalNode *> SV3_1aParser::Let_port_listContext::COMMA() {
  return getTokens(SV3_1aParser::COMMA);
}

tree::TerminalNode* SV3_1aParser::Let_port_listContext::COMMA(size_t i) {
  return getToken(SV3_1aParser::COMMA, i);
}


size_t SV3_1aParser::Let_port_listContext::getRuleIndex() const {
  return SV3_1aParser::RuleLet_port_list;
}

void SV3_1aParser::Let_port_listContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLet_port_list(this);
}

void SV3_1aParser::Let_port_listContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLet_port_list(this);
}

SV3_1aParser::Let_port_listContext* SV3_1aParser::let_port_list() {
  Let_port_listContext *_localctx = _tracker.createInstance<Let_port_listContext>(_ctx, getState());
  enterRule(_localctx, 512, SV3_1aParser::RuleLet_port_list);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4864);
    let_port_item();
    setState(4869);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == SV3_1aParser::COMMA) {
      setState(4865);
      match(SV3_1aParser::COMMA);
      setState(4866);
      let_port_item();
      setState(4871);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Let_port_itemContext ------------------------------------------------------------------

SV3_1aParser::Let_port_itemContext::Let_port_itemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::Let_formal_typeContext* SV3_1aParser::Let_port_itemContext::let_formal_type() {
  return getRuleContext<SV3_1aParser::Let_formal_typeContext>(0);
}

SV3_1aParser::IdentifierContext* SV3_1aParser::Let_port_itemContext::identifier() {
  return getRuleContext<SV3_1aParser::IdentifierContext>(0);
}

std::vector<SV3_1aParser::Attribute_instanceContext *> SV3_1aParser::Let_port_itemContext::attribute_instance() {
  return getRuleContexts<SV3_1aParser::Attribute_instanceContext>();
}

SV3_1aParser::Attribute_instanceContext* SV3_1aParser::Let_port_itemContext::attribute_instance(size_t i) {
  return getRuleContext<SV3_1aParser::Attribute_instanceContext>(i);
}

std::vector<SV3_1aParser::Variable_dimensionContext *> SV3_1aParser::Let_port_itemContext::variable_dimension() {
  return getRuleContexts<SV3_1aParser::Variable_dimensionContext>();
}

SV3_1aParser::Variable_dimensionContext* SV3_1aParser::Let_port_itemContext::variable_dimension(size_t i) {
  return getRuleContext<SV3_1aParser::Variable_dimensionContext>(i);
}

tree::TerminalNode* SV3_1aParser::Let_port_itemContext::ASSIGN_OP() {
  return getToken(SV3_1aParser::ASSIGN_OP, 0);
}

SV3_1aParser::ExpressionContext* SV3_1aParser::Let_port_itemContext::expression() {
  return getRuleContext<SV3_1aParser::ExpressionContext>(0);
}


size_t SV3_1aParser::Let_port_itemContext::getRuleIndex() const {
  return SV3_1aParser::RuleLet_port_item;
}

void SV3_1aParser::Let_port_itemContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLet_port_item(this);
}

void SV3_1aParser::Let_port_itemContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLet_port_item(this);
}

SV3_1aParser::Let_port_itemContext* SV3_1aParser::let_port_item() {
  Let_port_itemContext *_localctx = _tracker.createInstance<Let_port_itemContext>(_ctx, getState());
  enterRule(_localctx, 514, SV3_1aParser::RuleLet_port_item);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4875);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == SV3_1aParser::OPEN_PARENS_STAR) {
      setState(4872);
      attribute_instance();
      setState(4877);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(4878);
    let_formal_type();
    setState(4879);
    identifier();
    setState(4883);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == SV3_1aParser::ASSOCIATIVE_UNSPECIFIED || _la == SV3_1aParser::OPEN_BRACKET) {
      setState(4880);
      variable_dimension();
      setState(4885);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(4888);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SV3_1aParser::ASSIGN_OP) {
      setState(4886);
      match(SV3_1aParser::ASSIGN_OP);
      setState(4887);
      expression(0);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Let_formal_typeContext ------------------------------------------------------------------

SV3_1aParser::Let_formal_typeContext::Let_formal_typeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::Data_type_or_implicitContext* SV3_1aParser::Let_formal_typeContext::data_type_or_implicit() {
  return getRuleContext<SV3_1aParser::Data_type_or_implicitContext>(0);
}

tree::TerminalNode* SV3_1aParser::Let_formal_typeContext::UNTYPED() {
  return getToken(SV3_1aParser::UNTYPED, 0);
}


size_t SV3_1aParser::Let_formal_typeContext::getRuleIndex() const {
  return SV3_1aParser::RuleLet_formal_type;
}

void SV3_1aParser::Let_formal_typeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLet_formal_type(this);
}

void SV3_1aParser::Let_formal_typeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLet_formal_type(this);
}

SV3_1aParser::Let_formal_typeContext* SV3_1aParser::let_formal_type() {
  Let_formal_typeContext *_localctx = _tracker.createInstance<Let_formal_typeContext>(_ctx, getState());
  enterRule(_localctx, 516, SV3_1aParser::RuleLet_formal_type);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(4892);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SV3_1aParser::VIRTUAL:
      case SV3_1aParser::TYPE:
      case SV3_1aParser::ENUM:
      case SV3_1aParser::STRUCT:
      case SV3_1aParser::UNION:
      case SV3_1aParser::STRING:
      case SV3_1aParser::CHANDLE:
      case SV3_1aParser::EVENT:
      case SV3_1aParser::OPEN_BRACKET:
      case SV3_1aParser::BYTE:
      case SV3_1aParser::SHORTINT:
      case SV3_1aParser::INT:
      case SV3_1aParser::LONGINT:
      case SV3_1aParser::INTEGER:
      case SV3_1aParser::TIME:
      case SV3_1aParser::BIT:
      case SV3_1aParser::LOGIC:
      case SV3_1aParser::REG:
      case SV3_1aParser::SHORTREAL:
      case SV3_1aParser::REAL:
      case SV3_1aParser::REALTIME:
      case SV3_1aParser::SIGNED:
      case SV3_1aParser::UNSIGNED:
      case SV3_1aParser::DOLLAR_UNIT:
      case SV3_1aParser::THIS:
      case SV3_1aParser::RANDOMIZE:
      case SV3_1aParser::SAMPLE:
      case SV3_1aParser::Escaped_identifier:
      case SV3_1aParser::Simple_identifier: {
        enterOuterAlt(_localctx, 1);
        setState(4890);
        data_type_or_implicit();
        break;
      }

      case SV3_1aParser::UNTYPED: {
        enterOuterAlt(_localctx, 2);
        setState(4891);
        match(SV3_1aParser::UNTYPED);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Covergroup_declarationContext ------------------------------------------------------------------

SV3_1aParser::Covergroup_declarationContext::Covergroup_declarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Covergroup_declarationContext::COVERGROUP() {
  return getToken(SV3_1aParser::COVERGROUP, 0);
}

std::vector<SV3_1aParser::IdentifierContext *> SV3_1aParser::Covergroup_declarationContext::identifier() {
  return getRuleContexts<SV3_1aParser::IdentifierContext>();
}

SV3_1aParser::IdentifierContext* SV3_1aParser::Covergroup_declarationContext::identifier(size_t i) {
  return getRuleContext<SV3_1aParser::IdentifierContext>(i);
}

tree::TerminalNode* SV3_1aParser::Covergroup_declarationContext::SEMICOLON() {
  return getToken(SV3_1aParser::SEMICOLON, 0);
}

tree::TerminalNode* SV3_1aParser::Covergroup_declarationContext::ENDGROUP() {
  return getToken(SV3_1aParser::ENDGROUP, 0);
}

tree::TerminalNode* SV3_1aParser::Covergroup_declarationContext::OPEN_PARENS() {
  return getToken(SV3_1aParser::OPEN_PARENS, 0);
}

tree::TerminalNode* SV3_1aParser::Covergroup_declarationContext::CLOSE_PARENS() {
  return getToken(SV3_1aParser::CLOSE_PARENS, 0);
}

SV3_1aParser::Coverage_eventContext* SV3_1aParser::Covergroup_declarationContext::coverage_event() {
  return getRuleContext<SV3_1aParser::Coverage_eventContext>(0);
}

std::vector<SV3_1aParser::Coverage_spec_or_optionContext *> SV3_1aParser::Covergroup_declarationContext::coverage_spec_or_option() {
  return getRuleContexts<SV3_1aParser::Coverage_spec_or_optionContext>();
}

SV3_1aParser::Coverage_spec_or_optionContext* SV3_1aParser::Covergroup_declarationContext::coverage_spec_or_option(size_t i) {
  return getRuleContext<SV3_1aParser::Coverage_spec_or_optionContext>(i);
}

tree::TerminalNode* SV3_1aParser::Covergroup_declarationContext::COLON() {
  return getToken(SV3_1aParser::COLON, 0);
}

SV3_1aParser::Tf_port_listContext* SV3_1aParser::Covergroup_declarationContext::tf_port_list() {
  return getRuleContext<SV3_1aParser::Tf_port_listContext>(0);
}


size_t SV3_1aParser::Covergroup_declarationContext::getRuleIndex() const {
  return SV3_1aParser::RuleCovergroup_declaration;
}

void SV3_1aParser::Covergroup_declarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCovergroup_declaration(this);
}

void SV3_1aParser::Covergroup_declarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCovergroup_declaration(this);
}

SV3_1aParser::Covergroup_declarationContext* SV3_1aParser::covergroup_declaration() {
  Covergroup_declarationContext *_localctx = _tracker.createInstance<Covergroup_declarationContext>(_ctx, getState());
  enterRule(_localctx, 518, SV3_1aParser::RuleCovergroup_declaration);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4894);
    match(SV3_1aParser::COVERGROUP);
    setState(4895);
    identifier();
    setState(4901);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SV3_1aParser::OPEN_PARENS) {
      setState(4896);
      match(SV3_1aParser::OPEN_PARENS);
      setState(4898);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == SV3_1aParser::VIRTUAL || ((((_la - 64) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 64)) & 1152775819316167741) != 0) || ((((_la - 147) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 147)) & 6597069766667) != 0) || ((((_la - 326) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 326)) & 4672924483589) != 0)) {
        setState(4897);
        tf_port_list();
      }
      setState(4900);
      match(SV3_1aParser::CLOSE_PARENS);
    }
    setState(4904);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SV3_1aParser::ATAT || _la == SV3_1aParser::AT

    || _la == SV3_1aParser::WITH) {
      setState(4903);
      coverage_event();
    }
    setState(4906);
    match(SV3_1aParser::SEMICOLON);
    setState(4910);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (((((_la - 52) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 52)) & -596726950626586623) != 0) || ((((_la - 116) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 116)) & 6442451199) != 0) || ((((_la - 188) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 188)) & 12884901891) != 0) || ((((_la - 326) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 326)) & 4672924483685) != 0)) {
      setState(4907);
      coverage_spec_or_option();
      setState(4912);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(4913);
    match(SV3_1aParser::ENDGROUP);
    setState(4916);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 526, _ctx)) {
    case 1: {
      setState(4914);
      match(SV3_1aParser::COLON);
      setState(4915);
      identifier();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Coverage_spec_or_optionContext ------------------------------------------------------------------

SV3_1aParser::Coverage_spec_or_optionContext::Coverage_spec_or_optionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::Coverage_specContext* SV3_1aParser::Coverage_spec_or_optionContext::coverage_spec() {
  return getRuleContext<SV3_1aParser::Coverage_specContext>(0);
}

SV3_1aParser::Coverage_optionContext* SV3_1aParser::Coverage_spec_or_optionContext::coverage_option() {
  return getRuleContext<SV3_1aParser::Coverage_optionContext>(0);
}

tree::TerminalNode* SV3_1aParser::Coverage_spec_or_optionContext::SEMICOLON() {
  return getToken(SV3_1aParser::SEMICOLON, 0);
}

std::vector<SV3_1aParser::Attribute_instanceContext *> SV3_1aParser::Coverage_spec_or_optionContext::attribute_instance() {
  return getRuleContexts<SV3_1aParser::Attribute_instanceContext>();
}

SV3_1aParser::Attribute_instanceContext* SV3_1aParser::Coverage_spec_or_optionContext::attribute_instance(size_t i) {
  return getRuleContext<SV3_1aParser::Attribute_instanceContext>(i);
}


size_t SV3_1aParser::Coverage_spec_or_optionContext::getRuleIndex() const {
  return SV3_1aParser::RuleCoverage_spec_or_option;
}

void SV3_1aParser::Coverage_spec_or_optionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCoverage_spec_or_option(this);
}

void SV3_1aParser::Coverage_spec_or_optionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCoverage_spec_or_option(this);
}

SV3_1aParser::Coverage_spec_or_optionContext* SV3_1aParser::coverage_spec_or_option() {
  Coverage_spec_or_optionContext *_localctx = _tracker.createInstance<Coverage_spec_or_optionContext>(_ctx, getState());
  enterRule(_localctx, 520, SV3_1aParser::RuleCoverage_spec_or_option);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4921);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == SV3_1aParser::OPEN_PARENS_STAR) {
      setState(4918);
      attribute_instance();
      setState(4923);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(4928);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SV3_1aParser::VIRTUAL:
      case SV3_1aParser::TYPE:
      case SV3_1aParser::ENUM:
      case SV3_1aParser::STRUCT:
      case SV3_1aParser::UNION:
      case SV3_1aParser::STRING:
      case SV3_1aParser::CHANDLE:
      case SV3_1aParser::EVENT:
      case SV3_1aParser::OPEN_BRACKET:
      case SV3_1aParser::BYTE:
      case SV3_1aParser::SHORTINT:
      case SV3_1aParser::INT:
      case SV3_1aParser::LONGINT:
      case SV3_1aParser::INTEGER:
      case SV3_1aParser::TIME:
      case SV3_1aParser::BIT:
      case SV3_1aParser::LOGIC:
      case SV3_1aParser::REG:
      case SV3_1aParser::SHORTREAL:
      case SV3_1aParser::REAL:
      case SV3_1aParser::REALTIME:
      case SV3_1aParser::SIGNED:
      case SV3_1aParser::UNSIGNED:
      case SV3_1aParser::DOLLAR_UNIT:
      case SV3_1aParser::THIS:
      case SV3_1aParser::RANDOMIZE:
      case SV3_1aParser::COVERPOINT:
      case SV3_1aParser::CROSS:
      case SV3_1aParser::SAMPLE:
      case SV3_1aParser::Escaped_identifier:
      case SV3_1aParser::Simple_identifier: {
        setState(4924);
        coverage_spec();
        break;
      }

      case SV3_1aParser::OPTION_DOT:
      case SV3_1aParser::TYPE_OPTION_DOT: {
        setState(4925);
        coverage_option();
        setState(4926);
        match(SV3_1aParser::SEMICOLON);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Coverage_optionContext ------------------------------------------------------------------

SV3_1aParser::Coverage_optionContext::Coverage_optionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Coverage_optionContext::OPTION_DOT() {
  return getToken(SV3_1aParser::OPTION_DOT, 0);
}

SV3_1aParser::IdentifierContext* SV3_1aParser::Coverage_optionContext::identifier() {
  return getRuleContext<SV3_1aParser::IdentifierContext>(0);
}

tree::TerminalNode* SV3_1aParser::Coverage_optionContext::ASSIGN_OP() {
  return getToken(SV3_1aParser::ASSIGN_OP, 0);
}

SV3_1aParser::ExpressionContext* SV3_1aParser::Coverage_optionContext::expression() {
  return getRuleContext<SV3_1aParser::ExpressionContext>(0);
}

tree::TerminalNode* SV3_1aParser::Coverage_optionContext::TYPE_OPTION_DOT() {
  return getToken(SV3_1aParser::TYPE_OPTION_DOT, 0);
}


size_t SV3_1aParser::Coverage_optionContext::getRuleIndex() const {
  return SV3_1aParser::RuleCoverage_option;
}

void SV3_1aParser::Coverage_optionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCoverage_option(this);
}

void SV3_1aParser::Coverage_optionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCoverage_option(this);
}

SV3_1aParser::Coverage_optionContext* SV3_1aParser::coverage_option() {
  Coverage_optionContext *_localctx = _tracker.createInstance<Coverage_optionContext>(_ctx, getState());
  enterRule(_localctx, 522, SV3_1aParser::RuleCoverage_option);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(4940);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SV3_1aParser::OPTION_DOT: {
        enterOuterAlt(_localctx, 1);
        setState(4930);
        match(SV3_1aParser::OPTION_DOT);
        setState(4931);
        identifier();
        setState(4932);
        match(SV3_1aParser::ASSIGN_OP);
        setState(4933);
        expression(0);
        break;
      }

      case SV3_1aParser::TYPE_OPTION_DOT: {
        enterOuterAlt(_localctx, 2);
        setState(4935);
        match(SV3_1aParser::TYPE_OPTION_DOT);
        setState(4936);
        identifier();
        setState(4937);
        match(SV3_1aParser::ASSIGN_OP);
        setState(4938);
        expression(0);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Coverage_specContext ------------------------------------------------------------------

SV3_1aParser::Coverage_specContext::Coverage_specContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::Cover_pointContext* SV3_1aParser::Coverage_specContext::cover_point() {
  return getRuleContext<SV3_1aParser::Cover_pointContext>(0);
}

SV3_1aParser::Cover_crossContext* SV3_1aParser::Coverage_specContext::cover_cross() {
  return getRuleContext<SV3_1aParser::Cover_crossContext>(0);
}


size_t SV3_1aParser::Coverage_specContext::getRuleIndex() const {
  return SV3_1aParser::RuleCoverage_spec;
}

void SV3_1aParser::Coverage_specContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCoverage_spec(this);
}

void SV3_1aParser::Coverage_specContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCoverage_spec(this);
}

SV3_1aParser::Coverage_specContext* SV3_1aParser::coverage_spec() {
  Coverage_specContext *_localctx = _tracker.createInstance<Coverage_specContext>(_ctx, getState());
  enterRule(_localctx, 524, SV3_1aParser::RuleCoverage_spec);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(4944);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 530, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(4942);
      cover_point();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(4943);
      cover_cross();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Coverage_eventContext ------------------------------------------------------------------

SV3_1aParser::Coverage_eventContext::Coverage_eventContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::Clocking_eventContext* SV3_1aParser::Coverage_eventContext::clocking_event() {
  return getRuleContext<SV3_1aParser::Clocking_eventContext>(0);
}

tree::TerminalNode* SV3_1aParser::Coverage_eventContext::WITH() {
  return getToken(SV3_1aParser::WITH, 0);
}

tree::TerminalNode* SV3_1aParser::Coverage_eventContext::FUNCTION() {
  return getToken(SV3_1aParser::FUNCTION, 0);
}

tree::TerminalNode* SV3_1aParser::Coverage_eventContext::SAMPLE() {
  return getToken(SV3_1aParser::SAMPLE, 0);
}

tree::TerminalNode* SV3_1aParser::Coverage_eventContext::OPEN_PARENS() {
  return getToken(SV3_1aParser::OPEN_PARENS, 0);
}

tree::TerminalNode* SV3_1aParser::Coverage_eventContext::CLOSE_PARENS() {
  return getToken(SV3_1aParser::CLOSE_PARENS, 0);
}

SV3_1aParser::Tf_port_listContext* SV3_1aParser::Coverage_eventContext::tf_port_list() {
  return getRuleContext<SV3_1aParser::Tf_port_listContext>(0);
}

tree::TerminalNode* SV3_1aParser::Coverage_eventContext::ATAT() {
  return getToken(SV3_1aParser::ATAT, 0);
}

SV3_1aParser::Block_event_expressionContext* SV3_1aParser::Coverage_eventContext::block_event_expression() {
  return getRuleContext<SV3_1aParser::Block_event_expressionContext>(0);
}


size_t SV3_1aParser::Coverage_eventContext::getRuleIndex() const {
  return SV3_1aParser::RuleCoverage_event;
}

void SV3_1aParser::Coverage_eventContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCoverage_event(this);
}

void SV3_1aParser::Coverage_eventContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCoverage_event(this);
}

SV3_1aParser::Coverage_eventContext* SV3_1aParser::coverage_event() {
  Coverage_eventContext *_localctx = _tracker.createInstance<Coverage_eventContext>(_ctx, getState());
  enterRule(_localctx, 526, SV3_1aParser::RuleCoverage_event);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(4960);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SV3_1aParser::AT: {
        enterOuterAlt(_localctx, 1);
        setState(4946);
        clocking_event();
        break;
      }

      case SV3_1aParser::WITH: {
        enterOuterAlt(_localctx, 2);
        setState(4947);
        match(SV3_1aParser::WITH);
        setState(4948);
        match(SV3_1aParser::FUNCTION);
        setState(4949);
        match(SV3_1aParser::SAMPLE);
        setState(4950);
        match(SV3_1aParser::OPEN_PARENS);
        setState(4952);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == SV3_1aParser::VIRTUAL || ((((_la - 64) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 64)) & 1152775819316167741) != 0) || ((((_la - 147) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 147)) & 6597069766667) != 0) || ((((_la - 326) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 326)) & 4672924483589) != 0)) {
          setState(4951);
          tf_port_list();
        }
        setState(4954);
        match(SV3_1aParser::CLOSE_PARENS);
        break;
      }

      case SV3_1aParser::ATAT: {
        enterOuterAlt(_localctx, 3);
        setState(4955);
        match(SV3_1aParser::ATAT);
        setState(4956);
        match(SV3_1aParser::OPEN_PARENS);
        setState(4957);
        block_event_expression(0);
        setState(4958);
        match(SV3_1aParser::CLOSE_PARENS);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Block_event_expressionContext ------------------------------------------------------------------

SV3_1aParser::Block_event_expressionContext::Block_event_expressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Block_event_expressionContext::BEGIN() {
  return getToken(SV3_1aParser::BEGIN, 0);
}

SV3_1aParser::Hierarchical_btf_identifierContext* SV3_1aParser::Block_event_expressionContext::hierarchical_btf_identifier() {
  return getRuleContext<SV3_1aParser::Hierarchical_btf_identifierContext>(0);
}

tree::TerminalNode* SV3_1aParser::Block_event_expressionContext::END() {
  return getToken(SV3_1aParser::END, 0);
}

std::vector<SV3_1aParser::Block_event_expressionContext *> SV3_1aParser::Block_event_expressionContext::block_event_expression() {
  return getRuleContexts<SV3_1aParser::Block_event_expressionContext>();
}

SV3_1aParser::Block_event_expressionContext* SV3_1aParser::Block_event_expressionContext::block_event_expression(size_t i) {
  return getRuleContext<SV3_1aParser::Block_event_expressionContext>(i);
}

tree::TerminalNode* SV3_1aParser::Block_event_expressionContext::OR() {
  return getToken(SV3_1aParser::OR, 0);
}


size_t SV3_1aParser::Block_event_expressionContext::getRuleIndex() const {
  return SV3_1aParser::RuleBlock_event_expression;
}

void SV3_1aParser::Block_event_expressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBlock_event_expression(this);
}

void SV3_1aParser::Block_event_expressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBlock_event_expression(this);
}


SV3_1aParser::Block_event_expressionContext* SV3_1aParser::block_event_expression() {
   return block_event_expression(0);
}

SV3_1aParser::Block_event_expressionContext* SV3_1aParser::block_event_expression(int precedence) {
  ParserRuleContext *parentContext = _ctx;
  size_t parentState = getState();
  SV3_1aParser::Block_event_expressionContext *_localctx = _tracker.createInstance<Block_event_expressionContext>(_ctx, parentState);
  SV3_1aParser::Block_event_expressionContext *previousContext = _localctx;
  (void)previousContext; // Silence compiler, in case the context is not used by generated code.
  size_t startState = 528;
  enterRecursionRule(_localctx, 528, SV3_1aParser::RuleBlock_event_expression, precedence);

    

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    unrollRecursionContexts(parentContext);
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(4967);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SV3_1aParser::BEGIN: {
        setState(4963);
        match(SV3_1aParser::BEGIN);
        setState(4964);
        hierarchical_btf_identifier();
        break;
      }

      case SV3_1aParser::END: {
        setState(4965);
        match(SV3_1aParser::END);
        setState(4966);
        hierarchical_btf_identifier();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
    _ctx->stop = _input->LT(-1);
    setState(4974);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 534, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        if (!_parseListeners.empty())
          triggerExitRuleEvent();
        previousContext = _localctx;
        _localctx = _tracker.createInstance<Block_event_expressionContext>(parentContext, parentState);
        pushNewRecursionContext(_localctx, startState, RuleBlock_event_expression);
        setState(4969);

        if (!(precpred(_ctx, 3))) throw FailedPredicateException(this, "precpred(_ctx, 3)");
        setState(4970);
        match(SV3_1aParser::OR);
        setState(4971);
        block_event_expression(4); 
      }
      setState(4976);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 534, _ctx);
    }
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }
  return _localctx;
}

//----------------- Hierarchical_btf_identifierContext ------------------------------------------------------------------

SV3_1aParser::Hierarchical_btf_identifierContext::Hierarchical_btf_identifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::Hierarchical_identifierContext* SV3_1aParser::Hierarchical_btf_identifierContext::hierarchical_identifier() {
  return getRuleContext<SV3_1aParser::Hierarchical_identifierContext>(0);
}

std::vector<SV3_1aParser::IdentifierContext *> SV3_1aParser::Hierarchical_btf_identifierContext::identifier() {
  return getRuleContexts<SV3_1aParser::IdentifierContext>();
}

SV3_1aParser::IdentifierContext* SV3_1aParser::Hierarchical_btf_identifierContext::identifier(size_t i) {
  return getRuleContext<SV3_1aParser::IdentifierContext>(i);
}

SV3_1aParser::Dollar_root_keywordContext* SV3_1aParser::Hierarchical_btf_identifierContext::dollar_root_keyword() {
  return getRuleContext<SV3_1aParser::Dollar_root_keywordContext>(0);
}

std::vector<tree::TerminalNode *> SV3_1aParser::Hierarchical_btf_identifierContext::DOT() {
  return getTokens(SV3_1aParser::DOT);
}

tree::TerminalNode* SV3_1aParser::Hierarchical_btf_identifierContext::DOT(size_t i) {
  return getToken(SV3_1aParser::DOT, i);
}

SV3_1aParser::Class_scopeContext* SV3_1aParser::Hierarchical_btf_identifierContext::class_scope() {
  return getRuleContext<SV3_1aParser::Class_scopeContext>(0);
}

std::vector<tree::TerminalNode *> SV3_1aParser::Hierarchical_btf_identifierContext::OPEN_BRACKET() {
  return getTokens(SV3_1aParser::OPEN_BRACKET);
}

tree::TerminalNode* SV3_1aParser::Hierarchical_btf_identifierContext::OPEN_BRACKET(size_t i) {
  return getToken(SV3_1aParser::OPEN_BRACKET, i);
}

std::vector<SV3_1aParser::Constant_expressionContext *> SV3_1aParser::Hierarchical_btf_identifierContext::constant_expression() {
  return getRuleContexts<SV3_1aParser::Constant_expressionContext>();
}

SV3_1aParser::Constant_expressionContext* SV3_1aParser::Hierarchical_btf_identifierContext::constant_expression(size_t i) {
  return getRuleContext<SV3_1aParser::Constant_expressionContext>(i);
}

std::vector<tree::TerminalNode *> SV3_1aParser::Hierarchical_btf_identifierContext::CLOSE_BRACKET() {
  return getTokens(SV3_1aParser::CLOSE_BRACKET);
}

tree::TerminalNode* SV3_1aParser::Hierarchical_btf_identifierContext::CLOSE_BRACKET(size_t i) {
  return getToken(SV3_1aParser::CLOSE_BRACKET, i);
}


size_t SV3_1aParser::Hierarchical_btf_identifierContext::getRuleIndex() const {
  return SV3_1aParser::RuleHierarchical_btf_identifier;
}

void SV3_1aParser::Hierarchical_btf_identifierContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterHierarchical_btf_identifier(this);
}

void SV3_1aParser::Hierarchical_btf_identifierContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitHierarchical_btf_identifier(this);
}

SV3_1aParser::Hierarchical_btf_identifierContext* SV3_1aParser::hierarchical_btf_identifier() {
  Hierarchical_btf_identifierContext *_localctx = _tracker.createInstance<Hierarchical_btf_identifierContext>(_ctx, getState());
  enterRule(_localctx, 530, SV3_1aParser::RuleHierarchical_btf_identifier);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(5003);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 539, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(4977);
      hierarchical_identifier();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(4979);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == SV3_1aParser::DOLLAR_ROOT) {
        setState(4978);
        dollar_root_keyword();
      }
      setState(4981);
      identifier();
      setState(4995);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == SV3_1aParser::DOT || _la == SV3_1aParser::OPEN_BRACKET) {
        setState(4988);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == SV3_1aParser::OPEN_BRACKET) {
          setState(4982);
          match(SV3_1aParser::OPEN_BRACKET);
          setState(4983);
          constant_expression(0);
          setState(4984);
          match(SV3_1aParser::CLOSE_BRACKET);
          setState(4990);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(4991);
        match(SV3_1aParser::DOT);
        setState(4992);
        identifier();
        setState(4997);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(4999);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 538, _ctx)) {
      case 1: {
        setState(4998);
        class_scope();
        break;
      }

      default:
        break;
      }
      setState(5001);
      identifier();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Cover_pointContext ------------------------------------------------------------------

SV3_1aParser::Cover_pointContext::Cover_pointContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Cover_pointContext::COVERPOINT() {
  return getToken(SV3_1aParser::COVERPOINT, 0);
}

std::vector<SV3_1aParser::ExpressionContext *> SV3_1aParser::Cover_pointContext::expression() {
  return getRuleContexts<SV3_1aParser::ExpressionContext>();
}

SV3_1aParser::ExpressionContext* SV3_1aParser::Cover_pointContext::expression(size_t i) {
  return getRuleContext<SV3_1aParser::ExpressionContext>(i);
}

SV3_1aParser::Bins_or_emptyContext* SV3_1aParser::Cover_pointContext::bins_or_empty() {
  return getRuleContext<SV3_1aParser::Bins_or_emptyContext>(0);
}

SV3_1aParser::Data_type_or_implicitContext* SV3_1aParser::Cover_pointContext::data_type_or_implicit() {
  return getRuleContext<SV3_1aParser::Data_type_or_implicitContext>(0);
}

SV3_1aParser::IdentifierContext* SV3_1aParser::Cover_pointContext::identifier() {
  return getRuleContext<SV3_1aParser::IdentifierContext>(0);
}

tree::TerminalNode* SV3_1aParser::Cover_pointContext::COLON() {
  return getToken(SV3_1aParser::COLON, 0);
}

tree::TerminalNode* SV3_1aParser::Cover_pointContext::IFF() {
  return getToken(SV3_1aParser::IFF, 0);
}

tree::TerminalNode* SV3_1aParser::Cover_pointContext::OPEN_PARENS() {
  return getToken(SV3_1aParser::OPEN_PARENS, 0);
}

tree::TerminalNode* SV3_1aParser::Cover_pointContext::CLOSE_PARENS() {
  return getToken(SV3_1aParser::CLOSE_PARENS, 0);
}


size_t SV3_1aParser::Cover_pointContext::getRuleIndex() const {
  return SV3_1aParser::RuleCover_point;
}

void SV3_1aParser::Cover_pointContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCover_point(this);
}

void SV3_1aParser::Cover_pointContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCover_point(this);
}

SV3_1aParser::Cover_pointContext* SV3_1aParser::cover_point() {
  Cover_pointContext *_localctx = _tracker.createInstance<Cover_pointContext>(_ctx, getState());
  enterRule(_localctx, 532, SV3_1aParser::RuleCover_point);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5009);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SV3_1aParser::VIRTUAL || ((((_la - 64) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 64)) & 1152775819316166657) != 0) || ((((_la - 147) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 147)) & 2199023255555) != 0) || ((((_la - 326) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 326)) & 4672924483589) != 0)) {
      setState(5005);
      data_type_or_implicit();
      setState(5006);
      identifier();
      setState(5007);
      match(SV3_1aParser::COLON);
    }
    setState(5011);
    match(SV3_1aParser::COVERPOINT);
    setState(5012);
    expression(0);
    setState(5018);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SV3_1aParser::IFF) {
      setState(5013);
      match(SV3_1aParser::IFF);
      setState(5014);
      match(SV3_1aParser::OPEN_PARENS);
      setState(5015);
      expression(0);
      setState(5016);
      match(SV3_1aParser::CLOSE_PARENS);
    }
    setState(5020);
    bins_or_empty();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Bins_or_emptyContext ------------------------------------------------------------------

SV3_1aParser::Bins_or_emptyContext::Bins_or_emptyContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Bins_or_emptyContext::OPEN_CURLY() {
  return getToken(SV3_1aParser::OPEN_CURLY, 0);
}

tree::TerminalNode* SV3_1aParser::Bins_or_emptyContext::CLOSE_CURLY() {
  return getToken(SV3_1aParser::CLOSE_CURLY, 0);
}

std::vector<SV3_1aParser::Attribute_instanceContext *> SV3_1aParser::Bins_or_emptyContext::attribute_instance() {
  return getRuleContexts<SV3_1aParser::Attribute_instanceContext>();
}

SV3_1aParser::Attribute_instanceContext* SV3_1aParser::Bins_or_emptyContext::attribute_instance(size_t i) {
  return getRuleContext<SV3_1aParser::Attribute_instanceContext>(i);
}

std::vector<SV3_1aParser::Bins_or_optionsContext *> SV3_1aParser::Bins_or_emptyContext::bins_or_options() {
  return getRuleContexts<SV3_1aParser::Bins_or_optionsContext>();
}

SV3_1aParser::Bins_or_optionsContext* SV3_1aParser::Bins_or_emptyContext::bins_or_options(size_t i) {
  return getRuleContext<SV3_1aParser::Bins_or_optionsContext>(i);
}

std::vector<tree::TerminalNode *> SV3_1aParser::Bins_or_emptyContext::SEMICOLON() {
  return getTokens(SV3_1aParser::SEMICOLON);
}

tree::TerminalNode* SV3_1aParser::Bins_or_emptyContext::SEMICOLON(size_t i) {
  return getToken(SV3_1aParser::SEMICOLON, i);
}


size_t SV3_1aParser::Bins_or_emptyContext::getRuleIndex() const {
  return SV3_1aParser::RuleBins_or_empty;
}

void SV3_1aParser::Bins_or_emptyContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBins_or_empty(this);
}

void SV3_1aParser::Bins_or_emptyContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBins_or_empty(this);
}

SV3_1aParser::Bins_or_emptyContext* SV3_1aParser::bins_or_empty() {
  Bins_or_emptyContext *_localctx = _tracker.createInstance<Bins_or_emptyContext>(_ctx, getState());
  enterRule(_localctx, 534, SV3_1aParser::RuleBins_or_empty);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(5039);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SV3_1aParser::OPEN_CURLY: {
        enterOuterAlt(_localctx, 1);
        setState(5022);
        match(SV3_1aParser::OPEN_CURLY);
        setState(5026);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == SV3_1aParser::OPEN_PARENS_STAR) {
          setState(5023);
          attribute_instance();
          setState(5028);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(5034);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (((((_la - 220) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 220)) & 483) != 0)) {
          setState(5029);
          bins_or_options();
          setState(5030);
          match(SV3_1aParser::SEMICOLON);
          setState(5036);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(5037);
        match(SV3_1aParser::CLOSE_CURLY);
        break;
      }

      case SV3_1aParser::SEMICOLON: {
        enterOuterAlt(_localctx, 2);
        setState(5038);
        match(SV3_1aParser::SEMICOLON);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Bins_or_optionsContext ------------------------------------------------------------------

SV3_1aParser::Bins_or_optionsContext::Bins_or_optionsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::Coverage_optionContext* SV3_1aParser::Bins_or_optionsContext::coverage_option() {
  return getRuleContext<SV3_1aParser::Coverage_optionContext>(0);
}

SV3_1aParser::Bins_keywordContext* SV3_1aParser::Bins_or_optionsContext::bins_keyword() {
  return getRuleContext<SV3_1aParser::Bins_keywordContext>(0);
}

std::vector<SV3_1aParser::IdentifierContext *> SV3_1aParser::Bins_or_optionsContext::identifier() {
  return getRuleContexts<SV3_1aParser::IdentifierContext>();
}

SV3_1aParser::IdentifierContext* SV3_1aParser::Bins_or_optionsContext::identifier(size_t i) {
  return getRuleContext<SV3_1aParser::IdentifierContext>(i);
}

tree::TerminalNode* SV3_1aParser::Bins_or_optionsContext::ASSIGN_OP() {
  return getToken(SV3_1aParser::ASSIGN_OP, 0);
}

tree::TerminalNode* SV3_1aParser::Bins_or_optionsContext::OPEN_CURLY() {
  return getToken(SV3_1aParser::OPEN_CURLY, 0);
}

SV3_1aParser::Range_listContext* SV3_1aParser::Bins_or_optionsContext::range_list() {
  return getRuleContext<SV3_1aParser::Range_listContext>(0);
}

tree::TerminalNode* SV3_1aParser::Bins_or_optionsContext::CLOSE_CURLY() {
  return getToken(SV3_1aParser::CLOSE_CURLY, 0);
}

tree::TerminalNode* SV3_1aParser::Bins_or_optionsContext::WILDCARD() {
  return getToken(SV3_1aParser::WILDCARD, 0);
}

tree::TerminalNode* SV3_1aParser::Bins_or_optionsContext::OPEN_BRACKET() {
  return getToken(SV3_1aParser::OPEN_BRACKET, 0);
}

tree::TerminalNode* SV3_1aParser::Bins_or_optionsContext::CLOSE_BRACKET() {
  return getToken(SV3_1aParser::CLOSE_BRACKET, 0);
}

tree::TerminalNode* SV3_1aParser::Bins_or_optionsContext::WITH() {
  return getToken(SV3_1aParser::WITH, 0);
}

std::vector<tree::TerminalNode *> SV3_1aParser::Bins_or_optionsContext::OPEN_PARENS() {
  return getTokens(SV3_1aParser::OPEN_PARENS);
}

tree::TerminalNode* SV3_1aParser::Bins_or_optionsContext::OPEN_PARENS(size_t i) {
  return getToken(SV3_1aParser::OPEN_PARENS, i);
}

std::vector<SV3_1aParser::ExpressionContext *> SV3_1aParser::Bins_or_optionsContext::expression() {
  return getRuleContexts<SV3_1aParser::ExpressionContext>();
}

SV3_1aParser::ExpressionContext* SV3_1aParser::Bins_or_optionsContext::expression(size_t i) {
  return getRuleContext<SV3_1aParser::ExpressionContext>(i);
}

std::vector<tree::TerminalNode *> SV3_1aParser::Bins_or_optionsContext::CLOSE_PARENS() {
  return getTokens(SV3_1aParser::CLOSE_PARENS);
}

tree::TerminalNode* SV3_1aParser::Bins_or_optionsContext::CLOSE_PARENS(size_t i) {
  return getToken(SV3_1aParser::CLOSE_PARENS, i);
}

tree::TerminalNode* SV3_1aParser::Bins_or_optionsContext::IFF() {
  return getToken(SV3_1aParser::IFF, 0);
}

SV3_1aParser::Trans_listContext* SV3_1aParser::Bins_or_optionsContext::trans_list() {
  return getRuleContext<SV3_1aParser::Trans_listContext>(0);
}

SV3_1aParser::Unsized_dimensionContext* SV3_1aParser::Bins_or_optionsContext::unsized_dimension() {
  return getRuleContext<SV3_1aParser::Unsized_dimensionContext>(0);
}

tree::TerminalNode* SV3_1aParser::Bins_or_optionsContext::DEFAULT() {
  return getToken(SV3_1aParser::DEFAULT, 0);
}

tree::TerminalNode* SV3_1aParser::Bins_or_optionsContext::SEQUENCE() {
  return getToken(SV3_1aParser::SEQUENCE, 0);
}


size_t SV3_1aParser::Bins_or_optionsContext::getRuleIndex() const {
  return SV3_1aParser::RuleBins_or_options;
}

void SV3_1aParser::Bins_or_optionsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBins_or_options(this);
}

void SV3_1aParser::Bins_or_optionsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBins_or_options(this);
}

SV3_1aParser::Bins_or_optionsContext* SV3_1aParser::bins_or_options() {
  Bins_or_optionsContext *_localctx = _tracker.createInstance<Bins_or_optionsContext>(_ctx, getState());
  enterRule(_localctx, 536, SV3_1aParser::RuleBins_or_options);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(5168);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 566, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(5041);
      coverage_option();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(5043);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == SV3_1aParser::WILDCARD) {
        setState(5042);
        match(SV3_1aParser::WILDCARD);
      }
      setState(5045);
      bins_keyword();
      setState(5046);
      identifier();
      setState(5052);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == SV3_1aParser::OPEN_BRACKET) {
        setState(5047);
        match(SV3_1aParser::OPEN_BRACKET);
        setState(5049);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if ((((_la & ~ 0x3fULL) == 0) &&
          ((1ULL << _la) & 8796094922748) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 64)) & 1152648825725551617) != 0) || ((((_la - 147) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 147)) & 2199527096323) != 0) || _la == SV3_1aParser::BANG || ((((_la - 310) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 310)) & 559537073624154177) != 0)) {
          setState(5048);
          expression(0);
        }
        setState(5051);
        match(SV3_1aParser::CLOSE_BRACKET);
      }
      setState(5054);
      match(SV3_1aParser::ASSIGN_OP);
      setState(5055);
      match(SV3_1aParser::OPEN_CURLY);
      setState(5056);
      range_list();
      setState(5057);
      match(SV3_1aParser::CLOSE_CURLY);
      setState(5063);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == SV3_1aParser::WITH) {
        setState(5058);
        match(SV3_1aParser::WITH);
        setState(5059);
        match(SV3_1aParser::OPEN_PARENS);
        setState(5060);
        expression(0);
        setState(5061);
        match(SV3_1aParser::CLOSE_PARENS);
      }
      setState(5070);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == SV3_1aParser::IFF) {
        setState(5065);
        match(SV3_1aParser::IFF);
        setState(5066);
        match(SV3_1aParser::OPEN_PARENS);
        setState(5067);
        expression(0);
        setState(5068);
        match(SV3_1aParser::CLOSE_PARENS);
      }
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(5073);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == SV3_1aParser::WILDCARD) {
        setState(5072);
        match(SV3_1aParser::WILDCARD);
      }
      setState(5075);
      bins_keyword();
      setState(5076);
      identifier();
      setState(5082);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == SV3_1aParser::OPEN_BRACKET) {
        setState(5077);
        match(SV3_1aParser::OPEN_BRACKET);
        setState(5079);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if ((((_la & ~ 0x3fULL) == 0) &&
          ((1ULL << _la) & 8796094922748) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 64)) & 1152648825725551617) != 0) || ((((_la - 147) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 147)) & 2199527096323) != 0) || _la == SV3_1aParser::BANG || ((((_la - 310) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 310)) & 559537073624154177) != 0)) {
          setState(5078);
          expression(0);
        }
        setState(5081);
        match(SV3_1aParser::CLOSE_BRACKET);
      }
      setState(5084);
      match(SV3_1aParser::ASSIGN_OP);
      setState(5085);
      identifier();
      setState(5091);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == SV3_1aParser::WITH) {
        setState(5086);
        match(SV3_1aParser::WITH);
        setState(5087);
        match(SV3_1aParser::OPEN_PARENS);
        setState(5088);
        expression(0);
        setState(5089);
        match(SV3_1aParser::CLOSE_PARENS);
      }
      setState(5098);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == SV3_1aParser::IFF) {
        setState(5093);
        match(SV3_1aParser::IFF);
        setState(5094);
        match(SV3_1aParser::OPEN_PARENS);
        setState(5095);
        expression(0);
        setState(5096);
        match(SV3_1aParser::CLOSE_PARENS);
      }
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(5101);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == SV3_1aParser::WILDCARD) {
        setState(5100);
        match(SV3_1aParser::WILDCARD);
      }
      setState(5103);
      bins_keyword();
      setState(5104);
      identifier();
      setState(5110);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == SV3_1aParser::OPEN_BRACKET) {
        setState(5105);
        match(SV3_1aParser::OPEN_BRACKET);
        setState(5107);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if ((((_la & ~ 0x3fULL) == 0) &&
          ((1ULL << _la) & 8796094922748) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 64)) & 1152648825725551617) != 0) || ((((_la - 147) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 147)) & 2199527096323) != 0) || _la == SV3_1aParser::BANG || ((((_la - 310) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 310)) & 559537073624154177) != 0)) {
          setState(5106);
          expression(0);
        }
        setState(5109);
        match(SV3_1aParser::CLOSE_BRACKET);
      }
      setState(5112);
      match(SV3_1aParser::ASSIGN_OP);
      setState(5113);
      expression(0);
      setState(5119);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == SV3_1aParser::IFF) {
        setState(5114);
        match(SV3_1aParser::IFF);
        setState(5115);
        match(SV3_1aParser::OPEN_PARENS);
        setState(5116);
        expression(0);
        setState(5117);
        match(SV3_1aParser::CLOSE_PARENS);
      }
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(5122);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == SV3_1aParser::WILDCARD) {
        setState(5121);
        match(SV3_1aParser::WILDCARD);
      }
      setState(5124);
      bins_keyword();
      setState(5125);
      identifier();
      setState(5127);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == SV3_1aParser::OPEN_BRACKET) {
        setState(5126);
        unsized_dimension();
      }
      setState(5129);
      match(SV3_1aParser::ASSIGN_OP);
      setState(5130);
      trans_list();
      setState(5136);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == SV3_1aParser::IFF) {
        setState(5131);
        match(SV3_1aParser::IFF);
        setState(5132);
        match(SV3_1aParser::OPEN_PARENS);
        setState(5133);
        expression(0);
        setState(5134);
        match(SV3_1aParser::CLOSE_PARENS);
      }
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(5138);
      bins_keyword();
      setState(5139);
      identifier();
      setState(5145);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == SV3_1aParser::OPEN_BRACKET) {
        setState(5140);
        match(SV3_1aParser::OPEN_BRACKET);
        setState(5142);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if ((((_la & ~ 0x3fULL) == 0) &&
          ((1ULL << _la) & 8796094922748) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 64)) & 1152648825725551617) != 0) || ((((_la - 147) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 147)) & 2199527096323) != 0) || _la == SV3_1aParser::BANG || ((((_la - 310) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 310)) & 559537073624154177) != 0)) {
          setState(5141);
          expression(0);
        }
        setState(5144);
        match(SV3_1aParser::CLOSE_BRACKET);
      }
      setState(5147);
      match(SV3_1aParser::ASSIGN_OP);
      setState(5148);
      match(SV3_1aParser::DEFAULT);
      setState(5154);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == SV3_1aParser::IFF) {
        setState(5149);
        match(SV3_1aParser::IFF);
        setState(5150);
        match(SV3_1aParser::OPEN_PARENS);
        setState(5151);
        expression(0);
        setState(5152);
        match(SV3_1aParser::CLOSE_PARENS);
      }
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(5156);
      bins_keyword();
      setState(5157);
      identifier();
      setState(5158);
      match(SV3_1aParser::ASSIGN_OP);
      setState(5159);
      match(SV3_1aParser::DEFAULT);
      setState(5160);
      match(SV3_1aParser::SEQUENCE);
      setState(5166);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == SV3_1aParser::IFF) {
        setState(5161);
        match(SV3_1aParser::IFF);
        setState(5162);
        match(SV3_1aParser::OPEN_PARENS);
        setState(5163);
        expression(0);
        setState(5164);
        match(SV3_1aParser::CLOSE_PARENS);
      }
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Bins_keywordContext ------------------------------------------------------------------

SV3_1aParser::Bins_keywordContext::Bins_keywordContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t SV3_1aParser::Bins_keywordContext::getRuleIndex() const {
  return SV3_1aParser::RuleBins_keyword;
}

void SV3_1aParser::Bins_keywordContext::copyFrom(Bins_keywordContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- Bins_IgnoreContext ------------------------------------------------------------------

tree::TerminalNode* SV3_1aParser::Bins_IgnoreContext::IGNORE_BINS() {
  return getToken(SV3_1aParser::IGNORE_BINS, 0);
}

SV3_1aParser::Bins_IgnoreContext::Bins_IgnoreContext(Bins_keywordContext *ctx) { copyFrom(ctx); }

void SV3_1aParser::Bins_IgnoreContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBins_Ignore(this);
}
void SV3_1aParser::Bins_IgnoreContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBins_Ignore(this);
}
//----------------- Bins_BinsContext ------------------------------------------------------------------

tree::TerminalNode* SV3_1aParser::Bins_BinsContext::BINS() {
  return getToken(SV3_1aParser::BINS, 0);
}

SV3_1aParser::Bins_BinsContext::Bins_BinsContext(Bins_keywordContext *ctx) { copyFrom(ctx); }

void SV3_1aParser::Bins_BinsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBins_Bins(this);
}
void SV3_1aParser::Bins_BinsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBins_Bins(this);
}
//----------------- Bins_IllegalContext ------------------------------------------------------------------

tree::TerminalNode* SV3_1aParser::Bins_IllegalContext::ILLEGAL_BINS() {
  return getToken(SV3_1aParser::ILLEGAL_BINS, 0);
}

SV3_1aParser::Bins_IllegalContext::Bins_IllegalContext(Bins_keywordContext *ctx) { copyFrom(ctx); }

void SV3_1aParser::Bins_IllegalContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBins_Illegal(this);
}
void SV3_1aParser::Bins_IllegalContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBins_Illegal(this);
}
SV3_1aParser::Bins_keywordContext* SV3_1aParser::bins_keyword() {
  Bins_keywordContext *_localctx = _tracker.createInstance<Bins_keywordContext>(_ctx, getState());
  enterRule(_localctx, 538, SV3_1aParser::RuleBins_keyword);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(5173);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SV3_1aParser::BINS: {
        _localctx = _tracker.createInstance<SV3_1aParser::Bins_BinsContext>(_localctx);
        enterOuterAlt(_localctx, 1);
        setState(5170);
        match(SV3_1aParser::BINS);
        break;
      }

      case SV3_1aParser::ILLEGAL_BINS: {
        _localctx = _tracker.createInstance<SV3_1aParser::Bins_IllegalContext>(_localctx);
        enterOuterAlt(_localctx, 2);
        setState(5171);
        match(SV3_1aParser::ILLEGAL_BINS);
        break;
      }

      case SV3_1aParser::IGNORE_BINS: {
        _localctx = _tracker.createInstance<SV3_1aParser::Bins_IgnoreContext>(_localctx);
        enterOuterAlt(_localctx, 3);
        setState(5172);
        match(SV3_1aParser::IGNORE_BINS);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Range_listContext ------------------------------------------------------------------

SV3_1aParser::Range_listContext::Range_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<SV3_1aParser::Value_rangeContext *> SV3_1aParser::Range_listContext::value_range() {
  return getRuleContexts<SV3_1aParser::Value_rangeContext>();
}

SV3_1aParser::Value_rangeContext* SV3_1aParser::Range_listContext::value_range(size_t i) {
  return getRuleContext<SV3_1aParser::Value_rangeContext>(i);
}

std::vector<tree::TerminalNode *> SV3_1aParser::Range_listContext::COMMA() {
  return getTokens(SV3_1aParser::COMMA);
}

tree::TerminalNode* SV3_1aParser::Range_listContext::COMMA(size_t i) {
  return getToken(SV3_1aParser::COMMA, i);
}


size_t SV3_1aParser::Range_listContext::getRuleIndex() const {
  return SV3_1aParser::RuleRange_list;
}

void SV3_1aParser::Range_listContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRange_list(this);
}

void SV3_1aParser::Range_listContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRange_list(this);
}

SV3_1aParser::Range_listContext* SV3_1aParser::range_list() {
  Range_listContext *_localctx = _tracker.createInstance<Range_listContext>(_ctx, getState());
  enterRule(_localctx, 540, SV3_1aParser::RuleRange_list);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5175);
    value_range();
    setState(5180);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == SV3_1aParser::COMMA) {
      setState(5176);
      match(SV3_1aParser::COMMA);
      setState(5177);
      value_range();
      setState(5182);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Trans_listContext ------------------------------------------------------------------

SV3_1aParser::Trans_listContext::Trans_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> SV3_1aParser::Trans_listContext::OPEN_PARENS() {
  return getTokens(SV3_1aParser::OPEN_PARENS);
}

tree::TerminalNode* SV3_1aParser::Trans_listContext::OPEN_PARENS(size_t i) {
  return getToken(SV3_1aParser::OPEN_PARENS, i);
}

std::vector<SV3_1aParser::Trans_setContext *> SV3_1aParser::Trans_listContext::trans_set() {
  return getRuleContexts<SV3_1aParser::Trans_setContext>();
}

SV3_1aParser::Trans_setContext* SV3_1aParser::Trans_listContext::trans_set(size_t i) {
  return getRuleContext<SV3_1aParser::Trans_setContext>(i);
}

std::vector<tree::TerminalNode *> SV3_1aParser::Trans_listContext::CLOSE_PARENS() {
  return getTokens(SV3_1aParser::CLOSE_PARENS);
}

tree::TerminalNode* SV3_1aParser::Trans_listContext::CLOSE_PARENS(size_t i) {
  return getToken(SV3_1aParser::CLOSE_PARENS, i);
}

std::vector<tree::TerminalNode *> SV3_1aParser::Trans_listContext::COMMA() {
  return getTokens(SV3_1aParser::COMMA);
}

tree::TerminalNode* SV3_1aParser::Trans_listContext::COMMA(size_t i) {
  return getToken(SV3_1aParser::COMMA, i);
}


size_t SV3_1aParser::Trans_listContext::getRuleIndex() const {
  return SV3_1aParser::RuleTrans_list;
}

void SV3_1aParser::Trans_listContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTrans_list(this);
}

void SV3_1aParser::Trans_listContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTrans_list(this);
}

SV3_1aParser::Trans_listContext* SV3_1aParser::trans_list() {
  Trans_listContext *_localctx = _tracker.createInstance<Trans_listContext>(_ctx, getState());
  enterRule(_localctx, 542, SV3_1aParser::RuleTrans_list);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5183);
    match(SV3_1aParser::OPEN_PARENS);
    setState(5184);
    trans_set();
    setState(5185);
    match(SV3_1aParser::CLOSE_PARENS);
    setState(5193);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == SV3_1aParser::COMMA) {
      setState(5186);
      match(SV3_1aParser::COMMA);
      setState(5187);
      match(SV3_1aParser::OPEN_PARENS);
      setState(5188);
      trans_set();
      setState(5189);
      match(SV3_1aParser::CLOSE_PARENS);
      setState(5195);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Trans_setContext ------------------------------------------------------------------

SV3_1aParser::Trans_setContext::Trans_setContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<SV3_1aParser::Trans_range_listContext *> SV3_1aParser::Trans_setContext::trans_range_list() {
  return getRuleContexts<SV3_1aParser::Trans_range_listContext>();
}

SV3_1aParser::Trans_range_listContext* SV3_1aParser::Trans_setContext::trans_range_list(size_t i) {
  return getRuleContext<SV3_1aParser::Trans_range_listContext>(i);
}

std::vector<tree::TerminalNode *> SV3_1aParser::Trans_setContext::TRANSITION_OP() {
  return getTokens(SV3_1aParser::TRANSITION_OP);
}

tree::TerminalNode* SV3_1aParser::Trans_setContext::TRANSITION_OP(size_t i) {
  return getToken(SV3_1aParser::TRANSITION_OP, i);
}


size_t SV3_1aParser::Trans_setContext::getRuleIndex() const {
  return SV3_1aParser::RuleTrans_set;
}

void SV3_1aParser::Trans_setContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTrans_set(this);
}

void SV3_1aParser::Trans_setContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTrans_set(this);
}

SV3_1aParser::Trans_setContext* SV3_1aParser::trans_set() {
  Trans_setContext *_localctx = _tracker.createInstance<Trans_setContext>(_ctx, getState());
  enterRule(_localctx, 544, SV3_1aParser::RuleTrans_set);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5196);
    trans_range_list();
    setState(5201);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == SV3_1aParser::TRANSITION_OP) {
      setState(5197);
      match(SV3_1aParser::TRANSITION_OP);
      setState(5198);
      trans_range_list();
      setState(5203);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Trans_range_listContext ------------------------------------------------------------------

SV3_1aParser::Trans_range_listContext::Trans_range_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::Range_listContext* SV3_1aParser::Trans_range_listContext::range_list() {
  return getRuleContext<SV3_1aParser::Range_listContext>(0);
}

tree::TerminalNode* SV3_1aParser::Trans_range_listContext::CONSECUTIVE_REP() {
  return getToken(SV3_1aParser::CONSECUTIVE_REP, 0);
}

SV3_1aParser::Repeat_rangeContext* SV3_1aParser::Trans_range_listContext::repeat_range() {
  return getRuleContext<SV3_1aParser::Repeat_rangeContext>(0);
}

tree::TerminalNode* SV3_1aParser::Trans_range_listContext::CLOSE_BRACKET() {
  return getToken(SV3_1aParser::CLOSE_BRACKET, 0);
}

tree::TerminalNode* SV3_1aParser::Trans_range_listContext::GOTO_REP() {
  return getToken(SV3_1aParser::GOTO_REP, 0);
}

tree::TerminalNode* SV3_1aParser::Trans_range_listContext::NON_CONSECUTIVE_REP() {
  return getToken(SV3_1aParser::NON_CONSECUTIVE_REP, 0);
}


size_t SV3_1aParser::Trans_range_listContext::getRuleIndex() const {
  return SV3_1aParser::RuleTrans_range_list;
}

void SV3_1aParser::Trans_range_listContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTrans_range_list(this);
}

void SV3_1aParser::Trans_range_listContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTrans_range_list(this);
}

SV3_1aParser::Trans_range_listContext* SV3_1aParser::trans_range_list() {
  Trans_range_listContext *_localctx = _tracker.createInstance<Trans_range_listContext>(_ctx, getState());
  enterRule(_localctx, 546, SV3_1aParser::RuleTrans_range_list);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(5220);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 571, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(5204);
      range_list();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(5205);
      range_list();
      setState(5206);
      match(SV3_1aParser::CONSECUTIVE_REP);
      setState(5207);
      repeat_range();
      setState(5208);
      match(SV3_1aParser::CLOSE_BRACKET);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(5210);
      range_list();
      setState(5211);
      match(SV3_1aParser::GOTO_REP);
      setState(5212);
      repeat_range();
      setState(5213);
      match(SV3_1aParser::CLOSE_BRACKET);
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(5215);
      range_list();
      setState(5216);
      match(SV3_1aParser::NON_CONSECUTIVE_REP);
      setState(5217);
      repeat_range();
      setState(5218);
      match(SV3_1aParser::CLOSE_BRACKET);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Repeat_rangeContext ------------------------------------------------------------------

SV3_1aParser::Repeat_rangeContext::Repeat_rangeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<SV3_1aParser::ExpressionContext *> SV3_1aParser::Repeat_rangeContext::expression() {
  return getRuleContexts<SV3_1aParser::ExpressionContext>();
}

SV3_1aParser::ExpressionContext* SV3_1aParser::Repeat_rangeContext::expression(size_t i) {
  return getRuleContext<SV3_1aParser::ExpressionContext>(i);
}

tree::TerminalNode* SV3_1aParser::Repeat_rangeContext::COLON() {
  return getToken(SV3_1aParser::COLON, 0);
}


size_t SV3_1aParser::Repeat_rangeContext::getRuleIndex() const {
  return SV3_1aParser::RuleRepeat_range;
}

void SV3_1aParser::Repeat_rangeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRepeat_range(this);
}

void SV3_1aParser::Repeat_rangeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRepeat_range(this);
}

SV3_1aParser::Repeat_rangeContext* SV3_1aParser::repeat_range() {
  Repeat_rangeContext *_localctx = _tracker.createInstance<Repeat_rangeContext>(_ctx, getState());
  enterRule(_localctx, 548, SV3_1aParser::RuleRepeat_range);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(5227);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 572, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(5222);
      expression(0);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(5223);
      expression(0);
      setState(5224);
      match(SV3_1aParser::COLON);
      setState(5225);
      expression(0);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Cover_crossContext ------------------------------------------------------------------

SV3_1aParser::Cover_crossContext::Cover_crossContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Cover_crossContext::CROSS() {
  return getToken(SV3_1aParser::CROSS, 0);
}

SV3_1aParser::List_of_cross_itemsContext* SV3_1aParser::Cover_crossContext::list_of_cross_items() {
  return getRuleContext<SV3_1aParser::List_of_cross_itemsContext>(0);
}

SV3_1aParser::Cross_bodyContext* SV3_1aParser::Cover_crossContext::cross_body() {
  return getRuleContext<SV3_1aParser::Cross_bodyContext>(0);
}

SV3_1aParser::IdentifierContext* SV3_1aParser::Cover_crossContext::identifier() {
  return getRuleContext<SV3_1aParser::IdentifierContext>(0);
}

tree::TerminalNode* SV3_1aParser::Cover_crossContext::COLON() {
  return getToken(SV3_1aParser::COLON, 0);
}

tree::TerminalNode* SV3_1aParser::Cover_crossContext::IFF() {
  return getToken(SV3_1aParser::IFF, 0);
}

tree::TerminalNode* SV3_1aParser::Cover_crossContext::OPEN_PARENS() {
  return getToken(SV3_1aParser::OPEN_PARENS, 0);
}

SV3_1aParser::ExpressionContext* SV3_1aParser::Cover_crossContext::expression() {
  return getRuleContext<SV3_1aParser::ExpressionContext>(0);
}

tree::TerminalNode* SV3_1aParser::Cover_crossContext::CLOSE_PARENS() {
  return getToken(SV3_1aParser::CLOSE_PARENS, 0);
}


size_t SV3_1aParser::Cover_crossContext::getRuleIndex() const {
  return SV3_1aParser::RuleCover_cross;
}

void SV3_1aParser::Cover_crossContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCover_cross(this);
}

void SV3_1aParser::Cover_crossContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCover_cross(this);
}

SV3_1aParser::Cover_crossContext* SV3_1aParser::cover_cross() {
  Cover_crossContext *_localctx = _tracker.createInstance<Cover_crossContext>(_ctx, getState());
  enterRule(_localctx, 550, SV3_1aParser::RuleCover_cross);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5232);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (((((_la - 326) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 326)) & 4672924483589) != 0)) {
      setState(5229);
      identifier();
      setState(5230);
      match(SV3_1aParser::COLON);
    }
    setState(5234);
    match(SV3_1aParser::CROSS);
    setState(5235);
    list_of_cross_items();
    setState(5241);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SV3_1aParser::IFF) {
      setState(5236);
      match(SV3_1aParser::IFF);
      setState(5237);
      match(SV3_1aParser::OPEN_PARENS);
      setState(5238);
      expression(0);
      setState(5239);
      match(SV3_1aParser::CLOSE_PARENS);
    }
    setState(5243);
    cross_body();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- List_of_cross_itemsContext ------------------------------------------------------------------

SV3_1aParser::List_of_cross_itemsContext::List_of_cross_itemsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<SV3_1aParser::Cross_itemContext *> SV3_1aParser::List_of_cross_itemsContext::cross_item() {
  return getRuleContexts<SV3_1aParser::Cross_itemContext>();
}

SV3_1aParser::Cross_itemContext* SV3_1aParser::List_of_cross_itemsContext::cross_item(size_t i) {
  return getRuleContext<SV3_1aParser::Cross_itemContext>(i);
}

std::vector<tree::TerminalNode *> SV3_1aParser::List_of_cross_itemsContext::COMMA() {
  return getTokens(SV3_1aParser::COMMA);
}

tree::TerminalNode* SV3_1aParser::List_of_cross_itemsContext::COMMA(size_t i) {
  return getToken(SV3_1aParser::COMMA, i);
}


size_t SV3_1aParser::List_of_cross_itemsContext::getRuleIndex() const {
  return SV3_1aParser::RuleList_of_cross_items;
}

void SV3_1aParser::List_of_cross_itemsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterList_of_cross_items(this);
}

void SV3_1aParser::List_of_cross_itemsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitList_of_cross_items(this);
}

SV3_1aParser::List_of_cross_itemsContext* SV3_1aParser::list_of_cross_items() {
  List_of_cross_itemsContext *_localctx = _tracker.createInstance<List_of_cross_itemsContext>(_ctx, getState());
  enterRule(_localctx, 552, SV3_1aParser::RuleList_of_cross_items);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5245);
    cross_item();
    setState(5246);
    match(SV3_1aParser::COMMA);
    setState(5247);
    cross_item();
    setState(5252);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == SV3_1aParser::COMMA) {
      setState(5248);
      match(SV3_1aParser::COMMA);
      setState(5249);
      cross_item();
      setState(5254);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Cross_itemContext ------------------------------------------------------------------

SV3_1aParser::Cross_itemContext::Cross_itemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::IdentifierContext* SV3_1aParser::Cross_itemContext::identifier() {
  return getRuleContext<SV3_1aParser::IdentifierContext>(0);
}


size_t SV3_1aParser::Cross_itemContext::getRuleIndex() const {
  return SV3_1aParser::RuleCross_item;
}

void SV3_1aParser::Cross_itemContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCross_item(this);
}

void SV3_1aParser::Cross_itemContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCross_item(this);
}

SV3_1aParser::Cross_itemContext* SV3_1aParser::cross_item() {
  Cross_itemContext *_localctx = _tracker.createInstance<Cross_itemContext>(_ctx, getState());
  enterRule(_localctx, 554, SV3_1aParser::RuleCross_item);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5255);
    identifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Cross_bodyContext ------------------------------------------------------------------

SV3_1aParser::Cross_bodyContext::Cross_bodyContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Cross_bodyContext::OPEN_CURLY() {
  return getToken(SV3_1aParser::OPEN_CURLY, 0);
}

tree::TerminalNode* SV3_1aParser::Cross_bodyContext::CLOSE_CURLY() {
  return getToken(SV3_1aParser::CLOSE_CURLY, 0);
}

std::vector<SV3_1aParser::Cross_body_itemContext *> SV3_1aParser::Cross_bodyContext::cross_body_item() {
  return getRuleContexts<SV3_1aParser::Cross_body_itemContext>();
}

SV3_1aParser::Cross_body_itemContext* SV3_1aParser::Cross_bodyContext::cross_body_item(size_t i) {
  return getRuleContext<SV3_1aParser::Cross_body_itemContext>(i);
}

tree::TerminalNode* SV3_1aParser::Cross_bodyContext::SEMICOLON() {
  return getToken(SV3_1aParser::SEMICOLON, 0);
}


size_t SV3_1aParser::Cross_bodyContext::getRuleIndex() const {
  return SV3_1aParser::RuleCross_body;
}

void SV3_1aParser::Cross_bodyContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCross_body(this);
}

void SV3_1aParser::Cross_bodyContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCross_body(this);
}

SV3_1aParser::Cross_bodyContext* SV3_1aParser::cross_body() {
  Cross_bodyContext *_localctx = _tracker.createInstance<Cross_bodyContext>(_ctx, getState());
  enterRule(_localctx, 556, SV3_1aParser::RuleCross_body);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(5266);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SV3_1aParser::OPEN_CURLY: {
        enterOuterAlt(_localctx, 1);
        setState(5257);
        match(SV3_1aParser::OPEN_CURLY);
        setState(5261);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == SV3_1aParser::FUNCTION || ((((_la - 189) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 189)) & 968515125249) != 0)) {
          setState(5258);
          cross_body_item();
          setState(5263);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(5264);
        match(SV3_1aParser::CLOSE_CURLY);
        break;
      }

      case SV3_1aParser::SEMICOLON: {
        enterOuterAlt(_localctx, 2);
        setState(5265);
        match(SV3_1aParser::SEMICOLON);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Cross_body_itemContext ------------------------------------------------------------------

SV3_1aParser::Cross_body_itemContext::Cross_body_itemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::Function_declarationContext* SV3_1aParser::Cross_body_itemContext::function_declaration() {
  return getRuleContext<SV3_1aParser::Function_declarationContext>(0);
}

SV3_1aParser::Bins_selection_or_optionContext* SV3_1aParser::Cross_body_itemContext::bins_selection_or_option() {
  return getRuleContext<SV3_1aParser::Bins_selection_or_optionContext>(0);
}

tree::TerminalNode* SV3_1aParser::Cross_body_itemContext::SEMICOLON() {
  return getToken(SV3_1aParser::SEMICOLON, 0);
}


size_t SV3_1aParser::Cross_body_itemContext::getRuleIndex() const {
  return SV3_1aParser::RuleCross_body_item;
}

void SV3_1aParser::Cross_body_itemContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCross_body_item(this);
}

void SV3_1aParser::Cross_body_itemContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCross_body_item(this);
}

SV3_1aParser::Cross_body_itemContext* SV3_1aParser::cross_body_item() {
  Cross_body_itemContext *_localctx = _tracker.createInstance<Cross_body_itemContext>(_ctx, getState());
  enterRule(_localctx, 558, SV3_1aParser::RuleCross_body_item);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(5272);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SV3_1aParser::FUNCTION: {
        enterOuterAlt(_localctx, 1);
        setState(5268);
        function_declaration();
        break;
      }

      case SV3_1aParser::OPEN_PARENS_STAR:
      case SV3_1aParser::OPTION_DOT:
      case SV3_1aParser::TYPE_OPTION_DOT:
      case SV3_1aParser::BINS:
      case SV3_1aParser::ILLEGAL_BINS:
      case SV3_1aParser::IGNORE_BINS: {
        enterOuterAlt(_localctx, 2);
        setState(5269);
        bins_selection_or_option();
        setState(5270);
        match(SV3_1aParser::SEMICOLON);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Bins_selection_or_optionContext ------------------------------------------------------------------

SV3_1aParser::Bins_selection_or_optionContext::Bins_selection_or_optionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::Coverage_optionContext* SV3_1aParser::Bins_selection_or_optionContext::coverage_option() {
  return getRuleContext<SV3_1aParser::Coverage_optionContext>(0);
}

SV3_1aParser::Bins_selectionContext* SV3_1aParser::Bins_selection_or_optionContext::bins_selection() {
  return getRuleContext<SV3_1aParser::Bins_selectionContext>(0);
}

std::vector<SV3_1aParser::Attribute_instanceContext *> SV3_1aParser::Bins_selection_or_optionContext::attribute_instance() {
  return getRuleContexts<SV3_1aParser::Attribute_instanceContext>();
}

SV3_1aParser::Attribute_instanceContext* SV3_1aParser::Bins_selection_or_optionContext::attribute_instance(size_t i) {
  return getRuleContext<SV3_1aParser::Attribute_instanceContext>(i);
}


size_t SV3_1aParser::Bins_selection_or_optionContext::getRuleIndex() const {
  return SV3_1aParser::RuleBins_selection_or_option;
}

void SV3_1aParser::Bins_selection_or_optionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBins_selection_or_option(this);
}

void SV3_1aParser::Bins_selection_or_optionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBins_selection_or_option(this);
}

SV3_1aParser::Bins_selection_or_optionContext* SV3_1aParser::bins_selection_or_option() {
  Bins_selection_or_optionContext *_localctx = _tracker.createInstance<Bins_selection_or_optionContext>(_ctx, getState());
  enterRule(_localctx, 560, SV3_1aParser::RuleBins_selection_or_option);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5277);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == SV3_1aParser::OPEN_PARENS_STAR) {
      setState(5274);
      attribute_instance();
      setState(5279);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(5282);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SV3_1aParser::OPTION_DOT:
      case SV3_1aParser::TYPE_OPTION_DOT: {
        setState(5280);
        coverage_option();
        break;
      }

      case SV3_1aParser::BINS:
      case SV3_1aParser::ILLEGAL_BINS:
      case SV3_1aParser::IGNORE_BINS: {
        setState(5281);
        bins_selection();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Bins_selectionContext ------------------------------------------------------------------

SV3_1aParser::Bins_selectionContext::Bins_selectionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::Bins_keywordContext* SV3_1aParser::Bins_selectionContext::bins_keyword() {
  return getRuleContext<SV3_1aParser::Bins_keywordContext>(0);
}

SV3_1aParser::IdentifierContext* SV3_1aParser::Bins_selectionContext::identifier() {
  return getRuleContext<SV3_1aParser::IdentifierContext>(0);
}

tree::TerminalNode* SV3_1aParser::Bins_selectionContext::ASSIGN_OP() {
  return getToken(SV3_1aParser::ASSIGN_OP, 0);
}

SV3_1aParser::Select_expressionContext* SV3_1aParser::Bins_selectionContext::select_expression() {
  return getRuleContext<SV3_1aParser::Select_expressionContext>(0);
}

tree::TerminalNode* SV3_1aParser::Bins_selectionContext::IFF() {
  return getToken(SV3_1aParser::IFF, 0);
}

tree::TerminalNode* SV3_1aParser::Bins_selectionContext::OPEN_PARENS() {
  return getToken(SV3_1aParser::OPEN_PARENS, 0);
}

SV3_1aParser::ExpressionContext* SV3_1aParser::Bins_selectionContext::expression() {
  return getRuleContext<SV3_1aParser::ExpressionContext>(0);
}

tree::TerminalNode* SV3_1aParser::Bins_selectionContext::CLOSE_PARENS() {
  return getToken(SV3_1aParser::CLOSE_PARENS, 0);
}


size_t SV3_1aParser::Bins_selectionContext::getRuleIndex() const {
  return SV3_1aParser::RuleBins_selection;
}

void SV3_1aParser::Bins_selectionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBins_selection(this);
}

void SV3_1aParser::Bins_selectionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBins_selection(this);
}

SV3_1aParser::Bins_selectionContext* SV3_1aParser::bins_selection() {
  Bins_selectionContext *_localctx = _tracker.createInstance<Bins_selectionContext>(_ctx, getState());
  enterRule(_localctx, 562, SV3_1aParser::RuleBins_selection);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5284);
    bins_keyword();
    setState(5285);
    identifier();
    setState(5286);
    match(SV3_1aParser::ASSIGN_OP);
    setState(5287);
    select_expression(0);
    setState(5293);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SV3_1aParser::IFF) {
      setState(5288);
      match(SV3_1aParser::IFF);
      setState(5289);
      match(SV3_1aParser::OPEN_PARENS);
      setState(5290);
      expression(0);
      setState(5291);
      match(SV3_1aParser::CLOSE_PARENS);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Select_expressionContext ------------------------------------------------------------------

SV3_1aParser::Select_expressionContext::Select_expressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::Select_conditionContext* SV3_1aParser::Select_expressionContext::select_condition() {
  return getRuleContext<SV3_1aParser::Select_conditionContext>(0);
}

tree::TerminalNode* SV3_1aParser::Select_expressionContext::BANG() {
  return getToken(SV3_1aParser::BANG, 0);
}

tree::TerminalNode* SV3_1aParser::Select_expressionContext::OPEN_PARENS() {
  return getToken(SV3_1aParser::OPEN_PARENS, 0);
}

std::vector<SV3_1aParser::Select_expressionContext *> SV3_1aParser::Select_expressionContext::select_expression() {
  return getRuleContexts<SV3_1aParser::Select_expressionContext>();
}

SV3_1aParser::Select_expressionContext* SV3_1aParser::Select_expressionContext::select_expression(size_t i) {
  return getRuleContext<SV3_1aParser::Select_expressionContext>(i);
}

tree::TerminalNode* SV3_1aParser::Select_expressionContext::CLOSE_PARENS() {
  return getToken(SV3_1aParser::CLOSE_PARENS, 0);
}

SV3_1aParser::IdentifierContext* SV3_1aParser::Select_expressionContext::identifier() {
  return getRuleContext<SV3_1aParser::IdentifierContext>(0);
}

std::vector<SV3_1aParser::ExpressionContext *> SV3_1aParser::Select_expressionContext::expression() {
  return getRuleContexts<SV3_1aParser::ExpressionContext>();
}

SV3_1aParser::ExpressionContext* SV3_1aParser::Select_expressionContext::expression(size_t i) {
  return getRuleContext<SV3_1aParser::ExpressionContext>(i);
}

SV3_1aParser::MatchesContext* SV3_1aParser::Select_expressionContext::matches() {
  return getRuleContext<SV3_1aParser::MatchesContext>(0);
}

tree::TerminalNode* SV3_1aParser::Select_expressionContext::LOGICAL_AND() {
  return getToken(SV3_1aParser::LOGICAL_AND, 0);
}

tree::TerminalNode* SV3_1aParser::Select_expressionContext::LOGICAL_OR() {
  return getToken(SV3_1aParser::LOGICAL_OR, 0);
}

tree::TerminalNode* SV3_1aParser::Select_expressionContext::WITH() {
  return getToken(SV3_1aParser::WITH, 0);
}


size_t SV3_1aParser::Select_expressionContext::getRuleIndex() const {
  return SV3_1aParser::RuleSelect_expression;
}

void SV3_1aParser::Select_expressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSelect_expression(this);
}

void SV3_1aParser::Select_expressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSelect_expression(this);
}


SV3_1aParser::Select_expressionContext* SV3_1aParser::select_expression() {
   return select_expression(0);
}

SV3_1aParser::Select_expressionContext* SV3_1aParser::select_expression(int precedence) {
  ParserRuleContext *parentContext = _ctx;
  size_t parentState = getState();
  SV3_1aParser::Select_expressionContext *_localctx = _tracker.createInstance<Select_expressionContext>(_ctx, parentState);
  SV3_1aParser::Select_expressionContext *previousContext = _localctx;
  (void)previousContext; // Silence compiler, in case the context is not used by generated code.
  size_t startState = 564;
  enterRecursionRule(_localctx, 564, SV3_1aParser::RuleSelect_expression, precedence);

    size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    unrollRecursionContexts(parentContext);
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(5310);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 583, _ctx)) {
    case 1: {
      setState(5296);
      select_condition();
      break;
    }

    case 2: {
      setState(5297);
      match(SV3_1aParser::BANG);
      setState(5298);
      select_condition();
      break;
    }

    case 3: {
      setState(5299);
      match(SV3_1aParser::OPEN_PARENS);
      setState(5300);
      select_expression(0);
      setState(5301);
      match(SV3_1aParser::CLOSE_PARENS);
      break;
    }

    case 4: {
      setState(5303);
      identifier();
      break;
    }

    case 5: {
      setState(5304);
      expression(0);
      setState(5308);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 582, _ctx)) {
      case 1: {
        setState(5305);
        matches();
        setState(5306);
        expression(0);
        break;
      }

      default:
        break;
      }
      break;
    }

    default:
      break;
    }
    _ctx->stop = _input->LT(-1);
    setState(5327);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 586, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        if (!_parseListeners.empty())
          triggerExitRuleEvent();
        previousContext = _localctx;
        setState(5325);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 585, _ctx)) {
        case 1: {
          _localctx = _tracker.createInstance<Select_expressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleSelect_expression);
          setState(5312);

          if (!(precpred(_ctx, 5))) throw FailedPredicateException(this, "precpred(_ctx, 5)");
          setState(5313);
          _la = _input->LA(1);
          if (!(_la == SV3_1aParser::LOGICAL_AND

          || _la == SV3_1aParser::LOGICAL_OR)) {
          _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
          setState(5314);
          select_expression(6);
          break;
        }

        case 2: {
          _localctx = _tracker.createInstance<Select_expressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleSelect_expression);
          setState(5315);

          if (!(precpred(_ctx, 3))) throw FailedPredicateException(this, "precpred(_ctx, 3)");
          setState(5316);
          match(SV3_1aParser::WITH);
          setState(5317);
          match(SV3_1aParser::OPEN_PARENS);
          setState(5318);
          expression(0);
          setState(5319);
          match(SV3_1aParser::CLOSE_PARENS);
          setState(5323);
          _errHandler->sync(this);

          switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 584, _ctx)) {
          case 1: {
            setState(5320);
            matches();
            setState(5321);
            expression(0);
            break;
          }

          default:
            break;
          }
          break;
        }

        default:
          break;
        } 
      }
      setState(5329);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 586, _ctx);
    }
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }
  return _localctx;
}

//----------------- Select_conditionContext ------------------------------------------------------------------

SV3_1aParser::Select_conditionContext::Select_conditionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Select_conditionContext::BINSOF() {
  return getToken(SV3_1aParser::BINSOF, 0);
}

tree::TerminalNode* SV3_1aParser::Select_conditionContext::OPEN_PARENS() {
  return getToken(SV3_1aParser::OPEN_PARENS, 0);
}

SV3_1aParser::Bins_expressionContext* SV3_1aParser::Select_conditionContext::bins_expression() {
  return getRuleContext<SV3_1aParser::Bins_expressionContext>(0);
}

tree::TerminalNode* SV3_1aParser::Select_conditionContext::CLOSE_PARENS() {
  return getToken(SV3_1aParser::CLOSE_PARENS, 0);
}

tree::TerminalNode* SV3_1aParser::Select_conditionContext::INTERSECT() {
  return getToken(SV3_1aParser::INTERSECT, 0);
}

tree::TerminalNode* SV3_1aParser::Select_conditionContext::OPEN_CURLY() {
  return getToken(SV3_1aParser::OPEN_CURLY, 0);
}

SV3_1aParser::Open_range_listContext* SV3_1aParser::Select_conditionContext::open_range_list() {
  return getRuleContext<SV3_1aParser::Open_range_listContext>(0);
}

tree::TerminalNode* SV3_1aParser::Select_conditionContext::CLOSE_CURLY() {
  return getToken(SV3_1aParser::CLOSE_CURLY, 0);
}


size_t SV3_1aParser::Select_conditionContext::getRuleIndex() const {
  return SV3_1aParser::RuleSelect_condition;
}

void SV3_1aParser::Select_conditionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSelect_condition(this);
}

void SV3_1aParser::Select_conditionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSelect_condition(this);
}

SV3_1aParser::Select_conditionContext* SV3_1aParser::select_condition() {
  Select_conditionContext *_localctx = _tracker.createInstance<Select_conditionContext>(_ctx, getState());
  enterRule(_localctx, 566, SV3_1aParser::RuleSelect_condition);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5330);
    match(SV3_1aParser::BINSOF);
    setState(5331);
    match(SV3_1aParser::OPEN_PARENS);
    setState(5332);
    bins_expression();
    setState(5333);
    match(SV3_1aParser::CLOSE_PARENS);
    setState(5339);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 587, _ctx)) {
    case 1: {
      setState(5334);
      match(SV3_1aParser::INTERSECT);
      setState(5335);
      match(SV3_1aParser::OPEN_CURLY);
      setState(5336);
      open_range_list();
      setState(5337);
      match(SV3_1aParser::CLOSE_CURLY);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Bins_expressionContext ------------------------------------------------------------------

SV3_1aParser::Bins_expressionContext::Bins_expressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<SV3_1aParser::IdentifierContext *> SV3_1aParser::Bins_expressionContext::identifier() {
  return getRuleContexts<SV3_1aParser::IdentifierContext>();
}

SV3_1aParser::IdentifierContext* SV3_1aParser::Bins_expressionContext::identifier(size_t i) {
  return getRuleContext<SV3_1aParser::IdentifierContext>(i);
}

tree::TerminalNode* SV3_1aParser::Bins_expressionContext::DOT() {
  return getToken(SV3_1aParser::DOT, 0);
}


size_t SV3_1aParser::Bins_expressionContext::getRuleIndex() const {
  return SV3_1aParser::RuleBins_expression;
}

void SV3_1aParser::Bins_expressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBins_expression(this);
}

void SV3_1aParser::Bins_expressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBins_expression(this);
}

SV3_1aParser::Bins_expressionContext* SV3_1aParser::bins_expression() {
  Bins_expressionContext *_localctx = _tracker.createInstance<Bins_expressionContext>(_ctx, getState());
  enterRule(_localctx, 568, SV3_1aParser::RuleBins_expression);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5341);
    identifier();
    setState(5344);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SV3_1aParser::DOT) {
      setState(5342);
      match(SV3_1aParser::DOT);
      setState(5343);
      identifier();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Open_range_listContext ------------------------------------------------------------------

SV3_1aParser::Open_range_listContext::Open_range_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<SV3_1aParser::Value_rangeContext *> SV3_1aParser::Open_range_listContext::value_range() {
  return getRuleContexts<SV3_1aParser::Value_rangeContext>();
}

SV3_1aParser::Value_rangeContext* SV3_1aParser::Open_range_listContext::value_range(size_t i) {
  return getRuleContext<SV3_1aParser::Value_rangeContext>(i);
}

std::vector<tree::TerminalNode *> SV3_1aParser::Open_range_listContext::COMMA() {
  return getTokens(SV3_1aParser::COMMA);
}

tree::TerminalNode* SV3_1aParser::Open_range_listContext::COMMA(size_t i) {
  return getToken(SV3_1aParser::COMMA, i);
}


size_t SV3_1aParser::Open_range_listContext::getRuleIndex() const {
  return SV3_1aParser::RuleOpen_range_list;
}

void SV3_1aParser::Open_range_listContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOpen_range_list(this);
}

void SV3_1aParser::Open_range_listContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOpen_range_list(this);
}

SV3_1aParser::Open_range_listContext* SV3_1aParser::open_range_list() {
  Open_range_listContext *_localctx = _tracker.createInstance<Open_range_listContext>(_ctx, getState());
  enterRule(_localctx, 570, SV3_1aParser::RuleOpen_range_list);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5346);
    value_range();
    setState(5351);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == SV3_1aParser::COMMA) {
      setState(5347);
      match(SV3_1aParser::COMMA);
      setState(5348);
      value_range();
      setState(5353);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Gate_instantiationContext ------------------------------------------------------------------

SV3_1aParser::Gate_instantiationContext::Gate_instantiationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::Cmos_switchtypeContext* SV3_1aParser::Gate_instantiationContext::cmos_switchtype() {
  return getRuleContext<SV3_1aParser::Cmos_switchtypeContext>(0);
}

std::vector<SV3_1aParser::Cmos_switch_instanceContext *> SV3_1aParser::Gate_instantiationContext::cmos_switch_instance() {
  return getRuleContexts<SV3_1aParser::Cmos_switch_instanceContext>();
}

SV3_1aParser::Cmos_switch_instanceContext* SV3_1aParser::Gate_instantiationContext::cmos_switch_instance(size_t i) {
  return getRuleContext<SV3_1aParser::Cmos_switch_instanceContext>(i);
}

tree::TerminalNode* SV3_1aParser::Gate_instantiationContext::SEMICOLON() {
  return getToken(SV3_1aParser::SEMICOLON, 0);
}

SV3_1aParser::Delay3Context* SV3_1aParser::Gate_instantiationContext::delay3() {
  return getRuleContext<SV3_1aParser::Delay3Context>(0);
}

std::vector<tree::TerminalNode *> SV3_1aParser::Gate_instantiationContext::COMMA() {
  return getTokens(SV3_1aParser::COMMA);
}

tree::TerminalNode* SV3_1aParser::Gate_instantiationContext::COMMA(size_t i) {
  return getToken(SV3_1aParser::COMMA, i);
}

SV3_1aParser::Enable_gatetypeContext* SV3_1aParser::Gate_instantiationContext::enable_gatetype() {
  return getRuleContext<SV3_1aParser::Enable_gatetypeContext>(0);
}

std::vector<SV3_1aParser::Enable_gate_instanceContext *> SV3_1aParser::Gate_instantiationContext::enable_gate_instance() {
  return getRuleContexts<SV3_1aParser::Enable_gate_instanceContext>();
}

SV3_1aParser::Enable_gate_instanceContext* SV3_1aParser::Gate_instantiationContext::enable_gate_instance(size_t i) {
  return getRuleContext<SV3_1aParser::Enable_gate_instanceContext>(i);
}

SV3_1aParser::Drive_strengthContext* SV3_1aParser::Gate_instantiationContext::drive_strength() {
  return getRuleContext<SV3_1aParser::Drive_strengthContext>(0);
}

SV3_1aParser::Mos_switchtypeContext* SV3_1aParser::Gate_instantiationContext::mos_switchtype() {
  return getRuleContext<SV3_1aParser::Mos_switchtypeContext>(0);
}

std::vector<SV3_1aParser::Mos_switch_instanceContext *> SV3_1aParser::Gate_instantiationContext::mos_switch_instance() {
  return getRuleContexts<SV3_1aParser::Mos_switch_instanceContext>();
}

SV3_1aParser::Mos_switch_instanceContext* SV3_1aParser::Gate_instantiationContext::mos_switch_instance(size_t i) {
  return getRuleContext<SV3_1aParser::Mos_switch_instanceContext>(i);
}

SV3_1aParser::N_input_gatetypeContext* SV3_1aParser::Gate_instantiationContext::n_input_gatetype() {
  return getRuleContext<SV3_1aParser::N_input_gatetypeContext>(0);
}

std::vector<SV3_1aParser::N_input_gate_instanceContext *> SV3_1aParser::Gate_instantiationContext::n_input_gate_instance() {
  return getRuleContexts<SV3_1aParser::N_input_gate_instanceContext>();
}

SV3_1aParser::N_input_gate_instanceContext* SV3_1aParser::Gate_instantiationContext::n_input_gate_instance(size_t i) {
  return getRuleContext<SV3_1aParser::N_input_gate_instanceContext>(i);
}

SV3_1aParser::Delay2Context* SV3_1aParser::Gate_instantiationContext::delay2() {
  return getRuleContext<SV3_1aParser::Delay2Context>(0);
}

SV3_1aParser::N_output_gatetypeContext* SV3_1aParser::Gate_instantiationContext::n_output_gatetype() {
  return getRuleContext<SV3_1aParser::N_output_gatetypeContext>(0);
}

std::vector<SV3_1aParser::N_output_gate_instanceContext *> SV3_1aParser::Gate_instantiationContext::n_output_gate_instance() {
  return getRuleContexts<SV3_1aParser::N_output_gate_instanceContext>();
}

SV3_1aParser::N_output_gate_instanceContext* SV3_1aParser::Gate_instantiationContext::n_output_gate_instance(size_t i) {
  return getRuleContext<SV3_1aParser::N_output_gate_instanceContext>(i);
}

SV3_1aParser::Pass_en_switchtypeContext* SV3_1aParser::Gate_instantiationContext::pass_en_switchtype() {
  return getRuleContext<SV3_1aParser::Pass_en_switchtypeContext>(0);
}

std::vector<SV3_1aParser::Pass_enable_switch_instanceContext *> SV3_1aParser::Gate_instantiationContext::pass_enable_switch_instance() {
  return getRuleContexts<SV3_1aParser::Pass_enable_switch_instanceContext>();
}

SV3_1aParser::Pass_enable_switch_instanceContext* SV3_1aParser::Gate_instantiationContext::pass_enable_switch_instance(size_t i) {
  return getRuleContext<SV3_1aParser::Pass_enable_switch_instanceContext>(i);
}

SV3_1aParser::Pass_switchtypeContext* SV3_1aParser::Gate_instantiationContext::pass_switchtype() {
  return getRuleContext<SV3_1aParser::Pass_switchtypeContext>(0);
}

std::vector<SV3_1aParser::Pass_switch_instanceContext *> SV3_1aParser::Gate_instantiationContext::pass_switch_instance() {
  return getRuleContexts<SV3_1aParser::Pass_switch_instanceContext>();
}

SV3_1aParser::Pass_switch_instanceContext* SV3_1aParser::Gate_instantiationContext::pass_switch_instance(size_t i) {
  return getRuleContext<SV3_1aParser::Pass_switch_instanceContext>(i);
}

tree::TerminalNode* SV3_1aParser::Gate_instantiationContext::PULLDOWN() {
  return getToken(SV3_1aParser::PULLDOWN, 0);
}

std::vector<SV3_1aParser::Pull_gate_instanceContext *> SV3_1aParser::Gate_instantiationContext::pull_gate_instance() {
  return getRuleContexts<SV3_1aParser::Pull_gate_instanceContext>();
}

SV3_1aParser::Pull_gate_instanceContext* SV3_1aParser::Gate_instantiationContext::pull_gate_instance(size_t i) {
  return getRuleContext<SV3_1aParser::Pull_gate_instanceContext>(i);
}

SV3_1aParser::Pulldown_strengthContext* SV3_1aParser::Gate_instantiationContext::pulldown_strength() {
  return getRuleContext<SV3_1aParser::Pulldown_strengthContext>(0);
}

tree::TerminalNode* SV3_1aParser::Gate_instantiationContext::PULLUP() {
  return getToken(SV3_1aParser::PULLUP, 0);
}

SV3_1aParser::Pullup_strengthContext* SV3_1aParser::Gate_instantiationContext::pullup_strength() {
  return getRuleContext<SV3_1aParser::Pullup_strengthContext>(0);
}


size_t SV3_1aParser::Gate_instantiationContext::getRuleIndex() const {
  return SV3_1aParser::RuleGate_instantiation;
}

void SV3_1aParser::Gate_instantiationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGate_instantiation(this);
}

void SV3_1aParser::Gate_instantiationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGate_instantiation(this);
}

SV3_1aParser::Gate_instantiationContext* SV3_1aParser::gate_instantiation() {
  Gate_instantiationContext *_localctx = _tracker.createInstance<Gate_instantiationContext>(_ctx, getState());
  enterRule(_localctx, 572, SV3_1aParser::RuleGate_instantiation);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(5486);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SV3_1aParser::CMOS:
      case SV3_1aParser::RCMOS: {
        enterOuterAlt(_localctx, 1);
        setState(5354);
        cmos_switchtype();
        setState(5356);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == SV3_1aParser::Pound_Pound_delay

        || _la == SV3_1aParser::Pound_delay || _la == SV3_1aParser::POUND) {
          setState(5355);
          delay3();
        }
        setState(5358);
        cmos_switch_instance();
        setState(5363);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == SV3_1aParser::COMMA) {
          setState(5359);
          match(SV3_1aParser::COMMA);
          setState(5360);
          cmos_switch_instance();
          setState(5365);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(5366);
        match(SV3_1aParser::SEMICOLON);
        break;
      }

      case SV3_1aParser::BUFIF0:
      case SV3_1aParser::BUFIF1:
      case SV3_1aParser::NOTIF0:
      case SV3_1aParser::NOTIF1: {
        enterOuterAlt(_localctx, 2);
        setState(5368);
        enable_gatetype();
        setState(5370);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 592, _ctx)) {
        case 1: {
          setState(5369);
          drive_strength();
          break;
        }

        default:
          break;
        }
        setState(5373);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == SV3_1aParser::Pound_Pound_delay

        || _la == SV3_1aParser::Pound_delay || _la == SV3_1aParser::POUND) {
          setState(5372);
          delay3();
        }
        setState(5375);
        enable_gate_instance();
        setState(5380);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == SV3_1aParser::COMMA) {
          setState(5376);
          match(SV3_1aParser::COMMA);
          setState(5377);
          enable_gate_instance();
          setState(5382);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(5383);
        match(SV3_1aParser::SEMICOLON);
        break;
      }

      case SV3_1aParser::NMOS:
      case SV3_1aParser::PMOS:
      case SV3_1aParser::RNMOS:
      case SV3_1aParser::RPMOS: {
        enterOuterAlt(_localctx, 3);
        setState(5385);
        mos_switchtype();
        setState(5387);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == SV3_1aParser::Pound_Pound_delay

        || _la == SV3_1aParser::Pound_delay || _la == SV3_1aParser::POUND) {
          setState(5386);
          delay3();
        }
        setState(5389);
        mos_switch_instance();
        setState(5394);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == SV3_1aParser::COMMA) {
          setState(5390);
          match(SV3_1aParser::COMMA);
          setState(5391);
          mos_switch_instance();
          setState(5396);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(5397);
        match(SV3_1aParser::SEMICOLON);
        break;
      }

      case SV3_1aParser::OR:
      case SV3_1aParser::AND:
      case SV3_1aParser::NAND:
      case SV3_1aParser::NOR:
      case SV3_1aParser::XOR:
      case SV3_1aParser::XNOR: {
        enterOuterAlt(_localctx, 4);
        setState(5399);
        n_input_gatetype();
        setState(5401);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 597, _ctx)) {
        case 1: {
          setState(5400);
          drive_strength();
          break;
        }

        default:
          break;
        }
        setState(5404);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == SV3_1aParser::Pound_Pound_delay

        || _la == SV3_1aParser::Pound_delay || _la == SV3_1aParser::POUND) {
          setState(5403);
          delay2();
        }
        setState(5406);
        n_input_gate_instance();
        setState(5411);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == SV3_1aParser::COMMA) {
          setState(5407);
          match(SV3_1aParser::COMMA);
          setState(5408);
          n_input_gate_instance();
          setState(5413);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(5414);
        match(SV3_1aParser::SEMICOLON);
        break;
      }

      case SV3_1aParser::NOT:
      case SV3_1aParser::BUF: {
        enterOuterAlt(_localctx, 5);
        setState(5416);
        n_output_gatetype();
        setState(5418);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 600, _ctx)) {
        case 1: {
          setState(5417);
          drive_strength();
          break;
        }

        default:
          break;
        }
        setState(5421);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == SV3_1aParser::Pound_Pound_delay

        || _la == SV3_1aParser::Pound_delay || _la == SV3_1aParser::POUND) {
          setState(5420);
          delay2();
        }
        setState(5423);
        n_output_gate_instance();
        setState(5428);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == SV3_1aParser::COMMA) {
          setState(5424);
          match(SV3_1aParser::COMMA);
          setState(5425);
          n_output_gate_instance();
          setState(5430);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(5431);
        match(SV3_1aParser::SEMICOLON);
        break;
      }

      case SV3_1aParser::TRANIF0:
      case SV3_1aParser::TRANIF1:
      case SV3_1aParser::RTRANIF1:
      case SV3_1aParser::RTRANIF0: {
        enterOuterAlt(_localctx, 6);
        setState(5433);
        pass_en_switchtype();
        setState(5435);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == SV3_1aParser::Pound_Pound_delay

        || _la == SV3_1aParser::Pound_delay || _la == SV3_1aParser::POUND) {
          setState(5434);
          delay2();
        }
        setState(5437);
        pass_enable_switch_instance();
        setState(5442);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == SV3_1aParser::COMMA) {
          setState(5438);
          match(SV3_1aParser::COMMA);
          setState(5439);
          pass_enable_switch_instance();
          setState(5444);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(5445);
        match(SV3_1aParser::SEMICOLON);
        break;
      }

      case SV3_1aParser::TRAN:
      case SV3_1aParser::RTRAN: {
        enterOuterAlt(_localctx, 7);
        setState(5447);
        pass_switchtype();
        setState(5448);
        pass_switch_instance();
        setState(5453);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == SV3_1aParser::COMMA) {
          setState(5449);
          match(SV3_1aParser::COMMA);
          setState(5450);
          pass_switch_instance();
          setState(5455);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(5456);
        match(SV3_1aParser::SEMICOLON);
        break;
      }

      case SV3_1aParser::PULLDOWN: {
        enterOuterAlt(_localctx, 8);
        setState(5458);
        match(SV3_1aParser::PULLDOWN);
        setState(5460);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 606, _ctx)) {
        case 1: {
          setState(5459);
          pulldown_strength();
          break;
        }

        default:
          break;
        }
        setState(5462);
        pull_gate_instance();
        setState(5467);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == SV3_1aParser::COMMA) {
          setState(5463);
          match(SV3_1aParser::COMMA);
          setState(5464);
          pull_gate_instance();
          setState(5469);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(5470);
        match(SV3_1aParser::SEMICOLON);
        break;
      }

      case SV3_1aParser::PULLUP: {
        enterOuterAlt(_localctx, 9);
        setState(5472);
        match(SV3_1aParser::PULLUP);
        setState(5474);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 608, _ctx)) {
        case 1: {
          setState(5473);
          pullup_strength();
          break;
        }

        default:
          break;
        }
        setState(5476);
        pull_gate_instance();
        setState(5481);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == SV3_1aParser::COMMA) {
          setState(5477);
          match(SV3_1aParser::COMMA);
          setState(5478);
          pull_gate_instance();
          setState(5483);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(5484);
        match(SV3_1aParser::SEMICOLON);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Cmos_switch_instanceContext ------------------------------------------------------------------

SV3_1aParser::Cmos_switch_instanceContext::Cmos_switch_instanceContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Cmos_switch_instanceContext::OPEN_PARENS() {
  return getToken(SV3_1aParser::OPEN_PARENS, 0);
}

SV3_1aParser::Net_lvalueContext* SV3_1aParser::Cmos_switch_instanceContext::net_lvalue() {
  return getRuleContext<SV3_1aParser::Net_lvalueContext>(0);
}

std::vector<tree::TerminalNode *> SV3_1aParser::Cmos_switch_instanceContext::COMMA() {
  return getTokens(SV3_1aParser::COMMA);
}

tree::TerminalNode* SV3_1aParser::Cmos_switch_instanceContext::COMMA(size_t i) {
  return getToken(SV3_1aParser::COMMA, i);
}

std::vector<SV3_1aParser::ExpressionContext *> SV3_1aParser::Cmos_switch_instanceContext::expression() {
  return getRuleContexts<SV3_1aParser::ExpressionContext>();
}

SV3_1aParser::ExpressionContext* SV3_1aParser::Cmos_switch_instanceContext::expression(size_t i) {
  return getRuleContext<SV3_1aParser::ExpressionContext>(i);
}

tree::TerminalNode* SV3_1aParser::Cmos_switch_instanceContext::CLOSE_PARENS() {
  return getToken(SV3_1aParser::CLOSE_PARENS, 0);
}

SV3_1aParser::Name_of_instanceContext* SV3_1aParser::Cmos_switch_instanceContext::name_of_instance() {
  return getRuleContext<SV3_1aParser::Name_of_instanceContext>(0);
}


size_t SV3_1aParser::Cmos_switch_instanceContext::getRuleIndex() const {
  return SV3_1aParser::RuleCmos_switch_instance;
}

void SV3_1aParser::Cmos_switch_instanceContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCmos_switch_instance(this);
}

void SV3_1aParser::Cmos_switch_instanceContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCmos_switch_instance(this);
}

SV3_1aParser::Cmos_switch_instanceContext* SV3_1aParser::cmos_switch_instance() {
  Cmos_switch_instanceContext *_localctx = _tracker.createInstance<Cmos_switch_instanceContext>(_ctx, getState());
  enterRule(_localctx, 574, SV3_1aParser::RuleCmos_switch_instance);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5489);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (((((_la - 326) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 326)) & 4672924483589) != 0)) {
      setState(5488);
      name_of_instance();
    }
    setState(5491);
    match(SV3_1aParser::OPEN_PARENS);
    setState(5492);
    net_lvalue();
    setState(5493);
    match(SV3_1aParser::COMMA);
    setState(5494);
    expression(0);
    setState(5495);
    match(SV3_1aParser::COMMA);
    setState(5496);
    expression(0);
    setState(5497);
    match(SV3_1aParser::COMMA);
    setState(5498);
    expression(0);
    setState(5499);
    match(SV3_1aParser::CLOSE_PARENS);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Enable_gate_instanceContext ------------------------------------------------------------------

SV3_1aParser::Enable_gate_instanceContext::Enable_gate_instanceContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Enable_gate_instanceContext::OPEN_PARENS() {
  return getToken(SV3_1aParser::OPEN_PARENS, 0);
}

SV3_1aParser::Net_lvalueContext* SV3_1aParser::Enable_gate_instanceContext::net_lvalue() {
  return getRuleContext<SV3_1aParser::Net_lvalueContext>(0);
}

std::vector<tree::TerminalNode *> SV3_1aParser::Enable_gate_instanceContext::COMMA() {
  return getTokens(SV3_1aParser::COMMA);
}

tree::TerminalNode* SV3_1aParser::Enable_gate_instanceContext::COMMA(size_t i) {
  return getToken(SV3_1aParser::COMMA, i);
}

std::vector<SV3_1aParser::ExpressionContext *> SV3_1aParser::Enable_gate_instanceContext::expression() {
  return getRuleContexts<SV3_1aParser::ExpressionContext>();
}

SV3_1aParser::ExpressionContext* SV3_1aParser::Enable_gate_instanceContext::expression(size_t i) {
  return getRuleContext<SV3_1aParser::ExpressionContext>(i);
}

tree::TerminalNode* SV3_1aParser::Enable_gate_instanceContext::CLOSE_PARENS() {
  return getToken(SV3_1aParser::CLOSE_PARENS, 0);
}

SV3_1aParser::Name_of_instanceContext* SV3_1aParser::Enable_gate_instanceContext::name_of_instance() {
  return getRuleContext<SV3_1aParser::Name_of_instanceContext>(0);
}


size_t SV3_1aParser::Enable_gate_instanceContext::getRuleIndex() const {
  return SV3_1aParser::RuleEnable_gate_instance;
}

void SV3_1aParser::Enable_gate_instanceContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterEnable_gate_instance(this);
}

void SV3_1aParser::Enable_gate_instanceContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitEnable_gate_instance(this);
}

SV3_1aParser::Enable_gate_instanceContext* SV3_1aParser::enable_gate_instance() {
  Enable_gate_instanceContext *_localctx = _tracker.createInstance<Enable_gate_instanceContext>(_ctx, getState());
  enterRule(_localctx, 576, SV3_1aParser::RuleEnable_gate_instance);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5502);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (((((_la - 326) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 326)) & 4672924483589) != 0)) {
      setState(5501);
      name_of_instance();
    }
    setState(5504);
    match(SV3_1aParser::OPEN_PARENS);
    setState(5505);
    net_lvalue();
    setState(5506);
    match(SV3_1aParser::COMMA);
    setState(5507);
    expression(0);
    setState(5508);
    match(SV3_1aParser::COMMA);
    setState(5509);
    expression(0);
    setState(5510);
    match(SV3_1aParser::CLOSE_PARENS);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Mos_switch_instanceContext ------------------------------------------------------------------

SV3_1aParser::Mos_switch_instanceContext::Mos_switch_instanceContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Mos_switch_instanceContext::OPEN_PARENS() {
  return getToken(SV3_1aParser::OPEN_PARENS, 0);
}

SV3_1aParser::Net_lvalueContext* SV3_1aParser::Mos_switch_instanceContext::net_lvalue() {
  return getRuleContext<SV3_1aParser::Net_lvalueContext>(0);
}

std::vector<tree::TerminalNode *> SV3_1aParser::Mos_switch_instanceContext::COMMA() {
  return getTokens(SV3_1aParser::COMMA);
}

tree::TerminalNode* SV3_1aParser::Mos_switch_instanceContext::COMMA(size_t i) {
  return getToken(SV3_1aParser::COMMA, i);
}

std::vector<SV3_1aParser::ExpressionContext *> SV3_1aParser::Mos_switch_instanceContext::expression() {
  return getRuleContexts<SV3_1aParser::ExpressionContext>();
}

SV3_1aParser::ExpressionContext* SV3_1aParser::Mos_switch_instanceContext::expression(size_t i) {
  return getRuleContext<SV3_1aParser::ExpressionContext>(i);
}

tree::TerminalNode* SV3_1aParser::Mos_switch_instanceContext::CLOSE_PARENS() {
  return getToken(SV3_1aParser::CLOSE_PARENS, 0);
}

SV3_1aParser::Name_of_instanceContext* SV3_1aParser::Mos_switch_instanceContext::name_of_instance() {
  return getRuleContext<SV3_1aParser::Name_of_instanceContext>(0);
}


size_t SV3_1aParser::Mos_switch_instanceContext::getRuleIndex() const {
  return SV3_1aParser::RuleMos_switch_instance;
}

void SV3_1aParser::Mos_switch_instanceContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterMos_switch_instance(this);
}

void SV3_1aParser::Mos_switch_instanceContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitMos_switch_instance(this);
}

SV3_1aParser::Mos_switch_instanceContext* SV3_1aParser::mos_switch_instance() {
  Mos_switch_instanceContext *_localctx = _tracker.createInstance<Mos_switch_instanceContext>(_ctx, getState());
  enterRule(_localctx, 578, SV3_1aParser::RuleMos_switch_instance);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5513);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (((((_la - 326) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 326)) & 4672924483589) != 0)) {
      setState(5512);
      name_of_instance();
    }
    setState(5515);
    match(SV3_1aParser::OPEN_PARENS);
    setState(5516);
    net_lvalue();
    setState(5517);
    match(SV3_1aParser::COMMA);
    setState(5518);
    expression(0);
    setState(5519);
    match(SV3_1aParser::COMMA);
    setState(5520);
    expression(0);
    setState(5521);
    match(SV3_1aParser::CLOSE_PARENS);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- N_input_gate_instanceContext ------------------------------------------------------------------

SV3_1aParser::N_input_gate_instanceContext::N_input_gate_instanceContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::N_input_gate_instanceContext::OPEN_PARENS() {
  return getToken(SV3_1aParser::OPEN_PARENS, 0);
}

SV3_1aParser::Net_lvalueContext* SV3_1aParser::N_input_gate_instanceContext::net_lvalue() {
  return getRuleContext<SV3_1aParser::Net_lvalueContext>(0);
}

std::vector<tree::TerminalNode *> SV3_1aParser::N_input_gate_instanceContext::COMMA() {
  return getTokens(SV3_1aParser::COMMA);
}

tree::TerminalNode* SV3_1aParser::N_input_gate_instanceContext::COMMA(size_t i) {
  return getToken(SV3_1aParser::COMMA, i);
}

std::vector<SV3_1aParser::ExpressionContext *> SV3_1aParser::N_input_gate_instanceContext::expression() {
  return getRuleContexts<SV3_1aParser::ExpressionContext>();
}

SV3_1aParser::ExpressionContext* SV3_1aParser::N_input_gate_instanceContext::expression(size_t i) {
  return getRuleContext<SV3_1aParser::ExpressionContext>(i);
}

tree::TerminalNode* SV3_1aParser::N_input_gate_instanceContext::CLOSE_PARENS() {
  return getToken(SV3_1aParser::CLOSE_PARENS, 0);
}

SV3_1aParser::Name_of_instanceContext* SV3_1aParser::N_input_gate_instanceContext::name_of_instance() {
  return getRuleContext<SV3_1aParser::Name_of_instanceContext>(0);
}


size_t SV3_1aParser::N_input_gate_instanceContext::getRuleIndex() const {
  return SV3_1aParser::RuleN_input_gate_instance;
}

void SV3_1aParser::N_input_gate_instanceContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterN_input_gate_instance(this);
}

void SV3_1aParser::N_input_gate_instanceContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitN_input_gate_instance(this);
}

SV3_1aParser::N_input_gate_instanceContext* SV3_1aParser::n_input_gate_instance() {
  N_input_gate_instanceContext *_localctx = _tracker.createInstance<N_input_gate_instanceContext>(_ctx, getState());
  enterRule(_localctx, 580, SV3_1aParser::RuleN_input_gate_instance);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5524);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (((((_la - 326) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 326)) & 4672924483589) != 0)) {
      setState(5523);
      name_of_instance();
    }
    setState(5526);
    match(SV3_1aParser::OPEN_PARENS);
    setState(5527);
    net_lvalue();
    setState(5528);
    match(SV3_1aParser::COMMA);
    setState(5529);
    expression(0);
    setState(5534);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == SV3_1aParser::COMMA) {
      setState(5530);
      match(SV3_1aParser::COMMA);
      setState(5531);
      expression(0);
      setState(5536);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(5537);
    match(SV3_1aParser::CLOSE_PARENS);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- N_output_gate_instanceContext ------------------------------------------------------------------

SV3_1aParser::N_output_gate_instanceContext::N_output_gate_instanceContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::N_output_gate_instanceContext::OPEN_PARENS() {
  return getToken(SV3_1aParser::OPEN_PARENS, 0);
}

std::vector<SV3_1aParser::Net_lvalueContext *> SV3_1aParser::N_output_gate_instanceContext::net_lvalue() {
  return getRuleContexts<SV3_1aParser::Net_lvalueContext>();
}

SV3_1aParser::Net_lvalueContext* SV3_1aParser::N_output_gate_instanceContext::net_lvalue(size_t i) {
  return getRuleContext<SV3_1aParser::Net_lvalueContext>(i);
}

std::vector<tree::TerminalNode *> SV3_1aParser::N_output_gate_instanceContext::COMMA() {
  return getTokens(SV3_1aParser::COMMA);
}

tree::TerminalNode* SV3_1aParser::N_output_gate_instanceContext::COMMA(size_t i) {
  return getToken(SV3_1aParser::COMMA, i);
}

SV3_1aParser::ExpressionContext* SV3_1aParser::N_output_gate_instanceContext::expression() {
  return getRuleContext<SV3_1aParser::ExpressionContext>(0);
}

tree::TerminalNode* SV3_1aParser::N_output_gate_instanceContext::CLOSE_PARENS() {
  return getToken(SV3_1aParser::CLOSE_PARENS, 0);
}

SV3_1aParser::Name_of_instanceContext* SV3_1aParser::N_output_gate_instanceContext::name_of_instance() {
  return getRuleContext<SV3_1aParser::Name_of_instanceContext>(0);
}


size_t SV3_1aParser::N_output_gate_instanceContext::getRuleIndex() const {
  return SV3_1aParser::RuleN_output_gate_instance;
}

void SV3_1aParser::N_output_gate_instanceContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterN_output_gate_instance(this);
}

void SV3_1aParser::N_output_gate_instanceContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitN_output_gate_instance(this);
}

SV3_1aParser::N_output_gate_instanceContext* SV3_1aParser::n_output_gate_instance() {
  N_output_gate_instanceContext *_localctx = _tracker.createInstance<N_output_gate_instanceContext>(_ctx, getState());
  enterRule(_localctx, 582, SV3_1aParser::RuleN_output_gate_instance);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(5540);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (((((_la - 326) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 326)) & 4672924483589) != 0)) {
      setState(5539);
      name_of_instance();
    }
    setState(5542);
    match(SV3_1aParser::OPEN_PARENS);
    setState(5543);
    net_lvalue();
    setState(5548);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 617, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(5544);
        match(SV3_1aParser::COMMA);
        setState(5545);
        net_lvalue(); 
      }
      setState(5550);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 617, _ctx);
    }
    setState(5551);
    match(SV3_1aParser::COMMA);
    setState(5552);
    expression(0);
    setState(5553);
    match(SV3_1aParser::CLOSE_PARENS);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Pass_switch_instanceContext ------------------------------------------------------------------

SV3_1aParser::Pass_switch_instanceContext::Pass_switch_instanceContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Pass_switch_instanceContext::OPEN_PARENS() {
  return getToken(SV3_1aParser::OPEN_PARENS, 0);
}

std::vector<SV3_1aParser::Net_lvalueContext *> SV3_1aParser::Pass_switch_instanceContext::net_lvalue() {
  return getRuleContexts<SV3_1aParser::Net_lvalueContext>();
}

SV3_1aParser::Net_lvalueContext* SV3_1aParser::Pass_switch_instanceContext::net_lvalue(size_t i) {
  return getRuleContext<SV3_1aParser::Net_lvalueContext>(i);
}

tree::TerminalNode* SV3_1aParser::Pass_switch_instanceContext::COMMA() {
  return getToken(SV3_1aParser::COMMA, 0);
}

tree::TerminalNode* SV3_1aParser::Pass_switch_instanceContext::CLOSE_PARENS() {
  return getToken(SV3_1aParser::CLOSE_PARENS, 0);
}

SV3_1aParser::Name_of_instanceContext* SV3_1aParser::Pass_switch_instanceContext::name_of_instance() {
  return getRuleContext<SV3_1aParser::Name_of_instanceContext>(0);
}


size_t SV3_1aParser::Pass_switch_instanceContext::getRuleIndex() const {
  return SV3_1aParser::RulePass_switch_instance;
}

void SV3_1aParser::Pass_switch_instanceContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPass_switch_instance(this);
}

void SV3_1aParser::Pass_switch_instanceContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPass_switch_instance(this);
}

SV3_1aParser::Pass_switch_instanceContext* SV3_1aParser::pass_switch_instance() {
  Pass_switch_instanceContext *_localctx = _tracker.createInstance<Pass_switch_instanceContext>(_ctx, getState());
  enterRule(_localctx, 584, SV3_1aParser::RulePass_switch_instance);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5556);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (((((_la - 326) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 326)) & 4672924483589) != 0)) {
      setState(5555);
      name_of_instance();
    }
    setState(5558);
    match(SV3_1aParser::OPEN_PARENS);
    setState(5559);
    net_lvalue();
    setState(5560);
    match(SV3_1aParser::COMMA);
    setState(5561);
    net_lvalue();
    setState(5562);
    match(SV3_1aParser::CLOSE_PARENS);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Pass_enable_switch_instanceContext ------------------------------------------------------------------

SV3_1aParser::Pass_enable_switch_instanceContext::Pass_enable_switch_instanceContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Pass_enable_switch_instanceContext::OPEN_PARENS() {
  return getToken(SV3_1aParser::OPEN_PARENS, 0);
}

std::vector<SV3_1aParser::Net_lvalueContext *> SV3_1aParser::Pass_enable_switch_instanceContext::net_lvalue() {
  return getRuleContexts<SV3_1aParser::Net_lvalueContext>();
}

SV3_1aParser::Net_lvalueContext* SV3_1aParser::Pass_enable_switch_instanceContext::net_lvalue(size_t i) {
  return getRuleContext<SV3_1aParser::Net_lvalueContext>(i);
}

std::vector<tree::TerminalNode *> SV3_1aParser::Pass_enable_switch_instanceContext::COMMA() {
  return getTokens(SV3_1aParser::COMMA);
}

tree::TerminalNode* SV3_1aParser::Pass_enable_switch_instanceContext::COMMA(size_t i) {
  return getToken(SV3_1aParser::COMMA, i);
}

SV3_1aParser::ExpressionContext* SV3_1aParser::Pass_enable_switch_instanceContext::expression() {
  return getRuleContext<SV3_1aParser::ExpressionContext>(0);
}

tree::TerminalNode* SV3_1aParser::Pass_enable_switch_instanceContext::CLOSE_PARENS() {
  return getToken(SV3_1aParser::CLOSE_PARENS, 0);
}

SV3_1aParser::Name_of_instanceContext* SV3_1aParser::Pass_enable_switch_instanceContext::name_of_instance() {
  return getRuleContext<SV3_1aParser::Name_of_instanceContext>(0);
}


size_t SV3_1aParser::Pass_enable_switch_instanceContext::getRuleIndex() const {
  return SV3_1aParser::RulePass_enable_switch_instance;
}

void SV3_1aParser::Pass_enable_switch_instanceContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPass_enable_switch_instance(this);
}

void SV3_1aParser::Pass_enable_switch_instanceContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPass_enable_switch_instance(this);
}

SV3_1aParser::Pass_enable_switch_instanceContext* SV3_1aParser::pass_enable_switch_instance() {
  Pass_enable_switch_instanceContext *_localctx = _tracker.createInstance<Pass_enable_switch_instanceContext>(_ctx, getState());
  enterRule(_localctx, 586, SV3_1aParser::RulePass_enable_switch_instance);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5565);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (((((_la - 326) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 326)) & 4672924483589) != 0)) {
      setState(5564);
      name_of_instance();
    }
    setState(5567);
    match(SV3_1aParser::OPEN_PARENS);
    setState(5568);
    net_lvalue();
    setState(5569);
    match(SV3_1aParser::COMMA);
    setState(5570);
    net_lvalue();
    setState(5571);
    match(SV3_1aParser::COMMA);
    setState(5572);
    expression(0);
    setState(5573);
    match(SV3_1aParser::CLOSE_PARENS);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Pull_gate_instanceContext ------------------------------------------------------------------

SV3_1aParser::Pull_gate_instanceContext::Pull_gate_instanceContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Pull_gate_instanceContext::OPEN_PARENS() {
  return getToken(SV3_1aParser::OPEN_PARENS, 0);
}

SV3_1aParser::Net_lvalueContext* SV3_1aParser::Pull_gate_instanceContext::net_lvalue() {
  return getRuleContext<SV3_1aParser::Net_lvalueContext>(0);
}

tree::TerminalNode* SV3_1aParser::Pull_gate_instanceContext::CLOSE_PARENS() {
  return getToken(SV3_1aParser::CLOSE_PARENS, 0);
}

SV3_1aParser::Name_of_instanceContext* SV3_1aParser::Pull_gate_instanceContext::name_of_instance() {
  return getRuleContext<SV3_1aParser::Name_of_instanceContext>(0);
}


size_t SV3_1aParser::Pull_gate_instanceContext::getRuleIndex() const {
  return SV3_1aParser::RulePull_gate_instance;
}

void SV3_1aParser::Pull_gate_instanceContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPull_gate_instance(this);
}

void SV3_1aParser::Pull_gate_instanceContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPull_gate_instance(this);
}

SV3_1aParser::Pull_gate_instanceContext* SV3_1aParser::pull_gate_instance() {
  Pull_gate_instanceContext *_localctx = _tracker.createInstance<Pull_gate_instanceContext>(_ctx, getState());
  enterRule(_localctx, 588, SV3_1aParser::RulePull_gate_instance);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5576);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (((((_la - 326) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 326)) & 4672924483589) != 0)) {
      setState(5575);
      name_of_instance();
    }
    setState(5578);
    match(SV3_1aParser::OPEN_PARENS);
    setState(5579);
    net_lvalue();
    setState(5580);
    match(SV3_1aParser::CLOSE_PARENS);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Pulldown_strengthContext ------------------------------------------------------------------

SV3_1aParser::Pulldown_strengthContext::Pulldown_strengthContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Pulldown_strengthContext::OPEN_PARENS() {
  return getToken(SV3_1aParser::OPEN_PARENS, 0);
}

SV3_1aParser::Strength0Context* SV3_1aParser::Pulldown_strengthContext::strength0() {
  return getRuleContext<SV3_1aParser::Strength0Context>(0);
}

tree::TerminalNode* SV3_1aParser::Pulldown_strengthContext::COMMA() {
  return getToken(SV3_1aParser::COMMA, 0);
}

SV3_1aParser::Strength1Context* SV3_1aParser::Pulldown_strengthContext::strength1() {
  return getRuleContext<SV3_1aParser::Strength1Context>(0);
}

tree::TerminalNode* SV3_1aParser::Pulldown_strengthContext::CLOSE_PARENS() {
  return getToken(SV3_1aParser::CLOSE_PARENS, 0);
}


size_t SV3_1aParser::Pulldown_strengthContext::getRuleIndex() const {
  return SV3_1aParser::RulePulldown_strength;
}

void SV3_1aParser::Pulldown_strengthContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPulldown_strength(this);
}

void SV3_1aParser::Pulldown_strengthContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPulldown_strength(this);
}

SV3_1aParser::Pulldown_strengthContext* SV3_1aParser::pulldown_strength() {
  Pulldown_strengthContext *_localctx = _tracker.createInstance<Pulldown_strengthContext>(_ctx, getState());
  enterRule(_localctx, 590, SV3_1aParser::RulePulldown_strength);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(5598);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 621, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(5582);
      match(SV3_1aParser::OPEN_PARENS);
      setState(5583);
      strength0();
      setState(5584);
      match(SV3_1aParser::COMMA);
      setState(5585);
      strength1();
      setState(5586);
      match(SV3_1aParser::CLOSE_PARENS);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(5588);
      match(SV3_1aParser::OPEN_PARENS);
      setState(5589);
      strength1();
      setState(5590);
      match(SV3_1aParser::COMMA);
      setState(5591);
      strength0();
      setState(5592);
      match(SV3_1aParser::CLOSE_PARENS);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(5594);
      match(SV3_1aParser::OPEN_PARENS);
      setState(5595);
      strength0();
      setState(5596);
      match(SV3_1aParser::CLOSE_PARENS);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Pullup_strengthContext ------------------------------------------------------------------

SV3_1aParser::Pullup_strengthContext::Pullup_strengthContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Pullup_strengthContext::OPEN_PARENS() {
  return getToken(SV3_1aParser::OPEN_PARENS, 0);
}

SV3_1aParser::Strength0Context* SV3_1aParser::Pullup_strengthContext::strength0() {
  return getRuleContext<SV3_1aParser::Strength0Context>(0);
}

tree::TerminalNode* SV3_1aParser::Pullup_strengthContext::COMMA() {
  return getToken(SV3_1aParser::COMMA, 0);
}

SV3_1aParser::Strength1Context* SV3_1aParser::Pullup_strengthContext::strength1() {
  return getRuleContext<SV3_1aParser::Strength1Context>(0);
}

tree::TerminalNode* SV3_1aParser::Pullup_strengthContext::CLOSE_PARENS() {
  return getToken(SV3_1aParser::CLOSE_PARENS, 0);
}


size_t SV3_1aParser::Pullup_strengthContext::getRuleIndex() const {
  return SV3_1aParser::RulePullup_strength;
}

void SV3_1aParser::Pullup_strengthContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPullup_strength(this);
}

void SV3_1aParser::Pullup_strengthContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPullup_strength(this);
}

SV3_1aParser::Pullup_strengthContext* SV3_1aParser::pullup_strength() {
  Pullup_strengthContext *_localctx = _tracker.createInstance<Pullup_strengthContext>(_ctx, getState());
  enterRule(_localctx, 592, SV3_1aParser::RulePullup_strength);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(5616);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 622, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(5600);
      match(SV3_1aParser::OPEN_PARENS);
      setState(5601);
      strength0();
      setState(5602);
      match(SV3_1aParser::COMMA);
      setState(5603);
      strength1();
      setState(5604);
      match(SV3_1aParser::CLOSE_PARENS);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(5606);
      match(SV3_1aParser::OPEN_PARENS);
      setState(5607);
      strength1();
      setState(5608);
      match(SV3_1aParser::COMMA);
      setState(5609);
      strength0();
      setState(5610);
      match(SV3_1aParser::CLOSE_PARENS);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(5612);
      match(SV3_1aParser::OPEN_PARENS);
      setState(5613);
      strength1();
      setState(5614);
      match(SV3_1aParser::CLOSE_PARENS);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Cmos_switchtypeContext ------------------------------------------------------------------

SV3_1aParser::Cmos_switchtypeContext::Cmos_switchtypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t SV3_1aParser::Cmos_switchtypeContext::getRuleIndex() const {
  return SV3_1aParser::RuleCmos_switchtype;
}

void SV3_1aParser::Cmos_switchtypeContext::copyFrom(Cmos_switchtypeContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- CmosSwitchType_RCmosContext ------------------------------------------------------------------

tree::TerminalNode* SV3_1aParser::CmosSwitchType_RCmosContext::RCMOS() {
  return getToken(SV3_1aParser::RCMOS, 0);
}

SV3_1aParser::CmosSwitchType_RCmosContext::CmosSwitchType_RCmosContext(Cmos_switchtypeContext *ctx) { copyFrom(ctx); }

void SV3_1aParser::CmosSwitchType_RCmosContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCmosSwitchType_RCmos(this);
}
void SV3_1aParser::CmosSwitchType_RCmosContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCmosSwitchType_RCmos(this);
}
//----------------- CmosSwitchType_CmosContext ------------------------------------------------------------------

tree::TerminalNode* SV3_1aParser::CmosSwitchType_CmosContext::CMOS() {
  return getToken(SV3_1aParser::CMOS, 0);
}

SV3_1aParser::CmosSwitchType_CmosContext::CmosSwitchType_CmosContext(Cmos_switchtypeContext *ctx) { copyFrom(ctx); }

void SV3_1aParser::CmosSwitchType_CmosContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCmosSwitchType_Cmos(this);
}
void SV3_1aParser::CmosSwitchType_CmosContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCmosSwitchType_Cmos(this);
}
SV3_1aParser::Cmos_switchtypeContext* SV3_1aParser::cmos_switchtype() {
  Cmos_switchtypeContext *_localctx = _tracker.createInstance<Cmos_switchtypeContext>(_ctx, getState());
  enterRule(_localctx, 594, SV3_1aParser::RuleCmos_switchtype);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(5620);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SV3_1aParser::CMOS: {
        _localctx = _tracker.createInstance<SV3_1aParser::CmosSwitchType_CmosContext>(_localctx);
        enterOuterAlt(_localctx, 1);
        setState(5618);
        match(SV3_1aParser::CMOS);
        break;
      }

      case SV3_1aParser::RCMOS: {
        _localctx = _tracker.createInstance<SV3_1aParser::CmosSwitchType_RCmosContext>(_localctx);
        enterOuterAlt(_localctx, 2);
        setState(5619);
        match(SV3_1aParser::RCMOS);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Enable_gatetypeContext ------------------------------------------------------------------

SV3_1aParser::Enable_gatetypeContext::Enable_gatetypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t SV3_1aParser::Enable_gatetypeContext::getRuleIndex() const {
  return SV3_1aParser::RuleEnable_gatetype;
}

void SV3_1aParser::Enable_gatetypeContext::copyFrom(Enable_gatetypeContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- EnableGateType_Bufif0Context ------------------------------------------------------------------

tree::TerminalNode* SV3_1aParser::EnableGateType_Bufif0Context::BUFIF0() {
  return getToken(SV3_1aParser::BUFIF0, 0);
}

SV3_1aParser::EnableGateType_Bufif0Context::EnableGateType_Bufif0Context(Enable_gatetypeContext *ctx) { copyFrom(ctx); }

void SV3_1aParser::EnableGateType_Bufif0Context::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterEnableGateType_Bufif0(this);
}
void SV3_1aParser::EnableGateType_Bufif0Context::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitEnableGateType_Bufif0(this);
}
//----------------- EnableGateType_Notif0Context ------------------------------------------------------------------

tree::TerminalNode* SV3_1aParser::EnableGateType_Notif0Context::NOTIF0() {
  return getToken(SV3_1aParser::NOTIF0, 0);
}

SV3_1aParser::EnableGateType_Notif0Context::EnableGateType_Notif0Context(Enable_gatetypeContext *ctx) { copyFrom(ctx); }

void SV3_1aParser::EnableGateType_Notif0Context::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterEnableGateType_Notif0(this);
}
void SV3_1aParser::EnableGateType_Notif0Context::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitEnableGateType_Notif0(this);
}
//----------------- EnableGateType_Notif1Context ------------------------------------------------------------------

tree::TerminalNode* SV3_1aParser::EnableGateType_Notif1Context::NOTIF1() {
  return getToken(SV3_1aParser::NOTIF1, 0);
}

SV3_1aParser::EnableGateType_Notif1Context::EnableGateType_Notif1Context(Enable_gatetypeContext *ctx) { copyFrom(ctx); }

void SV3_1aParser::EnableGateType_Notif1Context::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterEnableGateType_Notif1(this);
}
void SV3_1aParser::EnableGateType_Notif1Context::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitEnableGateType_Notif1(this);
}
//----------------- EnableGateType_Bufif1Context ------------------------------------------------------------------

tree::TerminalNode* SV3_1aParser::EnableGateType_Bufif1Context::BUFIF1() {
  return getToken(SV3_1aParser::BUFIF1, 0);
}

SV3_1aParser::EnableGateType_Bufif1Context::EnableGateType_Bufif1Context(Enable_gatetypeContext *ctx) { copyFrom(ctx); }

void SV3_1aParser::EnableGateType_Bufif1Context::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterEnableGateType_Bufif1(this);
}
void SV3_1aParser::EnableGateType_Bufif1Context::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitEnableGateType_Bufif1(this);
}
SV3_1aParser::Enable_gatetypeContext* SV3_1aParser::enable_gatetype() {
  Enable_gatetypeContext *_localctx = _tracker.createInstance<Enable_gatetypeContext>(_ctx, getState());
  enterRule(_localctx, 596, SV3_1aParser::RuleEnable_gatetype);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(5626);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SV3_1aParser::BUFIF0: {
        _localctx = _tracker.createInstance<SV3_1aParser::EnableGateType_Bufif0Context>(_localctx);
        enterOuterAlt(_localctx, 1);
        setState(5622);
        match(SV3_1aParser::BUFIF0);
        break;
      }

      case SV3_1aParser::BUFIF1: {
        _localctx = _tracker.createInstance<SV3_1aParser::EnableGateType_Bufif1Context>(_localctx);
        enterOuterAlt(_localctx, 2);
        setState(5623);
        match(SV3_1aParser::BUFIF1);
        break;
      }

      case SV3_1aParser::NOTIF0: {
        _localctx = _tracker.createInstance<SV3_1aParser::EnableGateType_Notif0Context>(_localctx);
        enterOuterAlt(_localctx, 3);
        setState(5624);
        match(SV3_1aParser::NOTIF0);
        break;
      }

      case SV3_1aParser::NOTIF1: {
        _localctx = _tracker.createInstance<SV3_1aParser::EnableGateType_Notif1Context>(_localctx);
        enterOuterAlt(_localctx, 4);
        setState(5625);
        match(SV3_1aParser::NOTIF1);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Mos_switchtypeContext ------------------------------------------------------------------

SV3_1aParser::Mos_switchtypeContext::Mos_switchtypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t SV3_1aParser::Mos_switchtypeContext::getRuleIndex() const {
  return SV3_1aParser::RuleMos_switchtype;
}

void SV3_1aParser::Mos_switchtypeContext::copyFrom(Mos_switchtypeContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- MosSwitchType_PMosContext ------------------------------------------------------------------

tree::TerminalNode* SV3_1aParser::MosSwitchType_PMosContext::PMOS() {
  return getToken(SV3_1aParser::PMOS, 0);
}

SV3_1aParser::MosSwitchType_PMosContext::MosSwitchType_PMosContext(Mos_switchtypeContext *ctx) { copyFrom(ctx); }

void SV3_1aParser::MosSwitchType_PMosContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterMosSwitchType_PMos(this);
}
void SV3_1aParser::MosSwitchType_PMosContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitMosSwitchType_PMos(this);
}
//----------------- MosSwitchType_NMosContext ------------------------------------------------------------------

tree::TerminalNode* SV3_1aParser::MosSwitchType_NMosContext::NMOS() {
  return getToken(SV3_1aParser::NMOS, 0);
}

SV3_1aParser::MosSwitchType_NMosContext::MosSwitchType_NMosContext(Mos_switchtypeContext *ctx) { copyFrom(ctx); }

void SV3_1aParser::MosSwitchType_NMosContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterMosSwitchType_NMos(this);
}
void SV3_1aParser::MosSwitchType_NMosContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitMosSwitchType_NMos(this);
}
//----------------- MosSwitchType_RPMosContext ------------------------------------------------------------------

tree::TerminalNode* SV3_1aParser::MosSwitchType_RPMosContext::RPMOS() {
  return getToken(SV3_1aParser::RPMOS, 0);
}

SV3_1aParser::MosSwitchType_RPMosContext::MosSwitchType_RPMosContext(Mos_switchtypeContext *ctx) { copyFrom(ctx); }

void SV3_1aParser::MosSwitchType_RPMosContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterMosSwitchType_RPMos(this);
}
void SV3_1aParser::MosSwitchType_RPMosContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitMosSwitchType_RPMos(this);
}
//----------------- MosSwitchType_RNMosContext ------------------------------------------------------------------

tree::TerminalNode* SV3_1aParser::MosSwitchType_RNMosContext::RNMOS() {
  return getToken(SV3_1aParser::RNMOS, 0);
}

SV3_1aParser::MosSwitchType_RNMosContext::MosSwitchType_RNMosContext(Mos_switchtypeContext *ctx) { copyFrom(ctx); }

void SV3_1aParser::MosSwitchType_RNMosContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterMosSwitchType_RNMos(this);
}
void SV3_1aParser::MosSwitchType_RNMosContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitMosSwitchType_RNMos(this);
}
SV3_1aParser::Mos_switchtypeContext* SV3_1aParser::mos_switchtype() {
  Mos_switchtypeContext *_localctx = _tracker.createInstance<Mos_switchtypeContext>(_ctx, getState());
  enterRule(_localctx, 598, SV3_1aParser::RuleMos_switchtype);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(5632);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SV3_1aParser::NMOS: {
        _localctx = _tracker.createInstance<SV3_1aParser::MosSwitchType_NMosContext>(_localctx);
        enterOuterAlt(_localctx, 1);
        setState(5628);
        match(SV3_1aParser::NMOS);
        break;
      }

      case SV3_1aParser::PMOS: {
        _localctx = _tracker.createInstance<SV3_1aParser::MosSwitchType_PMosContext>(_localctx);
        enterOuterAlt(_localctx, 2);
        setState(5629);
        match(SV3_1aParser::PMOS);
        break;
      }

      case SV3_1aParser::RNMOS: {
        _localctx = _tracker.createInstance<SV3_1aParser::MosSwitchType_RNMosContext>(_localctx);
        enterOuterAlt(_localctx, 3);
        setState(5630);
        match(SV3_1aParser::RNMOS);
        break;
      }

      case SV3_1aParser::RPMOS: {
        _localctx = _tracker.createInstance<SV3_1aParser::MosSwitchType_RPMosContext>(_localctx);
        enterOuterAlt(_localctx, 4);
        setState(5631);
        match(SV3_1aParser::RPMOS);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- N_input_gatetypeContext ------------------------------------------------------------------

SV3_1aParser::N_input_gatetypeContext::N_input_gatetypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t SV3_1aParser::N_input_gatetypeContext::getRuleIndex() const {
  return SV3_1aParser::RuleN_input_gatetype;
}

void SV3_1aParser::N_input_gatetypeContext::copyFrom(N_input_gatetypeContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- NInpGate_XorContext ------------------------------------------------------------------

tree::TerminalNode* SV3_1aParser::NInpGate_XorContext::XOR() {
  return getToken(SV3_1aParser::XOR, 0);
}

SV3_1aParser::NInpGate_XorContext::NInpGate_XorContext(N_input_gatetypeContext *ctx) { copyFrom(ctx); }

void SV3_1aParser::NInpGate_XorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNInpGate_Xor(this);
}
void SV3_1aParser::NInpGate_XorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNInpGate_Xor(this);
}
//----------------- NInpGate_NandContext ------------------------------------------------------------------

tree::TerminalNode* SV3_1aParser::NInpGate_NandContext::NAND() {
  return getToken(SV3_1aParser::NAND, 0);
}

SV3_1aParser::NInpGate_NandContext::NInpGate_NandContext(N_input_gatetypeContext *ctx) { copyFrom(ctx); }

void SV3_1aParser::NInpGate_NandContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNInpGate_Nand(this);
}
void SV3_1aParser::NInpGate_NandContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNInpGate_Nand(this);
}
//----------------- NInpGate_AndContext ------------------------------------------------------------------

tree::TerminalNode* SV3_1aParser::NInpGate_AndContext::AND() {
  return getToken(SV3_1aParser::AND, 0);
}

SV3_1aParser::NInpGate_AndContext::NInpGate_AndContext(N_input_gatetypeContext *ctx) { copyFrom(ctx); }

void SV3_1aParser::NInpGate_AndContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNInpGate_And(this);
}
void SV3_1aParser::NInpGate_AndContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNInpGate_And(this);
}
//----------------- NInpGate_OrContext ------------------------------------------------------------------

tree::TerminalNode* SV3_1aParser::NInpGate_OrContext::OR() {
  return getToken(SV3_1aParser::OR, 0);
}

SV3_1aParser::NInpGate_OrContext::NInpGate_OrContext(N_input_gatetypeContext *ctx) { copyFrom(ctx); }

void SV3_1aParser::NInpGate_OrContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNInpGate_Or(this);
}
void SV3_1aParser::NInpGate_OrContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNInpGate_Or(this);
}
//----------------- NInpGate_XnorContext ------------------------------------------------------------------

tree::TerminalNode* SV3_1aParser::NInpGate_XnorContext::XNOR() {
  return getToken(SV3_1aParser::XNOR, 0);
}

SV3_1aParser::NInpGate_XnorContext::NInpGate_XnorContext(N_input_gatetypeContext *ctx) { copyFrom(ctx); }

void SV3_1aParser::NInpGate_XnorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNInpGate_Xnor(this);
}
void SV3_1aParser::NInpGate_XnorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNInpGate_Xnor(this);
}
//----------------- NInpGate_NorContext ------------------------------------------------------------------

tree::TerminalNode* SV3_1aParser::NInpGate_NorContext::NOR() {
  return getToken(SV3_1aParser::NOR, 0);
}

SV3_1aParser::NInpGate_NorContext::NInpGate_NorContext(N_input_gatetypeContext *ctx) { copyFrom(ctx); }

void SV3_1aParser::NInpGate_NorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNInpGate_Nor(this);
}
void SV3_1aParser::NInpGate_NorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNInpGate_Nor(this);
}
SV3_1aParser::N_input_gatetypeContext* SV3_1aParser::n_input_gatetype() {
  N_input_gatetypeContext *_localctx = _tracker.createInstance<N_input_gatetypeContext>(_ctx, getState());
  enterRule(_localctx, 600, SV3_1aParser::RuleN_input_gatetype);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(5640);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SV3_1aParser::AND: {
        _localctx = _tracker.createInstance<SV3_1aParser::NInpGate_AndContext>(_localctx);
        enterOuterAlt(_localctx, 1);
        setState(5634);
        match(SV3_1aParser::AND);
        break;
      }

      case SV3_1aParser::NAND: {
        _localctx = _tracker.createInstance<SV3_1aParser::NInpGate_NandContext>(_localctx);
        enterOuterAlt(_localctx, 2);
        setState(5635);
        match(SV3_1aParser::NAND);
        break;
      }

      case SV3_1aParser::OR: {
        _localctx = _tracker.createInstance<SV3_1aParser::NInpGate_OrContext>(_localctx);
        enterOuterAlt(_localctx, 3);
        setState(5636);
        match(SV3_1aParser::OR);
        break;
      }

      case SV3_1aParser::NOR: {
        _localctx = _tracker.createInstance<SV3_1aParser::NInpGate_NorContext>(_localctx);
        enterOuterAlt(_localctx, 4);
        setState(5637);
        match(SV3_1aParser::NOR);
        break;
      }

      case SV3_1aParser::XOR: {
        _localctx = _tracker.createInstance<SV3_1aParser::NInpGate_XorContext>(_localctx);
        enterOuterAlt(_localctx, 5);
        setState(5638);
        match(SV3_1aParser::XOR);
        break;
      }

      case SV3_1aParser::XNOR: {
        _localctx = _tracker.createInstance<SV3_1aParser::NInpGate_XnorContext>(_localctx);
        enterOuterAlt(_localctx, 6);
        setState(5639);
        match(SV3_1aParser::XNOR);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- N_output_gatetypeContext ------------------------------------------------------------------

SV3_1aParser::N_output_gatetypeContext::N_output_gatetypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t SV3_1aParser::N_output_gatetypeContext::getRuleIndex() const {
  return SV3_1aParser::RuleN_output_gatetype;
}

void SV3_1aParser::N_output_gatetypeContext::copyFrom(N_output_gatetypeContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- NOutGate_BufContext ------------------------------------------------------------------

tree::TerminalNode* SV3_1aParser::NOutGate_BufContext::BUF() {
  return getToken(SV3_1aParser::BUF, 0);
}

SV3_1aParser::NOutGate_BufContext::NOutGate_BufContext(N_output_gatetypeContext *ctx) { copyFrom(ctx); }

void SV3_1aParser::NOutGate_BufContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNOutGate_Buf(this);
}
void SV3_1aParser::NOutGate_BufContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNOutGate_Buf(this);
}
//----------------- NOutGate_NotContext ------------------------------------------------------------------

tree::TerminalNode* SV3_1aParser::NOutGate_NotContext::NOT() {
  return getToken(SV3_1aParser::NOT, 0);
}

SV3_1aParser::NOutGate_NotContext::NOutGate_NotContext(N_output_gatetypeContext *ctx) { copyFrom(ctx); }

void SV3_1aParser::NOutGate_NotContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNOutGate_Not(this);
}
void SV3_1aParser::NOutGate_NotContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNOutGate_Not(this);
}
SV3_1aParser::N_output_gatetypeContext* SV3_1aParser::n_output_gatetype() {
  N_output_gatetypeContext *_localctx = _tracker.createInstance<N_output_gatetypeContext>(_ctx, getState());
  enterRule(_localctx, 602, SV3_1aParser::RuleN_output_gatetype);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(5644);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SV3_1aParser::BUF: {
        _localctx = _tracker.createInstance<SV3_1aParser::NOutGate_BufContext>(_localctx);
        enterOuterAlt(_localctx, 1);
        setState(5642);
        match(SV3_1aParser::BUF);
        break;
      }

      case SV3_1aParser::NOT: {
        _localctx = _tracker.createInstance<SV3_1aParser::NOutGate_NotContext>(_localctx);
        enterOuterAlt(_localctx, 2);
        setState(5643);
        match(SV3_1aParser::NOT);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Pass_en_switchtypeContext ------------------------------------------------------------------

SV3_1aParser::Pass_en_switchtypeContext::Pass_en_switchtypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t SV3_1aParser::Pass_en_switchtypeContext::getRuleIndex() const {
  return SV3_1aParser::RulePass_en_switchtype;
}

void SV3_1aParser::Pass_en_switchtypeContext::copyFrom(Pass_en_switchtypeContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- PassEnSwitch_RTranif1Context ------------------------------------------------------------------

tree::TerminalNode* SV3_1aParser::PassEnSwitch_RTranif1Context::RTRANIF1() {
  return getToken(SV3_1aParser::RTRANIF1, 0);
}

SV3_1aParser::PassEnSwitch_RTranif1Context::PassEnSwitch_RTranif1Context(Pass_en_switchtypeContext *ctx) { copyFrom(ctx); }

void SV3_1aParser::PassEnSwitch_RTranif1Context::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPassEnSwitch_RTranif1(this);
}
void SV3_1aParser::PassEnSwitch_RTranif1Context::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPassEnSwitch_RTranif1(this);
}
//----------------- PassEnSwitch_Tranif0Context ------------------------------------------------------------------

tree::TerminalNode* SV3_1aParser::PassEnSwitch_Tranif0Context::TRANIF0() {
  return getToken(SV3_1aParser::TRANIF0, 0);
}

SV3_1aParser::PassEnSwitch_Tranif0Context::PassEnSwitch_Tranif0Context(Pass_en_switchtypeContext *ctx) { copyFrom(ctx); }

void SV3_1aParser::PassEnSwitch_Tranif0Context::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPassEnSwitch_Tranif0(this);
}
void SV3_1aParser::PassEnSwitch_Tranif0Context::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPassEnSwitch_Tranif0(this);
}
//----------------- PassEnSwitch_Tranif1Context ------------------------------------------------------------------

tree::TerminalNode* SV3_1aParser::PassEnSwitch_Tranif1Context::TRANIF1() {
  return getToken(SV3_1aParser::TRANIF1, 0);
}

SV3_1aParser::PassEnSwitch_Tranif1Context::PassEnSwitch_Tranif1Context(Pass_en_switchtypeContext *ctx) { copyFrom(ctx); }

void SV3_1aParser::PassEnSwitch_Tranif1Context::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPassEnSwitch_Tranif1(this);
}
void SV3_1aParser::PassEnSwitch_Tranif1Context::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPassEnSwitch_Tranif1(this);
}
//----------------- PassEnSwitch_RTranif0Context ------------------------------------------------------------------

tree::TerminalNode* SV3_1aParser::PassEnSwitch_RTranif0Context::RTRANIF0() {
  return getToken(SV3_1aParser::RTRANIF0, 0);
}

SV3_1aParser::PassEnSwitch_RTranif0Context::PassEnSwitch_RTranif0Context(Pass_en_switchtypeContext *ctx) { copyFrom(ctx); }

void SV3_1aParser::PassEnSwitch_RTranif0Context::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPassEnSwitch_RTranif0(this);
}
void SV3_1aParser::PassEnSwitch_RTranif0Context::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPassEnSwitch_RTranif0(this);
}
SV3_1aParser::Pass_en_switchtypeContext* SV3_1aParser::pass_en_switchtype() {
  Pass_en_switchtypeContext *_localctx = _tracker.createInstance<Pass_en_switchtypeContext>(_ctx, getState());
  enterRule(_localctx, 604, SV3_1aParser::RulePass_en_switchtype);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(5650);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SV3_1aParser::TRANIF0: {
        _localctx = _tracker.createInstance<SV3_1aParser::PassEnSwitch_Tranif0Context>(_localctx);
        enterOuterAlt(_localctx, 1);
        setState(5646);
        match(SV3_1aParser::TRANIF0);
        break;
      }

      case SV3_1aParser::TRANIF1: {
        _localctx = _tracker.createInstance<SV3_1aParser::PassEnSwitch_Tranif1Context>(_localctx);
        enterOuterAlt(_localctx, 2);
        setState(5647);
        match(SV3_1aParser::TRANIF1);
        break;
      }

      case SV3_1aParser::RTRANIF1: {
        _localctx = _tracker.createInstance<SV3_1aParser::PassEnSwitch_RTranif1Context>(_localctx);
        enterOuterAlt(_localctx, 3);
        setState(5648);
        match(SV3_1aParser::RTRANIF1);
        break;
      }

      case SV3_1aParser::RTRANIF0: {
        _localctx = _tracker.createInstance<SV3_1aParser::PassEnSwitch_RTranif0Context>(_localctx);
        enterOuterAlt(_localctx, 4);
        setState(5649);
        match(SV3_1aParser::RTRANIF0);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Pass_switchtypeContext ------------------------------------------------------------------

SV3_1aParser::Pass_switchtypeContext::Pass_switchtypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t SV3_1aParser::Pass_switchtypeContext::getRuleIndex() const {
  return SV3_1aParser::RulePass_switchtype;
}

void SV3_1aParser::Pass_switchtypeContext::copyFrom(Pass_switchtypeContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- PassSwitch_RTranContext ------------------------------------------------------------------

tree::TerminalNode* SV3_1aParser::PassSwitch_RTranContext::RTRAN() {
  return getToken(SV3_1aParser::RTRAN, 0);
}

SV3_1aParser::PassSwitch_RTranContext::PassSwitch_RTranContext(Pass_switchtypeContext *ctx) { copyFrom(ctx); }

void SV3_1aParser::PassSwitch_RTranContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPassSwitch_RTran(this);
}
void SV3_1aParser::PassSwitch_RTranContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPassSwitch_RTran(this);
}
//----------------- PassSwitch_TranContext ------------------------------------------------------------------

tree::TerminalNode* SV3_1aParser::PassSwitch_TranContext::TRAN() {
  return getToken(SV3_1aParser::TRAN, 0);
}

SV3_1aParser::PassSwitch_TranContext::PassSwitch_TranContext(Pass_switchtypeContext *ctx) { copyFrom(ctx); }

void SV3_1aParser::PassSwitch_TranContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPassSwitch_Tran(this);
}
void SV3_1aParser::PassSwitch_TranContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPassSwitch_Tran(this);
}
SV3_1aParser::Pass_switchtypeContext* SV3_1aParser::pass_switchtype() {
  Pass_switchtypeContext *_localctx = _tracker.createInstance<Pass_switchtypeContext>(_ctx, getState());
  enterRule(_localctx, 606, SV3_1aParser::RulePass_switchtype);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(5654);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SV3_1aParser::TRAN: {
        _localctx = _tracker.createInstance<SV3_1aParser::PassSwitch_TranContext>(_localctx);
        enterOuterAlt(_localctx, 1);
        setState(5652);
        match(SV3_1aParser::TRAN);
        break;
      }

      case SV3_1aParser::RTRAN: {
        _localctx = _tracker.createInstance<SV3_1aParser::PassSwitch_RTranContext>(_localctx);
        enterOuterAlt(_localctx, 2);
        setState(5653);
        match(SV3_1aParser::RTRAN);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Module_instantiationContext ------------------------------------------------------------------

SV3_1aParser::Module_instantiationContext::Module_instantiationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::IdentifierContext* SV3_1aParser::Module_instantiationContext::identifier() {
  return getRuleContext<SV3_1aParser::IdentifierContext>(0);
}

std::vector<SV3_1aParser::Hierarchical_instanceContext *> SV3_1aParser::Module_instantiationContext::hierarchical_instance() {
  return getRuleContexts<SV3_1aParser::Hierarchical_instanceContext>();
}

SV3_1aParser::Hierarchical_instanceContext* SV3_1aParser::Module_instantiationContext::hierarchical_instance(size_t i) {
  return getRuleContext<SV3_1aParser::Hierarchical_instanceContext>(i);
}

tree::TerminalNode* SV3_1aParser::Module_instantiationContext::SEMICOLON() {
  return getToken(SV3_1aParser::SEMICOLON, 0);
}

SV3_1aParser::Parameter_value_assignmentContext* SV3_1aParser::Module_instantiationContext::parameter_value_assignment() {
  return getRuleContext<SV3_1aParser::Parameter_value_assignmentContext>(0);
}

std::vector<tree::TerminalNode *> SV3_1aParser::Module_instantiationContext::COMMA() {
  return getTokens(SV3_1aParser::COMMA);
}

tree::TerminalNode* SV3_1aParser::Module_instantiationContext::COMMA(size_t i) {
  return getToken(SV3_1aParser::COMMA, i);
}


size_t SV3_1aParser::Module_instantiationContext::getRuleIndex() const {
  return SV3_1aParser::RuleModule_instantiation;
}

void SV3_1aParser::Module_instantiationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterModule_instantiation(this);
}

void SV3_1aParser::Module_instantiationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitModule_instantiation(this);
}

SV3_1aParser::Module_instantiationContext* SV3_1aParser::module_instantiation() {
  Module_instantiationContext *_localctx = _tracker.createInstance<Module_instantiationContext>(_ctx, getState());
  enterRule(_localctx, 608, SV3_1aParser::RuleModule_instantiation);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5656);
    identifier();
    setState(5658);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SV3_1aParser::Pound_delay || _la == SV3_1aParser::POUND) {
      setState(5657);
      parameter_value_assignment();
    }
    setState(5660);
    hierarchical_instance();
    setState(5665);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == SV3_1aParser::COMMA) {
      setState(5661);
      match(SV3_1aParser::COMMA);
      setState(5662);
      hierarchical_instance();
      setState(5667);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(5668);
    match(SV3_1aParser::SEMICOLON);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Parameter_value_assignmentContext ------------------------------------------------------------------

SV3_1aParser::Parameter_value_assignmentContext::Parameter_value_assignmentContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Parameter_value_assignmentContext::POUND() {
  return getToken(SV3_1aParser::POUND, 0);
}

tree::TerminalNode* SV3_1aParser::Parameter_value_assignmentContext::OPEN_PARENS() {
  return getToken(SV3_1aParser::OPEN_PARENS, 0);
}

tree::TerminalNode* SV3_1aParser::Parameter_value_assignmentContext::CLOSE_PARENS() {
  return getToken(SV3_1aParser::CLOSE_PARENS, 0);
}

SV3_1aParser::List_of_parameter_assignmentsContext* SV3_1aParser::Parameter_value_assignmentContext::list_of_parameter_assignments() {
  return getRuleContext<SV3_1aParser::List_of_parameter_assignmentsContext>(0);
}

tree::TerminalNode* SV3_1aParser::Parameter_value_assignmentContext::Pound_delay() {
  return getToken(SV3_1aParser::Pound_delay, 0);
}

tree::TerminalNode* SV3_1aParser::Parameter_value_assignmentContext::Simple_identifier() {
  return getToken(SV3_1aParser::Simple_identifier, 0);
}


size_t SV3_1aParser::Parameter_value_assignmentContext::getRuleIndex() const {
  return SV3_1aParser::RuleParameter_value_assignment;
}

void SV3_1aParser::Parameter_value_assignmentContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterParameter_value_assignment(this);
}

void SV3_1aParser::Parameter_value_assignmentContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitParameter_value_assignment(this);
}

SV3_1aParser::Parameter_value_assignmentContext* SV3_1aParser::parameter_value_assignment() {
  Parameter_value_assignmentContext *_localctx = _tracker.createInstance<Parameter_value_assignmentContext>(_ctx, getState());
  enterRule(_localctx, 610, SV3_1aParser::RuleParameter_value_assignment);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(5679);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 633, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(5670);
      match(SV3_1aParser::POUND);

      setState(5671);
      match(SV3_1aParser::OPEN_PARENS);
      setState(5673);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if ((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & 4512430082031612) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 64)) & 1152705450574382081) != 0) || ((((_la - 147) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 147)) & 2199527096323) != 0) || _la == SV3_1aParser::BANG || ((((_la - 310) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 310)) & 559537073624154177) != 0)) {
        setState(5672);
        list_of_parameter_assignments();
      }
      setState(5675);
      match(SV3_1aParser::CLOSE_PARENS);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(5676);
      match(SV3_1aParser::Pound_delay);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(5677);
      match(SV3_1aParser::POUND);
      setState(5678);
      match(SV3_1aParser::Simple_identifier);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- List_of_parameter_assignmentsContext ------------------------------------------------------------------

SV3_1aParser::List_of_parameter_assignmentsContext::List_of_parameter_assignmentsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<SV3_1aParser::Ordered_parameter_assignmentContext *> SV3_1aParser::List_of_parameter_assignmentsContext::ordered_parameter_assignment() {
  return getRuleContexts<SV3_1aParser::Ordered_parameter_assignmentContext>();
}

SV3_1aParser::Ordered_parameter_assignmentContext* SV3_1aParser::List_of_parameter_assignmentsContext::ordered_parameter_assignment(size_t i) {
  return getRuleContext<SV3_1aParser::Ordered_parameter_assignmentContext>(i);
}

std::vector<tree::TerminalNode *> SV3_1aParser::List_of_parameter_assignmentsContext::COMMA() {
  return getTokens(SV3_1aParser::COMMA);
}

tree::TerminalNode* SV3_1aParser::List_of_parameter_assignmentsContext::COMMA(size_t i) {
  return getToken(SV3_1aParser::COMMA, i);
}

std::vector<SV3_1aParser::Named_parameter_assignmentContext *> SV3_1aParser::List_of_parameter_assignmentsContext::named_parameter_assignment() {
  return getRuleContexts<SV3_1aParser::Named_parameter_assignmentContext>();
}

SV3_1aParser::Named_parameter_assignmentContext* SV3_1aParser::List_of_parameter_assignmentsContext::named_parameter_assignment(size_t i) {
  return getRuleContext<SV3_1aParser::Named_parameter_assignmentContext>(i);
}


size_t SV3_1aParser::List_of_parameter_assignmentsContext::getRuleIndex() const {
  return SV3_1aParser::RuleList_of_parameter_assignments;
}

void SV3_1aParser::List_of_parameter_assignmentsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterList_of_parameter_assignments(this);
}

void SV3_1aParser::List_of_parameter_assignmentsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitList_of_parameter_assignments(this);
}

SV3_1aParser::List_of_parameter_assignmentsContext* SV3_1aParser::list_of_parameter_assignments() {
  List_of_parameter_assignmentsContext *_localctx = _tracker.createInstance<List_of_parameter_assignmentsContext>(_ctx, getState());
  enterRule(_localctx, 612, SV3_1aParser::RuleList_of_parameter_assignments);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(5697);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SV3_1aParser::TICK_b0:
      case SV3_1aParser::TICK_b1:
      case SV3_1aParser::TICK_B0:
      case SV3_1aParser::TICK_B1:
      case SV3_1aParser::TICK_0:
      case SV3_1aParser::TICK_1:
      case SV3_1aParser::ONE_TICK_b0:
      case SV3_1aParser::ONE_TICK_b1:
      case SV3_1aParser::ONE_TICK_bx:
      case SV3_1aParser::ONE_TICK_bX:
      case SV3_1aParser::ONE_TICK_B0:
      case SV3_1aParser::ONE_TICK_B1:
      case SV3_1aParser::ONE_TICK_Bx:
      case SV3_1aParser::ONE_TICK_BX:
      case SV3_1aParser::Integral_number:
      case SV3_1aParser::Real_number:
      case SV3_1aParser::String:
      case SV3_1aParser::OPEN_PARENS:
      case SV3_1aParser::VIRTUAL:
      case SV3_1aParser::TYPE:
      case SV3_1aParser::CONST:
      case SV3_1aParser::LOCAL:
      case SV3_1aParser::SUPER:
      case SV3_1aParser::OPEN_CURLY:
      case SV3_1aParser::ENUM:
      case SV3_1aParser::STRUCT:
      case SV3_1aParser::UNION:
      case SV3_1aParser::STRING:
      case SV3_1aParser::CHANDLE:
      case SV3_1aParser::EVENT:
      case SV3_1aParser::BYTE:
      case SV3_1aParser::SHORTINT:
      case SV3_1aParser::INT:
      case SV3_1aParser::LONGINT:
      case SV3_1aParser::INTEGER:
      case SV3_1aParser::TIME:
      case SV3_1aParser::BIT:
      case SV3_1aParser::LOGIC:
      case SV3_1aParser::REG:
      case SV3_1aParser::SHORTREAL:
      case SV3_1aParser::REAL:
      case SV3_1aParser::REALTIME:
      case SV3_1aParser::SIGNED:
      case SV3_1aParser::UNSIGNED:
      case SV3_1aParser::DOLLAR:
      case SV3_1aParser::PLUSPLUS:
      case SV3_1aParser::PLUS:
      case SV3_1aParser::MINUSMINUS:
      case SV3_1aParser::MINUS:
      case SV3_1aParser::DOLLAR_UNIT:
      case SV3_1aParser::BANG:
      case SV3_1aParser::TAGGED:
      case SV3_1aParser::TICK:
      case SV3_1aParser::NULL_KEYWORD:
      case SV3_1aParser::THIS:
      case SV3_1aParser::DOLLAR_ROOT:
      case SV3_1aParser::RANDOMIZE:
      case SV3_1aParser::SAMPLE:
      case SV3_1aParser::BITW_AND:
      case SV3_1aParser::BITW_OR:
      case SV3_1aParser::REDUCTION_NOR:
      case SV3_1aParser::REDUCTION_NAND:
      case SV3_1aParser::REDUCTION_XNOR1:
      case SV3_1aParser::Escaped_identifier:
      case SV3_1aParser::TILDA:
      case SV3_1aParser::BITW_XOR:
      case SV3_1aParser::REDUCTION_XNOR2:
      case SV3_1aParser::Simple_identifier: {
        enterOuterAlt(_localctx, 1);
        setState(5681);
        ordered_parameter_assignment();
        setState(5686);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == SV3_1aParser::COMMA) {
          setState(5682);
          match(SV3_1aParser::COMMA);
          setState(5683);
          ordered_parameter_assignment();
          setState(5688);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        break;
      }

      case SV3_1aParser::DOT: {
        enterOuterAlt(_localctx, 2);
        setState(5689);
        named_parameter_assignment();
        setState(5694);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == SV3_1aParser::COMMA) {
          setState(5690);
          match(SV3_1aParser::COMMA);
          setState(5691);
          named_parameter_assignment();
          setState(5696);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Ordered_parameter_assignmentContext ------------------------------------------------------------------

SV3_1aParser::Ordered_parameter_assignmentContext::Ordered_parameter_assignmentContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::Param_expressionContext* SV3_1aParser::Ordered_parameter_assignmentContext::param_expression() {
  return getRuleContext<SV3_1aParser::Param_expressionContext>(0);
}


size_t SV3_1aParser::Ordered_parameter_assignmentContext::getRuleIndex() const {
  return SV3_1aParser::RuleOrdered_parameter_assignment;
}

void SV3_1aParser::Ordered_parameter_assignmentContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOrdered_parameter_assignment(this);
}

void SV3_1aParser::Ordered_parameter_assignmentContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOrdered_parameter_assignment(this);
}

SV3_1aParser::Ordered_parameter_assignmentContext* SV3_1aParser::ordered_parameter_assignment() {
  Ordered_parameter_assignmentContext *_localctx = _tracker.createInstance<Ordered_parameter_assignmentContext>(_ctx, getState());
  enterRule(_localctx, 614, SV3_1aParser::RuleOrdered_parameter_assignment);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5699);
    param_expression();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Named_parameter_assignmentContext ------------------------------------------------------------------

SV3_1aParser::Named_parameter_assignmentContext::Named_parameter_assignmentContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Named_parameter_assignmentContext::DOT() {
  return getToken(SV3_1aParser::DOT, 0);
}

SV3_1aParser::IdentifierContext* SV3_1aParser::Named_parameter_assignmentContext::identifier() {
  return getRuleContext<SV3_1aParser::IdentifierContext>(0);
}

tree::TerminalNode* SV3_1aParser::Named_parameter_assignmentContext::OPEN_PARENS() {
  return getToken(SV3_1aParser::OPEN_PARENS, 0);
}

tree::TerminalNode* SV3_1aParser::Named_parameter_assignmentContext::CLOSE_PARENS() {
  return getToken(SV3_1aParser::CLOSE_PARENS, 0);
}

SV3_1aParser::Param_expressionContext* SV3_1aParser::Named_parameter_assignmentContext::param_expression() {
  return getRuleContext<SV3_1aParser::Param_expressionContext>(0);
}


size_t SV3_1aParser::Named_parameter_assignmentContext::getRuleIndex() const {
  return SV3_1aParser::RuleNamed_parameter_assignment;
}

void SV3_1aParser::Named_parameter_assignmentContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNamed_parameter_assignment(this);
}

void SV3_1aParser::Named_parameter_assignmentContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNamed_parameter_assignment(this);
}

SV3_1aParser::Named_parameter_assignmentContext* SV3_1aParser::named_parameter_assignment() {
  Named_parameter_assignmentContext *_localctx = _tracker.createInstance<Named_parameter_assignmentContext>(_ctx, getState());
  enterRule(_localctx, 616, SV3_1aParser::RuleNamed_parameter_assignment);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5701);
    match(SV3_1aParser::DOT);
    setState(5702);
    identifier();
    setState(5703);
    match(SV3_1aParser::OPEN_PARENS);
    setState(5705);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 4512395722293244) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 64)) & 1152705450574382081) != 0) || ((((_la - 147) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 147)) & 2199527096323) != 0) || _la == SV3_1aParser::BANG || ((((_la - 310) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 310)) & 559537073624154177) != 0)) {
      setState(5704);
      param_expression();
    }
    setState(5707);
    match(SV3_1aParser::CLOSE_PARENS);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Hierarchical_instanceContext ------------------------------------------------------------------

SV3_1aParser::Hierarchical_instanceContext::Hierarchical_instanceContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::Name_of_instanceContext* SV3_1aParser::Hierarchical_instanceContext::name_of_instance() {
  return getRuleContext<SV3_1aParser::Name_of_instanceContext>(0);
}

tree::TerminalNode* SV3_1aParser::Hierarchical_instanceContext::OPEN_PARENS() {
  return getToken(SV3_1aParser::OPEN_PARENS, 0);
}

SV3_1aParser::List_of_port_connectionsContext* SV3_1aParser::Hierarchical_instanceContext::list_of_port_connections() {
  return getRuleContext<SV3_1aParser::List_of_port_connectionsContext>(0);
}

tree::TerminalNode* SV3_1aParser::Hierarchical_instanceContext::CLOSE_PARENS() {
  return getToken(SV3_1aParser::CLOSE_PARENS, 0);
}


size_t SV3_1aParser::Hierarchical_instanceContext::getRuleIndex() const {
  return SV3_1aParser::RuleHierarchical_instance;
}

void SV3_1aParser::Hierarchical_instanceContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterHierarchical_instance(this);
}

void SV3_1aParser::Hierarchical_instanceContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitHierarchical_instance(this);
}

SV3_1aParser::Hierarchical_instanceContext* SV3_1aParser::hierarchical_instance() {
  Hierarchical_instanceContext *_localctx = _tracker.createInstance<Hierarchical_instanceContext>(_ctx, getState());
  enterRule(_localctx, 618, SV3_1aParser::RuleHierarchical_instance);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5709);
    name_of_instance();
    setState(5710);
    match(SV3_1aParser::OPEN_PARENS);
    setState(5711);
    list_of_port_connections();
    setState(5712);
    match(SV3_1aParser::CLOSE_PARENS);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Name_of_instanceContext ------------------------------------------------------------------

SV3_1aParser::Name_of_instanceContext::Name_of_instanceContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::IdentifierContext* SV3_1aParser::Name_of_instanceContext::identifier() {
  return getRuleContext<SV3_1aParser::IdentifierContext>(0);
}

std::vector<SV3_1aParser::Unpacked_dimensionContext *> SV3_1aParser::Name_of_instanceContext::unpacked_dimension() {
  return getRuleContexts<SV3_1aParser::Unpacked_dimensionContext>();
}

SV3_1aParser::Unpacked_dimensionContext* SV3_1aParser::Name_of_instanceContext::unpacked_dimension(size_t i) {
  return getRuleContext<SV3_1aParser::Unpacked_dimensionContext>(i);
}


size_t SV3_1aParser::Name_of_instanceContext::getRuleIndex() const {
  return SV3_1aParser::RuleName_of_instance;
}

void SV3_1aParser::Name_of_instanceContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterName_of_instance(this);
}

void SV3_1aParser::Name_of_instanceContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitName_of_instance(this);
}

SV3_1aParser::Name_of_instanceContext* SV3_1aParser::name_of_instance() {
  Name_of_instanceContext *_localctx = _tracker.createInstance<Name_of_instanceContext>(_ctx, getState());
  enterRule(_localctx, 620, SV3_1aParser::RuleName_of_instance);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5714);
    identifier();
    setState(5718);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == SV3_1aParser::OPEN_BRACKET) {
      setState(5715);
      unpacked_dimension();
      setState(5720);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- List_of_port_connectionsContext ------------------------------------------------------------------

SV3_1aParser::List_of_port_connectionsContext::List_of_port_connectionsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<SV3_1aParser::Ordered_port_connectionContext *> SV3_1aParser::List_of_port_connectionsContext::ordered_port_connection() {
  return getRuleContexts<SV3_1aParser::Ordered_port_connectionContext>();
}

SV3_1aParser::Ordered_port_connectionContext* SV3_1aParser::List_of_port_connectionsContext::ordered_port_connection(size_t i) {
  return getRuleContext<SV3_1aParser::Ordered_port_connectionContext>(i);
}

std::vector<tree::TerminalNode *> SV3_1aParser::List_of_port_connectionsContext::COMMA() {
  return getTokens(SV3_1aParser::COMMA);
}

tree::TerminalNode* SV3_1aParser::List_of_port_connectionsContext::COMMA(size_t i) {
  return getToken(SV3_1aParser::COMMA, i);
}

std::vector<SV3_1aParser::Named_port_connectionContext *> SV3_1aParser::List_of_port_connectionsContext::named_port_connection() {
  return getRuleContexts<SV3_1aParser::Named_port_connectionContext>();
}

SV3_1aParser::Named_port_connectionContext* SV3_1aParser::List_of_port_connectionsContext::named_port_connection(size_t i) {
  return getRuleContext<SV3_1aParser::Named_port_connectionContext>(i);
}


size_t SV3_1aParser::List_of_port_connectionsContext::getRuleIndex() const {
  return SV3_1aParser::RuleList_of_port_connections;
}

void SV3_1aParser::List_of_port_connectionsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterList_of_port_connections(this);
}

void SV3_1aParser::List_of_port_connectionsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitList_of_port_connections(this);
}

SV3_1aParser::List_of_port_connectionsContext* SV3_1aParser::list_of_port_connections() {
  List_of_port_connectionsContext *_localctx = _tracker.createInstance<List_of_port_connectionsContext>(_ctx, getState());
  enterRule(_localctx, 622, SV3_1aParser::RuleList_of_port_connections);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(5737);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 641, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(5721);
      ordered_port_connection();
      setState(5726);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == SV3_1aParser::COMMA) {
        setState(5722);
        match(SV3_1aParser::COMMA);
        setState(5723);
        ordered_port_connection();
        setState(5728);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(5729);
      named_port_connection();
      setState(5734);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == SV3_1aParser::COMMA) {
        setState(5730);
        match(SV3_1aParser::COMMA);
        setState(5731);
        named_port_connection();
        setState(5736);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Ordered_port_connectionContext ------------------------------------------------------------------

SV3_1aParser::Ordered_port_connectionContext::Ordered_port_connectionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<SV3_1aParser::Attribute_instanceContext *> SV3_1aParser::Ordered_port_connectionContext::attribute_instance() {
  return getRuleContexts<SV3_1aParser::Attribute_instanceContext>();
}

SV3_1aParser::Attribute_instanceContext* SV3_1aParser::Ordered_port_connectionContext::attribute_instance(size_t i) {
  return getRuleContext<SV3_1aParser::Attribute_instanceContext>(i);
}

SV3_1aParser::ExpressionContext* SV3_1aParser::Ordered_port_connectionContext::expression() {
  return getRuleContext<SV3_1aParser::ExpressionContext>(0);
}


size_t SV3_1aParser::Ordered_port_connectionContext::getRuleIndex() const {
  return SV3_1aParser::RuleOrdered_port_connection;
}

void SV3_1aParser::Ordered_port_connectionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOrdered_port_connection(this);
}

void SV3_1aParser::Ordered_port_connectionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOrdered_port_connection(this);
}

SV3_1aParser::Ordered_port_connectionContext* SV3_1aParser::ordered_port_connection() {
  Ordered_port_connectionContext *_localctx = _tracker.createInstance<Ordered_port_connectionContext>(_ctx, getState());
  enterRule(_localctx, 624, SV3_1aParser::RuleOrdered_port_connection);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5742);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == SV3_1aParser::OPEN_PARENS_STAR) {
      setState(5739);
      attribute_instance();
      setState(5744);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(5746);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 8796094922748) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 64)) & 1152648825725551617) != 0) || ((((_la - 147) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 147)) & 2199527096323) != 0) || _la == SV3_1aParser::BANG || ((((_la - 310) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 310)) & 559537073624154177) != 0)) {
      setState(5745);
      expression(0);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Named_port_connectionContext ------------------------------------------------------------------

SV3_1aParser::Named_port_connectionContext::Named_port_connectionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Named_port_connectionContext::DOT() {
  return getToken(SV3_1aParser::DOT, 0);
}

SV3_1aParser::IdentifierContext* SV3_1aParser::Named_port_connectionContext::identifier() {
  return getRuleContext<SV3_1aParser::IdentifierContext>(0);
}

tree::TerminalNode* SV3_1aParser::Named_port_connectionContext::DOTSTAR() {
  return getToken(SV3_1aParser::DOTSTAR, 0);
}

std::vector<SV3_1aParser::Attribute_instanceContext *> SV3_1aParser::Named_port_connectionContext::attribute_instance() {
  return getRuleContexts<SV3_1aParser::Attribute_instanceContext>();
}

SV3_1aParser::Attribute_instanceContext* SV3_1aParser::Named_port_connectionContext::attribute_instance(size_t i) {
  return getRuleContext<SV3_1aParser::Attribute_instanceContext>(i);
}

tree::TerminalNode* SV3_1aParser::Named_port_connectionContext::OPEN_PARENS() {
  return getToken(SV3_1aParser::OPEN_PARENS, 0);
}

tree::TerminalNode* SV3_1aParser::Named_port_connectionContext::CLOSE_PARENS() {
  return getToken(SV3_1aParser::CLOSE_PARENS, 0);
}

SV3_1aParser::ExpressionContext* SV3_1aParser::Named_port_connectionContext::expression() {
  return getRuleContext<SV3_1aParser::ExpressionContext>(0);
}


size_t SV3_1aParser::Named_port_connectionContext::getRuleIndex() const {
  return SV3_1aParser::RuleNamed_port_connection;
}

void SV3_1aParser::Named_port_connectionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNamed_port_connection(this);
}

void SV3_1aParser::Named_port_connectionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNamed_port_connection(this);
}

SV3_1aParser::Named_port_connectionContext* SV3_1aParser::named_port_connection() {
  Named_port_connectionContext *_localctx = _tracker.createInstance<Named_port_connectionContext>(_ctx, getState());
  enterRule(_localctx, 626, SV3_1aParser::RuleNamed_port_connection);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5751);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == SV3_1aParser::OPEN_PARENS_STAR) {
      setState(5748);
      attribute_instance();
      setState(5753);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(5764);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SV3_1aParser::DOT: {
        setState(5754);
        match(SV3_1aParser::DOT);
        setState(5755);
        identifier();
        setState(5761);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == SV3_1aParser::OPEN_PARENS) {
          setState(5756);
          match(SV3_1aParser::OPEN_PARENS);
          setState(5758);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if ((((_la & ~ 0x3fULL) == 0) &&
            ((1ULL << _la) & 8796094922748) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
            ((1ULL << (_la - 64)) & 1152648825725551617) != 0) || ((((_la - 147) & ~ 0x3fULL) == 0) &&
            ((1ULL << (_la - 147)) & 2199527096323) != 0) || _la == SV3_1aParser::BANG || ((((_la - 310) & ~ 0x3fULL) == 0) &&
            ((1ULL << (_la - 310)) & 559537073624154177) != 0)) {
            setState(5757);
            expression(0);
          }
          setState(5760);
          match(SV3_1aParser::CLOSE_PARENS);
        }
        break;
      }

      case SV3_1aParser::DOTSTAR: {
        setState(5763);
        match(SV3_1aParser::DOTSTAR);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Checker_instantiationContext ------------------------------------------------------------------

SV3_1aParser::Checker_instantiationContext::Checker_instantiationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::Ps_identifierContext* SV3_1aParser::Checker_instantiationContext::ps_identifier() {
  return getRuleContext<SV3_1aParser::Ps_identifierContext>(0);
}

SV3_1aParser::Name_of_instanceContext* SV3_1aParser::Checker_instantiationContext::name_of_instance() {
  return getRuleContext<SV3_1aParser::Name_of_instanceContext>(0);
}

tree::TerminalNode* SV3_1aParser::Checker_instantiationContext::OPEN_PARENS() {
  return getToken(SV3_1aParser::OPEN_PARENS, 0);
}

SV3_1aParser::List_of_checker_port_connectionsContext* SV3_1aParser::Checker_instantiationContext::list_of_checker_port_connections() {
  return getRuleContext<SV3_1aParser::List_of_checker_port_connectionsContext>(0);
}

tree::TerminalNode* SV3_1aParser::Checker_instantiationContext::CLOSE_PARENS() {
  return getToken(SV3_1aParser::CLOSE_PARENS, 0);
}

tree::TerminalNode* SV3_1aParser::Checker_instantiationContext::SEMICOLON() {
  return getToken(SV3_1aParser::SEMICOLON, 0);
}


size_t SV3_1aParser::Checker_instantiationContext::getRuleIndex() const {
  return SV3_1aParser::RuleChecker_instantiation;
}

void SV3_1aParser::Checker_instantiationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterChecker_instantiation(this);
}

void SV3_1aParser::Checker_instantiationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitChecker_instantiation(this);
}

SV3_1aParser::Checker_instantiationContext* SV3_1aParser::checker_instantiation() {
  Checker_instantiationContext *_localctx = _tracker.createInstance<Checker_instantiationContext>(_ctx, getState());
  enterRule(_localctx, 628, SV3_1aParser::RuleChecker_instantiation);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5766);
    ps_identifier();
    setState(5767);
    name_of_instance();
    setState(5768);
    match(SV3_1aParser::OPEN_PARENS);
    setState(5769);
    list_of_checker_port_connections();
    setState(5770);
    match(SV3_1aParser::CLOSE_PARENS);
    setState(5771);
    match(SV3_1aParser::SEMICOLON);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- List_of_checker_port_connectionsContext ------------------------------------------------------------------

SV3_1aParser::List_of_checker_port_connectionsContext::List_of_checker_port_connectionsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<SV3_1aParser::Ordered_checker_port_connectionContext *> SV3_1aParser::List_of_checker_port_connectionsContext::ordered_checker_port_connection() {
  return getRuleContexts<SV3_1aParser::Ordered_checker_port_connectionContext>();
}

SV3_1aParser::Ordered_checker_port_connectionContext* SV3_1aParser::List_of_checker_port_connectionsContext::ordered_checker_port_connection(size_t i) {
  return getRuleContext<SV3_1aParser::Ordered_checker_port_connectionContext>(i);
}

tree::TerminalNode* SV3_1aParser::List_of_checker_port_connectionsContext::COMMA() {
  return getToken(SV3_1aParser::COMMA, 0);
}

std::vector<SV3_1aParser::Named_checker_port_connectionContext *> SV3_1aParser::List_of_checker_port_connectionsContext::named_checker_port_connection() {
  return getRuleContexts<SV3_1aParser::Named_checker_port_connectionContext>();
}

SV3_1aParser::Named_checker_port_connectionContext* SV3_1aParser::List_of_checker_port_connectionsContext::named_checker_port_connection(size_t i) {
  return getRuleContext<SV3_1aParser::Named_checker_port_connectionContext>(i);
}


size_t SV3_1aParser::List_of_checker_port_connectionsContext::getRuleIndex() const {
  return SV3_1aParser::RuleList_of_checker_port_connections;
}

void SV3_1aParser::List_of_checker_port_connectionsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterList_of_checker_port_connections(this);
}

void SV3_1aParser::List_of_checker_port_connectionsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitList_of_checker_port_connections(this);
}

SV3_1aParser::List_of_checker_port_connectionsContext* SV3_1aParser::list_of_checker_port_connections() {
  List_of_checker_port_connectionsContext *_localctx = _tracker.createInstance<List_of_checker_port_connectionsContext>(_ctx, getState());
  enterRule(_localctx, 630, SV3_1aParser::RuleList_of_checker_port_connections);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(5783);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 650, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(5773);
      ordered_checker_port_connection();
      setState(5776);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == SV3_1aParser::COMMA) {
        setState(5774);
        match(SV3_1aParser::COMMA);
        setState(5775);
        ordered_checker_port_connection();
      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(5778);
      named_checker_port_connection();
      setState(5781);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == SV3_1aParser::COMMA) {
        setState(5779);
        match(SV3_1aParser::COMMA);
        setState(5780);
        named_checker_port_connection();
      }
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Ordered_checker_port_connectionContext ------------------------------------------------------------------

SV3_1aParser::Ordered_checker_port_connectionContext::Ordered_checker_port_connectionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<SV3_1aParser::Attribute_instanceContext *> SV3_1aParser::Ordered_checker_port_connectionContext::attribute_instance() {
  return getRuleContexts<SV3_1aParser::Attribute_instanceContext>();
}

SV3_1aParser::Attribute_instanceContext* SV3_1aParser::Ordered_checker_port_connectionContext::attribute_instance(size_t i) {
  return getRuleContext<SV3_1aParser::Attribute_instanceContext>(i);
}

SV3_1aParser::Property_actual_argContext* SV3_1aParser::Ordered_checker_port_connectionContext::property_actual_arg() {
  return getRuleContext<SV3_1aParser::Property_actual_argContext>(0);
}


size_t SV3_1aParser::Ordered_checker_port_connectionContext::getRuleIndex() const {
  return SV3_1aParser::RuleOrdered_checker_port_connection;
}

void SV3_1aParser::Ordered_checker_port_connectionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOrdered_checker_port_connection(this);
}

void SV3_1aParser::Ordered_checker_port_connectionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOrdered_checker_port_connection(this);
}

SV3_1aParser::Ordered_checker_port_connectionContext* SV3_1aParser::ordered_checker_port_connection() {
  Ordered_checker_port_connectionContext *_localctx = _tracker.createInstance<Ordered_checker_port_connectionContext>(_ctx, getState());
  enterRule(_localctx, 632, SV3_1aParser::RuleOrdered_checker_port_connection);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5788);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == SV3_1aParser::OPEN_PARENS_STAR) {
      setState(5785);
      attribute_instance();
      setState(5790);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(5792);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 8796094988284) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 64)) & 9223099358040589313) != 0) || ((((_la - 129) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 129)) & 576592831239159871) != 0) || ((((_la - 201) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 201)) & -9223372036317904319) != 0) || ((((_la - 275) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 275)) & 881581860444962817) != 0) || ((((_la - 342) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 342)) & 130277379) != 0)) {
      setState(5791);
      property_actual_arg();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Named_checker_port_connectionContext ------------------------------------------------------------------

SV3_1aParser::Named_checker_port_connectionContext::Named_checker_port_connectionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Named_checker_port_connectionContext::DOT() {
  return getToken(SV3_1aParser::DOT, 0);
}

SV3_1aParser::IdentifierContext* SV3_1aParser::Named_checker_port_connectionContext::identifier() {
  return getRuleContext<SV3_1aParser::IdentifierContext>(0);
}

tree::TerminalNode* SV3_1aParser::Named_checker_port_connectionContext::DOTSTAR() {
  return getToken(SV3_1aParser::DOTSTAR, 0);
}

std::vector<SV3_1aParser::Attribute_instanceContext *> SV3_1aParser::Named_checker_port_connectionContext::attribute_instance() {
  return getRuleContexts<SV3_1aParser::Attribute_instanceContext>();
}

SV3_1aParser::Attribute_instanceContext* SV3_1aParser::Named_checker_port_connectionContext::attribute_instance(size_t i) {
  return getRuleContext<SV3_1aParser::Attribute_instanceContext>(i);
}

tree::TerminalNode* SV3_1aParser::Named_checker_port_connectionContext::OPEN_PARENS() {
  return getToken(SV3_1aParser::OPEN_PARENS, 0);
}

tree::TerminalNode* SV3_1aParser::Named_checker_port_connectionContext::CLOSE_PARENS() {
  return getToken(SV3_1aParser::CLOSE_PARENS, 0);
}

SV3_1aParser::Property_actual_argContext* SV3_1aParser::Named_checker_port_connectionContext::property_actual_arg() {
  return getRuleContext<SV3_1aParser::Property_actual_argContext>(0);
}


size_t SV3_1aParser::Named_checker_port_connectionContext::getRuleIndex() const {
  return SV3_1aParser::RuleNamed_checker_port_connection;
}

void SV3_1aParser::Named_checker_port_connectionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNamed_checker_port_connection(this);
}

void SV3_1aParser::Named_checker_port_connectionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNamed_checker_port_connection(this);
}

SV3_1aParser::Named_checker_port_connectionContext* SV3_1aParser::named_checker_port_connection() {
  Named_checker_port_connectionContext *_localctx = _tracker.createInstance<Named_checker_port_connectionContext>(_ctx, getState());
  enterRule(_localctx, 634, SV3_1aParser::RuleNamed_checker_port_connection);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5797);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == SV3_1aParser::OPEN_PARENS_STAR) {
      setState(5794);
      attribute_instance();
      setState(5799);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(5810);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SV3_1aParser::DOT: {
        setState(5800);
        match(SV3_1aParser::DOT);
        setState(5801);
        identifier();
        setState(5807);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == SV3_1aParser::OPEN_PARENS) {
          setState(5802);
          match(SV3_1aParser::OPEN_PARENS);
          setState(5804);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if ((((_la & ~ 0x3fULL) == 0) &&
            ((1ULL << _la) & 8796094988284) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
            ((1ULL << (_la - 64)) & 9223099358040589313) != 0) || ((((_la - 129) & ~ 0x3fULL) == 0) &&
            ((1ULL << (_la - 129)) & 576592831239159871) != 0) || ((((_la - 201) & ~ 0x3fULL) == 0) &&
            ((1ULL << (_la - 201)) & -9223372036317904319) != 0) || ((((_la - 275) & ~ 0x3fULL) == 0) &&
            ((1ULL << (_la - 275)) & 881581860444962817) != 0) || ((((_la - 342) & ~ 0x3fULL) == 0) &&
            ((1ULL << (_la - 342)) & 130277379) != 0)) {
            setState(5803);
            property_actual_arg();
          }
          setState(5806);
          match(SV3_1aParser::CLOSE_PARENS);
        }
        break;
      }

      case SV3_1aParser::DOTSTAR: {
        setState(5809);
        match(SV3_1aParser::DOTSTAR);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Generated_module_instantiationContext ------------------------------------------------------------------

SV3_1aParser::Generated_module_instantiationContext::Generated_module_instantiationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Generated_module_instantiationContext::GENERATE() {
  return getToken(SV3_1aParser::GENERATE, 0);
}

tree::TerminalNode* SV3_1aParser::Generated_module_instantiationContext::ENDGENERATE() {
  return getToken(SV3_1aParser::ENDGENERATE, 0);
}

std::vector<SV3_1aParser::Generate_module_itemContext *> SV3_1aParser::Generated_module_instantiationContext::generate_module_item() {
  return getRuleContexts<SV3_1aParser::Generate_module_itemContext>();
}

SV3_1aParser::Generate_module_itemContext* SV3_1aParser::Generated_module_instantiationContext::generate_module_item(size_t i) {
  return getRuleContext<SV3_1aParser::Generate_module_itemContext>(i);
}


size_t SV3_1aParser::Generated_module_instantiationContext::getRuleIndex() const {
  return SV3_1aParser::RuleGenerated_module_instantiation;
}

void SV3_1aParser::Generated_module_instantiationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGenerated_module_instantiation(this);
}

void SV3_1aParser::Generated_module_instantiationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGenerated_module_instantiation(this);
}

SV3_1aParser::Generated_module_instantiationContext* SV3_1aParser::generated_module_instantiation() {
  Generated_module_instantiationContext *_localctx = _tracker.createInstance<Generated_module_instantiationContext>(_ctx, getState());
  enterRule(_localctx, 636, SV3_1aParser::RuleGenerated_module_instantiation);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5812);
    match(SV3_1aParser::GENERATE);
    setState(5816);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (((((_la - 31) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 31)) & -8637803470849441759) != 0) || ((((_la - 95) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 95)) & 72056495063103387) != 0) || ((((_la - 166) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 166)) & 148619303615201283) != 0) || ((((_la - 238) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 238)) & 2182724190207) != 0) || ((((_la - 314) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 314)) & 19984723615010819) != 0)) {
      setState(5813);
      generate_module_item();
      setState(5818);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(5819);
    match(SV3_1aParser::ENDGENERATE);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Generate_module_itemContext ------------------------------------------------------------------

SV3_1aParser::Generate_module_itemContext::Generate_module_itemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::Generate_module_conditional_statementContext* SV3_1aParser::Generate_module_itemContext::generate_module_conditional_statement() {
  return getRuleContext<SV3_1aParser::Generate_module_conditional_statementContext>(0);
}

SV3_1aParser::Generate_module_case_statementContext* SV3_1aParser::Generate_module_itemContext::generate_module_case_statement() {
  return getRuleContext<SV3_1aParser::Generate_module_case_statementContext>(0);
}

SV3_1aParser::Generate_module_loop_statementContext* SV3_1aParser::Generate_module_itemContext::generate_module_loop_statement() {
  return getRuleContext<SV3_1aParser::Generate_module_loop_statementContext>(0);
}

SV3_1aParser::Generate_module_blockContext* SV3_1aParser::Generate_module_itemContext::generate_module_block() {
  return getRuleContext<SV3_1aParser::Generate_module_blockContext>(0);
}

SV3_1aParser::IdentifierContext* SV3_1aParser::Generate_module_itemContext::identifier() {
  return getRuleContext<SV3_1aParser::IdentifierContext>(0);
}

tree::TerminalNode* SV3_1aParser::Generate_module_itemContext::COLON() {
  return getToken(SV3_1aParser::COLON, 0);
}

SV3_1aParser::Module_or_generate_itemContext* SV3_1aParser::Generate_module_itemContext::module_or_generate_item() {
  return getRuleContext<SV3_1aParser::Module_or_generate_itemContext>(0);
}


size_t SV3_1aParser::Generate_module_itemContext::getRuleIndex() const {
  return SV3_1aParser::RuleGenerate_module_item;
}

void SV3_1aParser::Generate_module_itemContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGenerate_module_item(this);
}

void SV3_1aParser::Generate_module_itemContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGenerate_module_item(this);
}

SV3_1aParser::Generate_module_itemContext* SV3_1aParser::generate_module_item() {
  Generate_module_itemContext *_localctx = _tracker.createInstance<Generate_module_itemContext>(_ctx, getState());
  enterRule(_localctx, 638, SV3_1aParser::RuleGenerate_module_item);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(5831);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 659, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(5821);
      generate_module_conditional_statement();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(5822);
      generate_module_case_statement();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(5823);
      generate_module_loop_statement();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(5827);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (((((_la - 326) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 326)) & 4672924483589) != 0)) {
        setState(5824);
        identifier();
        setState(5825);
        match(SV3_1aParser::COLON);
      }
      setState(5829);
      generate_module_block();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(5830);
      module_or_generate_item();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Generate_module_conditional_statementContext ------------------------------------------------------------------

SV3_1aParser::Generate_module_conditional_statementContext::Generate_module_conditional_statementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Generate_module_conditional_statementContext::IF() {
  return getToken(SV3_1aParser::IF, 0);
}

tree::TerminalNode* SV3_1aParser::Generate_module_conditional_statementContext::OPEN_PARENS() {
  return getToken(SV3_1aParser::OPEN_PARENS, 0);
}

SV3_1aParser::Constant_expressionContext* SV3_1aParser::Generate_module_conditional_statementContext::constant_expression() {
  return getRuleContext<SV3_1aParser::Constant_expressionContext>(0);
}

tree::TerminalNode* SV3_1aParser::Generate_module_conditional_statementContext::CLOSE_PARENS() {
  return getToken(SV3_1aParser::CLOSE_PARENS, 0);
}

std::vector<SV3_1aParser::Generate_module_itemContext *> SV3_1aParser::Generate_module_conditional_statementContext::generate_module_item() {
  return getRuleContexts<SV3_1aParser::Generate_module_itemContext>();
}

SV3_1aParser::Generate_module_itemContext* SV3_1aParser::Generate_module_conditional_statementContext::generate_module_item(size_t i) {
  return getRuleContext<SV3_1aParser::Generate_module_itemContext>(i);
}

tree::TerminalNode* SV3_1aParser::Generate_module_conditional_statementContext::ELSE() {
  return getToken(SV3_1aParser::ELSE, 0);
}


size_t SV3_1aParser::Generate_module_conditional_statementContext::getRuleIndex() const {
  return SV3_1aParser::RuleGenerate_module_conditional_statement;
}

void SV3_1aParser::Generate_module_conditional_statementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGenerate_module_conditional_statement(this);
}

void SV3_1aParser::Generate_module_conditional_statementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGenerate_module_conditional_statement(this);
}

SV3_1aParser::Generate_module_conditional_statementContext* SV3_1aParser::generate_module_conditional_statement() {
  Generate_module_conditional_statementContext *_localctx = _tracker.createInstance<Generate_module_conditional_statementContext>(_ctx, getState());
  enterRule(_localctx, 640, SV3_1aParser::RuleGenerate_module_conditional_statement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5833);
    match(SV3_1aParser::IF);
    setState(5834);
    match(SV3_1aParser::OPEN_PARENS);
    setState(5835);
    constant_expression(0);
    setState(5836);
    match(SV3_1aParser::CLOSE_PARENS);
    setState(5837);
    generate_module_item();
    setState(5840);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 660, _ctx)) {
    case 1: {
      setState(5838);
      match(SV3_1aParser::ELSE);
      setState(5839);
      generate_module_item();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Generate_module_case_statementContext ------------------------------------------------------------------

SV3_1aParser::Generate_module_case_statementContext::Generate_module_case_statementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Generate_module_case_statementContext::CASE() {
  return getToken(SV3_1aParser::CASE, 0);
}

tree::TerminalNode* SV3_1aParser::Generate_module_case_statementContext::OPEN_PARENS() {
  return getToken(SV3_1aParser::OPEN_PARENS, 0);
}

SV3_1aParser::Constant_expressionContext* SV3_1aParser::Generate_module_case_statementContext::constant_expression() {
  return getRuleContext<SV3_1aParser::Constant_expressionContext>(0);
}

tree::TerminalNode* SV3_1aParser::Generate_module_case_statementContext::CLOSE_PARENS() {
  return getToken(SV3_1aParser::CLOSE_PARENS, 0);
}

std::vector<SV3_1aParser::Genvar_module_case_itemContext *> SV3_1aParser::Generate_module_case_statementContext::genvar_module_case_item() {
  return getRuleContexts<SV3_1aParser::Genvar_module_case_itemContext>();
}

SV3_1aParser::Genvar_module_case_itemContext* SV3_1aParser::Generate_module_case_statementContext::genvar_module_case_item(size_t i) {
  return getRuleContext<SV3_1aParser::Genvar_module_case_itemContext>(i);
}

tree::TerminalNode* SV3_1aParser::Generate_module_case_statementContext::ENDCASE() {
  return getToken(SV3_1aParser::ENDCASE, 0);
}


size_t SV3_1aParser::Generate_module_case_statementContext::getRuleIndex() const {
  return SV3_1aParser::RuleGenerate_module_case_statement;
}

void SV3_1aParser::Generate_module_case_statementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGenerate_module_case_statement(this);
}

void SV3_1aParser::Generate_module_case_statementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGenerate_module_case_statement(this);
}

SV3_1aParser::Generate_module_case_statementContext* SV3_1aParser::generate_module_case_statement() {
  Generate_module_case_statementContext *_localctx = _tracker.createInstance<Generate_module_case_statementContext>(_ctx, getState());
  enterRule(_localctx, 642, SV3_1aParser::RuleGenerate_module_case_statement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5842);
    match(SV3_1aParser::CASE);
    setState(5843);
    match(SV3_1aParser::OPEN_PARENS);
    setState(5844);
    constant_expression(0);
    setState(5845);
    match(SV3_1aParser::CLOSE_PARENS);
    setState(5846);
    genvar_module_case_item();
    setState(5850);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 8864814399484) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 64)) & 1152648825725551617) != 0) || ((((_la - 147) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 147)) & 2199359324163) != 0) || _la == SV3_1aParser::BANG || ((((_la - 316) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 316)) & 8742766775376897) != 0)) {
      setState(5847);
      genvar_module_case_item();
      setState(5852);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(5853);
    match(SV3_1aParser::ENDCASE);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Genvar_module_case_itemContext ------------------------------------------------------------------

SV3_1aParser::Genvar_module_case_itemContext::Genvar_module_case_itemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<SV3_1aParser::Constant_expressionContext *> SV3_1aParser::Genvar_module_case_itemContext::constant_expression() {
  return getRuleContexts<SV3_1aParser::Constant_expressionContext>();
}

SV3_1aParser::Constant_expressionContext* SV3_1aParser::Genvar_module_case_itemContext::constant_expression(size_t i) {
  return getRuleContext<SV3_1aParser::Constant_expressionContext>(i);
}

tree::TerminalNode* SV3_1aParser::Genvar_module_case_itemContext::COLON() {
  return getToken(SV3_1aParser::COLON, 0);
}

SV3_1aParser::Generate_module_itemContext* SV3_1aParser::Genvar_module_case_itemContext::generate_module_item() {
  return getRuleContext<SV3_1aParser::Generate_module_itemContext>(0);
}

std::vector<tree::TerminalNode *> SV3_1aParser::Genvar_module_case_itemContext::COMMA() {
  return getTokens(SV3_1aParser::COMMA);
}

tree::TerminalNode* SV3_1aParser::Genvar_module_case_itemContext::COMMA(size_t i) {
  return getToken(SV3_1aParser::COMMA, i);
}

tree::TerminalNode* SV3_1aParser::Genvar_module_case_itemContext::DEFAULT() {
  return getToken(SV3_1aParser::DEFAULT, 0);
}


size_t SV3_1aParser::Genvar_module_case_itemContext::getRuleIndex() const {
  return SV3_1aParser::RuleGenvar_module_case_item;
}

void SV3_1aParser::Genvar_module_case_itemContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGenvar_module_case_item(this);
}

void SV3_1aParser::Genvar_module_case_itemContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGenvar_module_case_item(this);
}

SV3_1aParser::Genvar_module_case_itemContext* SV3_1aParser::genvar_module_case_item() {
  Genvar_module_case_itemContext *_localctx = _tracker.createInstance<Genvar_module_case_itemContext>(_ctx, getState());
  enterRule(_localctx, 644, SV3_1aParser::RuleGenvar_module_case_item);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(5871);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SV3_1aParser::TICK_b0:
      case SV3_1aParser::TICK_b1:
      case SV3_1aParser::TICK_B0:
      case SV3_1aParser::TICK_B1:
      case SV3_1aParser::TICK_0:
      case SV3_1aParser::TICK_1:
      case SV3_1aParser::ONE_TICK_b0:
      case SV3_1aParser::ONE_TICK_b1:
      case SV3_1aParser::ONE_TICK_bx:
      case SV3_1aParser::ONE_TICK_bX:
      case SV3_1aParser::ONE_TICK_B0:
      case SV3_1aParser::ONE_TICK_B1:
      case SV3_1aParser::ONE_TICK_Bx:
      case SV3_1aParser::ONE_TICK_BX:
      case SV3_1aParser::Integral_number:
      case SV3_1aParser::Real_number:
      case SV3_1aParser::String:
      case SV3_1aParser::OPEN_PARENS:
      case SV3_1aParser::TYPE:
      case SV3_1aParser::CONST:
      case SV3_1aParser::LOCAL:
      case SV3_1aParser::SUPER:
      case SV3_1aParser::OPEN_CURLY:
      case SV3_1aParser::STRING:
      case SV3_1aParser::BYTE:
      case SV3_1aParser::SHORTINT:
      case SV3_1aParser::INT:
      case SV3_1aParser::LONGINT:
      case SV3_1aParser::INTEGER:
      case SV3_1aParser::TIME:
      case SV3_1aParser::BIT:
      case SV3_1aParser::LOGIC:
      case SV3_1aParser::REG:
      case SV3_1aParser::SHORTREAL:
      case SV3_1aParser::REAL:
      case SV3_1aParser::REALTIME:
      case SV3_1aParser::SIGNED:
      case SV3_1aParser::UNSIGNED:
      case SV3_1aParser::DOLLAR:
      case SV3_1aParser::PLUS:
      case SV3_1aParser::MINUS:
      case SV3_1aParser::DOLLAR_UNIT:
      case SV3_1aParser::BANG:
      case SV3_1aParser::TICK:
      case SV3_1aParser::THIS:
      case SV3_1aParser::DOLLAR_ROOT:
      case SV3_1aParser::RANDOMIZE:
      case SV3_1aParser::SAMPLE:
      case SV3_1aParser::BITW_AND:
      case SV3_1aParser::BITW_OR:
      case SV3_1aParser::REDUCTION_NOR:
      case SV3_1aParser::REDUCTION_NAND:
      case SV3_1aParser::REDUCTION_XNOR1:
      case SV3_1aParser::Escaped_identifier:
      case SV3_1aParser::TILDA:
      case SV3_1aParser::BITW_XOR:
      case SV3_1aParser::REDUCTION_XNOR2:
      case SV3_1aParser::Simple_identifier: {
        enterOuterAlt(_localctx, 1);
        setState(5855);
        constant_expression(0);
        setState(5860);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == SV3_1aParser::COMMA) {
          setState(5856);
          match(SV3_1aParser::COMMA);
          setState(5857);
          constant_expression(0);
          setState(5862);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(5863);
        match(SV3_1aParser::COLON);
        setState(5864);
        generate_module_item();
        break;
      }

      case SV3_1aParser::DEFAULT: {
        enterOuterAlt(_localctx, 2);
        setState(5866);
        match(SV3_1aParser::DEFAULT);
        setState(5868);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == SV3_1aParser::COLON) {
          setState(5867);
          match(SV3_1aParser::COLON);
        }
        setState(5870);
        generate_module_item();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Generate_module_loop_statementContext ------------------------------------------------------------------

SV3_1aParser::Generate_module_loop_statementContext::Generate_module_loop_statementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Generate_module_loop_statementContext::FOR() {
  return getToken(SV3_1aParser::FOR, 0);
}

tree::TerminalNode* SV3_1aParser::Generate_module_loop_statementContext::OPEN_PARENS() {
  return getToken(SV3_1aParser::OPEN_PARENS, 0);
}

SV3_1aParser::Genvar_decl_assignmentContext* SV3_1aParser::Generate_module_loop_statementContext::genvar_decl_assignment() {
  return getRuleContext<SV3_1aParser::Genvar_decl_assignmentContext>(0);
}

std::vector<tree::TerminalNode *> SV3_1aParser::Generate_module_loop_statementContext::SEMICOLON() {
  return getTokens(SV3_1aParser::SEMICOLON);
}

tree::TerminalNode* SV3_1aParser::Generate_module_loop_statementContext::SEMICOLON(size_t i) {
  return getToken(SV3_1aParser::SEMICOLON, i);
}

SV3_1aParser::Constant_expressionContext* SV3_1aParser::Generate_module_loop_statementContext::constant_expression() {
  return getRuleContext<SV3_1aParser::Constant_expressionContext>(0);
}

SV3_1aParser::Genvar_assignmentContext* SV3_1aParser::Generate_module_loop_statementContext::genvar_assignment() {
  return getRuleContext<SV3_1aParser::Genvar_assignmentContext>(0);
}

tree::TerminalNode* SV3_1aParser::Generate_module_loop_statementContext::CLOSE_PARENS() {
  return getToken(SV3_1aParser::CLOSE_PARENS, 0);
}

SV3_1aParser::Generate_module_named_blockContext* SV3_1aParser::Generate_module_loop_statementContext::generate_module_named_block() {
  return getRuleContext<SV3_1aParser::Generate_module_named_blockContext>(0);
}


size_t SV3_1aParser::Generate_module_loop_statementContext::getRuleIndex() const {
  return SV3_1aParser::RuleGenerate_module_loop_statement;
}

void SV3_1aParser::Generate_module_loop_statementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGenerate_module_loop_statement(this);
}

void SV3_1aParser::Generate_module_loop_statementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGenerate_module_loop_statement(this);
}

SV3_1aParser::Generate_module_loop_statementContext* SV3_1aParser::generate_module_loop_statement() {
  Generate_module_loop_statementContext *_localctx = _tracker.createInstance<Generate_module_loop_statementContext>(_ctx, getState());
  enterRule(_localctx, 646, SV3_1aParser::RuleGenerate_module_loop_statement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5873);
    match(SV3_1aParser::FOR);
    setState(5874);
    match(SV3_1aParser::OPEN_PARENS);
    setState(5875);
    genvar_decl_assignment();
    setState(5876);
    match(SV3_1aParser::SEMICOLON);
    setState(5877);
    constant_expression(0);
    setState(5878);
    match(SV3_1aParser::SEMICOLON);
    setState(5879);
    genvar_assignment();
    setState(5880);
    match(SV3_1aParser::CLOSE_PARENS);
    setState(5881);
    generate_module_named_block();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Genvar_assignmentContext ------------------------------------------------------------------

SV3_1aParser::Genvar_assignmentContext::Genvar_assignmentContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::IdentifierContext* SV3_1aParser::Genvar_assignmentContext::identifier() {
  return getRuleContext<SV3_1aParser::IdentifierContext>(0);
}

SV3_1aParser::Assignment_operatorContext* SV3_1aParser::Genvar_assignmentContext::assignment_operator() {
  return getRuleContext<SV3_1aParser::Assignment_operatorContext>(0);
}

SV3_1aParser::Constant_expressionContext* SV3_1aParser::Genvar_assignmentContext::constant_expression() {
  return getRuleContext<SV3_1aParser::Constant_expressionContext>(0);
}

SV3_1aParser::Inc_or_dec_operatorContext* SV3_1aParser::Genvar_assignmentContext::inc_or_dec_operator() {
  return getRuleContext<SV3_1aParser::Inc_or_dec_operatorContext>(0);
}


size_t SV3_1aParser::Genvar_assignmentContext::getRuleIndex() const {
  return SV3_1aParser::RuleGenvar_assignment;
}

void SV3_1aParser::Genvar_assignmentContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGenvar_assignment(this);
}

void SV3_1aParser::Genvar_assignmentContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGenvar_assignment(this);
}

SV3_1aParser::Genvar_assignmentContext* SV3_1aParser::genvar_assignment() {
  Genvar_assignmentContext *_localctx = _tracker.createInstance<Genvar_assignmentContext>(_ctx, getState());
  enterRule(_localctx, 648, SV3_1aParser::RuleGenvar_assignment);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(5893);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 665, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(5883);
      identifier();
      setState(5884);
      assignment_operator();
      setState(5885);
      constant_expression(0);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(5887);
      inc_or_dec_operator();
      setState(5888);
      identifier();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(5890);
      identifier();
      setState(5891);
      inc_or_dec_operator();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Genvar_decl_assignmentContext ------------------------------------------------------------------

SV3_1aParser::Genvar_decl_assignmentContext::Genvar_decl_assignmentContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::IdentifierContext* SV3_1aParser::Genvar_decl_assignmentContext::identifier() {
  return getRuleContext<SV3_1aParser::IdentifierContext>(0);
}

tree::TerminalNode* SV3_1aParser::Genvar_decl_assignmentContext::ASSIGN_OP() {
  return getToken(SV3_1aParser::ASSIGN_OP, 0);
}

SV3_1aParser::Constant_expressionContext* SV3_1aParser::Genvar_decl_assignmentContext::constant_expression() {
  return getRuleContext<SV3_1aParser::Constant_expressionContext>(0);
}

tree::TerminalNode* SV3_1aParser::Genvar_decl_assignmentContext::GENVAR() {
  return getToken(SV3_1aParser::GENVAR, 0);
}


size_t SV3_1aParser::Genvar_decl_assignmentContext::getRuleIndex() const {
  return SV3_1aParser::RuleGenvar_decl_assignment;
}

void SV3_1aParser::Genvar_decl_assignmentContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGenvar_decl_assignment(this);
}

void SV3_1aParser::Genvar_decl_assignmentContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGenvar_decl_assignment(this);
}

SV3_1aParser::Genvar_decl_assignmentContext* SV3_1aParser::genvar_decl_assignment() {
  Genvar_decl_assignmentContext *_localctx = _tracker.createInstance<Genvar_decl_assignmentContext>(_ctx, getState());
  enterRule(_localctx, 650, SV3_1aParser::RuleGenvar_decl_assignment);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5896);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SV3_1aParser::GENVAR) {
      setState(5895);
      match(SV3_1aParser::GENVAR);
    }
    setState(5898);
    identifier();
    setState(5899);
    match(SV3_1aParser::ASSIGN_OP);
    setState(5900);
    constant_expression(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Generate_module_named_blockContext ------------------------------------------------------------------

SV3_1aParser::Generate_module_named_blockContext::Generate_module_named_blockContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Generate_module_named_blockContext::BEGIN() {
  return getToken(SV3_1aParser::BEGIN, 0);
}

std::vector<tree::TerminalNode *> SV3_1aParser::Generate_module_named_blockContext::COLON() {
  return getTokens(SV3_1aParser::COLON);
}

tree::TerminalNode* SV3_1aParser::Generate_module_named_blockContext::COLON(size_t i) {
  return getToken(SV3_1aParser::COLON, i);
}

std::vector<SV3_1aParser::IdentifierContext *> SV3_1aParser::Generate_module_named_blockContext::identifier() {
  return getRuleContexts<SV3_1aParser::IdentifierContext>();
}

SV3_1aParser::IdentifierContext* SV3_1aParser::Generate_module_named_blockContext::identifier(size_t i) {
  return getRuleContext<SV3_1aParser::IdentifierContext>(i);
}

tree::TerminalNode* SV3_1aParser::Generate_module_named_blockContext::END() {
  return getToken(SV3_1aParser::END, 0);
}

std::vector<SV3_1aParser::Generate_module_itemContext *> SV3_1aParser::Generate_module_named_blockContext::generate_module_item() {
  return getRuleContexts<SV3_1aParser::Generate_module_itemContext>();
}

SV3_1aParser::Generate_module_itemContext* SV3_1aParser::Generate_module_named_blockContext::generate_module_item(size_t i) {
  return getRuleContext<SV3_1aParser::Generate_module_itemContext>(i);
}

SV3_1aParser::Generate_module_blockContext* SV3_1aParser::Generate_module_named_blockContext::generate_module_block() {
  return getRuleContext<SV3_1aParser::Generate_module_blockContext>(0);
}


size_t SV3_1aParser::Generate_module_named_blockContext::getRuleIndex() const {
  return SV3_1aParser::RuleGenerate_module_named_block;
}

void SV3_1aParser::Generate_module_named_blockContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGenerate_module_named_block(this);
}

void SV3_1aParser::Generate_module_named_blockContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGenerate_module_named_block(this);
}

SV3_1aParser::Generate_module_named_blockContext* SV3_1aParser::generate_module_named_block() {
  Generate_module_named_blockContext *_localctx = _tracker.createInstance<Generate_module_named_blockContext>(_ctx, getState());
  enterRule(_localctx, 652, SV3_1aParser::RuleGenerate_module_named_block);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(5920);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SV3_1aParser::BEGIN: {
        enterOuterAlt(_localctx, 1);
        setState(5902);
        match(SV3_1aParser::BEGIN);
        setState(5903);
        match(SV3_1aParser::COLON);
        setState(5904);
        identifier();
        setState(5908);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (((((_la - 31) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 31)) & -8637803470849441759) != 0) || ((((_la - 95) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 95)) & 72056495063103387) != 0) || ((((_la - 166) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 166)) & 148619303615201283) != 0) || ((((_la - 238) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 238)) & 2182724190207) != 0) || ((((_la - 314) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 314)) & 19984723615010819) != 0)) {
          setState(5905);
          generate_module_item();
          setState(5910);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(5911);
        match(SV3_1aParser::END);
        setState(5914);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == SV3_1aParser::COLON) {
          setState(5912);
          match(SV3_1aParser::COLON);
          setState(5913);
          identifier();
        }
        break;
      }

      case SV3_1aParser::THIS:
      case SV3_1aParser::RANDOMIZE:
      case SV3_1aParser::SAMPLE:
      case SV3_1aParser::Escaped_identifier:
      case SV3_1aParser::Simple_identifier: {
        enterOuterAlt(_localctx, 2);
        setState(5916);
        identifier();
        setState(5917);
        match(SV3_1aParser::COLON);
        setState(5918);
        generate_module_block();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Generate_module_blockContext ------------------------------------------------------------------

SV3_1aParser::Generate_module_blockContext::Generate_module_blockContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Generate_module_blockContext::BEGIN() {
  return getToken(SV3_1aParser::BEGIN, 0);
}

tree::TerminalNode* SV3_1aParser::Generate_module_blockContext::END() {
  return getToken(SV3_1aParser::END, 0);
}

std::vector<tree::TerminalNode *> SV3_1aParser::Generate_module_blockContext::COLON() {
  return getTokens(SV3_1aParser::COLON);
}

tree::TerminalNode* SV3_1aParser::Generate_module_blockContext::COLON(size_t i) {
  return getToken(SV3_1aParser::COLON, i);
}

std::vector<SV3_1aParser::IdentifierContext *> SV3_1aParser::Generate_module_blockContext::identifier() {
  return getRuleContexts<SV3_1aParser::IdentifierContext>();
}

SV3_1aParser::IdentifierContext* SV3_1aParser::Generate_module_blockContext::identifier(size_t i) {
  return getRuleContext<SV3_1aParser::IdentifierContext>(i);
}

std::vector<SV3_1aParser::Generate_module_itemContext *> SV3_1aParser::Generate_module_blockContext::generate_module_item() {
  return getRuleContexts<SV3_1aParser::Generate_module_itemContext>();
}

SV3_1aParser::Generate_module_itemContext* SV3_1aParser::Generate_module_blockContext::generate_module_item(size_t i) {
  return getRuleContext<SV3_1aParser::Generate_module_itemContext>(i);
}


size_t SV3_1aParser::Generate_module_blockContext::getRuleIndex() const {
  return SV3_1aParser::RuleGenerate_module_block;
}

void SV3_1aParser::Generate_module_blockContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGenerate_module_block(this);
}

void SV3_1aParser::Generate_module_blockContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGenerate_module_block(this);
}

SV3_1aParser::Generate_module_blockContext* SV3_1aParser::generate_module_block() {
  Generate_module_blockContext *_localctx = _tracker.createInstance<Generate_module_blockContext>(_ctx, getState());
  enterRule(_localctx, 654, SV3_1aParser::RuleGenerate_module_block);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5922);
    match(SV3_1aParser::BEGIN);
    setState(5925);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SV3_1aParser::COLON) {
      setState(5923);
      match(SV3_1aParser::COLON);
      setState(5924);
      identifier();
    }
    setState(5930);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (((((_la - 31) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 31)) & -8637803470849441759) != 0) || ((((_la - 95) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 95)) & 72056495063103387) != 0) || ((((_la - 166) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 166)) & 148619303615201283) != 0) || ((((_la - 238) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 238)) & 2182724190207) != 0) || ((((_la - 314) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 314)) & 19984723615010819) != 0)) {
      setState(5927);
      generate_module_item();
      setState(5932);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(5933);
    match(SV3_1aParser::END);
    setState(5936);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SV3_1aParser::COLON) {
      setState(5934);
      match(SV3_1aParser::COLON);
      setState(5935);
      identifier();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Generated_interface_instantiationContext ------------------------------------------------------------------

SV3_1aParser::Generated_interface_instantiationContext::Generated_interface_instantiationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Generated_interface_instantiationContext::GENERATE() {
  return getToken(SV3_1aParser::GENERATE, 0);
}

tree::TerminalNode* SV3_1aParser::Generated_interface_instantiationContext::ENDGENERATE() {
  return getToken(SV3_1aParser::ENDGENERATE, 0);
}

std::vector<SV3_1aParser::Generate_interface_itemContext *> SV3_1aParser::Generated_interface_instantiationContext::generate_interface_item() {
  return getRuleContexts<SV3_1aParser::Generate_interface_itemContext>();
}

SV3_1aParser::Generate_interface_itemContext* SV3_1aParser::Generated_interface_instantiationContext::generate_interface_item(size_t i) {
  return getRuleContext<SV3_1aParser::Generate_interface_itemContext>(i);
}


size_t SV3_1aParser::Generated_interface_instantiationContext::getRuleIndex() const {
  return SV3_1aParser::RuleGenerated_interface_instantiation;
}

void SV3_1aParser::Generated_interface_instantiationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGenerated_interface_instantiation(this);
}

void SV3_1aParser::Generated_interface_instantiationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGenerated_interface_instantiation(this);
}

SV3_1aParser::Generated_interface_instantiationContext* SV3_1aParser::generated_interface_instantiation() {
  Generated_interface_instantiationContext *_localctx = _tracker.createInstance<Generated_interface_instantiationContext>(_ctx, getState());
  enterRule(_localctx, 656, SV3_1aParser::RuleGenerated_interface_instantiation);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5938);
    match(SV3_1aParser::GENERATE);
    setState(5942);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (((((_la - 31) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 31)) & -8637804570361036767) != 0) || ((((_la - 95) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 95)) & 72056495063103387) != 0) || ((((_la - 166) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 166)) & 4503875023273987) != 0) || ((((_la - 264) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 264)) & 4615063718147948301) != 0) || ((((_la - 328) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 328)) & 1219770728455) != 0)) {
      setState(5939);
      generate_interface_item();
      setState(5944);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(5945);
    match(SV3_1aParser::ENDGENERATE);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Generate_interface_itemContext ------------------------------------------------------------------

SV3_1aParser::Generate_interface_itemContext::Generate_interface_itemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::Generate_interface_conditional_statementContext* SV3_1aParser::Generate_interface_itemContext::generate_interface_conditional_statement() {
  return getRuleContext<SV3_1aParser::Generate_interface_conditional_statementContext>(0);
}

SV3_1aParser::Generate_interface_case_statementContext* SV3_1aParser::Generate_interface_itemContext::generate_interface_case_statement() {
  return getRuleContext<SV3_1aParser::Generate_interface_case_statementContext>(0);
}

SV3_1aParser::Generate_interface_loop_statementContext* SV3_1aParser::Generate_interface_itemContext::generate_interface_loop_statement() {
  return getRuleContext<SV3_1aParser::Generate_interface_loop_statementContext>(0);
}

SV3_1aParser::Generate_interface_blockContext* SV3_1aParser::Generate_interface_itemContext::generate_interface_block() {
  return getRuleContext<SV3_1aParser::Generate_interface_blockContext>(0);
}

SV3_1aParser::IdentifierContext* SV3_1aParser::Generate_interface_itemContext::identifier() {
  return getRuleContext<SV3_1aParser::IdentifierContext>(0);
}

tree::TerminalNode* SV3_1aParser::Generate_interface_itemContext::COLON() {
  return getToken(SV3_1aParser::COLON, 0);
}

SV3_1aParser::Interface_or_generate_itemContext* SV3_1aParser::Generate_interface_itemContext::interface_or_generate_item() {
  return getRuleContext<SV3_1aParser::Interface_or_generate_itemContext>(0);
}


size_t SV3_1aParser::Generate_interface_itemContext::getRuleIndex() const {
  return SV3_1aParser::RuleGenerate_interface_item;
}

void SV3_1aParser::Generate_interface_itemContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGenerate_interface_item(this);
}

void SV3_1aParser::Generate_interface_itemContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGenerate_interface_item(this);
}

SV3_1aParser::Generate_interface_itemContext* SV3_1aParser::generate_interface_item() {
  Generate_interface_itemContext *_localctx = _tracker.createInstance<Generate_interface_itemContext>(_ctx, getState());
  enterRule(_localctx, 658, SV3_1aParser::RuleGenerate_interface_item);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(5956);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 674, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(5947);
      generate_interface_conditional_statement();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(5948);
      generate_interface_case_statement();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(5949);
      generate_interface_loop_statement();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(5950);
      identifier();
      setState(5951);
      match(SV3_1aParser::COLON);
      setState(5953);
      generate_interface_block();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(5955);
      interface_or_generate_item();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Generate_interface_conditional_statementContext ------------------------------------------------------------------

SV3_1aParser::Generate_interface_conditional_statementContext::Generate_interface_conditional_statementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Generate_interface_conditional_statementContext::IF() {
  return getToken(SV3_1aParser::IF, 0);
}

tree::TerminalNode* SV3_1aParser::Generate_interface_conditional_statementContext::OPEN_PARENS() {
  return getToken(SV3_1aParser::OPEN_PARENS, 0);
}

SV3_1aParser::Constant_expressionContext* SV3_1aParser::Generate_interface_conditional_statementContext::constant_expression() {
  return getRuleContext<SV3_1aParser::Constant_expressionContext>(0);
}

tree::TerminalNode* SV3_1aParser::Generate_interface_conditional_statementContext::CLOSE_PARENS() {
  return getToken(SV3_1aParser::CLOSE_PARENS, 0);
}

std::vector<SV3_1aParser::Generate_interface_itemContext *> SV3_1aParser::Generate_interface_conditional_statementContext::generate_interface_item() {
  return getRuleContexts<SV3_1aParser::Generate_interface_itemContext>();
}

SV3_1aParser::Generate_interface_itemContext* SV3_1aParser::Generate_interface_conditional_statementContext::generate_interface_item(size_t i) {
  return getRuleContext<SV3_1aParser::Generate_interface_itemContext>(i);
}

tree::TerminalNode* SV3_1aParser::Generate_interface_conditional_statementContext::ELSE() {
  return getToken(SV3_1aParser::ELSE, 0);
}


size_t SV3_1aParser::Generate_interface_conditional_statementContext::getRuleIndex() const {
  return SV3_1aParser::RuleGenerate_interface_conditional_statement;
}

void SV3_1aParser::Generate_interface_conditional_statementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGenerate_interface_conditional_statement(this);
}

void SV3_1aParser::Generate_interface_conditional_statementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGenerate_interface_conditional_statement(this);
}

SV3_1aParser::Generate_interface_conditional_statementContext* SV3_1aParser::generate_interface_conditional_statement() {
  Generate_interface_conditional_statementContext *_localctx = _tracker.createInstance<Generate_interface_conditional_statementContext>(_ctx, getState());
  enterRule(_localctx, 660, SV3_1aParser::RuleGenerate_interface_conditional_statement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5958);
    match(SV3_1aParser::IF);
    setState(5959);
    match(SV3_1aParser::OPEN_PARENS);
    setState(5960);
    constant_expression(0);
    setState(5961);
    match(SV3_1aParser::CLOSE_PARENS);
    setState(5962);
    generate_interface_item();
    setState(5965);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 675, _ctx)) {
    case 1: {
      setState(5963);
      match(SV3_1aParser::ELSE);
      setState(5964);
      generate_interface_item();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Generate_interface_case_statementContext ------------------------------------------------------------------

SV3_1aParser::Generate_interface_case_statementContext::Generate_interface_case_statementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Generate_interface_case_statementContext::CASE() {
  return getToken(SV3_1aParser::CASE, 0);
}

tree::TerminalNode* SV3_1aParser::Generate_interface_case_statementContext::OPEN_PARENS() {
  return getToken(SV3_1aParser::OPEN_PARENS, 0);
}

SV3_1aParser::Constant_expressionContext* SV3_1aParser::Generate_interface_case_statementContext::constant_expression() {
  return getRuleContext<SV3_1aParser::Constant_expressionContext>(0);
}

tree::TerminalNode* SV3_1aParser::Generate_interface_case_statementContext::CLOSE_PARENS() {
  return getToken(SV3_1aParser::CLOSE_PARENS, 0);
}

std::vector<SV3_1aParser::Genvar_interface_case_itemContext *> SV3_1aParser::Generate_interface_case_statementContext::genvar_interface_case_item() {
  return getRuleContexts<SV3_1aParser::Genvar_interface_case_itemContext>();
}

SV3_1aParser::Genvar_interface_case_itemContext* SV3_1aParser::Generate_interface_case_statementContext::genvar_interface_case_item(size_t i) {
  return getRuleContext<SV3_1aParser::Genvar_interface_case_itemContext>(i);
}

tree::TerminalNode* SV3_1aParser::Generate_interface_case_statementContext::ENDCASE() {
  return getToken(SV3_1aParser::ENDCASE, 0);
}


size_t SV3_1aParser::Generate_interface_case_statementContext::getRuleIndex() const {
  return SV3_1aParser::RuleGenerate_interface_case_statement;
}

void SV3_1aParser::Generate_interface_case_statementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGenerate_interface_case_statement(this);
}

void SV3_1aParser::Generate_interface_case_statementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGenerate_interface_case_statement(this);
}

SV3_1aParser::Generate_interface_case_statementContext* SV3_1aParser::generate_interface_case_statement() {
  Generate_interface_case_statementContext *_localctx = _tracker.createInstance<Generate_interface_case_statementContext>(_ctx, getState());
  enterRule(_localctx, 662, SV3_1aParser::RuleGenerate_interface_case_statement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5967);
    match(SV3_1aParser::CASE);
    setState(5968);
    match(SV3_1aParser::OPEN_PARENS);
    setState(5969);
    constant_expression(0);
    setState(5970);
    match(SV3_1aParser::CLOSE_PARENS);
    setState(5971);
    genvar_interface_case_item();
    setState(5975);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 8864814399484) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 64)) & 1152648825725551617) != 0) || ((((_la - 147) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 147)) & 2199359324163) != 0) || _la == SV3_1aParser::BANG || ((((_la - 316) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 316)) & 8742766775376897) != 0)) {
      setState(5972);
      genvar_interface_case_item();
      setState(5977);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(5978);
    match(SV3_1aParser::ENDCASE);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Genvar_interface_case_itemContext ------------------------------------------------------------------

SV3_1aParser::Genvar_interface_case_itemContext::Genvar_interface_case_itemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<SV3_1aParser::Constant_expressionContext *> SV3_1aParser::Genvar_interface_case_itemContext::constant_expression() {
  return getRuleContexts<SV3_1aParser::Constant_expressionContext>();
}

SV3_1aParser::Constant_expressionContext* SV3_1aParser::Genvar_interface_case_itemContext::constant_expression(size_t i) {
  return getRuleContext<SV3_1aParser::Constant_expressionContext>(i);
}

tree::TerminalNode* SV3_1aParser::Genvar_interface_case_itemContext::COLON() {
  return getToken(SV3_1aParser::COLON, 0);
}

SV3_1aParser::Generate_interface_itemContext* SV3_1aParser::Genvar_interface_case_itemContext::generate_interface_item() {
  return getRuleContext<SV3_1aParser::Generate_interface_itemContext>(0);
}

std::vector<tree::TerminalNode *> SV3_1aParser::Genvar_interface_case_itemContext::COMMA() {
  return getTokens(SV3_1aParser::COMMA);
}

tree::TerminalNode* SV3_1aParser::Genvar_interface_case_itemContext::COMMA(size_t i) {
  return getToken(SV3_1aParser::COMMA, i);
}

tree::TerminalNode* SV3_1aParser::Genvar_interface_case_itemContext::DEFAULT() {
  return getToken(SV3_1aParser::DEFAULT, 0);
}


size_t SV3_1aParser::Genvar_interface_case_itemContext::getRuleIndex() const {
  return SV3_1aParser::RuleGenvar_interface_case_item;
}

void SV3_1aParser::Genvar_interface_case_itemContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGenvar_interface_case_item(this);
}

void SV3_1aParser::Genvar_interface_case_itemContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGenvar_interface_case_item(this);
}

SV3_1aParser::Genvar_interface_case_itemContext* SV3_1aParser::genvar_interface_case_item() {
  Genvar_interface_case_itemContext *_localctx = _tracker.createInstance<Genvar_interface_case_itemContext>(_ctx, getState());
  enterRule(_localctx, 664, SV3_1aParser::RuleGenvar_interface_case_item);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(5996);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SV3_1aParser::TICK_b0:
      case SV3_1aParser::TICK_b1:
      case SV3_1aParser::TICK_B0:
      case SV3_1aParser::TICK_B1:
      case SV3_1aParser::TICK_0:
      case SV3_1aParser::TICK_1:
      case SV3_1aParser::ONE_TICK_b0:
      case SV3_1aParser::ONE_TICK_b1:
      case SV3_1aParser::ONE_TICK_bx:
      case SV3_1aParser::ONE_TICK_bX:
      case SV3_1aParser::ONE_TICK_B0:
      case SV3_1aParser::ONE_TICK_B1:
      case SV3_1aParser::ONE_TICK_Bx:
      case SV3_1aParser::ONE_TICK_BX:
      case SV3_1aParser::Integral_number:
      case SV3_1aParser::Real_number:
      case SV3_1aParser::String:
      case SV3_1aParser::OPEN_PARENS:
      case SV3_1aParser::TYPE:
      case SV3_1aParser::CONST:
      case SV3_1aParser::LOCAL:
      case SV3_1aParser::SUPER:
      case SV3_1aParser::OPEN_CURLY:
      case SV3_1aParser::STRING:
      case SV3_1aParser::BYTE:
      case SV3_1aParser::SHORTINT:
      case SV3_1aParser::INT:
      case SV3_1aParser::LONGINT:
      case SV3_1aParser::INTEGER:
      case SV3_1aParser::TIME:
      case SV3_1aParser::BIT:
      case SV3_1aParser::LOGIC:
      case SV3_1aParser::REG:
      case SV3_1aParser::SHORTREAL:
      case SV3_1aParser::REAL:
      case SV3_1aParser::REALTIME:
      case SV3_1aParser::SIGNED:
      case SV3_1aParser::UNSIGNED:
      case SV3_1aParser::DOLLAR:
      case SV3_1aParser::PLUS:
      case SV3_1aParser::MINUS:
      case SV3_1aParser::DOLLAR_UNIT:
      case SV3_1aParser::BANG:
      case SV3_1aParser::TICK:
      case SV3_1aParser::THIS:
      case SV3_1aParser::DOLLAR_ROOT:
      case SV3_1aParser::RANDOMIZE:
      case SV3_1aParser::SAMPLE:
      case SV3_1aParser::BITW_AND:
      case SV3_1aParser::BITW_OR:
      case SV3_1aParser::REDUCTION_NOR:
      case SV3_1aParser::REDUCTION_NAND:
      case SV3_1aParser::REDUCTION_XNOR1:
      case SV3_1aParser::Escaped_identifier:
      case SV3_1aParser::TILDA:
      case SV3_1aParser::BITW_XOR:
      case SV3_1aParser::REDUCTION_XNOR2:
      case SV3_1aParser::Simple_identifier: {
        enterOuterAlt(_localctx, 1);
        setState(5980);
        constant_expression(0);
        setState(5985);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == SV3_1aParser::COMMA) {
          setState(5981);
          match(SV3_1aParser::COMMA);
          setState(5982);
          constant_expression(0);
          setState(5987);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(5988);
        match(SV3_1aParser::COLON);
        setState(5989);
        generate_interface_item();
        break;
      }

      case SV3_1aParser::DEFAULT: {
        enterOuterAlt(_localctx, 2);
        setState(5991);
        match(SV3_1aParser::DEFAULT);
        setState(5993);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == SV3_1aParser::COLON) {
          setState(5992);
          match(SV3_1aParser::COLON);
        }
        setState(5995);
        generate_interface_item();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Generate_interface_loop_statementContext ------------------------------------------------------------------

SV3_1aParser::Generate_interface_loop_statementContext::Generate_interface_loop_statementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Generate_interface_loop_statementContext::FOR() {
  return getToken(SV3_1aParser::FOR, 0);
}

tree::TerminalNode* SV3_1aParser::Generate_interface_loop_statementContext::OPEN_PARENS() {
  return getToken(SV3_1aParser::OPEN_PARENS, 0);
}

SV3_1aParser::Genvar_decl_assignmentContext* SV3_1aParser::Generate_interface_loop_statementContext::genvar_decl_assignment() {
  return getRuleContext<SV3_1aParser::Genvar_decl_assignmentContext>(0);
}

std::vector<tree::TerminalNode *> SV3_1aParser::Generate_interface_loop_statementContext::SEMICOLON() {
  return getTokens(SV3_1aParser::SEMICOLON);
}

tree::TerminalNode* SV3_1aParser::Generate_interface_loop_statementContext::SEMICOLON(size_t i) {
  return getToken(SV3_1aParser::SEMICOLON, i);
}

SV3_1aParser::Constant_expressionContext* SV3_1aParser::Generate_interface_loop_statementContext::constant_expression() {
  return getRuleContext<SV3_1aParser::Constant_expressionContext>(0);
}

SV3_1aParser::Genvar_assignmentContext* SV3_1aParser::Generate_interface_loop_statementContext::genvar_assignment() {
  return getRuleContext<SV3_1aParser::Genvar_assignmentContext>(0);
}

tree::TerminalNode* SV3_1aParser::Generate_interface_loop_statementContext::CLOSE_PARENS() {
  return getToken(SV3_1aParser::CLOSE_PARENS, 0);
}

SV3_1aParser::Generate_interface_named_blockContext* SV3_1aParser::Generate_interface_loop_statementContext::generate_interface_named_block() {
  return getRuleContext<SV3_1aParser::Generate_interface_named_blockContext>(0);
}


size_t SV3_1aParser::Generate_interface_loop_statementContext::getRuleIndex() const {
  return SV3_1aParser::RuleGenerate_interface_loop_statement;
}

void SV3_1aParser::Generate_interface_loop_statementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGenerate_interface_loop_statement(this);
}

void SV3_1aParser::Generate_interface_loop_statementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGenerate_interface_loop_statement(this);
}

SV3_1aParser::Generate_interface_loop_statementContext* SV3_1aParser::generate_interface_loop_statement() {
  Generate_interface_loop_statementContext *_localctx = _tracker.createInstance<Generate_interface_loop_statementContext>(_ctx, getState());
  enterRule(_localctx, 666, SV3_1aParser::RuleGenerate_interface_loop_statement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5998);
    match(SV3_1aParser::FOR);
    setState(5999);
    match(SV3_1aParser::OPEN_PARENS);
    setState(6000);
    genvar_decl_assignment();
    setState(6001);
    match(SV3_1aParser::SEMICOLON);
    setState(6002);
    constant_expression(0);
    setState(6003);
    match(SV3_1aParser::SEMICOLON);
    setState(6004);
    genvar_assignment();
    setState(6005);
    match(SV3_1aParser::CLOSE_PARENS);
    setState(6006);
    generate_interface_named_block();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Generate_interface_named_blockContext ------------------------------------------------------------------

SV3_1aParser::Generate_interface_named_blockContext::Generate_interface_named_blockContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Generate_interface_named_blockContext::BEGIN() {
  return getToken(SV3_1aParser::BEGIN, 0);
}

std::vector<tree::TerminalNode *> SV3_1aParser::Generate_interface_named_blockContext::COLON() {
  return getTokens(SV3_1aParser::COLON);
}

tree::TerminalNode* SV3_1aParser::Generate_interface_named_blockContext::COLON(size_t i) {
  return getToken(SV3_1aParser::COLON, i);
}

std::vector<SV3_1aParser::IdentifierContext *> SV3_1aParser::Generate_interface_named_blockContext::identifier() {
  return getRuleContexts<SV3_1aParser::IdentifierContext>();
}

SV3_1aParser::IdentifierContext* SV3_1aParser::Generate_interface_named_blockContext::identifier(size_t i) {
  return getRuleContext<SV3_1aParser::IdentifierContext>(i);
}

tree::TerminalNode* SV3_1aParser::Generate_interface_named_blockContext::END() {
  return getToken(SV3_1aParser::END, 0);
}

std::vector<SV3_1aParser::Generate_interface_itemContext *> SV3_1aParser::Generate_interface_named_blockContext::generate_interface_item() {
  return getRuleContexts<SV3_1aParser::Generate_interface_itemContext>();
}

SV3_1aParser::Generate_interface_itemContext* SV3_1aParser::Generate_interface_named_blockContext::generate_interface_item(size_t i) {
  return getRuleContext<SV3_1aParser::Generate_interface_itemContext>(i);
}

SV3_1aParser::Generate_interface_blockContext* SV3_1aParser::Generate_interface_named_blockContext::generate_interface_block() {
  return getRuleContext<SV3_1aParser::Generate_interface_blockContext>(0);
}


size_t SV3_1aParser::Generate_interface_named_blockContext::getRuleIndex() const {
  return SV3_1aParser::RuleGenerate_interface_named_block;
}

void SV3_1aParser::Generate_interface_named_blockContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGenerate_interface_named_block(this);
}

void SV3_1aParser::Generate_interface_named_blockContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGenerate_interface_named_block(this);
}

SV3_1aParser::Generate_interface_named_blockContext* SV3_1aParser::generate_interface_named_block() {
  Generate_interface_named_blockContext *_localctx = _tracker.createInstance<Generate_interface_named_blockContext>(_ctx, getState());
  enterRule(_localctx, 668, SV3_1aParser::RuleGenerate_interface_named_block);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(6026);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SV3_1aParser::BEGIN: {
        enterOuterAlt(_localctx, 1);
        setState(6008);
        match(SV3_1aParser::BEGIN);
        setState(6009);
        match(SV3_1aParser::COLON);
        setState(6010);
        identifier();
        setState(6014);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (((((_la - 31) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 31)) & -8637804570361036767) != 0) || ((((_la - 95) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 95)) & 72056495063103387) != 0) || ((((_la - 166) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 166)) & 4503875023273987) != 0) || ((((_la - 264) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 264)) & 4615063718147948301) != 0) || ((((_la - 328) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 328)) & 1219770728455) != 0)) {
          setState(6011);
          generate_interface_item();
          setState(6016);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(6017);
        match(SV3_1aParser::END);
        setState(6020);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == SV3_1aParser::COLON) {
          setState(6018);
          match(SV3_1aParser::COLON);
          setState(6019);
          identifier();
        }
        break;
      }

      case SV3_1aParser::THIS:
      case SV3_1aParser::RANDOMIZE:
      case SV3_1aParser::SAMPLE:
      case SV3_1aParser::Escaped_identifier:
      case SV3_1aParser::Simple_identifier: {
        enterOuterAlt(_localctx, 2);
        setState(6022);
        identifier();
        setState(6023);
        match(SV3_1aParser::COLON);
        setState(6024);
        generate_interface_block();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Generate_interface_blockContext ------------------------------------------------------------------

SV3_1aParser::Generate_interface_blockContext::Generate_interface_blockContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Generate_interface_blockContext::BEGIN() {
  return getToken(SV3_1aParser::BEGIN, 0);
}

tree::TerminalNode* SV3_1aParser::Generate_interface_blockContext::END() {
  return getToken(SV3_1aParser::END, 0);
}

std::vector<tree::TerminalNode *> SV3_1aParser::Generate_interface_blockContext::COLON() {
  return getTokens(SV3_1aParser::COLON);
}

tree::TerminalNode* SV3_1aParser::Generate_interface_blockContext::COLON(size_t i) {
  return getToken(SV3_1aParser::COLON, i);
}

std::vector<SV3_1aParser::IdentifierContext *> SV3_1aParser::Generate_interface_blockContext::identifier() {
  return getRuleContexts<SV3_1aParser::IdentifierContext>();
}

SV3_1aParser::IdentifierContext* SV3_1aParser::Generate_interface_blockContext::identifier(size_t i) {
  return getRuleContext<SV3_1aParser::IdentifierContext>(i);
}

std::vector<SV3_1aParser::Generate_interface_itemContext *> SV3_1aParser::Generate_interface_blockContext::generate_interface_item() {
  return getRuleContexts<SV3_1aParser::Generate_interface_itemContext>();
}

SV3_1aParser::Generate_interface_itemContext* SV3_1aParser::Generate_interface_blockContext::generate_interface_item(size_t i) {
  return getRuleContext<SV3_1aParser::Generate_interface_itemContext>(i);
}


size_t SV3_1aParser::Generate_interface_blockContext::getRuleIndex() const {
  return SV3_1aParser::RuleGenerate_interface_block;
}

void SV3_1aParser::Generate_interface_blockContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGenerate_interface_block(this);
}

void SV3_1aParser::Generate_interface_blockContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGenerate_interface_block(this);
}

SV3_1aParser::Generate_interface_blockContext* SV3_1aParser::generate_interface_block() {
  Generate_interface_blockContext *_localctx = _tracker.createInstance<Generate_interface_blockContext>(_ctx, getState());
  enterRule(_localctx, 670, SV3_1aParser::RuleGenerate_interface_block);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6028);
    match(SV3_1aParser::BEGIN);
    setState(6031);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SV3_1aParser::COLON) {
      setState(6029);
      match(SV3_1aParser::COLON);
      setState(6030);
      identifier();
    }
    setState(6036);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (((((_la - 31) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 31)) & -8637804570361036767) != 0) || ((((_la - 95) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 95)) & 72056495063103387) != 0) || ((((_la - 166) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 166)) & 4503875023273987) != 0) || ((((_la - 264) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 264)) & 4615063718147948301) != 0) || ((((_la - 328) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 328)) & 1219770728455) != 0)) {
      setState(6033);
      generate_interface_item();
      setState(6038);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(6039);
    match(SV3_1aParser::END);
    setState(6042);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SV3_1aParser::COLON) {
      setState(6040);
      match(SV3_1aParser::COLON);
      setState(6041);
      identifier();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Generate_regionContext ------------------------------------------------------------------

SV3_1aParser::Generate_regionContext::Generate_regionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Generate_regionContext::GENERATE() {
  return getToken(SV3_1aParser::GENERATE, 0);
}

tree::TerminalNode* SV3_1aParser::Generate_regionContext::ENDGENERATE() {
  return getToken(SV3_1aParser::ENDGENERATE, 0);
}

std::vector<SV3_1aParser::Generate_itemContext *> SV3_1aParser::Generate_regionContext::generate_item() {
  return getRuleContexts<SV3_1aParser::Generate_itemContext>();
}

SV3_1aParser::Generate_itemContext* SV3_1aParser::Generate_regionContext::generate_item(size_t i) {
  return getRuleContext<SV3_1aParser::Generate_itemContext>(i);
}


size_t SV3_1aParser::Generate_regionContext::getRuleIndex() const {
  return SV3_1aParser::RuleGenerate_region;
}

void SV3_1aParser::Generate_regionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGenerate_region(this);
}

void SV3_1aParser::Generate_regionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGenerate_region(this);
}

SV3_1aParser::Generate_regionContext* SV3_1aParser::generate_region() {
  Generate_regionContext *_localctx = _tracker.createInstance<Generate_regionContext>(_ctx, getState());
  enterRule(_localctx, 672, SV3_1aParser::RuleGenerate_region);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6044);
    match(SV3_1aParser::GENERATE);
    setState(6048);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (((((_la - 31) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 31)) & -8637240520895987679) != 0) || ((((_la - 95) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 95)) & 72056495063103387) != 0) || ((((_la - 166) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 166)) & 148619303617298435) != 0) || ((((_la - 238) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 238)) & 2182740967423) != 0) || ((((_la - 314) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 314)) & 19984723615010819) != 0) || _la == SV3_1aParser::SURELOG_MACRO_NOT_DEFINED) {
      setState(6045);
      generate_item();
      setState(6050);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(6051);
    match(SV3_1aParser::ENDGENERATE);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Loop_generate_constructContext ------------------------------------------------------------------

SV3_1aParser::Loop_generate_constructContext::Loop_generate_constructContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Loop_generate_constructContext::FOR() {
  return getToken(SV3_1aParser::FOR, 0);
}

tree::TerminalNode* SV3_1aParser::Loop_generate_constructContext::OPEN_PARENS() {
  return getToken(SV3_1aParser::OPEN_PARENS, 0);
}

SV3_1aParser::Genvar_initializationContext* SV3_1aParser::Loop_generate_constructContext::genvar_initialization() {
  return getRuleContext<SV3_1aParser::Genvar_initializationContext>(0);
}

std::vector<tree::TerminalNode *> SV3_1aParser::Loop_generate_constructContext::SEMICOLON() {
  return getTokens(SV3_1aParser::SEMICOLON);
}

tree::TerminalNode* SV3_1aParser::Loop_generate_constructContext::SEMICOLON(size_t i) {
  return getToken(SV3_1aParser::SEMICOLON, i);
}

SV3_1aParser::Constant_expressionContext* SV3_1aParser::Loop_generate_constructContext::constant_expression() {
  return getRuleContext<SV3_1aParser::Constant_expressionContext>(0);
}

SV3_1aParser::Genvar_iterationContext* SV3_1aParser::Loop_generate_constructContext::genvar_iteration() {
  return getRuleContext<SV3_1aParser::Genvar_iterationContext>(0);
}

tree::TerminalNode* SV3_1aParser::Loop_generate_constructContext::CLOSE_PARENS() {
  return getToken(SV3_1aParser::CLOSE_PARENS, 0);
}

SV3_1aParser::Generate_itemContext* SV3_1aParser::Loop_generate_constructContext::generate_item() {
  return getRuleContext<SV3_1aParser::Generate_itemContext>(0);
}


size_t SV3_1aParser::Loop_generate_constructContext::getRuleIndex() const {
  return SV3_1aParser::RuleLoop_generate_construct;
}

void SV3_1aParser::Loop_generate_constructContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLoop_generate_construct(this);
}

void SV3_1aParser::Loop_generate_constructContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLoop_generate_construct(this);
}

SV3_1aParser::Loop_generate_constructContext* SV3_1aParser::loop_generate_construct() {
  Loop_generate_constructContext *_localctx = _tracker.createInstance<Loop_generate_constructContext>(_ctx, getState());
  enterRule(_localctx, 674, SV3_1aParser::RuleLoop_generate_construct);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6053);
    match(SV3_1aParser::FOR);
    setState(6054);
    match(SV3_1aParser::OPEN_PARENS);
    setState(6055);
    genvar_initialization();
    setState(6056);
    match(SV3_1aParser::SEMICOLON);
    setState(6057);
    constant_expression(0);
    setState(6058);
    match(SV3_1aParser::SEMICOLON);
    setState(6059);
    genvar_iteration();
    setState(6060);
    match(SV3_1aParser::CLOSE_PARENS);
    setState(6061);
    generate_item();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Genvar_initializationContext ------------------------------------------------------------------

SV3_1aParser::Genvar_initializationContext::Genvar_initializationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::IdentifierContext* SV3_1aParser::Genvar_initializationContext::identifier() {
  return getRuleContext<SV3_1aParser::IdentifierContext>(0);
}

tree::TerminalNode* SV3_1aParser::Genvar_initializationContext::ASSIGN_OP() {
  return getToken(SV3_1aParser::ASSIGN_OP, 0);
}

SV3_1aParser::Constant_expressionContext* SV3_1aParser::Genvar_initializationContext::constant_expression() {
  return getRuleContext<SV3_1aParser::Constant_expressionContext>(0);
}

tree::TerminalNode* SV3_1aParser::Genvar_initializationContext::GENVAR() {
  return getToken(SV3_1aParser::GENVAR, 0);
}


size_t SV3_1aParser::Genvar_initializationContext::getRuleIndex() const {
  return SV3_1aParser::RuleGenvar_initialization;
}

void SV3_1aParser::Genvar_initializationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGenvar_initialization(this);
}

void SV3_1aParser::Genvar_initializationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGenvar_initialization(this);
}

SV3_1aParser::Genvar_initializationContext* SV3_1aParser::genvar_initialization() {
  Genvar_initializationContext *_localctx = _tracker.createInstance<Genvar_initializationContext>(_ctx, getState());
  enterRule(_localctx, 676, SV3_1aParser::RuleGenvar_initialization);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6064);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SV3_1aParser::GENVAR) {
      setState(6063);
      match(SV3_1aParser::GENVAR);
    }
    setState(6066);
    identifier();
    setState(6067);
    match(SV3_1aParser::ASSIGN_OP);
    setState(6068);
    constant_expression(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Genvar_iterationContext ------------------------------------------------------------------

SV3_1aParser::Genvar_iterationContext::Genvar_iterationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::IdentifierContext* SV3_1aParser::Genvar_iterationContext::identifier() {
  return getRuleContext<SV3_1aParser::IdentifierContext>(0);
}

SV3_1aParser::Assignment_operatorContext* SV3_1aParser::Genvar_iterationContext::assignment_operator() {
  return getRuleContext<SV3_1aParser::Assignment_operatorContext>(0);
}

SV3_1aParser::Constant_expressionContext* SV3_1aParser::Genvar_iterationContext::constant_expression() {
  return getRuleContext<SV3_1aParser::Constant_expressionContext>(0);
}

SV3_1aParser::Inc_or_dec_operatorContext* SV3_1aParser::Genvar_iterationContext::inc_or_dec_operator() {
  return getRuleContext<SV3_1aParser::Inc_or_dec_operatorContext>(0);
}


size_t SV3_1aParser::Genvar_iterationContext::getRuleIndex() const {
  return SV3_1aParser::RuleGenvar_iteration;
}

void SV3_1aParser::Genvar_iterationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGenvar_iteration(this);
}

void SV3_1aParser::Genvar_iterationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGenvar_iteration(this);
}

SV3_1aParser::Genvar_iterationContext* SV3_1aParser::genvar_iteration() {
  Genvar_iterationContext *_localctx = _tracker.createInstance<Genvar_iterationContext>(_ctx, getState());
  enterRule(_localctx, 678, SV3_1aParser::RuleGenvar_iteration);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(6080);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 688, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(6070);
      identifier();
      setState(6071);
      assignment_operator();
      setState(6072);
      constant_expression(0);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(6074);
      inc_or_dec_operator();
      setState(6075);
      identifier();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(6077);
      identifier();
      setState(6078);
      inc_or_dec_operator();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Conditional_generate_constructContext ------------------------------------------------------------------

SV3_1aParser::Conditional_generate_constructContext::Conditional_generate_constructContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::If_generate_constructContext* SV3_1aParser::Conditional_generate_constructContext::if_generate_construct() {
  return getRuleContext<SV3_1aParser::If_generate_constructContext>(0);
}

SV3_1aParser::Case_generate_constructContext* SV3_1aParser::Conditional_generate_constructContext::case_generate_construct() {
  return getRuleContext<SV3_1aParser::Case_generate_constructContext>(0);
}


size_t SV3_1aParser::Conditional_generate_constructContext::getRuleIndex() const {
  return SV3_1aParser::RuleConditional_generate_construct;
}

void SV3_1aParser::Conditional_generate_constructContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterConditional_generate_construct(this);
}

void SV3_1aParser::Conditional_generate_constructContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitConditional_generate_construct(this);
}

SV3_1aParser::Conditional_generate_constructContext* SV3_1aParser::conditional_generate_construct() {
  Conditional_generate_constructContext *_localctx = _tracker.createInstance<Conditional_generate_constructContext>(_ctx, getState());
  enterRule(_localctx, 680, SV3_1aParser::RuleConditional_generate_construct);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(6084);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SV3_1aParser::IF: {
        enterOuterAlt(_localctx, 1);
        setState(6082);
        if_generate_construct();
        break;
      }

      case SV3_1aParser::CASE: {
        enterOuterAlt(_localctx, 2);
        setState(6083);
        case_generate_construct();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- If_generate_constructContext ------------------------------------------------------------------

SV3_1aParser::If_generate_constructContext::If_generate_constructContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::If_generate_constructContext::IF() {
  return getToken(SV3_1aParser::IF, 0);
}

tree::TerminalNode* SV3_1aParser::If_generate_constructContext::OPEN_PARENS() {
  return getToken(SV3_1aParser::OPEN_PARENS, 0);
}

SV3_1aParser::Constant_expressionContext* SV3_1aParser::If_generate_constructContext::constant_expression() {
  return getRuleContext<SV3_1aParser::Constant_expressionContext>(0);
}

tree::TerminalNode* SV3_1aParser::If_generate_constructContext::CLOSE_PARENS() {
  return getToken(SV3_1aParser::CLOSE_PARENS, 0);
}

std::vector<SV3_1aParser::Generate_itemContext *> SV3_1aParser::If_generate_constructContext::generate_item() {
  return getRuleContexts<SV3_1aParser::Generate_itemContext>();
}

SV3_1aParser::Generate_itemContext* SV3_1aParser::If_generate_constructContext::generate_item(size_t i) {
  return getRuleContext<SV3_1aParser::Generate_itemContext>(i);
}

tree::TerminalNode* SV3_1aParser::If_generate_constructContext::ELSE() {
  return getToken(SV3_1aParser::ELSE, 0);
}


size_t SV3_1aParser::If_generate_constructContext::getRuleIndex() const {
  return SV3_1aParser::RuleIf_generate_construct;
}

void SV3_1aParser::If_generate_constructContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIf_generate_construct(this);
}

void SV3_1aParser::If_generate_constructContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIf_generate_construct(this);
}

SV3_1aParser::If_generate_constructContext* SV3_1aParser::if_generate_construct() {
  If_generate_constructContext *_localctx = _tracker.createInstance<If_generate_constructContext>(_ctx, getState());
  enterRule(_localctx, 682, SV3_1aParser::RuleIf_generate_construct);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6086);
    match(SV3_1aParser::IF);
    setState(6087);
    match(SV3_1aParser::OPEN_PARENS);
    setState(6088);
    constant_expression(0);
    setState(6089);
    match(SV3_1aParser::CLOSE_PARENS);
    setState(6090);
    generate_item();
    setState(6094);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 690, _ctx)) {
    case 1: {
      setState(6091);
      match(SV3_1aParser::ELSE);
      setState(6092);
      generate_item();
      break;
    }

    case 2: {
      setState(6093);

      if (!(_input->LA(1) != ELSE)) throw FailedPredicateException(this, "_input->LA(1) != ELSE");
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Case_generate_constructContext ------------------------------------------------------------------

SV3_1aParser::Case_generate_constructContext::Case_generate_constructContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Case_generate_constructContext::CASE() {
  return getToken(SV3_1aParser::CASE, 0);
}

tree::TerminalNode* SV3_1aParser::Case_generate_constructContext::OPEN_PARENS() {
  return getToken(SV3_1aParser::OPEN_PARENS, 0);
}

SV3_1aParser::Constant_expressionContext* SV3_1aParser::Case_generate_constructContext::constant_expression() {
  return getRuleContext<SV3_1aParser::Constant_expressionContext>(0);
}

tree::TerminalNode* SV3_1aParser::Case_generate_constructContext::CLOSE_PARENS() {
  return getToken(SV3_1aParser::CLOSE_PARENS, 0);
}

tree::TerminalNode* SV3_1aParser::Case_generate_constructContext::ENDCASE() {
  return getToken(SV3_1aParser::ENDCASE, 0);
}

std::vector<SV3_1aParser::Case_generate_itemContext *> SV3_1aParser::Case_generate_constructContext::case_generate_item() {
  return getRuleContexts<SV3_1aParser::Case_generate_itemContext>();
}

SV3_1aParser::Case_generate_itemContext* SV3_1aParser::Case_generate_constructContext::case_generate_item(size_t i) {
  return getRuleContext<SV3_1aParser::Case_generate_itemContext>(i);
}


size_t SV3_1aParser::Case_generate_constructContext::getRuleIndex() const {
  return SV3_1aParser::RuleCase_generate_construct;
}

void SV3_1aParser::Case_generate_constructContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCase_generate_construct(this);
}

void SV3_1aParser::Case_generate_constructContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCase_generate_construct(this);
}

SV3_1aParser::Case_generate_constructContext* SV3_1aParser::case_generate_construct() {
  Case_generate_constructContext *_localctx = _tracker.createInstance<Case_generate_constructContext>(_ctx, getState());
  enterRule(_localctx, 684, SV3_1aParser::RuleCase_generate_construct);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6096);
    match(SV3_1aParser::CASE);
    setState(6097);
    match(SV3_1aParser::OPEN_PARENS);
    setState(6098);
    constant_expression(0);
    setState(6099);
    match(SV3_1aParser::CLOSE_PARENS);
    setState(6101); 
    _errHandler->sync(this);
    _la = _input->LA(1);
    do {
      setState(6100);
      case_generate_item();
      setState(6103); 
      _errHandler->sync(this);
      _la = _input->LA(1);
    } while ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 8864814399484) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 64)) & 1152648825725551617) != 0) || ((((_la - 147) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 147)) & 2199359324163) != 0) || _la == SV3_1aParser::BANG || ((((_la - 316) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 316)) & 8742766775376897) != 0));
    setState(6105);
    match(SV3_1aParser::ENDCASE);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Case_generate_itemContext ------------------------------------------------------------------

SV3_1aParser::Case_generate_itemContext::Case_generate_itemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<SV3_1aParser::Constant_expressionContext *> SV3_1aParser::Case_generate_itemContext::constant_expression() {
  return getRuleContexts<SV3_1aParser::Constant_expressionContext>();
}

SV3_1aParser::Constant_expressionContext* SV3_1aParser::Case_generate_itemContext::constant_expression(size_t i) {
  return getRuleContext<SV3_1aParser::Constant_expressionContext>(i);
}

tree::TerminalNode* SV3_1aParser::Case_generate_itemContext::COLON() {
  return getToken(SV3_1aParser::COLON, 0);
}

SV3_1aParser::Generate_itemContext* SV3_1aParser::Case_generate_itemContext::generate_item() {
  return getRuleContext<SV3_1aParser::Generate_itemContext>(0);
}

std::vector<tree::TerminalNode *> SV3_1aParser::Case_generate_itemContext::COMMA() {
  return getTokens(SV3_1aParser::COMMA);
}

tree::TerminalNode* SV3_1aParser::Case_generate_itemContext::COMMA(size_t i) {
  return getToken(SV3_1aParser::COMMA, i);
}

tree::TerminalNode* SV3_1aParser::Case_generate_itemContext::DEFAULT() {
  return getToken(SV3_1aParser::DEFAULT, 0);
}


size_t SV3_1aParser::Case_generate_itemContext::getRuleIndex() const {
  return SV3_1aParser::RuleCase_generate_item;
}

void SV3_1aParser::Case_generate_itemContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCase_generate_item(this);
}

void SV3_1aParser::Case_generate_itemContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCase_generate_item(this);
}

SV3_1aParser::Case_generate_itemContext* SV3_1aParser::case_generate_item() {
  Case_generate_itemContext *_localctx = _tracker.createInstance<Case_generate_itemContext>(_ctx, getState());
  enterRule(_localctx, 686, SV3_1aParser::RuleCase_generate_item);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(6123);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SV3_1aParser::TICK_b0:
      case SV3_1aParser::TICK_b1:
      case SV3_1aParser::TICK_B0:
      case SV3_1aParser::TICK_B1:
      case SV3_1aParser::TICK_0:
      case SV3_1aParser::TICK_1:
      case SV3_1aParser::ONE_TICK_b0:
      case SV3_1aParser::ONE_TICK_b1:
      case SV3_1aParser::ONE_TICK_bx:
      case SV3_1aParser::ONE_TICK_bX:
      case SV3_1aParser::ONE_TICK_B0:
      case SV3_1aParser::ONE_TICK_B1:
      case SV3_1aParser::ONE_TICK_Bx:
      case SV3_1aParser::ONE_TICK_BX:
      case SV3_1aParser::Integral_number:
      case SV3_1aParser::Real_number:
      case SV3_1aParser::String:
      case SV3_1aParser::OPEN_PARENS:
      case SV3_1aParser::TYPE:
      case SV3_1aParser::CONST:
      case SV3_1aParser::LOCAL:
      case SV3_1aParser::SUPER:
      case SV3_1aParser::OPEN_CURLY:
      case SV3_1aParser::STRING:
      case SV3_1aParser::BYTE:
      case SV3_1aParser::SHORTINT:
      case SV3_1aParser::INT:
      case SV3_1aParser::LONGINT:
      case SV3_1aParser::INTEGER:
      case SV3_1aParser::TIME:
      case SV3_1aParser::BIT:
      case SV3_1aParser::LOGIC:
      case SV3_1aParser::REG:
      case SV3_1aParser::SHORTREAL:
      case SV3_1aParser::REAL:
      case SV3_1aParser::REALTIME:
      case SV3_1aParser::SIGNED:
      case SV3_1aParser::UNSIGNED:
      case SV3_1aParser::DOLLAR:
      case SV3_1aParser::PLUS:
      case SV3_1aParser::MINUS:
      case SV3_1aParser::DOLLAR_UNIT:
      case SV3_1aParser::BANG:
      case SV3_1aParser::TICK:
      case SV3_1aParser::THIS:
      case SV3_1aParser::DOLLAR_ROOT:
      case SV3_1aParser::RANDOMIZE:
      case SV3_1aParser::SAMPLE:
      case SV3_1aParser::BITW_AND:
      case SV3_1aParser::BITW_OR:
      case SV3_1aParser::REDUCTION_NOR:
      case SV3_1aParser::REDUCTION_NAND:
      case SV3_1aParser::REDUCTION_XNOR1:
      case SV3_1aParser::Escaped_identifier:
      case SV3_1aParser::TILDA:
      case SV3_1aParser::BITW_XOR:
      case SV3_1aParser::REDUCTION_XNOR2:
      case SV3_1aParser::Simple_identifier: {
        enterOuterAlt(_localctx, 1);
        setState(6107);
        constant_expression(0);
        setState(6112);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == SV3_1aParser::COMMA) {
          setState(6108);
          match(SV3_1aParser::COMMA);
          setState(6109);
          constant_expression(0);
          setState(6114);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(6115);
        match(SV3_1aParser::COLON);
        setState(6116);
        generate_item();
        break;
      }

      case SV3_1aParser::DEFAULT: {
        enterOuterAlt(_localctx, 2);
        setState(6118);
        match(SV3_1aParser::DEFAULT);
        setState(6120);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == SV3_1aParser::COLON) {
          setState(6119);
          match(SV3_1aParser::COLON);
        }
        setState(6122);
        generate_item();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Generate_begin_end_blockContext ------------------------------------------------------------------

SV3_1aParser::Generate_begin_end_blockContext::Generate_begin_end_blockContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Generate_begin_end_blockContext::BEGIN() {
  return getToken(SV3_1aParser::BEGIN, 0);
}

tree::TerminalNode* SV3_1aParser::Generate_begin_end_blockContext::END() {
  return getToken(SV3_1aParser::END, 0);
}

std::vector<tree::TerminalNode *> SV3_1aParser::Generate_begin_end_blockContext::COLON() {
  return getTokens(SV3_1aParser::COLON);
}

tree::TerminalNode* SV3_1aParser::Generate_begin_end_blockContext::COLON(size_t i) {
  return getToken(SV3_1aParser::COLON, i);
}

std::vector<SV3_1aParser::IdentifierContext *> SV3_1aParser::Generate_begin_end_blockContext::identifier() {
  return getRuleContexts<SV3_1aParser::IdentifierContext>();
}

SV3_1aParser::IdentifierContext* SV3_1aParser::Generate_begin_end_blockContext::identifier(size_t i) {
  return getRuleContext<SV3_1aParser::IdentifierContext>(i);
}

std::vector<SV3_1aParser::Generate_itemContext *> SV3_1aParser::Generate_begin_end_blockContext::generate_item() {
  return getRuleContexts<SV3_1aParser::Generate_itemContext>();
}

SV3_1aParser::Generate_itemContext* SV3_1aParser::Generate_begin_end_blockContext::generate_item(size_t i) {
  return getRuleContext<SV3_1aParser::Generate_itemContext>(i);
}


size_t SV3_1aParser::Generate_begin_end_blockContext::getRuleIndex() const {
  return SV3_1aParser::RuleGenerate_begin_end_block;
}

void SV3_1aParser::Generate_begin_end_blockContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGenerate_begin_end_block(this);
}

void SV3_1aParser::Generate_begin_end_blockContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGenerate_begin_end_block(this);
}

SV3_1aParser::Generate_begin_end_blockContext* SV3_1aParser::generate_begin_end_block() {
  Generate_begin_end_blockContext *_localctx = _tracker.createInstance<Generate_begin_end_blockContext>(_ctx, getState());
  enterRule(_localctx, 688, SV3_1aParser::RuleGenerate_begin_end_block);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6128);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (((((_la - 326) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 326)) & 4672924483589) != 0)) {
      setState(6125);
      identifier();
      setState(6126);
      match(SV3_1aParser::COLON);
    }
    setState(6130);
    match(SV3_1aParser::BEGIN);
    setState(6134);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 696, _ctx)) {
    case 1: {
      setState(6131);
      match(SV3_1aParser::COLON);
      setState(6132);
      identifier();
      break;
    }

    case 2: {
      setState(6133);

      if (!(_input->LA(1) != COLON)) throw FailedPredicateException(this, "_input->LA(1) != COLON");
      break;
    }

    default:
      break;
    }
    setState(6139);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (((((_la - 31) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 31)) & -8637240520895987679) != 0) || ((((_la - 95) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 95)) & 72056495063103387) != 0) || ((((_la - 166) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 166)) & 148619303617298435) != 0) || ((((_la - 238) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 238)) & 2182740967423) != 0) || ((((_la - 314) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 314)) & 19984723615010819) != 0) || _la == SV3_1aParser::SURELOG_MACRO_NOT_DEFINED) {
      setState(6136);
      generate_item();
      setState(6141);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(6142);
    match(SV3_1aParser::END);
    setState(6146);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 698, _ctx)) {
    case 1: {
      setState(6143);
      match(SV3_1aParser::COLON);
      setState(6144);
      identifier();
      break;
    }

    case 2: {
      setState(6145);

      if (!(_input->LA(1) != COLON)) throw FailedPredicateException(this, "_input->LA(1) != COLON");
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Generate_itemContext ------------------------------------------------------------------

SV3_1aParser::Generate_itemContext::Generate_itemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::Module_or_generate_itemContext* SV3_1aParser::Generate_itemContext::module_or_generate_item() {
  return getRuleContext<SV3_1aParser::Module_or_generate_itemContext>(0);
}

tree::TerminalNode* SV3_1aParser::Generate_itemContext::MODPORT() {
  return getToken(SV3_1aParser::MODPORT, 0);
}

std::vector<SV3_1aParser::Modport_itemContext *> SV3_1aParser::Generate_itemContext::modport_item() {
  return getRuleContexts<SV3_1aParser::Modport_itemContext>();
}

SV3_1aParser::Modport_itemContext* SV3_1aParser::Generate_itemContext::modport_item(size_t i) {
  return getRuleContext<SV3_1aParser::Modport_itemContext>(i);
}

tree::TerminalNode* SV3_1aParser::Generate_itemContext::SEMICOLON() {
  return getToken(SV3_1aParser::SEMICOLON, 0);
}

SV3_1aParser::Extern_tf_declarationContext* SV3_1aParser::Generate_itemContext::extern_tf_declaration() {
  return getRuleContext<SV3_1aParser::Extern_tf_declarationContext>(0);
}

std::vector<SV3_1aParser::Attribute_instanceContext *> SV3_1aParser::Generate_itemContext::attribute_instance() {
  return getRuleContexts<SV3_1aParser::Attribute_instanceContext>();
}

SV3_1aParser::Attribute_instanceContext* SV3_1aParser::Generate_itemContext::attribute_instance(size_t i) {
  return getRuleContext<SV3_1aParser::Attribute_instanceContext>(i);
}

std::vector<tree::TerminalNode *> SV3_1aParser::Generate_itemContext::COMMA() {
  return getTokens(SV3_1aParser::COMMA);
}

tree::TerminalNode* SV3_1aParser::Generate_itemContext::COMMA(size_t i) {
  return getToken(SV3_1aParser::COMMA, i);
}

SV3_1aParser::Checker_or_generate_item_declarationContext* SV3_1aParser::Generate_itemContext::checker_or_generate_item_declaration() {
  return getRuleContext<SV3_1aParser::Checker_or_generate_item_declarationContext>(0);
}

SV3_1aParser::Generate_regionContext* SV3_1aParser::Generate_itemContext::generate_region() {
  return getRuleContext<SV3_1aParser::Generate_regionContext>(0);
}

SV3_1aParser::Generate_begin_end_blockContext* SV3_1aParser::Generate_itemContext::generate_begin_end_block() {
  return getRuleContext<SV3_1aParser::Generate_begin_end_blockContext>(0);
}


size_t SV3_1aParser::Generate_itemContext::getRuleIndex() const {
  return SV3_1aParser::RuleGenerate_item;
}

void SV3_1aParser::Generate_itemContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGenerate_item(this);
}

void SV3_1aParser::Generate_itemContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGenerate_item(this);
}

SV3_1aParser::Generate_itemContext* SV3_1aParser::generate_item() {
  Generate_itemContext *_localctx = _tracker.createInstance<Generate_itemContext>(_ctx, getState());
  enterRule(_localctx, 690, SV3_1aParser::RuleGenerate_item);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(6172);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 702, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(6148);
      module_or_generate_item();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(6152);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == SV3_1aParser::OPEN_PARENS_STAR) {
        setState(6149);
        attribute_instance();
        setState(6154);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(6167);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case SV3_1aParser::MODPORT: {
          setState(6155);
          match(SV3_1aParser::MODPORT);
          setState(6156);
          modport_item();
          setState(6161);
          _errHandler->sync(this);
          _la = _input->LA(1);
          while (_la == SV3_1aParser::COMMA) {
            setState(6157);
            match(SV3_1aParser::COMMA);
            setState(6158);
            modport_item();
            setState(6163);
            _errHandler->sync(this);
            _la = _input->LA(1);
          }
          setState(6164);
          match(SV3_1aParser::SEMICOLON);
          break;
        }

        case SV3_1aParser::EXTERN: {
          setState(6166);
          extern_tf_declaration();
          break;
        }

      default:
        throw NoViableAltException(this);
      }
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(6169);
      checker_or_generate_item_declaration();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(6170);
      generate_region();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(6171);
      generate_begin_end_block();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Udp_nonansi_declarationContext ------------------------------------------------------------------

SV3_1aParser::Udp_nonansi_declarationContext::Udp_nonansi_declarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Udp_nonansi_declarationContext::PRIMITIVE() {
  return getToken(SV3_1aParser::PRIMITIVE, 0);
}

SV3_1aParser::IdentifierContext* SV3_1aParser::Udp_nonansi_declarationContext::identifier() {
  return getRuleContext<SV3_1aParser::IdentifierContext>(0);
}

tree::TerminalNode* SV3_1aParser::Udp_nonansi_declarationContext::OPEN_PARENS() {
  return getToken(SV3_1aParser::OPEN_PARENS, 0);
}

SV3_1aParser::Udp_port_listContext* SV3_1aParser::Udp_nonansi_declarationContext::udp_port_list() {
  return getRuleContext<SV3_1aParser::Udp_port_listContext>(0);
}

tree::TerminalNode* SV3_1aParser::Udp_nonansi_declarationContext::CLOSE_PARENS() {
  return getToken(SV3_1aParser::CLOSE_PARENS, 0);
}

tree::TerminalNode* SV3_1aParser::Udp_nonansi_declarationContext::SEMICOLON() {
  return getToken(SV3_1aParser::SEMICOLON, 0);
}

std::vector<SV3_1aParser::Attribute_instanceContext *> SV3_1aParser::Udp_nonansi_declarationContext::attribute_instance() {
  return getRuleContexts<SV3_1aParser::Attribute_instanceContext>();
}

SV3_1aParser::Attribute_instanceContext* SV3_1aParser::Udp_nonansi_declarationContext::attribute_instance(size_t i) {
  return getRuleContext<SV3_1aParser::Attribute_instanceContext>(i);
}


size_t SV3_1aParser::Udp_nonansi_declarationContext::getRuleIndex() const {
  return SV3_1aParser::RuleUdp_nonansi_declaration;
}

void SV3_1aParser::Udp_nonansi_declarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUdp_nonansi_declaration(this);
}

void SV3_1aParser::Udp_nonansi_declarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUdp_nonansi_declaration(this);
}

SV3_1aParser::Udp_nonansi_declarationContext* SV3_1aParser::udp_nonansi_declaration() {
  Udp_nonansi_declarationContext *_localctx = _tracker.createInstance<Udp_nonansi_declarationContext>(_ctx, getState());
  enterRule(_localctx, 692, SV3_1aParser::RuleUdp_nonansi_declaration);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6177);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == SV3_1aParser::OPEN_PARENS_STAR) {
      setState(6174);
      attribute_instance();
      setState(6179);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(6180);
    match(SV3_1aParser::PRIMITIVE);
    setState(6181);
    identifier();
    setState(6182);
    match(SV3_1aParser::OPEN_PARENS);
    setState(6183);
    udp_port_list();
    setState(6184);
    match(SV3_1aParser::CLOSE_PARENS);
    setState(6185);
    match(SV3_1aParser::SEMICOLON);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Udp_ansi_declarationContext ------------------------------------------------------------------

SV3_1aParser::Udp_ansi_declarationContext::Udp_ansi_declarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Udp_ansi_declarationContext::PRIMITIVE() {
  return getToken(SV3_1aParser::PRIMITIVE, 0);
}

SV3_1aParser::IdentifierContext* SV3_1aParser::Udp_ansi_declarationContext::identifier() {
  return getRuleContext<SV3_1aParser::IdentifierContext>(0);
}

tree::TerminalNode* SV3_1aParser::Udp_ansi_declarationContext::OPEN_PARENS() {
  return getToken(SV3_1aParser::OPEN_PARENS, 0);
}

SV3_1aParser::Udp_declaration_port_listContext* SV3_1aParser::Udp_ansi_declarationContext::udp_declaration_port_list() {
  return getRuleContext<SV3_1aParser::Udp_declaration_port_listContext>(0);
}

tree::TerminalNode* SV3_1aParser::Udp_ansi_declarationContext::CLOSE_PARENS() {
  return getToken(SV3_1aParser::CLOSE_PARENS, 0);
}

tree::TerminalNode* SV3_1aParser::Udp_ansi_declarationContext::SEMICOLON() {
  return getToken(SV3_1aParser::SEMICOLON, 0);
}

std::vector<SV3_1aParser::Attribute_instanceContext *> SV3_1aParser::Udp_ansi_declarationContext::attribute_instance() {
  return getRuleContexts<SV3_1aParser::Attribute_instanceContext>();
}

SV3_1aParser::Attribute_instanceContext* SV3_1aParser::Udp_ansi_declarationContext::attribute_instance(size_t i) {
  return getRuleContext<SV3_1aParser::Attribute_instanceContext>(i);
}


size_t SV3_1aParser::Udp_ansi_declarationContext::getRuleIndex() const {
  return SV3_1aParser::RuleUdp_ansi_declaration;
}

void SV3_1aParser::Udp_ansi_declarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUdp_ansi_declaration(this);
}

void SV3_1aParser::Udp_ansi_declarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUdp_ansi_declaration(this);
}

SV3_1aParser::Udp_ansi_declarationContext* SV3_1aParser::udp_ansi_declaration() {
  Udp_ansi_declarationContext *_localctx = _tracker.createInstance<Udp_ansi_declarationContext>(_ctx, getState());
  enterRule(_localctx, 694, SV3_1aParser::RuleUdp_ansi_declaration);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6190);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == SV3_1aParser::OPEN_PARENS_STAR) {
      setState(6187);
      attribute_instance();
      setState(6192);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(6193);
    match(SV3_1aParser::PRIMITIVE);
    setState(6194);
    identifier();
    setState(6195);
    match(SV3_1aParser::OPEN_PARENS);
    setState(6196);
    udp_declaration_port_list();
    setState(6197);
    match(SV3_1aParser::CLOSE_PARENS);
    setState(6198);
    match(SV3_1aParser::SEMICOLON);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Udp_declarationContext ------------------------------------------------------------------

SV3_1aParser::Udp_declarationContext::Udp_declarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::Udp_nonansi_declarationContext* SV3_1aParser::Udp_declarationContext::udp_nonansi_declaration() {
  return getRuleContext<SV3_1aParser::Udp_nonansi_declarationContext>(0);
}

std::vector<SV3_1aParser::Udp_port_declarationContext *> SV3_1aParser::Udp_declarationContext::udp_port_declaration() {
  return getRuleContexts<SV3_1aParser::Udp_port_declarationContext>();
}

SV3_1aParser::Udp_port_declarationContext* SV3_1aParser::Udp_declarationContext::udp_port_declaration(size_t i) {
  return getRuleContext<SV3_1aParser::Udp_port_declarationContext>(i);
}

SV3_1aParser::Udp_bodyContext* SV3_1aParser::Udp_declarationContext::udp_body() {
  return getRuleContext<SV3_1aParser::Udp_bodyContext>(0);
}

tree::TerminalNode* SV3_1aParser::Udp_declarationContext::ENDPRIMITIVE() {
  return getToken(SV3_1aParser::ENDPRIMITIVE, 0);
}

tree::TerminalNode* SV3_1aParser::Udp_declarationContext::COLON() {
  return getToken(SV3_1aParser::COLON, 0);
}

std::vector<SV3_1aParser::IdentifierContext *> SV3_1aParser::Udp_declarationContext::identifier() {
  return getRuleContexts<SV3_1aParser::IdentifierContext>();
}

SV3_1aParser::IdentifierContext* SV3_1aParser::Udp_declarationContext::identifier(size_t i) {
  return getRuleContext<SV3_1aParser::IdentifierContext>(i);
}

SV3_1aParser::Udp_ansi_declarationContext* SV3_1aParser::Udp_declarationContext::udp_ansi_declaration() {
  return getRuleContext<SV3_1aParser::Udp_ansi_declarationContext>(0);
}

tree::TerminalNode* SV3_1aParser::Udp_declarationContext::EXTERN() {
  return getToken(SV3_1aParser::EXTERN, 0);
}

tree::TerminalNode* SV3_1aParser::Udp_declarationContext::PRIMITIVE() {
  return getToken(SV3_1aParser::PRIMITIVE, 0);
}

tree::TerminalNode* SV3_1aParser::Udp_declarationContext::OPEN_PARENS() {
  return getToken(SV3_1aParser::OPEN_PARENS, 0);
}

tree::TerminalNode* SV3_1aParser::Udp_declarationContext::DOTSTAR() {
  return getToken(SV3_1aParser::DOTSTAR, 0);
}

tree::TerminalNode* SV3_1aParser::Udp_declarationContext::CLOSE_PARENS() {
  return getToken(SV3_1aParser::CLOSE_PARENS, 0);
}

tree::TerminalNode* SV3_1aParser::Udp_declarationContext::SEMICOLON() {
  return getToken(SV3_1aParser::SEMICOLON, 0);
}

std::vector<SV3_1aParser::Attribute_instanceContext *> SV3_1aParser::Udp_declarationContext::attribute_instance() {
  return getRuleContexts<SV3_1aParser::Attribute_instanceContext>();
}

SV3_1aParser::Attribute_instanceContext* SV3_1aParser::Udp_declarationContext::attribute_instance(size_t i) {
  return getRuleContext<SV3_1aParser::Attribute_instanceContext>(i);
}


size_t SV3_1aParser::Udp_declarationContext::getRuleIndex() const {
  return SV3_1aParser::RuleUdp_declaration;
}

void SV3_1aParser::Udp_declarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUdp_declaration(this);
}

void SV3_1aParser::Udp_declarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUdp_declaration(this);
}

SV3_1aParser::Udp_declarationContext* SV3_1aParser::udp_declaration() {
  Udp_declarationContext *_localctx = _tracker.createInstance<Udp_declarationContext>(_ctx, getState());
  enterRule(_localctx, 696, SV3_1aParser::RuleUdp_declaration);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(6249);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 711, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(6200);
      udp_nonansi_declaration();
      setState(6201);
      udp_port_declaration();
      setState(6205);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (((((_la - 66) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 66)) & 18014398509481987) != 0) || _la == SV3_1aParser::OPEN_PARENS_STAR) {
        setState(6202);
        udp_port_declaration();
        setState(6207);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(6208);
      udp_body();
      setState(6209);
      match(SV3_1aParser::ENDPRIMITIVE);
      setState(6212);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == SV3_1aParser::COLON) {
        setState(6210);
        match(SV3_1aParser::COLON);
        setState(6211);
        identifier();
      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(6214);
      udp_ansi_declaration();
      setState(6215);
      udp_body();
      setState(6216);
      match(SV3_1aParser::ENDPRIMITIVE);
      setState(6219);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == SV3_1aParser::COLON) {
        setState(6217);
        match(SV3_1aParser::COLON);
        setState(6218);
        identifier();
      }
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(6221);
      match(SV3_1aParser::EXTERN);
      setState(6222);
      udp_nonansi_declaration();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(6223);
      match(SV3_1aParser::EXTERN);
      setState(6224);
      udp_ansi_declaration();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(6228);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == SV3_1aParser::OPEN_PARENS_STAR) {
        setState(6225);
        attribute_instance();
        setState(6230);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(6231);
      match(SV3_1aParser::PRIMITIVE);
      setState(6232);
      identifier();
      setState(6233);
      match(SV3_1aParser::OPEN_PARENS);
      setState(6234);
      match(SV3_1aParser::DOTSTAR);
      setState(6235);
      match(SV3_1aParser::CLOSE_PARENS);
      setState(6236);
      match(SV3_1aParser::SEMICOLON);
      setState(6240);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (((((_la - 66) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 66)) & 18014398509481987) != 0) || _la == SV3_1aParser::OPEN_PARENS_STAR) {
        setState(6237);
        udp_port_declaration();
        setState(6242);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(6243);
      udp_body();
      setState(6244);
      match(SV3_1aParser::ENDPRIMITIVE);
      setState(6247);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == SV3_1aParser::COLON) {
        setState(6245);
        match(SV3_1aParser::COLON);
        setState(6246);
        identifier();
      }
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Udp_port_listContext ------------------------------------------------------------------

SV3_1aParser::Udp_port_listContext::Udp_port_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<SV3_1aParser::IdentifierContext *> SV3_1aParser::Udp_port_listContext::identifier() {
  return getRuleContexts<SV3_1aParser::IdentifierContext>();
}

SV3_1aParser::IdentifierContext* SV3_1aParser::Udp_port_listContext::identifier(size_t i) {
  return getRuleContext<SV3_1aParser::IdentifierContext>(i);
}

std::vector<tree::TerminalNode *> SV3_1aParser::Udp_port_listContext::COMMA() {
  return getTokens(SV3_1aParser::COMMA);
}

tree::TerminalNode* SV3_1aParser::Udp_port_listContext::COMMA(size_t i) {
  return getToken(SV3_1aParser::COMMA, i);
}


size_t SV3_1aParser::Udp_port_listContext::getRuleIndex() const {
  return SV3_1aParser::RuleUdp_port_list;
}

void SV3_1aParser::Udp_port_listContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUdp_port_list(this);
}

void SV3_1aParser::Udp_port_listContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUdp_port_list(this);
}

SV3_1aParser::Udp_port_listContext* SV3_1aParser::udp_port_list() {
  Udp_port_listContext *_localctx = _tracker.createInstance<Udp_port_listContext>(_ctx, getState());
  enterRule(_localctx, 698, SV3_1aParser::RuleUdp_port_list);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6251);
    identifier();
    setState(6252);
    match(SV3_1aParser::COMMA);
    setState(6253);
    identifier();
    setState(6258);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == SV3_1aParser::COMMA) {
      setState(6254);
      match(SV3_1aParser::COMMA);
      setState(6255);
      identifier();
      setState(6260);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Udp_declaration_port_listContext ------------------------------------------------------------------

SV3_1aParser::Udp_declaration_port_listContext::Udp_declaration_port_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::Udp_output_declarationContext* SV3_1aParser::Udp_declaration_port_listContext::udp_output_declaration() {
  return getRuleContext<SV3_1aParser::Udp_output_declarationContext>(0);
}

std::vector<tree::TerminalNode *> SV3_1aParser::Udp_declaration_port_listContext::COMMA() {
  return getTokens(SV3_1aParser::COMMA);
}

tree::TerminalNode* SV3_1aParser::Udp_declaration_port_listContext::COMMA(size_t i) {
  return getToken(SV3_1aParser::COMMA, i);
}

std::vector<SV3_1aParser::Udp_input_declarationContext *> SV3_1aParser::Udp_declaration_port_listContext::udp_input_declaration() {
  return getRuleContexts<SV3_1aParser::Udp_input_declarationContext>();
}

SV3_1aParser::Udp_input_declarationContext* SV3_1aParser::Udp_declaration_port_listContext::udp_input_declaration(size_t i) {
  return getRuleContext<SV3_1aParser::Udp_input_declarationContext>(i);
}


size_t SV3_1aParser::Udp_declaration_port_listContext::getRuleIndex() const {
  return SV3_1aParser::RuleUdp_declaration_port_list;
}

void SV3_1aParser::Udp_declaration_port_listContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUdp_declaration_port_list(this);
}

void SV3_1aParser::Udp_declaration_port_listContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUdp_declaration_port_list(this);
}

SV3_1aParser::Udp_declaration_port_listContext* SV3_1aParser::udp_declaration_port_list() {
  Udp_declaration_port_listContext *_localctx = _tracker.createInstance<Udp_declaration_port_listContext>(_ctx, getState());
  enterRule(_localctx, 700, SV3_1aParser::RuleUdp_declaration_port_list);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6261);
    udp_output_declaration();
    setState(6262);
    match(SV3_1aParser::COMMA);
    setState(6263);
    udp_input_declaration();
    setState(6268);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == SV3_1aParser::COMMA) {
      setState(6264);
      match(SV3_1aParser::COMMA);
      setState(6265);
      udp_input_declaration();
      setState(6270);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Udp_port_declarationContext ------------------------------------------------------------------

SV3_1aParser::Udp_port_declarationContext::Udp_port_declarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::Udp_output_declarationContext* SV3_1aParser::Udp_port_declarationContext::udp_output_declaration() {
  return getRuleContext<SV3_1aParser::Udp_output_declarationContext>(0);
}

tree::TerminalNode* SV3_1aParser::Udp_port_declarationContext::SEMICOLON() {
  return getToken(SV3_1aParser::SEMICOLON, 0);
}

SV3_1aParser::Udp_input_declarationContext* SV3_1aParser::Udp_port_declarationContext::udp_input_declaration() {
  return getRuleContext<SV3_1aParser::Udp_input_declarationContext>(0);
}

SV3_1aParser::Udp_reg_declarationContext* SV3_1aParser::Udp_port_declarationContext::udp_reg_declaration() {
  return getRuleContext<SV3_1aParser::Udp_reg_declarationContext>(0);
}


size_t SV3_1aParser::Udp_port_declarationContext::getRuleIndex() const {
  return SV3_1aParser::RuleUdp_port_declaration;
}

void SV3_1aParser::Udp_port_declarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUdp_port_declaration(this);
}

void SV3_1aParser::Udp_port_declarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUdp_port_declaration(this);
}

SV3_1aParser::Udp_port_declarationContext* SV3_1aParser::udp_port_declaration() {
  Udp_port_declarationContext *_localctx = _tracker.createInstance<Udp_port_declarationContext>(_ctx, getState());
  enterRule(_localctx, 702, SV3_1aParser::RuleUdp_port_declaration);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(6280);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 714, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(6271);
      udp_output_declaration();
      setState(6272);
      match(SV3_1aParser::SEMICOLON);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(6274);
      udp_input_declaration();
      setState(6275);
      match(SV3_1aParser::SEMICOLON);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(6277);
      udp_reg_declaration();
      setState(6278);
      match(SV3_1aParser::SEMICOLON);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Udp_output_declarationContext ------------------------------------------------------------------

SV3_1aParser::Udp_output_declarationContext::Udp_output_declarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Udp_output_declarationContext::OUTPUT() {
  return getToken(SV3_1aParser::OUTPUT, 0);
}

SV3_1aParser::IdentifierContext* SV3_1aParser::Udp_output_declarationContext::identifier() {
  return getRuleContext<SV3_1aParser::IdentifierContext>(0);
}

tree::TerminalNode* SV3_1aParser::Udp_output_declarationContext::REG() {
  return getToken(SV3_1aParser::REG, 0);
}

std::vector<SV3_1aParser::Attribute_instanceContext *> SV3_1aParser::Udp_output_declarationContext::attribute_instance() {
  return getRuleContexts<SV3_1aParser::Attribute_instanceContext>();
}

SV3_1aParser::Attribute_instanceContext* SV3_1aParser::Udp_output_declarationContext::attribute_instance(size_t i) {
  return getRuleContext<SV3_1aParser::Attribute_instanceContext>(i);
}

tree::TerminalNode* SV3_1aParser::Udp_output_declarationContext::ASSIGN_OP() {
  return getToken(SV3_1aParser::ASSIGN_OP, 0);
}

SV3_1aParser::Constant_expressionContext* SV3_1aParser::Udp_output_declarationContext::constant_expression() {
  return getRuleContext<SV3_1aParser::Constant_expressionContext>(0);
}


size_t SV3_1aParser::Udp_output_declarationContext::getRuleIndex() const {
  return SV3_1aParser::RuleUdp_output_declaration;
}

void SV3_1aParser::Udp_output_declarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUdp_output_declaration(this);
}

void SV3_1aParser::Udp_output_declarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUdp_output_declaration(this);
}

SV3_1aParser::Udp_output_declarationContext* SV3_1aParser::udp_output_declaration() {
  Udp_output_declarationContext *_localctx = _tracker.createInstance<Udp_output_declarationContext>(_ctx, getState());
  enterRule(_localctx, 704, SV3_1aParser::RuleUdp_output_declaration);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6285);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == SV3_1aParser::OPEN_PARENS_STAR) {
      setState(6282);
      attribute_instance();
      setState(6287);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(6297);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 717, _ctx)) {
    case 1: {
      setState(6288);
      match(SV3_1aParser::OUTPUT);
      setState(6289);
      identifier();
      break;
    }

    case 2: {
      setState(6290);
      match(SV3_1aParser::OUTPUT);
      setState(6291);
      match(SV3_1aParser::REG);
      setState(6292);
      identifier();
      setState(6295);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == SV3_1aParser::ASSIGN_OP) {
        setState(6293);
        match(SV3_1aParser::ASSIGN_OP);
        setState(6294);
        constant_expression(0);
      }
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Udp_input_declarationContext ------------------------------------------------------------------

SV3_1aParser::Udp_input_declarationContext::Udp_input_declarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Udp_input_declarationContext::INPUT() {
  return getToken(SV3_1aParser::INPUT, 0);
}

SV3_1aParser::Identifier_listContext* SV3_1aParser::Udp_input_declarationContext::identifier_list() {
  return getRuleContext<SV3_1aParser::Identifier_listContext>(0);
}

std::vector<SV3_1aParser::Attribute_instanceContext *> SV3_1aParser::Udp_input_declarationContext::attribute_instance() {
  return getRuleContexts<SV3_1aParser::Attribute_instanceContext>();
}

SV3_1aParser::Attribute_instanceContext* SV3_1aParser::Udp_input_declarationContext::attribute_instance(size_t i) {
  return getRuleContext<SV3_1aParser::Attribute_instanceContext>(i);
}


size_t SV3_1aParser::Udp_input_declarationContext::getRuleIndex() const {
  return SV3_1aParser::RuleUdp_input_declaration;
}

void SV3_1aParser::Udp_input_declarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUdp_input_declaration(this);
}

void SV3_1aParser::Udp_input_declarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUdp_input_declaration(this);
}

SV3_1aParser::Udp_input_declarationContext* SV3_1aParser::udp_input_declaration() {
  Udp_input_declarationContext *_localctx = _tracker.createInstance<Udp_input_declarationContext>(_ctx, getState());
  enterRule(_localctx, 706, SV3_1aParser::RuleUdp_input_declaration);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6302);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == SV3_1aParser::OPEN_PARENS_STAR) {
      setState(6299);
      attribute_instance();
      setState(6304);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(6305);
    match(SV3_1aParser::INPUT);
    setState(6306);
    identifier_list();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Udp_reg_declarationContext ------------------------------------------------------------------

SV3_1aParser::Udp_reg_declarationContext::Udp_reg_declarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Udp_reg_declarationContext::REG() {
  return getToken(SV3_1aParser::REG, 0);
}

SV3_1aParser::IdentifierContext* SV3_1aParser::Udp_reg_declarationContext::identifier() {
  return getRuleContext<SV3_1aParser::IdentifierContext>(0);
}

std::vector<SV3_1aParser::Attribute_instanceContext *> SV3_1aParser::Udp_reg_declarationContext::attribute_instance() {
  return getRuleContexts<SV3_1aParser::Attribute_instanceContext>();
}

SV3_1aParser::Attribute_instanceContext* SV3_1aParser::Udp_reg_declarationContext::attribute_instance(size_t i) {
  return getRuleContext<SV3_1aParser::Attribute_instanceContext>(i);
}


size_t SV3_1aParser::Udp_reg_declarationContext::getRuleIndex() const {
  return SV3_1aParser::RuleUdp_reg_declaration;
}

void SV3_1aParser::Udp_reg_declarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUdp_reg_declaration(this);
}

void SV3_1aParser::Udp_reg_declarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUdp_reg_declaration(this);
}

SV3_1aParser::Udp_reg_declarationContext* SV3_1aParser::udp_reg_declaration() {
  Udp_reg_declarationContext *_localctx = _tracker.createInstance<Udp_reg_declarationContext>(_ctx, getState());
  enterRule(_localctx, 708, SV3_1aParser::RuleUdp_reg_declaration);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6311);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == SV3_1aParser::OPEN_PARENS_STAR) {
      setState(6308);
      attribute_instance();
      setState(6313);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(6314);
    match(SV3_1aParser::REG);
    setState(6315);
    identifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Udp_bodyContext ------------------------------------------------------------------

SV3_1aParser::Udp_bodyContext::Udp_bodyContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::Combinational_bodyContext* SV3_1aParser::Udp_bodyContext::combinational_body() {
  return getRuleContext<SV3_1aParser::Combinational_bodyContext>(0);
}

SV3_1aParser::Sequential_bodyContext* SV3_1aParser::Udp_bodyContext::sequential_body() {
  return getRuleContext<SV3_1aParser::Sequential_bodyContext>(0);
}


size_t SV3_1aParser::Udp_bodyContext::getRuleIndex() const {
  return SV3_1aParser::RuleUdp_body;
}

void SV3_1aParser::Udp_bodyContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUdp_body(this);
}

void SV3_1aParser::Udp_bodyContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUdp_body(this);
}

SV3_1aParser::Udp_bodyContext* SV3_1aParser::udp_body() {
  Udp_bodyContext *_localctx = _tracker.createInstance<Udp_bodyContext>(_ctx, getState());
  enterRule(_localctx, 710, SV3_1aParser::RuleUdp_body);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(6319);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 720, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(6317);
      combinational_body();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(6318);
      sequential_body();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Combinational_bodyContext ------------------------------------------------------------------

SV3_1aParser::Combinational_bodyContext::Combinational_bodyContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Combinational_bodyContext::TABLE() {
  return getToken(SV3_1aParser::TABLE, 0);
}

std::vector<SV3_1aParser::Combinational_entryContext *> SV3_1aParser::Combinational_bodyContext::combinational_entry() {
  return getRuleContexts<SV3_1aParser::Combinational_entryContext>();
}

SV3_1aParser::Combinational_entryContext* SV3_1aParser::Combinational_bodyContext::combinational_entry(size_t i) {
  return getRuleContext<SV3_1aParser::Combinational_entryContext>(i);
}

tree::TerminalNode* SV3_1aParser::Combinational_bodyContext::ENDTABLE() {
  return getToken(SV3_1aParser::ENDTABLE, 0);
}


size_t SV3_1aParser::Combinational_bodyContext::getRuleIndex() const {
  return SV3_1aParser::RuleCombinational_body;
}

void SV3_1aParser::Combinational_bodyContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCombinational_body(this);
}

void SV3_1aParser::Combinational_bodyContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCombinational_body(this);
}

SV3_1aParser::Combinational_bodyContext* SV3_1aParser::combinational_body() {
  Combinational_bodyContext *_localctx = _tracker.createInstance<Combinational_bodyContext>(_ctx, getState());
  enterRule(_localctx, 712, SV3_1aParser::RuleCombinational_body);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6321);
    match(SV3_1aParser::TABLE);
    setState(6322);
    combinational_entry();
    setState(6326);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == SV3_1aParser::QMARK

    || _la == SV3_1aParser::Integral_number || _la == SV3_1aParser::Simple_identifier) {
      setState(6323);
      combinational_entry();
      setState(6328);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(6329);
    match(SV3_1aParser::ENDTABLE);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Combinational_entryContext ------------------------------------------------------------------

SV3_1aParser::Combinational_entryContext::Combinational_entryContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::Level_input_listContext* SV3_1aParser::Combinational_entryContext::level_input_list() {
  return getRuleContext<SV3_1aParser::Level_input_listContext>(0);
}

tree::TerminalNode* SV3_1aParser::Combinational_entryContext::COLON() {
  return getToken(SV3_1aParser::COLON, 0);
}

SV3_1aParser::Output_symbolContext* SV3_1aParser::Combinational_entryContext::output_symbol() {
  return getRuleContext<SV3_1aParser::Output_symbolContext>(0);
}

tree::TerminalNode* SV3_1aParser::Combinational_entryContext::SEMICOLON() {
  return getToken(SV3_1aParser::SEMICOLON, 0);
}


size_t SV3_1aParser::Combinational_entryContext::getRuleIndex() const {
  return SV3_1aParser::RuleCombinational_entry;
}

void SV3_1aParser::Combinational_entryContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCombinational_entry(this);
}

void SV3_1aParser::Combinational_entryContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCombinational_entry(this);
}

SV3_1aParser::Combinational_entryContext* SV3_1aParser::combinational_entry() {
  Combinational_entryContext *_localctx = _tracker.createInstance<Combinational_entryContext>(_ctx, getState());
  enterRule(_localctx, 714, SV3_1aParser::RuleCombinational_entry);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6331);
    level_input_list();
    setState(6332);
    match(SV3_1aParser::COLON);
    setState(6333);
    output_symbol();
    setState(6334);
    match(SV3_1aParser::SEMICOLON);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Sequential_bodyContext ------------------------------------------------------------------

SV3_1aParser::Sequential_bodyContext::Sequential_bodyContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Sequential_bodyContext::TABLE() {
  return getToken(SV3_1aParser::TABLE, 0);
}

std::vector<SV3_1aParser::Sequential_entryContext *> SV3_1aParser::Sequential_bodyContext::sequential_entry() {
  return getRuleContexts<SV3_1aParser::Sequential_entryContext>();
}

SV3_1aParser::Sequential_entryContext* SV3_1aParser::Sequential_bodyContext::sequential_entry(size_t i) {
  return getRuleContext<SV3_1aParser::Sequential_entryContext>(i);
}

tree::TerminalNode* SV3_1aParser::Sequential_bodyContext::ENDTABLE() {
  return getToken(SV3_1aParser::ENDTABLE, 0);
}

SV3_1aParser::Udp_initial_statementContext* SV3_1aParser::Sequential_bodyContext::udp_initial_statement() {
  return getRuleContext<SV3_1aParser::Udp_initial_statementContext>(0);
}


size_t SV3_1aParser::Sequential_bodyContext::getRuleIndex() const {
  return SV3_1aParser::RuleSequential_body;
}

void SV3_1aParser::Sequential_bodyContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSequential_body(this);
}

void SV3_1aParser::Sequential_bodyContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSequential_body(this);
}

SV3_1aParser::Sequential_bodyContext* SV3_1aParser::sequential_body() {
  Sequential_bodyContext *_localctx = _tracker.createInstance<Sequential_bodyContext>(_ctx, getState());
  enterRule(_localctx, 716, SV3_1aParser::RuleSequential_body);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6337);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SV3_1aParser::INITIAL) {
      setState(6336);
      udp_initial_statement();
    }
    setState(6339);
    match(SV3_1aParser::TABLE);
    setState(6340);
    sequential_entry();
    setState(6344);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 43980465373186) != 0) || _la == SV3_1aParser::Simple_identifier) {
      setState(6341);
      sequential_entry();
      setState(6346);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(6347);
    match(SV3_1aParser::ENDTABLE);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Udp_initial_statementContext ------------------------------------------------------------------

SV3_1aParser::Udp_initial_statementContext::Udp_initial_statementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Udp_initial_statementContext::INITIAL() {
  return getToken(SV3_1aParser::INITIAL, 0);
}

SV3_1aParser::IdentifierContext* SV3_1aParser::Udp_initial_statementContext::identifier() {
  return getRuleContext<SV3_1aParser::IdentifierContext>(0);
}

tree::TerminalNode* SV3_1aParser::Udp_initial_statementContext::ASSIGN_OP() {
  return getToken(SV3_1aParser::ASSIGN_OP, 0);
}

SV3_1aParser::Init_valContext* SV3_1aParser::Udp_initial_statementContext::init_val() {
  return getRuleContext<SV3_1aParser::Init_valContext>(0);
}

tree::TerminalNode* SV3_1aParser::Udp_initial_statementContext::SEMICOLON() {
  return getToken(SV3_1aParser::SEMICOLON, 0);
}


size_t SV3_1aParser::Udp_initial_statementContext::getRuleIndex() const {
  return SV3_1aParser::RuleUdp_initial_statement;
}

void SV3_1aParser::Udp_initial_statementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUdp_initial_statement(this);
}

void SV3_1aParser::Udp_initial_statementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUdp_initial_statement(this);
}

SV3_1aParser::Udp_initial_statementContext* SV3_1aParser::udp_initial_statement() {
  Udp_initial_statementContext *_localctx = _tracker.createInstance<Udp_initial_statementContext>(_ctx, getState());
  enterRule(_localctx, 718, SV3_1aParser::RuleUdp_initial_statement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6349);
    match(SV3_1aParser::INITIAL);
    setState(6350);
    identifier();
    setState(6351);
    match(SV3_1aParser::ASSIGN_OP);
    setState(6352);
    init_val();
    setState(6353);
    match(SV3_1aParser::SEMICOLON);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Init_valContext ------------------------------------------------------------------

SV3_1aParser::Init_valContext::Init_valContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t SV3_1aParser::Init_valContext::getRuleIndex() const {
  return SV3_1aParser::RuleInit_val;
}

void SV3_1aParser::Init_valContext::copyFrom(Init_valContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- InitVal_1Tickb1Context ------------------------------------------------------------------

tree::TerminalNode* SV3_1aParser::InitVal_1Tickb1Context::ONE_TICK_b1() {
  return getToken(SV3_1aParser::ONE_TICK_b1, 0);
}

SV3_1aParser::InitVal_1Tickb1Context::InitVal_1Tickb1Context(Init_valContext *ctx) { copyFrom(ctx); }

void SV3_1aParser::InitVal_1Tickb1Context::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInitVal_1Tickb1(this);
}
void SV3_1aParser::InitVal_1Tickb1Context::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInitVal_1Tickb1(this);
}
//----------------- InitVal_1TickB1Context ------------------------------------------------------------------

tree::TerminalNode* SV3_1aParser::InitVal_1TickB1Context::ONE_TICK_B1() {
  return getToken(SV3_1aParser::ONE_TICK_B1, 0);
}

SV3_1aParser::InitVal_1TickB1Context::InitVal_1TickB1Context(Init_valContext *ctx) { copyFrom(ctx); }

void SV3_1aParser::InitVal_1TickB1Context::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInitVal_1TickB1(this);
}
void SV3_1aParser::InitVal_1TickB1Context::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInitVal_1TickB1(this);
}
//----------------- InitVal_1Tickb0Context ------------------------------------------------------------------

tree::TerminalNode* SV3_1aParser::InitVal_1Tickb0Context::ONE_TICK_b0() {
  return getToken(SV3_1aParser::ONE_TICK_b0, 0);
}

SV3_1aParser::InitVal_1Tickb0Context::InitVal_1Tickb0Context(Init_valContext *ctx) { copyFrom(ctx); }

void SV3_1aParser::InitVal_1Tickb0Context::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInitVal_1Tickb0(this);
}
void SV3_1aParser::InitVal_1Tickb0Context::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInitVal_1Tickb0(this);
}
//----------------- InitVal_1TickB0Context ------------------------------------------------------------------

tree::TerminalNode* SV3_1aParser::InitVal_1TickB0Context::ONE_TICK_B0() {
  return getToken(SV3_1aParser::ONE_TICK_B0, 0);
}

SV3_1aParser::InitVal_1TickB0Context::InitVal_1TickB0Context(Init_valContext *ctx) { copyFrom(ctx); }

void SV3_1aParser::InitVal_1TickB0Context::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInitVal_1TickB0(this);
}
void SV3_1aParser::InitVal_1TickB0Context::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInitVal_1TickB0(this);
}
//----------------- InitVal_1TickbxContext ------------------------------------------------------------------

tree::TerminalNode* SV3_1aParser::InitVal_1TickbxContext::ONE_TICK_bx() {
  return getToken(SV3_1aParser::ONE_TICK_bx, 0);
}

SV3_1aParser::InitVal_1TickbxContext::InitVal_1TickbxContext(Init_valContext *ctx) { copyFrom(ctx); }

void SV3_1aParser::InitVal_1TickbxContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInitVal_1Tickbx(this);
}
void SV3_1aParser::InitVal_1TickbxContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInitVal_1Tickbx(this);
}
//----------------- InitVal_1TickbXContext ------------------------------------------------------------------

tree::TerminalNode* SV3_1aParser::InitVal_1TickbXContext::ONE_TICK_bX() {
  return getToken(SV3_1aParser::ONE_TICK_bX, 0);
}

SV3_1aParser::InitVal_1TickbXContext::InitVal_1TickbXContext(Init_valContext *ctx) { copyFrom(ctx); }

void SV3_1aParser::InitVal_1TickbXContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInitVal_1TickbX(this);
}
void SV3_1aParser::InitVal_1TickbXContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInitVal_1TickbX(this);
}
//----------------- InitVal_1TickBxContext ------------------------------------------------------------------

tree::TerminalNode* SV3_1aParser::InitVal_1TickBxContext::ONE_TICK_Bx() {
  return getToken(SV3_1aParser::ONE_TICK_Bx, 0);
}

SV3_1aParser::InitVal_1TickBxContext::InitVal_1TickBxContext(Init_valContext *ctx) { copyFrom(ctx); }

void SV3_1aParser::InitVal_1TickBxContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInitVal_1TickBx(this);
}
void SV3_1aParser::InitVal_1TickBxContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInitVal_1TickBx(this);
}
//----------------- InitVal_1TickBXContext ------------------------------------------------------------------

tree::TerminalNode* SV3_1aParser::InitVal_1TickBXContext::ONE_TICK_BX() {
  return getToken(SV3_1aParser::ONE_TICK_BX, 0);
}

SV3_1aParser::InitVal_1TickBXContext::InitVal_1TickBXContext(Init_valContext *ctx) { copyFrom(ctx); }

void SV3_1aParser::InitVal_1TickBXContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInitVal_1TickBX(this);
}
void SV3_1aParser::InitVal_1TickBXContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInitVal_1TickBX(this);
}
//----------------- InitVal_IntegralContext ------------------------------------------------------------------

tree::TerminalNode* SV3_1aParser::InitVal_IntegralContext::Integral_number() {
  return getToken(SV3_1aParser::Integral_number, 0);
}

SV3_1aParser::InitVal_IntegralContext::InitVal_IntegralContext(Init_valContext *ctx) { copyFrom(ctx); }

void SV3_1aParser::InitVal_IntegralContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInitVal_Integral(this);
}
void SV3_1aParser::InitVal_IntegralContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInitVal_Integral(this);
}
SV3_1aParser::Init_valContext* SV3_1aParser::init_val() {
  Init_valContext *_localctx = _tracker.createInstance<Init_valContext>(_ctx, getState());
  enterRule(_localctx, 720, SV3_1aParser::RuleInit_val);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(6364);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SV3_1aParser::ONE_TICK_b0: {
        _localctx = _tracker.createInstance<SV3_1aParser::InitVal_1Tickb0Context>(_localctx);
        enterOuterAlt(_localctx, 1);
        setState(6355);
        match(SV3_1aParser::ONE_TICK_b0);
        break;
      }

      case SV3_1aParser::ONE_TICK_b1: {
        _localctx = _tracker.createInstance<SV3_1aParser::InitVal_1Tickb1Context>(_localctx);
        enterOuterAlt(_localctx, 2);
        setState(6356);
        match(SV3_1aParser::ONE_TICK_b1);
        break;
      }

      case SV3_1aParser::ONE_TICK_B0: {
        _localctx = _tracker.createInstance<SV3_1aParser::InitVal_1TickB0Context>(_localctx);
        enterOuterAlt(_localctx, 3);
        setState(6357);
        match(SV3_1aParser::ONE_TICK_B0);
        break;
      }

      case SV3_1aParser::ONE_TICK_B1: {
        _localctx = _tracker.createInstance<SV3_1aParser::InitVal_1TickB1Context>(_localctx);
        enterOuterAlt(_localctx, 4);
        setState(6358);
        match(SV3_1aParser::ONE_TICK_B1);
        break;
      }

      case SV3_1aParser::ONE_TICK_bx: {
        _localctx = _tracker.createInstance<SV3_1aParser::InitVal_1TickbxContext>(_localctx);
        enterOuterAlt(_localctx, 5);
        setState(6359);
        match(SV3_1aParser::ONE_TICK_bx);
        break;
      }

      case SV3_1aParser::ONE_TICK_bX: {
        _localctx = _tracker.createInstance<SV3_1aParser::InitVal_1TickbXContext>(_localctx);
        enterOuterAlt(_localctx, 6);
        setState(6360);
        match(SV3_1aParser::ONE_TICK_bX);
        break;
      }

      case SV3_1aParser::ONE_TICK_Bx: {
        _localctx = _tracker.createInstance<SV3_1aParser::InitVal_1TickBxContext>(_localctx);
        enterOuterAlt(_localctx, 7);
        setState(6361);
        match(SV3_1aParser::ONE_TICK_Bx);
        break;
      }

      case SV3_1aParser::ONE_TICK_BX: {
        _localctx = _tracker.createInstance<SV3_1aParser::InitVal_1TickBXContext>(_localctx);
        enterOuterAlt(_localctx, 8);
        setState(6362);
        match(SV3_1aParser::ONE_TICK_BX);
        break;
      }

      case SV3_1aParser::Integral_number: {
        _localctx = _tracker.createInstance<SV3_1aParser::InitVal_IntegralContext>(_localctx);
        enterOuterAlt(_localctx, 9);
        setState(6363);
        match(SV3_1aParser::Integral_number);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Sequential_entryContext ------------------------------------------------------------------

SV3_1aParser::Sequential_entryContext::Sequential_entryContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::Seq_input_listContext* SV3_1aParser::Sequential_entryContext::seq_input_list() {
  return getRuleContext<SV3_1aParser::Seq_input_listContext>(0);
}

std::vector<tree::TerminalNode *> SV3_1aParser::Sequential_entryContext::COLON() {
  return getTokens(SV3_1aParser::COLON);
}

tree::TerminalNode* SV3_1aParser::Sequential_entryContext::COLON(size_t i) {
  return getToken(SV3_1aParser::COLON, i);
}

SV3_1aParser::Level_symbolContext* SV3_1aParser::Sequential_entryContext::level_symbol() {
  return getRuleContext<SV3_1aParser::Level_symbolContext>(0);
}

SV3_1aParser::Next_stateContext* SV3_1aParser::Sequential_entryContext::next_state() {
  return getRuleContext<SV3_1aParser::Next_stateContext>(0);
}

tree::TerminalNode* SV3_1aParser::Sequential_entryContext::SEMICOLON() {
  return getToken(SV3_1aParser::SEMICOLON, 0);
}


size_t SV3_1aParser::Sequential_entryContext::getRuleIndex() const {
  return SV3_1aParser::RuleSequential_entry;
}

void SV3_1aParser::Sequential_entryContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSequential_entry(this);
}

void SV3_1aParser::Sequential_entryContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSequential_entry(this);
}

SV3_1aParser::Sequential_entryContext* SV3_1aParser::sequential_entry() {
  Sequential_entryContext *_localctx = _tracker.createInstance<Sequential_entryContext>(_ctx, getState());
  enterRule(_localctx, 722, SV3_1aParser::RuleSequential_entry);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6366);
    seq_input_list();
    setState(6367);
    match(SV3_1aParser::COLON);
    setState(6368);
    level_symbol();
    setState(6369);
    match(SV3_1aParser::COLON);
    setState(6370);
    next_state();
    setState(6371);
    match(SV3_1aParser::SEMICOLON);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Seq_input_listContext ------------------------------------------------------------------

SV3_1aParser::Seq_input_listContext::Seq_input_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::Level_input_listContext* SV3_1aParser::Seq_input_listContext::level_input_list() {
  return getRuleContext<SV3_1aParser::Level_input_listContext>(0);
}

SV3_1aParser::Edge_input_listContext* SV3_1aParser::Seq_input_listContext::edge_input_list() {
  return getRuleContext<SV3_1aParser::Edge_input_listContext>(0);
}


size_t SV3_1aParser::Seq_input_listContext::getRuleIndex() const {
  return SV3_1aParser::RuleSeq_input_list;
}

void SV3_1aParser::Seq_input_listContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSeq_input_list(this);
}

void SV3_1aParser::Seq_input_listContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSeq_input_list(this);
}

SV3_1aParser::Seq_input_listContext* SV3_1aParser::seq_input_list() {
  Seq_input_listContext *_localctx = _tracker.createInstance<Seq_input_listContext>(_ctx, getState());
  enterRule(_localctx, 724, SV3_1aParser::RuleSeq_input_list);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(6375);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 725, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(6373);
      level_input_list();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(6374);
      edge_input_list();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Level_input_listContext ------------------------------------------------------------------

SV3_1aParser::Level_input_listContext::Level_input_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<SV3_1aParser::Level_symbolContext *> SV3_1aParser::Level_input_listContext::level_symbol() {
  return getRuleContexts<SV3_1aParser::Level_symbolContext>();
}

SV3_1aParser::Level_symbolContext* SV3_1aParser::Level_input_listContext::level_symbol(size_t i) {
  return getRuleContext<SV3_1aParser::Level_symbolContext>(i);
}


size_t SV3_1aParser::Level_input_listContext::getRuleIndex() const {
  return SV3_1aParser::RuleLevel_input_list;
}

void SV3_1aParser::Level_input_listContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLevel_input_list(this);
}

void SV3_1aParser::Level_input_listContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLevel_input_list(this);
}

SV3_1aParser::Level_input_listContext* SV3_1aParser::level_input_list() {
  Level_input_listContext *_localctx = _tracker.createInstance<Level_input_listContext>(_ctx, getState());
  enterRule(_localctx, 726, SV3_1aParser::RuleLevel_input_list);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6377);
    level_symbol();
    setState(6381);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == SV3_1aParser::QMARK

    || _la == SV3_1aParser::Integral_number || _la == SV3_1aParser::Simple_identifier) {
      setState(6378);
      level_symbol();
      setState(6383);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Edge_input_listContext ------------------------------------------------------------------

SV3_1aParser::Edge_input_listContext::Edge_input_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::Edge_indicatorContext* SV3_1aParser::Edge_input_listContext::edge_indicator() {
  return getRuleContext<SV3_1aParser::Edge_indicatorContext>(0);
}

std::vector<SV3_1aParser::Level_symbolContext *> SV3_1aParser::Edge_input_listContext::level_symbol() {
  return getRuleContexts<SV3_1aParser::Level_symbolContext>();
}

SV3_1aParser::Level_symbolContext* SV3_1aParser::Edge_input_listContext::level_symbol(size_t i) {
  return getRuleContext<SV3_1aParser::Level_symbolContext>(i);
}


size_t SV3_1aParser::Edge_input_listContext::getRuleIndex() const {
  return SV3_1aParser::RuleEdge_input_list;
}

void SV3_1aParser::Edge_input_listContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterEdge_input_list(this);
}

void SV3_1aParser::Edge_input_listContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitEdge_input_list(this);
}

SV3_1aParser::Edge_input_listContext* SV3_1aParser::edge_input_list() {
  Edge_input_listContext *_localctx = _tracker.createInstance<Edge_input_listContext>(_ctx, getState());
  enterRule(_localctx, 728, SV3_1aParser::RuleEdge_input_list);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(6387);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 727, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(6384);
        level_symbol(); 
      }
      setState(6389);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 727, _ctx);
    }
    setState(6390);
    edge_indicator();
    setState(6394);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == SV3_1aParser::QMARK

    || _la == SV3_1aParser::Integral_number || _la == SV3_1aParser::Simple_identifier) {
      setState(6391);
      level_symbol();
      setState(6396);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Edge_indicatorContext ------------------------------------------------------------------

SV3_1aParser::Edge_indicatorContext::Edge_indicatorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Edge_indicatorContext::OPEN_PARENS() {
  return getToken(SV3_1aParser::OPEN_PARENS, 0);
}

tree::TerminalNode* SV3_1aParser::Edge_indicatorContext::CLOSE_PARENS() {
  return getToken(SV3_1aParser::CLOSE_PARENS, 0);
}

std::vector<SV3_1aParser::Level_symbolContext *> SV3_1aParser::Edge_indicatorContext::level_symbol() {
  return getRuleContexts<SV3_1aParser::Level_symbolContext>();
}

SV3_1aParser::Level_symbolContext* SV3_1aParser::Edge_indicatorContext::level_symbol(size_t i) {
  return getRuleContext<SV3_1aParser::Level_symbolContext>(i);
}

SV3_1aParser::Edge_symbolContext* SV3_1aParser::Edge_indicatorContext::edge_symbol() {
  return getRuleContext<SV3_1aParser::Edge_symbolContext>(0);
}


size_t SV3_1aParser::Edge_indicatorContext::getRuleIndex() const {
  return SV3_1aParser::RuleEdge_indicator;
}

void SV3_1aParser::Edge_indicatorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterEdge_indicator(this);
}

void SV3_1aParser::Edge_indicatorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitEdge_indicator(this);
}

SV3_1aParser::Edge_indicatorContext* SV3_1aParser::edge_indicator() {
  Edge_indicatorContext *_localctx = _tracker.createInstance<Edge_indicatorContext>(_ctx, getState());
  enterRule(_localctx, 730, SV3_1aParser::RuleEdge_indicator);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(6406);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SV3_1aParser::OPEN_PARENS: {
        enterOuterAlt(_localctx, 1);
        setState(6397);
        match(SV3_1aParser::OPEN_PARENS);
        setState(6399); 
        _errHandler->sync(this);
        _la = _input->LA(1);
        do {
          setState(6398);
          level_symbol();
          setState(6401); 
          _errHandler->sync(this);
          _la = _input->LA(1);
        } while (_la == SV3_1aParser::QMARK

        || _la == SV3_1aParser::Integral_number || _la == SV3_1aParser::Simple_identifier);
        setState(6403);
        match(SV3_1aParser::CLOSE_PARENS);
        break;
      }

      case SV3_1aParser::STAR:
      case SV3_1aParser::Simple_identifier: {
        enterOuterAlt(_localctx, 2);
        setState(6405);
        edge_symbol();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Next_stateContext ------------------------------------------------------------------

SV3_1aParser::Next_stateContext::Next_stateContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::Output_symbolContext* SV3_1aParser::Next_stateContext::output_symbol() {
  return getRuleContext<SV3_1aParser::Output_symbolContext>(0);
}

tree::TerminalNode* SV3_1aParser::Next_stateContext::MINUS() {
  return getToken(SV3_1aParser::MINUS, 0);
}


size_t SV3_1aParser::Next_stateContext::getRuleIndex() const {
  return SV3_1aParser::RuleNext_state;
}

void SV3_1aParser::Next_stateContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNext_state(this);
}

void SV3_1aParser::Next_stateContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNext_state(this);
}

SV3_1aParser::Next_stateContext* SV3_1aParser::next_state() {
  Next_stateContext *_localctx = _tracker.createInstance<Next_stateContext>(_ctx, getState());
  enterRule(_localctx, 732, SV3_1aParser::RuleNext_state);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(6410);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SV3_1aParser::Integral_number:
      case SV3_1aParser::Simple_identifier: {
        enterOuterAlt(_localctx, 1);
        setState(6408);
        output_symbol();
        break;
      }

      case SV3_1aParser::MINUS: {
        enterOuterAlt(_localctx, 2);
        setState(6409);
        match(SV3_1aParser::MINUS);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Output_symbolContext ------------------------------------------------------------------

SV3_1aParser::Output_symbolContext::Output_symbolContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Output_symbolContext::Integral_number() {
  return getToken(SV3_1aParser::Integral_number, 0);
}

tree::TerminalNode* SV3_1aParser::Output_symbolContext::Simple_identifier() {
  return getToken(SV3_1aParser::Simple_identifier, 0);
}


size_t SV3_1aParser::Output_symbolContext::getRuleIndex() const {
  return SV3_1aParser::RuleOutput_symbol;
}

void SV3_1aParser::Output_symbolContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOutput_symbol(this);
}

void SV3_1aParser::Output_symbolContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOutput_symbol(this);
}

SV3_1aParser::Output_symbolContext* SV3_1aParser::output_symbol() {
  Output_symbolContext *_localctx = _tracker.createInstance<Output_symbolContext>(_ctx, getState());
  enterRule(_localctx, 734, SV3_1aParser::RuleOutput_symbol);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6412);
    _la = _input->LA(1);
    if (!(_la == SV3_1aParser::Integral_number || _la == SV3_1aParser::Simple_identifier)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Level_symbolContext ------------------------------------------------------------------

SV3_1aParser::Level_symbolContext::Level_symbolContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Level_symbolContext::Integral_number() {
  return getToken(SV3_1aParser::Integral_number, 0);
}

tree::TerminalNode* SV3_1aParser::Level_symbolContext::Simple_identifier() {
  return getToken(SV3_1aParser::Simple_identifier, 0);
}

tree::TerminalNode* SV3_1aParser::Level_symbolContext::QMARK() {
  return getToken(SV3_1aParser::QMARK, 0);
}


size_t SV3_1aParser::Level_symbolContext::getRuleIndex() const {
  return SV3_1aParser::RuleLevel_symbol;
}

void SV3_1aParser::Level_symbolContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLevel_symbol(this);
}

void SV3_1aParser::Level_symbolContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLevel_symbol(this);
}

SV3_1aParser::Level_symbolContext* SV3_1aParser::level_symbol() {
  Level_symbolContext *_localctx = _tracker.createInstance<Level_symbolContext>(_ctx, getState());
  enterRule(_localctx, 736, SV3_1aParser::RuleLevel_symbol);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6414);
    _la = _input->LA(1);
    if (!(_la == SV3_1aParser::QMARK

    || _la == SV3_1aParser::Integral_number || _la == SV3_1aParser::Simple_identifier)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Edge_symbolContext ------------------------------------------------------------------

SV3_1aParser::Edge_symbolContext::Edge_symbolContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Edge_symbolContext::Simple_identifier() {
  return getToken(SV3_1aParser::Simple_identifier, 0);
}

tree::TerminalNode* SV3_1aParser::Edge_symbolContext::STAR() {
  return getToken(SV3_1aParser::STAR, 0);
}


size_t SV3_1aParser::Edge_symbolContext::getRuleIndex() const {
  return SV3_1aParser::RuleEdge_symbol;
}

void SV3_1aParser::Edge_symbolContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterEdge_symbol(this);
}

void SV3_1aParser::Edge_symbolContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitEdge_symbol(this);
}

SV3_1aParser::Edge_symbolContext* SV3_1aParser::edge_symbol() {
  Edge_symbolContext *_localctx = _tracker.createInstance<Edge_symbolContext>(_ctx, getState());
  enterRule(_localctx, 738, SV3_1aParser::RuleEdge_symbol);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6416);
    _la = _input->LA(1);
    if (!(_la == SV3_1aParser::STAR || _la == SV3_1aParser::Simple_identifier)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Udp_instantiationContext ------------------------------------------------------------------

SV3_1aParser::Udp_instantiationContext::Udp_instantiationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::IdentifierContext* SV3_1aParser::Udp_instantiationContext::identifier() {
  return getRuleContext<SV3_1aParser::IdentifierContext>(0);
}

std::vector<SV3_1aParser::Udp_instanceContext *> SV3_1aParser::Udp_instantiationContext::udp_instance() {
  return getRuleContexts<SV3_1aParser::Udp_instanceContext>();
}

SV3_1aParser::Udp_instanceContext* SV3_1aParser::Udp_instantiationContext::udp_instance(size_t i) {
  return getRuleContext<SV3_1aParser::Udp_instanceContext>(i);
}

tree::TerminalNode* SV3_1aParser::Udp_instantiationContext::SEMICOLON() {
  return getToken(SV3_1aParser::SEMICOLON, 0);
}

SV3_1aParser::Drive_strengthContext* SV3_1aParser::Udp_instantiationContext::drive_strength() {
  return getRuleContext<SV3_1aParser::Drive_strengthContext>(0);
}

SV3_1aParser::Delay2Context* SV3_1aParser::Udp_instantiationContext::delay2() {
  return getRuleContext<SV3_1aParser::Delay2Context>(0);
}

std::vector<tree::TerminalNode *> SV3_1aParser::Udp_instantiationContext::COMMA() {
  return getTokens(SV3_1aParser::COMMA);
}

tree::TerminalNode* SV3_1aParser::Udp_instantiationContext::COMMA(size_t i) {
  return getToken(SV3_1aParser::COMMA, i);
}


size_t SV3_1aParser::Udp_instantiationContext::getRuleIndex() const {
  return SV3_1aParser::RuleUdp_instantiation;
}

void SV3_1aParser::Udp_instantiationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUdp_instantiation(this);
}

void SV3_1aParser::Udp_instantiationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUdp_instantiation(this);
}

SV3_1aParser::Udp_instantiationContext* SV3_1aParser::udp_instantiation() {
  Udp_instantiationContext *_localctx = _tracker.createInstance<Udp_instantiationContext>(_ctx, getState());
  enterRule(_localctx, 740, SV3_1aParser::RuleUdp_instantiation);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6418);
    identifier();
    setState(6420);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 732, _ctx)) {
    case 1: {
      setState(6419);
      drive_strength();
      break;
    }

    default:
      break;
    }
    setState(6423);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SV3_1aParser::Pound_Pound_delay

    || _la == SV3_1aParser::Pound_delay || _la == SV3_1aParser::POUND) {
      setState(6422);
      delay2();
    }
    setState(6425);
    udp_instance();
    setState(6430);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == SV3_1aParser::COMMA) {
      setState(6426);
      match(SV3_1aParser::COMMA);
      setState(6427);
      udp_instance();
      setState(6432);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(6433);
    match(SV3_1aParser::SEMICOLON);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Udp_instanceContext ------------------------------------------------------------------

SV3_1aParser::Udp_instanceContext::Udp_instanceContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Udp_instanceContext::OPEN_PARENS() {
  return getToken(SV3_1aParser::OPEN_PARENS, 0);
}

SV3_1aParser::Net_lvalueContext* SV3_1aParser::Udp_instanceContext::net_lvalue() {
  return getRuleContext<SV3_1aParser::Net_lvalueContext>(0);
}

std::vector<tree::TerminalNode *> SV3_1aParser::Udp_instanceContext::COMMA() {
  return getTokens(SV3_1aParser::COMMA);
}

tree::TerminalNode* SV3_1aParser::Udp_instanceContext::COMMA(size_t i) {
  return getToken(SV3_1aParser::COMMA, i);
}

std::vector<SV3_1aParser::ExpressionContext *> SV3_1aParser::Udp_instanceContext::expression() {
  return getRuleContexts<SV3_1aParser::ExpressionContext>();
}

SV3_1aParser::ExpressionContext* SV3_1aParser::Udp_instanceContext::expression(size_t i) {
  return getRuleContext<SV3_1aParser::ExpressionContext>(i);
}

tree::TerminalNode* SV3_1aParser::Udp_instanceContext::CLOSE_PARENS() {
  return getToken(SV3_1aParser::CLOSE_PARENS, 0);
}

SV3_1aParser::Name_of_instanceContext* SV3_1aParser::Udp_instanceContext::name_of_instance() {
  return getRuleContext<SV3_1aParser::Name_of_instanceContext>(0);
}


size_t SV3_1aParser::Udp_instanceContext::getRuleIndex() const {
  return SV3_1aParser::RuleUdp_instance;
}

void SV3_1aParser::Udp_instanceContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUdp_instance(this);
}

void SV3_1aParser::Udp_instanceContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUdp_instance(this);
}

SV3_1aParser::Udp_instanceContext* SV3_1aParser::udp_instance() {
  Udp_instanceContext *_localctx = _tracker.createInstance<Udp_instanceContext>(_ctx, getState());
  enterRule(_localctx, 742, SV3_1aParser::RuleUdp_instance);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6436);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (((((_la - 326) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 326)) & 4672924483589) != 0)) {
      setState(6435);
      name_of_instance();
    }
    setState(6438);
    match(SV3_1aParser::OPEN_PARENS);
    setState(6439);
    net_lvalue();
    setState(6440);
    match(SV3_1aParser::COMMA);
    setState(6441);
    expression(0);
    setState(6446);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == SV3_1aParser::COMMA) {
      setState(6442);
      match(SV3_1aParser::COMMA);
      setState(6443);
      expression(0);
      setState(6448);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(6449);
    match(SV3_1aParser::CLOSE_PARENS);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Continuous_assignContext ------------------------------------------------------------------

SV3_1aParser::Continuous_assignContext::Continuous_assignContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Continuous_assignContext::ASSIGN() {
  return getToken(SV3_1aParser::ASSIGN, 0);
}

SV3_1aParser::List_of_net_assignmentsContext* SV3_1aParser::Continuous_assignContext::list_of_net_assignments() {
  return getRuleContext<SV3_1aParser::List_of_net_assignmentsContext>(0);
}

tree::TerminalNode* SV3_1aParser::Continuous_assignContext::SEMICOLON() {
  return getToken(SV3_1aParser::SEMICOLON, 0);
}

SV3_1aParser::Drive_strengthContext* SV3_1aParser::Continuous_assignContext::drive_strength() {
  return getRuleContext<SV3_1aParser::Drive_strengthContext>(0);
}

SV3_1aParser::Delay3Context* SV3_1aParser::Continuous_assignContext::delay3() {
  return getRuleContext<SV3_1aParser::Delay3Context>(0);
}

tree::TerminalNode* SV3_1aParser::Continuous_assignContext::ASSIGN_OP() {
  return getToken(SV3_1aParser::ASSIGN_OP, 0);
}

SV3_1aParser::List_of_variable_assignmentsContext* SV3_1aParser::Continuous_assignContext::list_of_variable_assignments() {
  return getRuleContext<SV3_1aParser::List_of_variable_assignmentsContext>(0);
}

SV3_1aParser::Delay_controlContext* SV3_1aParser::Continuous_assignContext::delay_control() {
  return getRuleContext<SV3_1aParser::Delay_controlContext>(0);
}


size_t SV3_1aParser::Continuous_assignContext::getRuleIndex() const {
  return SV3_1aParser::RuleContinuous_assign;
}

void SV3_1aParser::Continuous_assignContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterContinuous_assign(this);
}

void SV3_1aParser::Continuous_assignContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitContinuous_assign(this);
}

SV3_1aParser::Continuous_assignContext* SV3_1aParser::continuous_assign() {
  Continuous_assignContext *_localctx = _tracker.createInstance<Continuous_assignContext>(_ctx, getState());
  enterRule(_localctx, 744, SV3_1aParser::RuleContinuous_assign);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(6468);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SV3_1aParser::ASSIGN: {
        enterOuterAlt(_localctx, 1);
        setState(6451);
        match(SV3_1aParser::ASSIGN);
        setState(6453);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == SV3_1aParser::OPEN_PARENS) {
          setState(6452);
          drive_strength();
        }
        setState(6456);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == SV3_1aParser::Pound_Pound_delay

        || _la == SV3_1aParser::Pound_delay || _la == SV3_1aParser::POUND) {
          setState(6455);
          delay3();
        }
        setState(6458);
        list_of_net_assignments();
        setState(6459);
        match(SV3_1aParser::SEMICOLON);
        break;
      }

      case SV3_1aParser::ASSIGN_OP: {
        enterOuterAlt(_localctx, 2);
        setState(6461);
        match(SV3_1aParser::ASSIGN_OP);
        setState(6463);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == SV3_1aParser::Pound_Pound_delay

        || _la == SV3_1aParser::Pound_delay || _la == SV3_1aParser::POUND) {
          setState(6462);
          delay_control();
        }
        setState(6465);
        list_of_variable_assignments();
        setState(6466);
        match(SV3_1aParser::SEMICOLON);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- List_of_net_assignmentsContext ------------------------------------------------------------------

SV3_1aParser::List_of_net_assignmentsContext::List_of_net_assignmentsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<SV3_1aParser::Net_assignmentContext *> SV3_1aParser::List_of_net_assignmentsContext::net_assignment() {
  return getRuleContexts<SV3_1aParser::Net_assignmentContext>();
}

SV3_1aParser::Net_assignmentContext* SV3_1aParser::List_of_net_assignmentsContext::net_assignment(size_t i) {
  return getRuleContext<SV3_1aParser::Net_assignmentContext>(i);
}

std::vector<tree::TerminalNode *> SV3_1aParser::List_of_net_assignmentsContext::COMMA() {
  return getTokens(SV3_1aParser::COMMA);
}

tree::TerminalNode* SV3_1aParser::List_of_net_assignmentsContext::COMMA(size_t i) {
  return getToken(SV3_1aParser::COMMA, i);
}


size_t SV3_1aParser::List_of_net_assignmentsContext::getRuleIndex() const {
  return SV3_1aParser::RuleList_of_net_assignments;
}

void SV3_1aParser::List_of_net_assignmentsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterList_of_net_assignments(this);
}

void SV3_1aParser::List_of_net_assignmentsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitList_of_net_assignments(this);
}

SV3_1aParser::List_of_net_assignmentsContext* SV3_1aParser::list_of_net_assignments() {
  List_of_net_assignmentsContext *_localctx = _tracker.createInstance<List_of_net_assignmentsContext>(_ctx, getState());
  enterRule(_localctx, 746, SV3_1aParser::RuleList_of_net_assignments);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6470);
    net_assignment();
    setState(6475);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == SV3_1aParser::COMMA) {
      setState(6471);
      match(SV3_1aParser::COMMA);
      setState(6472);
      net_assignment();
      setState(6477);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- List_of_variable_assignmentsContext ------------------------------------------------------------------

SV3_1aParser::List_of_variable_assignmentsContext::List_of_variable_assignmentsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<SV3_1aParser::Variable_assignmentContext *> SV3_1aParser::List_of_variable_assignmentsContext::variable_assignment() {
  return getRuleContexts<SV3_1aParser::Variable_assignmentContext>();
}

SV3_1aParser::Variable_assignmentContext* SV3_1aParser::List_of_variable_assignmentsContext::variable_assignment(size_t i) {
  return getRuleContext<SV3_1aParser::Variable_assignmentContext>(i);
}

std::vector<tree::TerminalNode *> SV3_1aParser::List_of_variable_assignmentsContext::COMMA() {
  return getTokens(SV3_1aParser::COMMA);
}

tree::TerminalNode* SV3_1aParser::List_of_variable_assignmentsContext::COMMA(size_t i) {
  return getToken(SV3_1aParser::COMMA, i);
}


size_t SV3_1aParser::List_of_variable_assignmentsContext::getRuleIndex() const {
  return SV3_1aParser::RuleList_of_variable_assignments;
}

void SV3_1aParser::List_of_variable_assignmentsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterList_of_variable_assignments(this);
}

void SV3_1aParser::List_of_variable_assignmentsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitList_of_variable_assignments(this);
}

SV3_1aParser::List_of_variable_assignmentsContext* SV3_1aParser::list_of_variable_assignments() {
  List_of_variable_assignmentsContext *_localctx = _tracker.createInstance<List_of_variable_assignmentsContext>(_ctx, getState());
  enterRule(_localctx, 748, SV3_1aParser::RuleList_of_variable_assignments);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6478);
    variable_assignment();
    setState(6483);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == SV3_1aParser::COMMA) {
      setState(6479);
      match(SV3_1aParser::COMMA);
      setState(6480);
      variable_assignment();
      setState(6485);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Net_aliasContext ------------------------------------------------------------------

SV3_1aParser::Net_aliasContext::Net_aliasContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Net_aliasContext::ALIAS() {
  return getToken(SV3_1aParser::ALIAS, 0);
}

std::vector<SV3_1aParser::Net_lvalueContext *> SV3_1aParser::Net_aliasContext::net_lvalue() {
  return getRuleContexts<SV3_1aParser::Net_lvalueContext>();
}

SV3_1aParser::Net_lvalueContext* SV3_1aParser::Net_aliasContext::net_lvalue(size_t i) {
  return getRuleContext<SV3_1aParser::Net_lvalueContext>(i);
}

tree::TerminalNode* SV3_1aParser::Net_aliasContext::SEMICOLON() {
  return getToken(SV3_1aParser::SEMICOLON, 0);
}

std::vector<tree::TerminalNode *> SV3_1aParser::Net_aliasContext::ASSIGN_OP() {
  return getTokens(SV3_1aParser::ASSIGN_OP);
}

tree::TerminalNode* SV3_1aParser::Net_aliasContext::ASSIGN_OP(size_t i) {
  return getToken(SV3_1aParser::ASSIGN_OP, i);
}


size_t SV3_1aParser::Net_aliasContext::getRuleIndex() const {
  return SV3_1aParser::RuleNet_alias;
}

void SV3_1aParser::Net_aliasContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNet_alias(this);
}

void SV3_1aParser::Net_aliasContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNet_alias(this);
}

SV3_1aParser::Net_aliasContext* SV3_1aParser::net_alias() {
  Net_aliasContext *_localctx = _tracker.createInstance<Net_aliasContext>(_ctx, getState());
  enterRule(_localctx, 750, SV3_1aParser::RuleNet_alias);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6486);
    match(SV3_1aParser::ALIAS);
    setState(6487);
    net_lvalue();
    setState(6490); 
    _errHandler->sync(this);
    _la = _input->LA(1);
    do {
      setState(6488);
      match(SV3_1aParser::ASSIGN_OP);
      setState(6489);
      net_lvalue();
      setState(6492); 
      _errHandler->sync(this);
      _la = _input->LA(1);
    } while (_la == SV3_1aParser::ASSIGN_OP);
    setState(6494);
    match(SV3_1aParser::SEMICOLON);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Net_assignmentContext ------------------------------------------------------------------

SV3_1aParser::Net_assignmentContext::Net_assignmentContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::Net_lvalueContext* SV3_1aParser::Net_assignmentContext::net_lvalue() {
  return getRuleContext<SV3_1aParser::Net_lvalueContext>(0);
}

tree::TerminalNode* SV3_1aParser::Net_assignmentContext::ASSIGN_OP() {
  return getToken(SV3_1aParser::ASSIGN_OP, 0);
}

SV3_1aParser::ExpressionContext* SV3_1aParser::Net_assignmentContext::expression() {
  return getRuleContext<SV3_1aParser::ExpressionContext>(0);
}


size_t SV3_1aParser::Net_assignmentContext::getRuleIndex() const {
  return SV3_1aParser::RuleNet_assignment;
}

void SV3_1aParser::Net_assignmentContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNet_assignment(this);
}

void SV3_1aParser::Net_assignmentContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNet_assignment(this);
}

SV3_1aParser::Net_assignmentContext* SV3_1aParser::net_assignment() {
  Net_assignmentContext *_localctx = _tracker.createInstance<Net_assignmentContext>(_ctx, getState());
  enterRule(_localctx, 752, SV3_1aParser::RuleNet_assignment);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6496);
    net_lvalue();
    setState(6497);
    match(SV3_1aParser::ASSIGN_OP);
    setState(6498);
    expression(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Initial_constructContext ------------------------------------------------------------------

SV3_1aParser::Initial_constructContext::Initial_constructContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Initial_constructContext::INITIAL() {
  return getToken(SV3_1aParser::INITIAL, 0);
}

SV3_1aParser::Statement_or_nullContext* SV3_1aParser::Initial_constructContext::statement_or_null() {
  return getRuleContext<SV3_1aParser::Statement_or_nullContext>(0);
}


size_t SV3_1aParser::Initial_constructContext::getRuleIndex() const {
  return SV3_1aParser::RuleInitial_construct;
}

void SV3_1aParser::Initial_constructContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInitial_construct(this);
}

void SV3_1aParser::Initial_constructContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInitial_construct(this);
}

SV3_1aParser::Initial_constructContext* SV3_1aParser::initial_construct() {
  Initial_constructContext *_localctx = _tracker.createInstance<Initial_constructContext>(_ctx, getState());
  enterRule(_localctx, 754, SV3_1aParser::RuleInitial_construct);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6500);
    match(SV3_1aParser::INITIAL);
    setState(6501);
    statement_or_null();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Always_constructContext ------------------------------------------------------------------

SV3_1aParser::Always_constructContext::Always_constructContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::Always_keywordContext* SV3_1aParser::Always_constructContext::always_keyword() {
  return getRuleContext<SV3_1aParser::Always_keywordContext>(0);
}

SV3_1aParser::StatementContext* SV3_1aParser::Always_constructContext::statement() {
  return getRuleContext<SV3_1aParser::StatementContext>(0);
}


size_t SV3_1aParser::Always_constructContext::getRuleIndex() const {
  return SV3_1aParser::RuleAlways_construct;
}

void SV3_1aParser::Always_constructContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlways_construct(this);
}

void SV3_1aParser::Always_constructContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlways_construct(this);
}

SV3_1aParser::Always_constructContext* SV3_1aParser::always_construct() {
  Always_constructContext *_localctx = _tracker.createInstance<Always_constructContext>(_ctx, getState());
  enterRule(_localctx, 756, SV3_1aParser::RuleAlways_construct);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6503);
    always_keyword();
    setState(6504);
    statement();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Always_keywordContext ------------------------------------------------------------------

SV3_1aParser::Always_keywordContext::Always_keywordContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Always_keywordContext::ALWAYS() {
  return getToken(SV3_1aParser::ALWAYS, 0);
}

tree::TerminalNode* SV3_1aParser::Always_keywordContext::ALWAYS_COMB() {
  return getToken(SV3_1aParser::ALWAYS_COMB, 0);
}

tree::TerminalNode* SV3_1aParser::Always_keywordContext::ALWAYS_LATCH() {
  return getToken(SV3_1aParser::ALWAYS_LATCH, 0);
}

tree::TerminalNode* SV3_1aParser::Always_keywordContext::ALWAYS_FF() {
  return getToken(SV3_1aParser::ALWAYS_FF, 0);
}


size_t SV3_1aParser::Always_keywordContext::getRuleIndex() const {
  return SV3_1aParser::RuleAlways_keyword;
}

void SV3_1aParser::Always_keywordContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlways_keyword(this);
}

void SV3_1aParser::Always_keywordContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlways_keyword(this);
}

SV3_1aParser::Always_keywordContext* SV3_1aParser::always_keyword() {
  Always_keywordContext *_localctx = _tracker.createInstance<Always_keywordContext>(_ctx, getState());
  enterRule(_localctx, 758, SV3_1aParser::RuleAlways_keyword);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6506);
    _la = _input->LA(1);
    if (!(((((_la - 275) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 275)) & 15) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Blocking_assignmentContext ------------------------------------------------------------------

SV3_1aParser::Blocking_assignmentContext::Blocking_assignmentContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::Variable_lvalueContext* SV3_1aParser::Blocking_assignmentContext::variable_lvalue() {
  return getRuleContext<SV3_1aParser::Variable_lvalueContext>(0);
}

tree::TerminalNode* SV3_1aParser::Blocking_assignmentContext::ASSIGN_OP() {
  return getToken(SV3_1aParser::ASSIGN_OP, 0);
}

SV3_1aParser::Delay_or_event_controlContext* SV3_1aParser::Blocking_assignmentContext::delay_or_event_control() {
  return getRuleContext<SV3_1aParser::Delay_or_event_controlContext>(0);
}

SV3_1aParser::ExpressionContext* SV3_1aParser::Blocking_assignmentContext::expression() {
  return getRuleContext<SV3_1aParser::ExpressionContext>(0);
}

SV3_1aParser::Nonrange_variable_lvalueContext* SV3_1aParser::Blocking_assignmentContext::nonrange_variable_lvalue() {
  return getRuleContext<SV3_1aParser::Nonrange_variable_lvalueContext>(0);
}

SV3_1aParser::Dynamic_array_newContext* SV3_1aParser::Blocking_assignmentContext::dynamic_array_new() {
  return getRuleContext<SV3_1aParser::Dynamic_array_newContext>(0);
}

SV3_1aParser::SelectContext* SV3_1aParser::Blocking_assignmentContext::select() {
  return getRuleContext<SV3_1aParser::SelectContext>(0);
}

SV3_1aParser::Class_newContext* SV3_1aParser::Blocking_assignmentContext::class_new() {
  return getRuleContext<SV3_1aParser::Class_newContext>(0);
}

SV3_1aParser::IdentifierContext* SV3_1aParser::Blocking_assignmentContext::identifier() {
  return getRuleContext<SV3_1aParser::IdentifierContext>(0);
}

SV3_1aParser::Hierarchical_identifierContext* SV3_1aParser::Blocking_assignmentContext::hierarchical_identifier() {
  return getRuleContext<SV3_1aParser::Hierarchical_identifierContext>(0);
}

SV3_1aParser::Implicit_class_handleContext* SV3_1aParser::Blocking_assignmentContext::implicit_class_handle() {
  return getRuleContext<SV3_1aParser::Implicit_class_handleContext>(0);
}

tree::TerminalNode* SV3_1aParser::Blocking_assignmentContext::DOT() {
  return getToken(SV3_1aParser::DOT, 0);
}

SV3_1aParser::Class_scopeContext* SV3_1aParser::Blocking_assignmentContext::class_scope() {
  return getRuleContext<SV3_1aParser::Class_scopeContext>(0);
}

SV3_1aParser::Package_scopeContext* SV3_1aParser::Blocking_assignmentContext::package_scope() {
  return getRuleContext<SV3_1aParser::Package_scopeContext>(0);
}

SV3_1aParser::Operator_assignmentContext* SV3_1aParser::Blocking_assignmentContext::operator_assignment() {
  return getRuleContext<SV3_1aParser::Operator_assignmentContext>(0);
}


size_t SV3_1aParser::Blocking_assignmentContext::getRuleIndex() const {
  return SV3_1aParser::RuleBlocking_assignment;
}

void SV3_1aParser::Blocking_assignmentContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBlocking_assignment(this);
}

void SV3_1aParser::Blocking_assignmentContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBlocking_assignment(this);
}

SV3_1aParser::Blocking_assignmentContext* SV3_1aParser::blocking_assignment() {
  Blocking_assignmentContext *_localctx = _tracker.createInstance<Blocking_assignmentContext>(_ctx, getState());
  enterRule(_localctx, 760, SV3_1aParser::RuleBlocking_assignment);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(6533);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 746, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(6508);
      variable_lvalue();
      setState(6509);
      match(SV3_1aParser::ASSIGN_OP);
      setState(6510);
      delay_or_event_control();
      setState(6511);
      expression(0);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(6513);
      nonrange_variable_lvalue();
      setState(6514);
      match(SV3_1aParser::ASSIGN_OP);
      setState(6515);
      dynamic_array_new();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(6522);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 744, _ctx)) {
      case 1: {
        setState(6517);
        implicit_class_handle();
        setState(6518);
        match(SV3_1aParser::DOT);
        break;
      }

      case 2: {
        setState(6520);
        class_scope();
        break;
      }

      case 3: {
        setState(6521);
        package_scope();
        break;
      }

      default:
        break;
      }
      setState(6526);
      _errHandler->sync(this);
      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 745, _ctx)) {
      case 1: {
        setState(6524);
        identifier();
        break;
      }

      case 2: {
        setState(6525);
        hierarchical_identifier();
        break;
      }

      default:
        break;
      }
      setState(6528);
      select();
      setState(6529);
      match(SV3_1aParser::ASSIGN_OP);
      setState(6530);
      class_new();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(6532);
      operator_assignment();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Operator_assignmentContext ------------------------------------------------------------------

SV3_1aParser::Operator_assignmentContext::Operator_assignmentContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::Variable_lvalueContext* SV3_1aParser::Operator_assignmentContext::variable_lvalue() {
  return getRuleContext<SV3_1aParser::Variable_lvalueContext>(0);
}

SV3_1aParser::Assignment_operatorContext* SV3_1aParser::Operator_assignmentContext::assignment_operator() {
  return getRuleContext<SV3_1aParser::Assignment_operatorContext>(0);
}

SV3_1aParser::ExpressionContext* SV3_1aParser::Operator_assignmentContext::expression() {
  return getRuleContext<SV3_1aParser::ExpressionContext>(0);
}


size_t SV3_1aParser::Operator_assignmentContext::getRuleIndex() const {
  return SV3_1aParser::RuleOperator_assignment;
}

void SV3_1aParser::Operator_assignmentContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOperator_assignment(this);
}

void SV3_1aParser::Operator_assignmentContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOperator_assignment(this);
}

SV3_1aParser::Operator_assignmentContext* SV3_1aParser::operator_assignment() {
  Operator_assignmentContext *_localctx = _tracker.createInstance<Operator_assignmentContext>(_ctx, getState());
  enterRule(_localctx, 762, SV3_1aParser::RuleOperator_assignment);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6535);
    variable_lvalue();
    setState(6536);
    assignment_operator();
    setState(6537);
    expression(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Assignment_operatorContext ------------------------------------------------------------------

SV3_1aParser::Assignment_operatorContext::Assignment_operatorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Assignment_operatorContext::ASSIGN_OP() {
  return getToken(SV3_1aParser::ASSIGN_OP, 0);
}

tree::TerminalNode* SV3_1aParser::Assignment_operatorContext::ADD_ASSIGN() {
  return getToken(SV3_1aParser::ADD_ASSIGN, 0);
}

tree::TerminalNode* SV3_1aParser::Assignment_operatorContext::SUB_ASSIGN() {
  return getToken(SV3_1aParser::SUB_ASSIGN, 0);
}

tree::TerminalNode* SV3_1aParser::Assignment_operatorContext::MULT_ASSIGN() {
  return getToken(SV3_1aParser::MULT_ASSIGN, 0);
}

tree::TerminalNode* SV3_1aParser::Assignment_operatorContext::DIV_ASSIGN() {
  return getToken(SV3_1aParser::DIV_ASSIGN, 0);
}

tree::TerminalNode* SV3_1aParser::Assignment_operatorContext::MODULO_ASSIGN() {
  return getToken(SV3_1aParser::MODULO_ASSIGN, 0);
}

tree::TerminalNode* SV3_1aParser::Assignment_operatorContext::BITW_AND_ASSIGN() {
  return getToken(SV3_1aParser::BITW_AND_ASSIGN, 0);
}

tree::TerminalNode* SV3_1aParser::Assignment_operatorContext::BITW_OR_ASSIGN() {
  return getToken(SV3_1aParser::BITW_OR_ASSIGN, 0);
}

tree::TerminalNode* SV3_1aParser::Assignment_operatorContext::BITW_XOR_ASSIGN() {
  return getToken(SV3_1aParser::BITW_XOR_ASSIGN, 0);
}

tree::TerminalNode* SV3_1aParser::Assignment_operatorContext::BITW_LEFT_SHIFT_ASSIGN() {
  return getToken(SV3_1aParser::BITW_LEFT_SHIFT_ASSIGN, 0);
}

tree::TerminalNode* SV3_1aParser::Assignment_operatorContext::BITW_RIGHT_SHIFT_ASSIGN() {
  return getToken(SV3_1aParser::BITW_RIGHT_SHIFT_ASSIGN, 0);
}

tree::TerminalNode* SV3_1aParser::Assignment_operatorContext::ARITH_SHIFT_LEFT_ASSIGN() {
  return getToken(SV3_1aParser::ARITH_SHIFT_LEFT_ASSIGN, 0);
}

tree::TerminalNode* SV3_1aParser::Assignment_operatorContext::ARITH_SHIFT_RIGHT_ASSIGN() {
  return getToken(SV3_1aParser::ARITH_SHIFT_RIGHT_ASSIGN, 0);
}


size_t SV3_1aParser::Assignment_operatorContext::getRuleIndex() const {
  return SV3_1aParser::RuleAssignment_operator;
}

void SV3_1aParser::Assignment_operatorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAssignment_operator(this);
}

void SV3_1aParser::Assignment_operatorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAssignment_operator(this);
}

SV3_1aParser::Assignment_operatorContext* SV3_1aParser::assignment_operator() {
  Assignment_operatorContext *_localctx = _tracker.createInstance<Assignment_operatorContext>(_ctx, getState());
  enterRule(_localctx, 764, SV3_1aParser::RuleAssignment_operator);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6539);
    _la = _input->LA(1);
    if (!(((((_la - 279) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 279)) & 1023) != 0) || ((((_la - 347) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 347)) & 32771) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Nonblocking_assignmentContext ------------------------------------------------------------------

SV3_1aParser::Nonblocking_assignmentContext::Nonblocking_assignmentContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::Variable_lvalueContext* SV3_1aParser::Nonblocking_assignmentContext::variable_lvalue() {
  return getRuleContext<SV3_1aParser::Variable_lvalueContext>(0);
}

tree::TerminalNode* SV3_1aParser::Nonblocking_assignmentContext::LESS_EQUAL() {
  return getToken(SV3_1aParser::LESS_EQUAL, 0);
}

SV3_1aParser::ExpressionContext* SV3_1aParser::Nonblocking_assignmentContext::expression() {
  return getRuleContext<SV3_1aParser::ExpressionContext>(0);
}

SV3_1aParser::Delay_or_event_controlContext* SV3_1aParser::Nonblocking_assignmentContext::delay_or_event_control() {
  return getRuleContext<SV3_1aParser::Delay_or_event_controlContext>(0);
}


size_t SV3_1aParser::Nonblocking_assignmentContext::getRuleIndex() const {
  return SV3_1aParser::RuleNonblocking_assignment;
}

void SV3_1aParser::Nonblocking_assignmentContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNonblocking_assignment(this);
}

void SV3_1aParser::Nonblocking_assignmentContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNonblocking_assignment(this);
}

SV3_1aParser::Nonblocking_assignmentContext* SV3_1aParser::nonblocking_assignment() {
  Nonblocking_assignmentContext *_localctx = _tracker.createInstance<Nonblocking_assignmentContext>(_ctx, getState());
  enterRule(_localctx, 766, SV3_1aParser::RuleNonblocking_assignment);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6541);
    variable_lvalue();
    setState(6542);
    match(SV3_1aParser::LESS_EQUAL);
    setState(6544);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 50528256) != 0) || _la == SV3_1aParser::POUND || _la == SV3_1aParser::REPEAT

    || _la == SV3_1aParser::AT) {
      setState(6543);
      delay_or_event_control();
    }
    setState(6546);
    expression(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Procedural_continuous_assignmentContext ------------------------------------------------------------------

SV3_1aParser::Procedural_continuous_assignmentContext::Procedural_continuous_assignmentContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Procedural_continuous_assignmentContext::ASSIGN() {
  return getToken(SV3_1aParser::ASSIGN, 0);
}

SV3_1aParser::Variable_assignmentContext* SV3_1aParser::Procedural_continuous_assignmentContext::variable_assignment() {
  return getRuleContext<SV3_1aParser::Variable_assignmentContext>(0);
}

tree::TerminalNode* SV3_1aParser::Procedural_continuous_assignmentContext::DEASSIGN() {
  return getToken(SV3_1aParser::DEASSIGN, 0);
}

SV3_1aParser::Variable_lvalueContext* SV3_1aParser::Procedural_continuous_assignmentContext::variable_lvalue() {
  return getRuleContext<SV3_1aParser::Variable_lvalueContext>(0);
}

tree::TerminalNode* SV3_1aParser::Procedural_continuous_assignmentContext::FORCE() {
  return getToken(SV3_1aParser::FORCE, 0);
}

SV3_1aParser::Net_assignmentContext* SV3_1aParser::Procedural_continuous_assignmentContext::net_assignment() {
  return getRuleContext<SV3_1aParser::Net_assignmentContext>(0);
}

tree::TerminalNode* SV3_1aParser::Procedural_continuous_assignmentContext::RELEASE() {
  return getToken(SV3_1aParser::RELEASE, 0);
}

SV3_1aParser::Net_lvalueContext* SV3_1aParser::Procedural_continuous_assignmentContext::net_lvalue() {
  return getRuleContext<SV3_1aParser::Net_lvalueContext>(0);
}


size_t SV3_1aParser::Procedural_continuous_assignmentContext::getRuleIndex() const {
  return SV3_1aParser::RuleProcedural_continuous_assignment;
}

void SV3_1aParser::Procedural_continuous_assignmentContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterProcedural_continuous_assignment(this);
}

void SV3_1aParser::Procedural_continuous_assignmentContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitProcedural_continuous_assignment(this);
}

SV3_1aParser::Procedural_continuous_assignmentContext* SV3_1aParser::procedural_continuous_assignment() {
  Procedural_continuous_assignmentContext *_localctx = _tracker.createInstance<Procedural_continuous_assignmentContext>(_ctx, getState());
  enterRule(_localctx, 768, SV3_1aParser::RuleProcedural_continuous_assignment);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(6562);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SV3_1aParser::ASSIGN: {
        enterOuterAlt(_localctx, 1);
        setState(6548);
        match(SV3_1aParser::ASSIGN);
        setState(6549);
        variable_assignment();
        break;
      }

      case SV3_1aParser::DEASSIGN: {
        enterOuterAlt(_localctx, 2);
        setState(6550);
        match(SV3_1aParser::DEASSIGN);
        setState(6551);
        variable_lvalue();
        break;
      }

      case SV3_1aParser::FORCE: {
        enterOuterAlt(_localctx, 3);
        setState(6552);
        match(SV3_1aParser::FORCE);
        setState(6555);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 748, _ctx)) {
        case 1: {
          setState(6553);
          variable_assignment();
          break;
        }

        case 2: {
          setState(6554);
          net_assignment();
          break;
        }

        default:
          break;
        }
        break;
      }

      case SV3_1aParser::RELEASE: {
        enterOuterAlt(_localctx, 4);
        setState(6557);
        match(SV3_1aParser::RELEASE);
        setState(6560);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 749, _ctx)) {
        case 1: {
          setState(6558);
          variable_lvalue();
          break;
        }

        case 2: {
          setState(6559);
          net_lvalue();
          break;
        }

        default:
          break;
        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Variable_assignmentContext ------------------------------------------------------------------

SV3_1aParser::Variable_assignmentContext::Variable_assignmentContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::Variable_lvalueContext* SV3_1aParser::Variable_assignmentContext::variable_lvalue() {
  return getRuleContext<SV3_1aParser::Variable_lvalueContext>(0);
}

tree::TerminalNode* SV3_1aParser::Variable_assignmentContext::ASSIGN_OP() {
  return getToken(SV3_1aParser::ASSIGN_OP, 0);
}

SV3_1aParser::ExpressionContext* SV3_1aParser::Variable_assignmentContext::expression() {
  return getRuleContext<SV3_1aParser::ExpressionContext>(0);
}


size_t SV3_1aParser::Variable_assignmentContext::getRuleIndex() const {
  return SV3_1aParser::RuleVariable_assignment;
}

void SV3_1aParser::Variable_assignmentContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterVariable_assignment(this);
}

void SV3_1aParser::Variable_assignmentContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitVariable_assignment(this);
}

SV3_1aParser::Variable_assignmentContext* SV3_1aParser::variable_assignment() {
  Variable_assignmentContext *_localctx = _tracker.createInstance<Variable_assignmentContext>(_ctx, getState());
  enterRule(_localctx, 770, SV3_1aParser::RuleVariable_assignment);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6564);
    variable_lvalue();
    setState(6565);
    match(SV3_1aParser::ASSIGN_OP);
    setState(6566);
    expression(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Action_blockContext ------------------------------------------------------------------

SV3_1aParser::Action_blockContext::Action_blockContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::Statement_or_nullContext* SV3_1aParser::Action_blockContext::statement_or_null() {
  return getRuleContext<SV3_1aParser::Statement_or_nullContext>(0);
}

tree::TerminalNode* SV3_1aParser::Action_blockContext::ELSE() {
  return getToken(SV3_1aParser::ELSE, 0);
}

SV3_1aParser::StatementContext* SV3_1aParser::Action_blockContext::statement() {
  return getRuleContext<SV3_1aParser::StatementContext>(0);
}


size_t SV3_1aParser::Action_blockContext::getRuleIndex() const {
  return SV3_1aParser::RuleAction_block;
}

void SV3_1aParser::Action_blockContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAction_block(this);
}

void SV3_1aParser::Action_blockContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAction_block(this);
}

SV3_1aParser::Action_blockContext* SV3_1aParser::action_block() {
  Action_blockContext *_localctx = _tracker.createInstance<Action_blockContext>(_ctx, getState());
  enterRule(_localctx, 772, SV3_1aParser::RuleAction_block);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(6574);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 752, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(6568);
      statement_or_null();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(6570);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if ((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & 50528256) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 64)) & 17732923904262145) != 0) || ((((_la - 151) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 151)) & 5188249437639573505) != 0) || ((((_la - 223) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 223)) & 1136895023120385) != 0) || ((((_la - 289) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 289)) & 45036959082348431) != 0) || ((((_la - 364) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 364)) & 8796093022225) != 0)) {
        setState(6569);
        statement();
      }
      setState(6572);
      match(SV3_1aParser::ELSE);
      setState(6573);
      statement_or_null();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Seq_blockContext ------------------------------------------------------------------

SV3_1aParser::Seq_blockContext::Seq_blockContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Seq_blockContext::BEGIN() {
  return getToken(SV3_1aParser::BEGIN, 0);
}

tree::TerminalNode* SV3_1aParser::Seq_blockContext::END() {
  return getToken(SV3_1aParser::END, 0);
}

std::vector<tree::TerminalNode *> SV3_1aParser::Seq_blockContext::COLON() {
  return getTokens(SV3_1aParser::COLON);
}

tree::TerminalNode* SV3_1aParser::Seq_blockContext::COLON(size_t i) {
  return getToken(SV3_1aParser::COLON, i);
}

std::vector<SV3_1aParser::IdentifierContext *> SV3_1aParser::Seq_blockContext::identifier() {
  return getRuleContexts<SV3_1aParser::IdentifierContext>();
}

SV3_1aParser::IdentifierContext* SV3_1aParser::Seq_blockContext::identifier(size_t i) {
  return getRuleContext<SV3_1aParser::IdentifierContext>(i);
}

std::vector<SV3_1aParser::Block_item_declarationContext *> SV3_1aParser::Seq_blockContext::block_item_declaration() {
  return getRuleContexts<SV3_1aParser::Block_item_declarationContext>();
}

SV3_1aParser::Block_item_declarationContext* SV3_1aParser::Seq_blockContext::block_item_declaration(size_t i) {
  return getRuleContext<SV3_1aParser::Block_item_declarationContext>(i);
}

std::vector<SV3_1aParser::Statement_or_nullContext *> SV3_1aParser::Seq_blockContext::statement_or_null() {
  return getRuleContexts<SV3_1aParser::Statement_or_nullContext>();
}

SV3_1aParser::Statement_or_nullContext* SV3_1aParser::Seq_blockContext::statement_or_null(size_t i) {
  return getRuleContext<SV3_1aParser::Statement_or_nullContext>(i);
}


size_t SV3_1aParser::Seq_blockContext::getRuleIndex() const {
  return SV3_1aParser::RuleSeq_block;
}

void SV3_1aParser::Seq_blockContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSeq_block(this);
}

void SV3_1aParser::Seq_blockContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSeq_block(this);
}

SV3_1aParser::Seq_blockContext* SV3_1aParser::seq_block() {
  Seq_blockContext *_localctx = _tracker.createInstance<Seq_blockContext>(_ctx, getState());
  enterRule(_localctx, 774, SV3_1aParser::RuleSeq_block);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(6576);
    match(SV3_1aParser::BEGIN);
    setState(6579);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SV3_1aParser::COLON) {
      setState(6577);
      match(SV3_1aParser::COLON);
      setState(6578);
      identifier();
    }
    setState(6584);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 754, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(6581);
        block_item_declaration(); 
      }
      setState(6586);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 754, _ctx);
    }
    setState(6590);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 2198011904) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 64)) & 17732923904262145) != 0) || ((((_la - 151) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 151)) & 5188249437639573505) != 0) || ((((_la - 223) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 223)) & 1136895023120385) != 0) || ((((_la - 289) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 289)) & 45036959082348431) != 0) || ((((_la - 364) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 364)) & 8796093022225) != 0)) {
      setState(6587);
      statement_or_null();
      setState(6592);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(6593);
    match(SV3_1aParser::END);
    setState(6596);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 756, _ctx)) {
    case 1: {
      setState(6594);
      match(SV3_1aParser::COLON);
      setState(6595);
      identifier();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Par_blockContext ------------------------------------------------------------------

SV3_1aParser::Par_blockContext::Par_blockContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Par_blockContext::FORK() {
  return getToken(SV3_1aParser::FORK, 0);
}

SV3_1aParser::Join_keywordContext* SV3_1aParser::Par_blockContext::join_keyword() {
  return getRuleContext<SV3_1aParser::Join_keywordContext>(0);
}

SV3_1aParser::Join_any_keywordContext* SV3_1aParser::Par_blockContext::join_any_keyword() {
  return getRuleContext<SV3_1aParser::Join_any_keywordContext>(0);
}

SV3_1aParser::Join_none_keywordContext* SV3_1aParser::Par_blockContext::join_none_keyword() {
  return getRuleContext<SV3_1aParser::Join_none_keywordContext>(0);
}

std::vector<tree::TerminalNode *> SV3_1aParser::Par_blockContext::COLON() {
  return getTokens(SV3_1aParser::COLON);
}

tree::TerminalNode* SV3_1aParser::Par_blockContext::COLON(size_t i) {
  return getToken(SV3_1aParser::COLON, i);
}

std::vector<SV3_1aParser::IdentifierContext *> SV3_1aParser::Par_blockContext::identifier() {
  return getRuleContexts<SV3_1aParser::IdentifierContext>();
}

SV3_1aParser::IdentifierContext* SV3_1aParser::Par_blockContext::identifier(size_t i) {
  return getRuleContext<SV3_1aParser::IdentifierContext>(i);
}

std::vector<SV3_1aParser::Block_item_declarationContext *> SV3_1aParser::Par_blockContext::block_item_declaration() {
  return getRuleContexts<SV3_1aParser::Block_item_declarationContext>();
}

SV3_1aParser::Block_item_declarationContext* SV3_1aParser::Par_blockContext::block_item_declaration(size_t i) {
  return getRuleContext<SV3_1aParser::Block_item_declarationContext>(i);
}

std::vector<SV3_1aParser::Statement_or_nullContext *> SV3_1aParser::Par_blockContext::statement_or_null() {
  return getRuleContexts<SV3_1aParser::Statement_or_nullContext>();
}

SV3_1aParser::Statement_or_nullContext* SV3_1aParser::Par_blockContext::statement_or_null(size_t i) {
  return getRuleContext<SV3_1aParser::Statement_or_nullContext>(i);
}


size_t SV3_1aParser::Par_blockContext::getRuleIndex() const {
  return SV3_1aParser::RulePar_block;
}

void SV3_1aParser::Par_blockContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPar_block(this);
}

void SV3_1aParser::Par_blockContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPar_block(this);
}

SV3_1aParser::Par_blockContext* SV3_1aParser::par_block() {
  Par_blockContext *_localctx = _tracker.createInstance<Par_blockContext>(_ctx, getState());
  enterRule(_localctx, 776, SV3_1aParser::RulePar_block);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(6598);
    match(SV3_1aParser::FORK);
    setState(6601);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SV3_1aParser::COLON) {
      setState(6599);
      match(SV3_1aParser::COLON);
      setState(6600);
      identifier();
    }
    setState(6606);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 758, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(6603);
        block_item_declaration(); 
      }
      setState(6608);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 758, _ctx);
    }
    setState(6612);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 2198011904) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 64)) & 17732923904262145) != 0) || ((((_la - 151) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 151)) & 5188249437639573505) != 0) || ((((_la - 223) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 223)) & 1136895023120385) != 0) || ((((_la - 289) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 289)) & 45036959082348431) != 0) || ((((_la - 364) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 364)) & 8796093022225) != 0)) {
      setState(6609);
      statement_or_null();
      setState(6614);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(6618);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SV3_1aParser::JOIN: {
        setState(6615);
        join_keyword();
        break;
      }

      case SV3_1aParser::JOIN_ANY: {
        setState(6616);
        join_any_keyword();
        break;
      }

      case SV3_1aParser::JOIN_NONE: {
        setState(6617);
        join_none_keyword();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
    setState(6622);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 761, _ctx)) {
    case 1: {
      setState(6620);
      match(SV3_1aParser::COLON);
      setState(6621);
      identifier();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Join_keywordContext ------------------------------------------------------------------

SV3_1aParser::Join_keywordContext::Join_keywordContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Join_keywordContext::JOIN() {
  return getToken(SV3_1aParser::JOIN, 0);
}


size_t SV3_1aParser::Join_keywordContext::getRuleIndex() const {
  return SV3_1aParser::RuleJoin_keyword;
}

void SV3_1aParser::Join_keywordContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterJoin_keyword(this);
}

void SV3_1aParser::Join_keywordContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitJoin_keyword(this);
}

SV3_1aParser::Join_keywordContext* SV3_1aParser::join_keyword() {
  Join_keywordContext *_localctx = _tracker.createInstance<Join_keywordContext>(_ctx, getState());
  enterRule(_localctx, 778, SV3_1aParser::RuleJoin_keyword);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6624);
    match(SV3_1aParser::JOIN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Join_any_keywordContext ------------------------------------------------------------------

SV3_1aParser::Join_any_keywordContext::Join_any_keywordContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Join_any_keywordContext::JOIN_ANY() {
  return getToken(SV3_1aParser::JOIN_ANY, 0);
}


size_t SV3_1aParser::Join_any_keywordContext::getRuleIndex() const {
  return SV3_1aParser::RuleJoin_any_keyword;
}

void SV3_1aParser::Join_any_keywordContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterJoin_any_keyword(this);
}

void SV3_1aParser::Join_any_keywordContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitJoin_any_keyword(this);
}

SV3_1aParser::Join_any_keywordContext* SV3_1aParser::join_any_keyword() {
  Join_any_keywordContext *_localctx = _tracker.createInstance<Join_any_keywordContext>(_ctx, getState());
  enterRule(_localctx, 780, SV3_1aParser::RuleJoin_any_keyword);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6626);
    match(SV3_1aParser::JOIN_ANY);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Join_none_keywordContext ------------------------------------------------------------------

SV3_1aParser::Join_none_keywordContext::Join_none_keywordContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Join_none_keywordContext::JOIN_NONE() {
  return getToken(SV3_1aParser::JOIN_NONE, 0);
}


size_t SV3_1aParser::Join_none_keywordContext::getRuleIndex() const {
  return SV3_1aParser::RuleJoin_none_keyword;
}

void SV3_1aParser::Join_none_keywordContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterJoin_none_keyword(this);
}

void SV3_1aParser::Join_none_keywordContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitJoin_none_keyword(this);
}

SV3_1aParser::Join_none_keywordContext* SV3_1aParser::join_none_keyword() {
  Join_none_keywordContext *_localctx = _tracker.createInstance<Join_none_keywordContext>(_ctx, getState());
  enterRule(_localctx, 782, SV3_1aParser::RuleJoin_none_keyword);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6628);
    match(SV3_1aParser::JOIN_NONE);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Statement_or_nullContext ------------------------------------------------------------------

SV3_1aParser::Statement_or_nullContext::Statement_or_nullContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::StatementContext* SV3_1aParser::Statement_or_nullContext::statement() {
  return getRuleContext<SV3_1aParser::StatementContext>(0);
}

tree::TerminalNode* SV3_1aParser::Statement_or_nullContext::SEMICOLON() {
  return getToken(SV3_1aParser::SEMICOLON, 0);
}

std::vector<SV3_1aParser::Attribute_instanceContext *> SV3_1aParser::Statement_or_nullContext::attribute_instance() {
  return getRuleContexts<SV3_1aParser::Attribute_instanceContext>();
}

SV3_1aParser::Attribute_instanceContext* SV3_1aParser::Statement_or_nullContext::attribute_instance(size_t i) {
  return getRuleContext<SV3_1aParser::Attribute_instanceContext>(i);
}


size_t SV3_1aParser::Statement_or_nullContext::getRuleIndex() const {
  return SV3_1aParser::RuleStatement_or_null;
}

void SV3_1aParser::Statement_or_nullContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterStatement_or_null(this);
}

void SV3_1aParser::Statement_or_nullContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitStatement_or_null(this);
}

SV3_1aParser::Statement_or_nullContext* SV3_1aParser::statement_or_null() {
  Statement_or_nullContext *_localctx = _tracker.createInstance<Statement_or_nullContext>(_ctx, getState());
  enterRule(_localctx, 784, SV3_1aParser::RuleStatement_or_null);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(6638);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 763, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(6630);
      statement();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(6634);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == SV3_1aParser::OPEN_PARENS_STAR) {
        setState(6631);
        attribute_instance();
        setState(6636);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(6637);
      match(SV3_1aParser::SEMICOLON);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- StatementContext ------------------------------------------------------------------

SV3_1aParser::StatementContext::StatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::Statement_itemContext* SV3_1aParser::StatementContext::statement_item() {
  return getRuleContext<SV3_1aParser::Statement_itemContext>(0);
}

SV3_1aParser::IdentifierContext* SV3_1aParser::StatementContext::identifier() {
  return getRuleContext<SV3_1aParser::IdentifierContext>(0);
}

tree::TerminalNode* SV3_1aParser::StatementContext::COLON() {
  return getToken(SV3_1aParser::COLON, 0);
}

std::vector<SV3_1aParser::Attribute_instanceContext *> SV3_1aParser::StatementContext::attribute_instance() {
  return getRuleContexts<SV3_1aParser::Attribute_instanceContext>();
}

SV3_1aParser::Attribute_instanceContext* SV3_1aParser::StatementContext::attribute_instance(size_t i) {
  return getRuleContext<SV3_1aParser::Attribute_instanceContext>(i);
}


size_t SV3_1aParser::StatementContext::getRuleIndex() const {
  return SV3_1aParser::RuleStatement;
}

void SV3_1aParser::StatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterStatement(this);
}

void SV3_1aParser::StatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitStatement(this);
}

SV3_1aParser::StatementContext* SV3_1aParser::statement() {
  StatementContext *_localctx = _tracker.createInstance<StatementContext>(_ctx, getState());
  enterRule(_localctx, 786, SV3_1aParser::RuleStatement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6643);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 764, _ctx)) {
    case 1: {
      setState(6640);
      identifier();
      setState(6641);
      match(SV3_1aParser::COLON);
      break;
    }

    default:
      break;
    }
    setState(6648);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == SV3_1aParser::OPEN_PARENS_STAR) {
      setState(6645);
      attribute_instance();
      setState(6650);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(6651);
    statement_item();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Statement_itemContext ------------------------------------------------------------------

SV3_1aParser::Statement_itemContext::Statement_itemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::Blocking_assignmentContext* SV3_1aParser::Statement_itemContext::blocking_assignment() {
  return getRuleContext<SV3_1aParser::Blocking_assignmentContext>(0);
}

tree::TerminalNode* SV3_1aParser::Statement_itemContext::SEMICOLON() {
  return getToken(SV3_1aParser::SEMICOLON, 0);
}

SV3_1aParser::Nonblocking_assignmentContext* SV3_1aParser::Statement_itemContext::nonblocking_assignment() {
  return getRuleContext<SV3_1aParser::Nonblocking_assignmentContext>(0);
}

SV3_1aParser::Procedural_continuous_assignmentContext* SV3_1aParser::Statement_itemContext::procedural_continuous_assignment() {
  return getRuleContext<SV3_1aParser::Procedural_continuous_assignmentContext>(0);
}

SV3_1aParser::Case_statementContext* SV3_1aParser::Statement_itemContext::case_statement() {
  return getRuleContext<SV3_1aParser::Case_statementContext>(0);
}

SV3_1aParser::Conditional_statementContext* SV3_1aParser::Statement_itemContext::conditional_statement() {
  return getRuleContext<SV3_1aParser::Conditional_statementContext>(0);
}

SV3_1aParser::Inc_or_dec_expressionContext* SV3_1aParser::Statement_itemContext::inc_or_dec_expression() {
  return getRuleContext<SV3_1aParser::Inc_or_dec_expressionContext>(0);
}

SV3_1aParser::Subroutine_call_statementContext* SV3_1aParser::Statement_itemContext::subroutine_call_statement() {
  return getRuleContext<SV3_1aParser::Subroutine_call_statementContext>(0);
}

SV3_1aParser::Disable_statementContext* SV3_1aParser::Statement_itemContext::disable_statement() {
  return getRuleContext<SV3_1aParser::Disable_statementContext>(0);
}

SV3_1aParser::Event_triggerContext* SV3_1aParser::Statement_itemContext::event_trigger() {
  return getRuleContext<SV3_1aParser::Event_triggerContext>(0);
}

SV3_1aParser::Loop_statementContext* SV3_1aParser::Statement_itemContext::loop_statement() {
  return getRuleContext<SV3_1aParser::Loop_statementContext>(0);
}

SV3_1aParser::Jump_statementContext* SV3_1aParser::Statement_itemContext::jump_statement() {
  return getRuleContext<SV3_1aParser::Jump_statementContext>(0);
}

SV3_1aParser::Par_blockContext* SV3_1aParser::Statement_itemContext::par_block() {
  return getRuleContext<SV3_1aParser::Par_blockContext>(0);
}

SV3_1aParser::Procedural_timing_control_statementContext* SV3_1aParser::Statement_itemContext::procedural_timing_control_statement() {
  return getRuleContext<SV3_1aParser::Procedural_timing_control_statementContext>(0);
}

SV3_1aParser::Seq_blockContext* SV3_1aParser::Statement_itemContext::seq_block() {
  return getRuleContext<SV3_1aParser::Seq_blockContext>(0);
}

SV3_1aParser::Wait_statementContext* SV3_1aParser::Statement_itemContext::wait_statement() {
  return getRuleContext<SV3_1aParser::Wait_statementContext>(0);
}

SV3_1aParser::Procedural_assertion_statementContext* SV3_1aParser::Statement_itemContext::procedural_assertion_statement() {
  return getRuleContext<SV3_1aParser::Procedural_assertion_statementContext>(0);
}

SV3_1aParser::Randsequence_statementContext* SV3_1aParser::Statement_itemContext::randsequence_statement() {
  return getRuleContext<SV3_1aParser::Randsequence_statementContext>(0);
}

SV3_1aParser::Randcase_statementContext* SV3_1aParser::Statement_itemContext::randcase_statement() {
  return getRuleContext<SV3_1aParser::Randcase_statementContext>(0);
}

SV3_1aParser::Expect_property_statementContext* SV3_1aParser::Statement_itemContext::expect_property_statement() {
  return getRuleContext<SV3_1aParser::Expect_property_statementContext>(0);
}

SV3_1aParser::System_taskContext* SV3_1aParser::Statement_itemContext::system_task() {
  return getRuleContext<SV3_1aParser::System_taskContext>(0);
}

SV3_1aParser::Surelog_macro_not_definedContext* SV3_1aParser::Statement_itemContext::surelog_macro_not_defined() {
  return getRuleContext<SV3_1aParser::Surelog_macro_not_definedContext>(0);
}


size_t SV3_1aParser::Statement_itemContext::getRuleIndex() const {
  return SV3_1aParser::RuleStatement_item;
}

void SV3_1aParser::Statement_itemContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterStatement_item(this);
}

void SV3_1aParser::Statement_itemContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitStatement_item(this);
}

SV3_1aParser::Statement_itemContext* SV3_1aParser::statement_item() {
  Statement_itemContext *_localctx = _tracker.createInstance<Statement_itemContext>(_ctx, getState());
  enterRule(_localctx, 788, SV3_1aParser::RuleStatement_item);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(6684);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 766, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(6653);
      blocking_assignment();
      setState(6654);
      match(SV3_1aParser::SEMICOLON);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(6656);
      nonblocking_assignment();
      setState(6657);
      match(SV3_1aParser::SEMICOLON);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(6659);
      procedural_continuous_assignment();
      setState(6660);
      match(SV3_1aParser::SEMICOLON);
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(6662);
      case_statement();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(6663);
      conditional_statement();
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(6664);
      inc_or_dec_expression();
      setState(6665);
      match(SV3_1aParser::SEMICOLON);
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(6667);
      subroutine_call_statement();
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(6668);
      disable_statement();
      break;
    }

    case 9: {
      enterOuterAlt(_localctx, 9);
      setState(6669);
      event_trigger();
      break;
    }

    case 10: {
      enterOuterAlt(_localctx, 10);
      setState(6670);
      loop_statement();
      break;
    }

    case 11: {
      enterOuterAlt(_localctx, 11);
      setState(6671);
      jump_statement();
      break;
    }

    case 12: {
      enterOuterAlt(_localctx, 12);
      setState(6672);
      par_block();
      break;
    }

    case 13: {
      enterOuterAlt(_localctx, 13);
      setState(6673);
      procedural_timing_control_statement();
      break;
    }

    case 14: {
      enterOuterAlt(_localctx, 14);
      setState(6674);
      seq_block();
      break;
    }

    case 15: {
      enterOuterAlt(_localctx, 15);
      setState(6675);
      wait_statement();
      break;
    }

    case 16: {
      enterOuterAlt(_localctx, 16);
      setState(6676);
      procedural_assertion_statement();
      break;
    }

    case 17: {
      enterOuterAlt(_localctx, 17);
      setState(6677);
      randsequence_statement();
      break;
    }

    case 18: {
      enterOuterAlt(_localctx, 18);
      setState(6678);
      randcase_statement();
      break;
    }

    case 19: {
      enterOuterAlt(_localctx, 19);
      setState(6679);
      expect_property_statement();
      break;
    }

    case 20: {
      enterOuterAlt(_localctx, 20);
      setState(6680);
      system_task();
      setState(6681);
      match(SV3_1aParser::SEMICOLON);
      break;
    }

    case 21: {
      enterOuterAlt(_localctx, 21);
      setState(6683);
      surelog_macro_not_defined();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Function_statement_or_nullContext ------------------------------------------------------------------

SV3_1aParser::Function_statement_or_nullContext::Function_statement_or_nullContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::StatementContext* SV3_1aParser::Function_statement_or_nullContext::statement() {
  return getRuleContext<SV3_1aParser::StatementContext>(0);
}

tree::TerminalNode* SV3_1aParser::Function_statement_or_nullContext::SEMICOLON() {
  return getToken(SV3_1aParser::SEMICOLON, 0);
}

std::vector<SV3_1aParser::Attribute_instanceContext *> SV3_1aParser::Function_statement_or_nullContext::attribute_instance() {
  return getRuleContexts<SV3_1aParser::Attribute_instanceContext>();
}

SV3_1aParser::Attribute_instanceContext* SV3_1aParser::Function_statement_or_nullContext::attribute_instance(size_t i) {
  return getRuleContext<SV3_1aParser::Attribute_instanceContext>(i);
}


size_t SV3_1aParser::Function_statement_or_nullContext::getRuleIndex() const {
  return SV3_1aParser::RuleFunction_statement_or_null;
}

void SV3_1aParser::Function_statement_or_nullContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFunction_statement_or_null(this);
}

void SV3_1aParser::Function_statement_or_nullContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFunction_statement_or_null(this);
}

SV3_1aParser::Function_statement_or_nullContext* SV3_1aParser::function_statement_or_null() {
  Function_statement_or_nullContext *_localctx = _tracker.createInstance<Function_statement_or_nullContext>(_ctx, getState());
  enterRule(_localctx, 790, SV3_1aParser::RuleFunction_statement_or_null);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(6694);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 768, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(6686);
      statement();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(6690);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == SV3_1aParser::OPEN_PARENS_STAR) {
        setState(6687);
        attribute_instance();
        setState(6692);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(6693);
      match(SV3_1aParser::SEMICOLON);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Procedural_timing_control_statementContext ------------------------------------------------------------------

SV3_1aParser::Procedural_timing_control_statementContext::Procedural_timing_control_statementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::Procedural_timing_controlContext* SV3_1aParser::Procedural_timing_control_statementContext::procedural_timing_control() {
  return getRuleContext<SV3_1aParser::Procedural_timing_controlContext>(0);
}

SV3_1aParser::Statement_or_nullContext* SV3_1aParser::Procedural_timing_control_statementContext::statement_or_null() {
  return getRuleContext<SV3_1aParser::Statement_or_nullContext>(0);
}


size_t SV3_1aParser::Procedural_timing_control_statementContext::getRuleIndex() const {
  return SV3_1aParser::RuleProcedural_timing_control_statement;
}

void SV3_1aParser::Procedural_timing_control_statementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterProcedural_timing_control_statement(this);
}

void SV3_1aParser::Procedural_timing_control_statementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitProcedural_timing_control_statement(this);
}

SV3_1aParser::Procedural_timing_control_statementContext* SV3_1aParser::procedural_timing_control_statement() {
  Procedural_timing_control_statementContext *_localctx = _tracker.createInstance<Procedural_timing_control_statementContext>(_ctx, getState());
  enterRule(_localctx, 792, SV3_1aParser::RuleProcedural_timing_control_statement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6696);
    procedural_timing_control();
    setState(6697);
    statement_or_null();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Delay_or_event_controlContext ------------------------------------------------------------------

SV3_1aParser::Delay_or_event_controlContext::Delay_or_event_controlContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::Delay_controlContext* SV3_1aParser::Delay_or_event_controlContext::delay_control() {
  return getRuleContext<SV3_1aParser::Delay_controlContext>(0);
}

SV3_1aParser::Event_controlContext* SV3_1aParser::Delay_or_event_controlContext::event_control() {
  return getRuleContext<SV3_1aParser::Event_controlContext>(0);
}

tree::TerminalNode* SV3_1aParser::Delay_or_event_controlContext::REPEAT() {
  return getToken(SV3_1aParser::REPEAT, 0);
}

tree::TerminalNode* SV3_1aParser::Delay_or_event_controlContext::OPEN_PARENS() {
  return getToken(SV3_1aParser::OPEN_PARENS, 0);
}

SV3_1aParser::ExpressionContext* SV3_1aParser::Delay_or_event_controlContext::expression() {
  return getRuleContext<SV3_1aParser::ExpressionContext>(0);
}

tree::TerminalNode* SV3_1aParser::Delay_or_event_controlContext::CLOSE_PARENS() {
  return getToken(SV3_1aParser::CLOSE_PARENS, 0);
}


size_t SV3_1aParser::Delay_or_event_controlContext::getRuleIndex() const {
  return SV3_1aParser::RuleDelay_or_event_control;
}

void SV3_1aParser::Delay_or_event_controlContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDelay_or_event_control(this);
}

void SV3_1aParser::Delay_or_event_controlContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDelay_or_event_control(this);
}

SV3_1aParser::Delay_or_event_controlContext* SV3_1aParser::delay_or_event_control() {
  Delay_or_event_controlContext *_localctx = _tracker.createInstance<Delay_or_event_controlContext>(_ctx, getState());
  enterRule(_localctx, 794, SV3_1aParser::RuleDelay_or_event_control);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(6707);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SV3_1aParser::Pound_Pound_delay:
      case SV3_1aParser::Pound_delay:
      case SV3_1aParser::POUND: {
        enterOuterAlt(_localctx, 1);
        setState(6699);
        delay_control();
        break;
      }

      case SV3_1aParser::ATSTAR:
      case SV3_1aParser::AT_PARENS_STAR:
      case SV3_1aParser::AT: {
        enterOuterAlt(_localctx, 2);
        setState(6700);
        event_control();
        break;
      }

      case SV3_1aParser::REPEAT: {
        enterOuterAlt(_localctx, 3);
        setState(6701);
        match(SV3_1aParser::REPEAT);
        setState(6702);
        match(SV3_1aParser::OPEN_PARENS);
        setState(6703);
        expression(0);
        setState(6704);
        match(SV3_1aParser::CLOSE_PARENS);
        setState(6705);
        event_control();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Delay_controlContext ------------------------------------------------------------------

SV3_1aParser::Delay_controlContext::Delay_controlContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::Pound_delay_valueContext* SV3_1aParser::Delay_controlContext::pound_delay_value() {
  return getRuleContext<SV3_1aParser::Pound_delay_valueContext>(0);
}

tree::TerminalNode* SV3_1aParser::Delay_controlContext::POUND() {
  return getToken(SV3_1aParser::POUND, 0);
}

tree::TerminalNode* SV3_1aParser::Delay_controlContext::OPEN_PARENS() {
  return getToken(SV3_1aParser::OPEN_PARENS, 0);
}

SV3_1aParser::Mintypmax_expressionContext* SV3_1aParser::Delay_controlContext::mintypmax_expression() {
  return getRuleContext<SV3_1aParser::Mintypmax_expressionContext>(0);
}

tree::TerminalNode* SV3_1aParser::Delay_controlContext::CLOSE_PARENS() {
  return getToken(SV3_1aParser::CLOSE_PARENS, 0);
}


size_t SV3_1aParser::Delay_controlContext::getRuleIndex() const {
  return SV3_1aParser::RuleDelay_control;
}

void SV3_1aParser::Delay_controlContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDelay_control(this);
}

void SV3_1aParser::Delay_controlContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDelay_control(this);
}

SV3_1aParser::Delay_controlContext* SV3_1aParser::delay_control() {
  Delay_controlContext *_localctx = _tracker.createInstance<Delay_controlContext>(_ctx, getState());
  enterRule(_localctx, 796, SV3_1aParser::RuleDelay_control);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(6715);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 770, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(6709);
      pound_delay_value();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(6710);
      match(SV3_1aParser::POUND);
      setState(6711);
      match(SV3_1aParser::OPEN_PARENS);
      setState(6712);
      mintypmax_expression();
      setState(6713);
      match(SV3_1aParser::CLOSE_PARENS);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Event_controlContext ------------------------------------------------------------------

SV3_1aParser::Event_controlContext::Event_controlContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Event_controlContext::AT() {
  return getToken(SV3_1aParser::AT, 0);
}

tree::TerminalNode* SV3_1aParser::Event_controlContext::OPEN_PARENS() {
  return getToken(SV3_1aParser::OPEN_PARENS, 0);
}

SV3_1aParser::Event_expressionContext* SV3_1aParser::Event_controlContext::event_expression() {
  return getRuleContext<SV3_1aParser::Event_expressionContext>(0);
}

tree::TerminalNode* SV3_1aParser::Event_controlContext::CLOSE_PARENS() {
  return getToken(SV3_1aParser::CLOSE_PARENS, 0);
}

tree::TerminalNode* SV3_1aParser::Event_controlContext::ATSTAR() {
  return getToken(SV3_1aParser::ATSTAR, 0);
}

tree::TerminalNode* SV3_1aParser::Event_controlContext::AT_PARENS_STAR() {
  return getToken(SV3_1aParser::AT_PARENS_STAR, 0);
}

SV3_1aParser::Ps_or_hierarchical_identifierContext* SV3_1aParser::Event_controlContext::ps_or_hierarchical_identifier() {
  return getRuleContext<SV3_1aParser::Ps_or_hierarchical_identifierContext>(0);
}


size_t SV3_1aParser::Event_controlContext::getRuleIndex() const {
  return SV3_1aParser::RuleEvent_control;
}

void SV3_1aParser::Event_controlContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterEvent_control(this);
}

void SV3_1aParser::Event_controlContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitEvent_control(this);
}

SV3_1aParser::Event_controlContext* SV3_1aParser::event_control() {
  Event_controlContext *_localctx = _tracker.createInstance<Event_controlContext>(_ctx, getState());
  enterRule(_localctx, 798, SV3_1aParser::RuleEvent_control);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(6726);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 771, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(6717);
      match(SV3_1aParser::AT);
      setState(6718);
      match(SV3_1aParser::OPEN_PARENS);
      setState(6719);
      event_expression(0);
      setState(6720);
      match(SV3_1aParser::CLOSE_PARENS);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(6722);
      match(SV3_1aParser::ATSTAR);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(6723);
      match(SV3_1aParser::AT_PARENS_STAR);
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(6724);
      match(SV3_1aParser::AT);
      setState(6725);
      ps_or_hierarchical_identifier();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Event_expressionContext ------------------------------------------------------------------

SV3_1aParser::Event_expressionContext::Event_expressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<SV3_1aParser::ExpressionContext *> SV3_1aParser::Event_expressionContext::expression() {
  return getRuleContexts<SV3_1aParser::ExpressionContext>();
}

SV3_1aParser::ExpressionContext* SV3_1aParser::Event_expressionContext::expression(size_t i) {
  return getRuleContext<SV3_1aParser::ExpressionContext>(i);
}

SV3_1aParser::Edge_identifierContext* SV3_1aParser::Event_expressionContext::edge_identifier() {
  return getRuleContext<SV3_1aParser::Edge_identifierContext>(0);
}

tree::TerminalNode* SV3_1aParser::Event_expressionContext::IFF() {
  return getToken(SV3_1aParser::IFF, 0);
}

SV3_1aParser::Sequence_instanceContext* SV3_1aParser::Event_expressionContext::sequence_instance() {
  return getRuleContext<SV3_1aParser::Sequence_instanceContext>(0);
}

tree::TerminalNode* SV3_1aParser::Event_expressionContext::OPEN_PARENS() {
  return getToken(SV3_1aParser::OPEN_PARENS, 0);
}

std::vector<SV3_1aParser::Event_expressionContext *> SV3_1aParser::Event_expressionContext::event_expression() {
  return getRuleContexts<SV3_1aParser::Event_expressionContext>();
}

SV3_1aParser::Event_expressionContext* SV3_1aParser::Event_expressionContext::event_expression(size_t i) {
  return getRuleContext<SV3_1aParser::Event_expressionContext>(i);
}

tree::TerminalNode* SV3_1aParser::Event_expressionContext::CLOSE_PARENS() {
  return getToken(SV3_1aParser::CLOSE_PARENS, 0);
}

SV3_1aParser::Or_operatorContext* SV3_1aParser::Event_expressionContext::or_operator() {
  return getRuleContext<SV3_1aParser::Or_operatorContext>(0);
}

SV3_1aParser::Comma_operatorContext* SV3_1aParser::Event_expressionContext::comma_operator() {
  return getRuleContext<SV3_1aParser::Comma_operatorContext>(0);
}


size_t SV3_1aParser::Event_expressionContext::getRuleIndex() const {
  return SV3_1aParser::RuleEvent_expression;
}

void SV3_1aParser::Event_expressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterEvent_expression(this);
}

void SV3_1aParser::Event_expressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitEvent_expression(this);
}


SV3_1aParser::Event_expressionContext* SV3_1aParser::event_expression() {
   return event_expression(0);
}

SV3_1aParser::Event_expressionContext* SV3_1aParser::event_expression(int precedence) {
  ParserRuleContext *parentContext = _ctx;
  size_t parentState = getState();
  SV3_1aParser::Event_expressionContext *_localctx = _tracker.createInstance<Event_expressionContext>(_ctx, parentState);
  SV3_1aParser::Event_expressionContext *previousContext = _localctx;
  (void)previousContext; // Silence compiler, in case the context is not used by generated code.
  size_t startState = 800;
  enterRecursionRule(_localctx, 800, SV3_1aParser::RuleEvent_expression, precedence);

    size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    unrollRecursionContexts(parentContext);
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(6746);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 775, _ctx)) {
    case 1: {
      setState(6730);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (((((_la - 333) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 333)) & 1027) != 0)) {
        setState(6729);
        edge_identifier();
      }
      setState(6732);
      expression(0);
      setState(6735);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 773, _ctx)) {
      case 1: {
        setState(6733);
        match(SV3_1aParser::IFF);
        setState(6734);
        expression(0);
        break;
      }

      default:
        break;
      }
      break;
    }

    case 2: {
      setState(6737);
      sequence_instance();
      setState(6740);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 774, _ctx)) {
      case 1: {
        setState(6738);
        match(SV3_1aParser::IFF);
        setState(6739);
        expression(0);
        break;
      }

      default:
        break;
      }
      break;
    }

    case 3: {
      setState(6742);
      match(SV3_1aParser::OPEN_PARENS);
      setState(6743);
      event_expression(0);
      setState(6744);
      match(SV3_1aParser::CLOSE_PARENS);
      break;
    }

    default:
      break;
    }
    _ctx->stop = _input->LT(-1);
    setState(6757);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 777, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        if (!_parseListeners.empty())
          triggerExitRuleEvent();
        previousContext = _localctx;
        _localctx = _tracker.createInstance<Event_expressionContext>(parentContext, parentState);
        pushNewRecursionContext(_localctx, startState, RuleEvent_expression);
        setState(6748);

        if (!(precpred(_ctx, 2))) throw FailedPredicateException(this, "precpred(_ctx, 2)");
        setState(6751);
        _errHandler->sync(this);
        switch (_input->LA(1)) {
          case SV3_1aParser::OR: {
            setState(6749);
            or_operator();
            break;
          }

          case SV3_1aParser::COMMA: {
            setState(6750);
            comma_operator();
            break;
          }

        default:
          throw NoViableAltException(this);
        }
        setState(6753);
        event_expression(3); 
      }
      setState(6759);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 777, _ctx);
    }
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }
  return _localctx;
}

//----------------- Or_operatorContext ------------------------------------------------------------------

SV3_1aParser::Or_operatorContext::Or_operatorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Or_operatorContext::OR() {
  return getToken(SV3_1aParser::OR, 0);
}


size_t SV3_1aParser::Or_operatorContext::getRuleIndex() const {
  return SV3_1aParser::RuleOr_operator;
}

void SV3_1aParser::Or_operatorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOr_operator(this);
}

void SV3_1aParser::Or_operatorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOr_operator(this);
}

SV3_1aParser::Or_operatorContext* SV3_1aParser::or_operator() {
  Or_operatorContext *_localctx = _tracker.createInstance<Or_operatorContext>(_ctx, getState());
  enterRule(_localctx, 802, SV3_1aParser::RuleOr_operator);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6760);
    match(SV3_1aParser::OR);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Comma_operatorContext ------------------------------------------------------------------

SV3_1aParser::Comma_operatorContext::Comma_operatorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Comma_operatorContext::COMMA() {
  return getToken(SV3_1aParser::COMMA, 0);
}


size_t SV3_1aParser::Comma_operatorContext::getRuleIndex() const {
  return SV3_1aParser::RuleComma_operator;
}

void SV3_1aParser::Comma_operatorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterComma_operator(this);
}

void SV3_1aParser::Comma_operatorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitComma_operator(this);
}

SV3_1aParser::Comma_operatorContext* SV3_1aParser::comma_operator() {
  Comma_operatorContext *_localctx = _tracker.createInstance<Comma_operatorContext>(_ctx, getState());
  enterRule(_localctx, 804, SV3_1aParser::RuleComma_operator);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6762);
    match(SV3_1aParser::COMMA);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Procedural_timing_controlContext ------------------------------------------------------------------

SV3_1aParser::Procedural_timing_controlContext::Procedural_timing_controlContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::Delay_controlContext* SV3_1aParser::Procedural_timing_controlContext::delay_control() {
  return getRuleContext<SV3_1aParser::Delay_controlContext>(0);
}

SV3_1aParser::Event_controlContext* SV3_1aParser::Procedural_timing_controlContext::event_control() {
  return getRuleContext<SV3_1aParser::Event_controlContext>(0);
}

SV3_1aParser::Cycle_delayContext* SV3_1aParser::Procedural_timing_controlContext::cycle_delay() {
  return getRuleContext<SV3_1aParser::Cycle_delayContext>(0);
}


size_t SV3_1aParser::Procedural_timing_controlContext::getRuleIndex() const {
  return SV3_1aParser::RuleProcedural_timing_control;
}

void SV3_1aParser::Procedural_timing_controlContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterProcedural_timing_control(this);
}

void SV3_1aParser::Procedural_timing_controlContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitProcedural_timing_control(this);
}

SV3_1aParser::Procedural_timing_controlContext* SV3_1aParser::procedural_timing_control() {
  Procedural_timing_controlContext *_localctx = _tracker.createInstance<Procedural_timing_controlContext>(_ctx, getState());
  enterRule(_localctx, 806, SV3_1aParser::RuleProcedural_timing_control);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(6767);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 778, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(6764);
      delay_control();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(6765);
      event_control();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(6766);
      cycle_delay();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Jump_statementContext ------------------------------------------------------------------

SV3_1aParser::Jump_statementContext::Jump_statementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Jump_statementContext::RETURN() {
  return getToken(SV3_1aParser::RETURN, 0);
}

tree::TerminalNode* SV3_1aParser::Jump_statementContext::SEMICOLON() {
  return getToken(SV3_1aParser::SEMICOLON, 0);
}

SV3_1aParser::ExpressionContext* SV3_1aParser::Jump_statementContext::expression() {
  return getRuleContext<SV3_1aParser::ExpressionContext>(0);
}

tree::TerminalNode* SV3_1aParser::Jump_statementContext::BREAK() {
  return getToken(SV3_1aParser::BREAK, 0);
}

tree::TerminalNode* SV3_1aParser::Jump_statementContext::CONTINUE() {
  return getToken(SV3_1aParser::CONTINUE, 0);
}


size_t SV3_1aParser::Jump_statementContext::getRuleIndex() const {
  return SV3_1aParser::RuleJump_statement;
}

void SV3_1aParser::Jump_statementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterJump_statement(this);
}

void SV3_1aParser::Jump_statementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitJump_statement(this);
}

SV3_1aParser::Jump_statementContext* SV3_1aParser::jump_statement() {
  Jump_statementContext *_localctx = _tracker.createInstance<Jump_statementContext>(_ctx, getState());
  enterRule(_localctx, 808, SV3_1aParser::RuleJump_statement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(6778);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SV3_1aParser::RETURN: {
        enterOuterAlt(_localctx, 1);
        setState(6769);
        match(SV3_1aParser::RETURN);
        setState(6771);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if ((((_la & ~ 0x3fULL) == 0) &&
          ((1ULL << _la) & 8796094922748) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 64)) & 1152648825725551617) != 0) || ((((_la - 147) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 147)) & 2199527096323) != 0) || _la == SV3_1aParser::BANG || ((((_la - 310) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 310)) & 559537073624154177) != 0)) {
          setState(6770);
          expression(0);
        }
        setState(6773);
        match(SV3_1aParser::SEMICOLON);
        break;
      }

      case SV3_1aParser::BREAK: {
        enterOuterAlt(_localctx, 2);
        setState(6774);
        match(SV3_1aParser::BREAK);
        setState(6775);
        match(SV3_1aParser::SEMICOLON);
        break;
      }

      case SV3_1aParser::CONTINUE: {
        enterOuterAlt(_localctx, 3);
        setState(6776);
        match(SV3_1aParser::CONTINUE);
        setState(6777);
        match(SV3_1aParser::SEMICOLON);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Final_constructContext ------------------------------------------------------------------

SV3_1aParser::Final_constructContext::Final_constructContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Final_constructContext::FINAL() {
  return getToken(SV3_1aParser::FINAL, 0);
}

SV3_1aParser::StatementContext* SV3_1aParser::Final_constructContext::statement() {
  return getRuleContext<SV3_1aParser::StatementContext>(0);
}


size_t SV3_1aParser::Final_constructContext::getRuleIndex() const {
  return SV3_1aParser::RuleFinal_construct;
}

void SV3_1aParser::Final_constructContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFinal_construct(this);
}

void SV3_1aParser::Final_constructContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFinal_construct(this);
}

SV3_1aParser::Final_constructContext* SV3_1aParser::final_construct() {
  Final_constructContext *_localctx = _tracker.createInstance<Final_constructContext>(_ctx, getState());
  enterRule(_localctx, 810, SV3_1aParser::RuleFinal_construct);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6780);
    match(SV3_1aParser::FINAL);
    setState(6781);
    statement();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Wait_statementContext ------------------------------------------------------------------

SV3_1aParser::Wait_statementContext::Wait_statementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Wait_statementContext::WAIT() {
  return getToken(SV3_1aParser::WAIT, 0);
}

tree::TerminalNode* SV3_1aParser::Wait_statementContext::OPEN_PARENS() {
  return getToken(SV3_1aParser::OPEN_PARENS, 0);
}

SV3_1aParser::ExpressionContext* SV3_1aParser::Wait_statementContext::expression() {
  return getRuleContext<SV3_1aParser::ExpressionContext>(0);
}

tree::TerminalNode* SV3_1aParser::Wait_statementContext::CLOSE_PARENS() {
  return getToken(SV3_1aParser::CLOSE_PARENS, 0);
}

SV3_1aParser::Statement_or_nullContext* SV3_1aParser::Wait_statementContext::statement_or_null() {
  return getRuleContext<SV3_1aParser::Statement_or_nullContext>(0);
}

tree::TerminalNode* SV3_1aParser::Wait_statementContext::FORK() {
  return getToken(SV3_1aParser::FORK, 0);
}

tree::TerminalNode* SV3_1aParser::Wait_statementContext::SEMICOLON() {
  return getToken(SV3_1aParser::SEMICOLON, 0);
}

tree::TerminalNode* SV3_1aParser::Wait_statementContext::WAIT_ORDER() {
  return getToken(SV3_1aParser::WAIT_ORDER, 0);
}

SV3_1aParser::Action_blockContext* SV3_1aParser::Wait_statementContext::action_block() {
  return getRuleContext<SV3_1aParser::Action_blockContext>(0);
}

std::vector<SV3_1aParser::IdentifierContext *> SV3_1aParser::Wait_statementContext::identifier() {
  return getRuleContexts<SV3_1aParser::IdentifierContext>();
}

SV3_1aParser::IdentifierContext* SV3_1aParser::Wait_statementContext::identifier(size_t i) {
  return getRuleContext<SV3_1aParser::IdentifierContext>(i);
}

std::vector<SV3_1aParser::Hierarchical_identifierContext *> SV3_1aParser::Wait_statementContext::hierarchical_identifier() {
  return getRuleContexts<SV3_1aParser::Hierarchical_identifierContext>();
}

SV3_1aParser::Hierarchical_identifierContext* SV3_1aParser::Wait_statementContext::hierarchical_identifier(size_t i) {
  return getRuleContext<SV3_1aParser::Hierarchical_identifierContext>(i);
}

std::vector<tree::TerminalNode *> SV3_1aParser::Wait_statementContext::COMMA() {
  return getTokens(SV3_1aParser::COMMA);
}

tree::TerminalNode* SV3_1aParser::Wait_statementContext::COMMA(size_t i) {
  return getToken(SV3_1aParser::COMMA, i);
}


size_t SV3_1aParser::Wait_statementContext::getRuleIndex() const {
  return SV3_1aParser::RuleWait_statement;
}

void SV3_1aParser::Wait_statementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterWait_statement(this);
}

void SV3_1aParser::Wait_statementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitWait_statement(this);
}

SV3_1aParser::Wait_statementContext* SV3_1aParser::wait_statement() {
  Wait_statementContext *_localctx = _tracker.createInstance<Wait_statementContext>(_ctx, getState());
  enterRule(_localctx, 812, SV3_1aParser::RuleWait_statement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(6812);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SV3_1aParser::WAIT: {
        enterOuterAlt(_localctx, 1);
        setState(6783);
        match(SV3_1aParser::WAIT);
        setState(6791);
        _errHandler->sync(this);
        switch (_input->LA(1)) {
          case SV3_1aParser::OPEN_PARENS: {
            setState(6784);
            match(SV3_1aParser::OPEN_PARENS);
            setState(6785);
            expression(0);
            setState(6786);
            match(SV3_1aParser::CLOSE_PARENS);
            setState(6787);
            statement_or_null();
            break;
          }

          case SV3_1aParser::FORK: {
            setState(6789);
            match(SV3_1aParser::FORK);
            setState(6790);
            match(SV3_1aParser::SEMICOLON);
            break;
          }

        default:
          throw NoViableAltException(this);
        }
        break;
      }

      case SV3_1aParser::WAIT_ORDER: {
        enterOuterAlt(_localctx, 2);
        setState(6793);
        match(SV3_1aParser::WAIT_ORDER);
        setState(6794);
        match(SV3_1aParser::OPEN_PARENS);
        setState(6797);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 782, _ctx)) {
        case 1: {
          setState(6795);
          identifier();
          break;
        }

        case 2: {
          setState(6796);
          hierarchical_identifier();
          break;
        }

        default:
          break;
        }
        setState(6806);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == SV3_1aParser::COMMA) {
          setState(6799);
          match(SV3_1aParser::COMMA);
          setState(6802);
          _errHandler->sync(this);
          switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 783, _ctx)) {
          case 1: {
            setState(6800);
            identifier();
            break;
          }

          case 2: {
            setState(6801);
            hierarchical_identifier();
            break;
          }

          default:
            break;
          }
          setState(6808);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(6809);
        match(SV3_1aParser::CLOSE_PARENS);
        setState(6810);
        action_block();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Event_triggerContext ------------------------------------------------------------------

SV3_1aParser::Event_triggerContext::Event_triggerContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Event_triggerContext::IMPLY() {
  return getToken(SV3_1aParser::IMPLY, 0);
}

tree::TerminalNode* SV3_1aParser::Event_triggerContext::SEMICOLON() {
  return getToken(SV3_1aParser::SEMICOLON, 0);
}

SV3_1aParser::IdentifierContext* SV3_1aParser::Event_triggerContext::identifier() {
  return getRuleContext<SV3_1aParser::IdentifierContext>(0);
}

SV3_1aParser::Hierarchical_identifierContext* SV3_1aParser::Event_triggerContext::hierarchical_identifier() {
  return getRuleContext<SV3_1aParser::Hierarchical_identifierContext>(0);
}

tree::TerminalNode* SV3_1aParser::Event_triggerContext::NON_BLOCKING_TRIGGER_EVENT_OP() {
  return getToken(SV3_1aParser::NON_BLOCKING_TRIGGER_EVENT_OP, 0);
}

SV3_1aParser::Delay_or_event_controlContext* SV3_1aParser::Event_triggerContext::delay_or_event_control() {
  return getRuleContext<SV3_1aParser::Delay_or_event_controlContext>(0);
}


size_t SV3_1aParser::Event_triggerContext::getRuleIndex() const {
  return SV3_1aParser::RuleEvent_trigger;
}

void SV3_1aParser::Event_triggerContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterEvent_trigger(this);
}

void SV3_1aParser::Event_triggerContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitEvent_trigger(this);
}

SV3_1aParser::Event_triggerContext* SV3_1aParser::event_trigger() {
  Event_triggerContext *_localctx = _tracker.createInstance<Event_triggerContext>(_ctx, getState());
  enterRule(_localctx, 814, SV3_1aParser::RuleEvent_trigger);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(6831);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SV3_1aParser::IMPLY: {
        enterOuterAlt(_localctx, 1);
        setState(6814);
        match(SV3_1aParser::IMPLY);
        setState(6817);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 786, _ctx)) {
        case 1: {
          setState(6815);
          identifier();
          break;
        }

        case 2: {
          setState(6816);
          hierarchical_identifier();
          break;
        }

        default:
          break;
        }
        setState(6819);
        match(SV3_1aParser::SEMICOLON);
        break;
      }

      case SV3_1aParser::NON_BLOCKING_TRIGGER_EVENT_OP: {
        enterOuterAlt(_localctx, 2);
        setState(6821);
        match(SV3_1aParser::NON_BLOCKING_TRIGGER_EVENT_OP);
        setState(6823);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if ((((_la & ~ 0x3fULL) == 0) &&
          ((1ULL << _la) & 50528256) != 0) || _la == SV3_1aParser::POUND || _la == SV3_1aParser::REPEAT

        || _la == SV3_1aParser::AT) {
          setState(6822);
          delay_or_event_control();
        }
        setState(6827);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 788, _ctx)) {
        case 1: {
          setState(6825);
          identifier();
          break;
        }

        case 2: {
          setState(6826);
          hierarchical_identifier();
          break;
        }

        default:
          break;
        }
        setState(6829);
        match(SV3_1aParser::SEMICOLON);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Disable_statementContext ------------------------------------------------------------------

SV3_1aParser::Disable_statementContext::Disable_statementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Disable_statementContext::DISABLE() {
  return getToken(SV3_1aParser::DISABLE, 0);
}

tree::TerminalNode* SV3_1aParser::Disable_statementContext::SEMICOLON() {
  return getToken(SV3_1aParser::SEMICOLON, 0);
}

SV3_1aParser::IdentifierContext* SV3_1aParser::Disable_statementContext::identifier() {
  return getRuleContext<SV3_1aParser::IdentifierContext>(0);
}

SV3_1aParser::Hierarchical_identifierContext* SV3_1aParser::Disable_statementContext::hierarchical_identifier() {
  return getRuleContext<SV3_1aParser::Hierarchical_identifierContext>(0);
}

tree::TerminalNode* SV3_1aParser::Disable_statementContext::FORK() {
  return getToken(SV3_1aParser::FORK, 0);
}


size_t SV3_1aParser::Disable_statementContext::getRuleIndex() const {
  return SV3_1aParser::RuleDisable_statement;
}

void SV3_1aParser::Disable_statementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDisable_statement(this);
}

void SV3_1aParser::Disable_statementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDisable_statement(this);
}

SV3_1aParser::Disable_statementContext* SV3_1aParser::disable_statement() {
  Disable_statementContext *_localctx = _tracker.createInstance<Disable_statementContext>(_ctx, getState());
  enterRule(_localctx, 816, SV3_1aParser::RuleDisable_statement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6833);
    match(SV3_1aParser::DISABLE);
    setState(6837);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 790, _ctx)) {
    case 1: {
      setState(6834);
      identifier();
      break;
    }

    case 2: {
      setState(6835);
      hierarchical_identifier();
      break;
    }

    case 3: {
      setState(6836);
      match(SV3_1aParser::FORK);
      break;
    }

    default:
      break;
    }
    setState(6839);
    match(SV3_1aParser::SEMICOLON);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Conditional_statementContext ------------------------------------------------------------------

SV3_1aParser::Conditional_statementContext::Conditional_statementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Conditional_statementContext::IF() {
  return getToken(SV3_1aParser::IF, 0);
}

tree::TerminalNode* SV3_1aParser::Conditional_statementContext::OPEN_PARENS() {
  return getToken(SV3_1aParser::OPEN_PARENS, 0);
}

SV3_1aParser::Cond_predicateContext* SV3_1aParser::Conditional_statementContext::cond_predicate() {
  return getRuleContext<SV3_1aParser::Cond_predicateContext>(0);
}

tree::TerminalNode* SV3_1aParser::Conditional_statementContext::CLOSE_PARENS() {
  return getToken(SV3_1aParser::CLOSE_PARENS, 0);
}

std::vector<SV3_1aParser::Statement_or_nullContext *> SV3_1aParser::Conditional_statementContext::statement_or_null() {
  return getRuleContexts<SV3_1aParser::Statement_or_nullContext>();
}

SV3_1aParser::Statement_or_nullContext* SV3_1aParser::Conditional_statementContext::statement_or_null(size_t i) {
  return getRuleContext<SV3_1aParser::Statement_or_nullContext>(i);
}

tree::TerminalNode* SV3_1aParser::Conditional_statementContext::ELSE() {
  return getToken(SV3_1aParser::ELSE, 0);
}

SV3_1aParser::Unique_priorityContext* SV3_1aParser::Conditional_statementContext::unique_priority() {
  return getRuleContext<SV3_1aParser::Unique_priorityContext>(0);
}


size_t SV3_1aParser::Conditional_statementContext::getRuleIndex() const {
  return SV3_1aParser::RuleConditional_statement;
}

void SV3_1aParser::Conditional_statementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterConditional_statement(this);
}

void SV3_1aParser::Conditional_statementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitConditional_statement(this);
}

SV3_1aParser::Conditional_statementContext* SV3_1aParser::conditional_statement() {
  Conditional_statementContext *_localctx = _tracker.createInstance<Conditional_statementContext>(_ctx, getState());
  enterRule(_localctx, 818, SV3_1aParser::RuleConditional_statement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6842);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (((((_la - 303) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 303)) & 7) != 0)) {
      setState(6841);
      unique_priority();
    }
    setState(6844);
    match(SV3_1aParser::IF);
    setState(6845);
    match(SV3_1aParser::OPEN_PARENS);
    setState(6846);
    cond_predicate();
    setState(6847);
    match(SV3_1aParser::CLOSE_PARENS);
    setState(6848);
    statement_or_null();
    setState(6852);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 792, _ctx)) {
    case 1: {
      setState(6849);
      match(SV3_1aParser::ELSE);
      setState(6850);
      statement_or_null();
      break;
    }

    case 2: {
      setState(6851);

      if (!(_input->LA(1) != ELSE)) throw FailedPredicateException(this, "_input->LA(1) != ELSE");
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Unique_priorityContext ------------------------------------------------------------------

SV3_1aParser::Unique_priorityContext::Unique_priorityContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Unique_priorityContext::UNIQUE() {
  return getToken(SV3_1aParser::UNIQUE, 0);
}

tree::TerminalNode* SV3_1aParser::Unique_priorityContext::UNIQUE0() {
  return getToken(SV3_1aParser::UNIQUE0, 0);
}

tree::TerminalNode* SV3_1aParser::Unique_priorityContext::PRIORITY() {
  return getToken(SV3_1aParser::PRIORITY, 0);
}


size_t SV3_1aParser::Unique_priorityContext::getRuleIndex() const {
  return SV3_1aParser::RuleUnique_priority;
}

void SV3_1aParser::Unique_priorityContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUnique_priority(this);
}

void SV3_1aParser::Unique_priorityContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUnique_priority(this);
}

SV3_1aParser::Unique_priorityContext* SV3_1aParser::unique_priority() {
  Unique_priorityContext *_localctx = _tracker.createInstance<Unique_priorityContext>(_ctx, getState());
  enterRule(_localctx, 820, SV3_1aParser::RuleUnique_priority);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6854);
    _la = _input->LA(1);
    if (!(((((_la - 303) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 303)) & 7) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Cond_predicateContext ------------------------------------------------------------------

SV3_1aParser::Cond_predicateContext::Cond_predicateContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<SV3_1aParser::Expression_or_cond_patternContext *> SV3_1aParser::Cond_predicateContext::expression_or_cond_pattern() {
  return getRuleContexts<SV3_1aParser::Expression_or_cond_patternContext>();
}

SV3_1aParser::Expression_or_cond_patternContext* SV3_1aParser::Cond_predicateContext::expression_or_cond_pattern(size_t i) {
  return getRuleContext<SV3_1aParser::Expression_or_cond_patternContext>(i);
}

std::vector<tree::TerminalNode *> SV3_1aParser::Cond_predicateContext::COND_PRED_OP() {
  return getTokens(SV3_1aParser::COND_PRED_OP);
}

tree::TerminalNode* SV3_1aParser::Cond_predicateContext::COND_PRED_OP(size_t i) {
  return getToken(SV3_1aParser::COND_PRED_OP, i);
}


size_t SV3_1aParser::Cond_predicateContext::getRuleIndex() const {
  return SV3_1aParser::RuleCond_predicate;
}

void SV3_1aParser::Cond_predicateContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCond_predicate(this);
}

void SV3_1aParser::Cond_predicateContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCond_predicate(this);
}

SV3_1aParser::Cond_predicateContext* SV3_1aParser::cond_predicate() {
  Cond_predicateContext *_localctx = _tracker.createInstance<Cond_predicateContext>(_ctx, getState());
  enterRule(_localctx, 822, SV3_1aParser::RuleCond_predicate);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6856);
    expression_or_cond_pattern();
    setState(6861);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == SV3_1aParser::COND_PRED_OP) {
      setState(6857);
      match(SV3_1aParser::COND_PRED_OP);
      setState(6858);
      expression_or_cond_pattern();
      setState(6863);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Expression_or_cond_patternContext ------------------------------------------------------------------

SV3_1aParser::Expression_or_cond_patternContext::Expression_or_cond_patternContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::ExpressionContext* SV3_1aParser::Expression_or_cond_patternContext::expression() {
  return getRuleContext<SV3_1aParser::ExpressionContext>(0);
}

SV3_1aParser::MatchesContext* SV3_1aParser::Expression_or_cond_patternContext::matches() {
  return getRuleContext<SV3_1aParser::MatchesContext>(0);
}

SV3_1aParser::PatternContext* SV3_1aParser::Expression_or_cond_patternContext::pattern() {
  return getRuleContext<SV3_1aParser::PatternContext>(0);
}


size_t SV3_1aParser::Expression_or_cond_patternContext::getRuleIndex() const {
  return SV3_1aParser::RuleExpression_or_cond_pattern;
}

void SV3_1aParser::Expression_or_cond_patternContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExpression_or_cond_pattern(this);
}

void SV3_1aParser::Expression_or_cond_patternContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExpression_or_cond_pattern(this);
}

SV3_1aParser::Expression_or_cond_patternContext* SV3_1aParser::expression_or_cond_pattern() {
  Expression_or_cond_patternContext *_localctx = _tracker.createInstance<Expression_or_cond_patternContext>(_ctx, getState());
  enterRule(_localctx, 824, SV3_1aParser::RuleExpression_or_cond_pattern);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6864);
    expression(0);
    setState(6868);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SV3_1aParser::MATCHES) {
      setState(6865);
      matches();
      setState(6866);
      pattern();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- MatchesContext ------------------------------------------------------------------

SV3_1aParser::MatchesContext::MatchesContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::MatchesContext::MATCHES() {
  return getToken(SV3_1aParser::MATCHES, 0);
}


size_t SV3_1aParser::MatchesContext::getRuleIndex() const {
  return SV3_1aParser::RuleMatches;
}

void SV3_1aParser::MatchesContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterMatches(this);
}

void SV3_1aParser::MatchesContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitMatches(this);
}

SV3_1aParser::MatchesContext* SV3_1aParser::matches() {
  MatchesContext *_localctx = _tracker.createInstance<MatchesContext>(_ctx, getState());
  enterRule(_localctx, 826, SV3_1aParser::RuleMatches);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6870);
    match(SV3_1aParser::MATCHES);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Case_statementContext ------------------------------------------------------------------

SV3_1aParser::Case_statementContext::Case_statementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::Case_keywordContext* SV3_1aParser::Case_statementContext::case_keyword() {
  return getRuleContext<SV3_1aParser::Case_keywordContext>(0);
}

tree::TerminalNode* SV3_1aParser::Case_statementContext::OPEN_PARENS() {
  return getToken(SV3_1aParser::OPEN_PARENS, 0);
}

SV3_1aParser::ExpressionContext* SV3_1aParser::Case_statementContext::expression() {
  return getRuleContext<SV3_1aParser::ExpressionContext>(0);
}

tree::TerminalNode* SV3_1aParser::Case_statementContext::CLOSE_PARENS() {
  return getToken(SV3_1aParser::CLOSE_PARENS, 0);
}

tree::TerminalNode* SV3_1aParser::Case_statementContext::ENDCASE() {
  return getToken(SV3_1aParser::ENDCASE, 0);
}

SV3_1aParser::Unique_priorityContext* SV3_1aParser::Case_statementContext::unique_priority() {
  return getRuleContext<SV3_1aParser::Unique_priorityContext>(0);
}

std::vector<SV3_1aParser::Case_itemContext *> SV3_1aParser::Case_statementContext::case_item() {
  return getRuleContexts<SV3_1aParser::Case_itemContext>();
}

SV3_1aParser::Case_itemContext* SV3_1aParser::Case_statementContext::case_item(size_t i) {
  return getRuleContext<SV3_1aParser::Case_itemContext>(i);
}

tree::TerminalNode* SV3_1aParser::Case_statementContext::MATCHES() {
  return getToken(SV3_1aParser::MATCHES, 0);
}

std::vector<SV3_1aParser::Case_pattern_itemContext *> SV3_1aParser::Case_statementContext::case_pattern_item() {
  return getRuleContexts<SV3_1aParser::Case_pattern_itemContext>();
}

SV3_1aParser::Case_pattern_itemContext* SV3_1aParser::Case_statementContext::case_pattern_item(size_t i) {
  return getRuleContext<SV3_1aParser::Case_pattern_itemContext>(i);
}

tree::TerminalNode* SV3_1aParser::Case_statementContext::INSIDE() {
  return getToken(SV3_1aParser::INSIDE, 0);
}

std::vector<SV3_1aParser::Case_inside_itemContext *> SV3_1aParser::Case_statementContext::case_inside_item() {
  return getRuleContexts<SV3_1aParser::Case_inside_itemContext>();
}

SV3_1aParser::Case_inside_itemContext* SV3_1aParser::Case_statementContext::case_inside_item(size_t i) {
  return getRuleContext<SV3_1aParser::Case_inside_itemContext>(i);
}


size_t SV3_1aParser::Case_statementContext::getRuleIndex() const {
  return SV3_1aParser::RuleCase_statement;
}

void SV3_1aParser::Case_statementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCase_statement(this);
}

void SV3_1aParser::Case_statementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCase_statement(this);
}

SV3_1aParser::Case_statementContext* SV3_1aParser::case_statement() {
  Case_statementContext *_localctx = _tracker.createInstance<Case_statementContext>(_ctx, getState());
  enterRule(_localctx, 828, SV3_1aParser::RuleCase_statement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6873);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (((((_la - 303) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 303)) & 7) != 0)) {
      setState(6872);
      unique_priority();
    }
    setState(6875);
    case_keyword();
    setState(6876);
    match(SV3_1aParser::OPEN_PARENS);
    setState(6877);
    expression(0);
    setState(6878);
    match(SV3_1aParser::CLOSE_PARENS);
    setState(6902);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SV3_1aParser::TICK_b0:
      case SV3_1aParser::TICK_b1:
      case SV3_1aParser::TICK_B0:
      case SV3_1aParser::TICK_B1:
      case SV3_1aParser::TICK_0:
      case SV3_1aParser::TICK_1:
      case SV3_1aParser::ONE_TICK_b0:
      case SV3_1aParser::ONE_TICK_b1:
      case SV3_1aParser::ONE_TICK_bx:
      case SV3_1aParser::ONE_TICK_bX:
      case SV3_1aParser::ONE_TICK_B0:
      case SV3_1aParser::ONE_TICK_B1:
      case SV3_1aParser::ONE_TICK_Bx:
      case SV3_1aParser::ONE_TICK_BX:
      case SV3_1aParser::Integral_number:
      case SV3_1aParser::Real_number:
      case SV3_1aParser::String:
      case SV3_1aParser::DEFAULT:
      case SV3_1aParser::OPEN_PARENS:
      case SV3_1aParser::TYPE:
      case SV3_1aParser::CONST:
      case SV3_1aParser::LOCAL:
      case SV3_1aParser::SUPER:
      case SV3_1aParser::OPEN_CURLY:
      case SV3_1aParser::STRING:
      case SV3_1aParser::BYTE:
      case SV3_1aParser::SHORTINT:
      case SV3_1aParser::INT:
      case SV3_1aParser::LONGINT:
      case SV3_1aParser::INTEGER:
      case SV3_1aParser::TIME:
      case SV3_1aParser::BIT:
      case SV3_1aParser::LOGIC:
      case SV3_1aParser::REG:
      case SV3_1aParser::SHORTREAL:
      case SV3_1aParser::REAL:
      case SV3_1aParser::REALTIME:
      case SV3_1aParser::SIGNED:
      case SV3_1aParser::UNSIGNED:
      case SV3_1aParser::DOLLAR:
      case SV3_1aParser::PLUSPLUS:
      case SV3_1aParser::PLUS:
      case SV3_1aParser::MINUSMINUS:
      case SV3_1aParser::MINUS:
      case SV3_1aParser::DOLLAR_UNIT:
      case SV3_1aParser::BANG:
      case SV3_1aParser::TAGGED:
      case SV3_1aParser::TICK:
      case SV3_1aParser::NULL_KEYWORD:
      case SV3_1aParser::THIS:
      case SV3_1aParser::DOLLAR_ROOT:
      case SV3_1aParser::RANDOMIZE:
      case SV3_1aParser::SAMPLE:
      case SV3_1aParser::BITW_AND:
      case SV3_1aParser::BITW_OR:
      case SV3_1aParser::REDUCTION_NOR:
      case SV3_1aParser::REDUCTION_NAND:
      case SV3_1aParser::REDUCTION_XNOR1:
      case SV3_1aParser::Escaped_identifier:
      case SV3_1aParser::TILDA:
      case SV3_1aParser::BITW_XOR:
      case SV3_1aParser::REDUCTION_XNOR2:
      case SV3_1aParser::Simple_identifier: {
        setState(6879);
        case_item();
        setState(6883);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while ((((_la & ~ 0x3fULL) == 0) &&
          ((1ULL << _la) & 8864814399484) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 64)) & 1152648825725551617) != 0) || ((((_la - 147) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 147)) & 2199527096323) != 0) || _la == SV3_1aParser::BANG || ((((_la - 310) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 310)) & 559537073624154177) != 0)) {
          setState(6880);
          case_item();
          setState(6885);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        break;
      }

      case SV3_1aParser::MATCHES: {
        setState(6886);
        match(SV3_1aParser::MATCHES);
        setState(6887);
        case_pattern_item();
        setState(6891);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while ((((_la & ~ 0x3fULL) == 0) &&
          ((1ULL << _la) & 8899174137852) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 64)) & 1152648825725551617) != 0) || ((((_la - 147) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 147)) & 2199359324163) != 0) || _la == SV3_1aParser::BANG

        || _la == SV3_1aParser::DOTSTAR || ((((_la - 310) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 310)) & 559537073624121409) != 0)) {
          setState(6888);
          case_pattern_item();
          setState(6893);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        break;
      }

      case SV3_1aParser::INSIDE: {
        setState(6894);
        match(SV3_1aParser::INSIDE);
        setState(6895);
        case_inside_item();
        setState(6899);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while ((((_la & ~ 0x3fULL) == 0) &&
          ((1ULL << _la) & 8864814399484) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 64)) & 1152719194469729281) != 0) || ((((_la - 147) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 147)) & 2199527096323) != 0) || _la == SV3_1aParser::BANG || ((((_la - 310) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 310)) & 559537073624154177) != 0)) {
          setState(6896);
          case_inside_item();
          setState(6901);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
    setState(6904);
    match(SV3_1aParser::ENDCASE);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Case_keywordContext ------------------------------------------------------------------

SV3_1aParser::Case_keywordContext::Case_keywordContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Case_keywordContext::CASE() {
  return getToken(SV3_1aParser::CASE, 0);
}

tree::TerminalNode* SV3_1aParser::Case_keywordContext::CASEZ() {
  return getToken(SV3_1aParser::CASEZ, 0);
}

tree::TerminalNode* SV3_1aParser::Case_keywordContext::CASEX() {
  return getToken(SV3_1aParser::CASEX, 0);
}


size_t SV3_1aParser::Case_keywordContext::getRuleIndex() const {
  return SV3_1aParser::RuleCase_keyword;
}

void SV3_1aParser::Case_keywordContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCase_keyword(this);
}

void SV3_1aParser::Case_keywordContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCase_keyword(this);
}

SV3_1aParser::Case_keywordContext* SV3_1aParser::case_keyword() {
  Case_keywordContext *_localctx = _tracker.createInstance<Case_keywordContext>(_ctx, getState());
  enterRule(_localctx, 830, SV3_1aParser::RuleCase_keyword);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6906);
    _la = _input->LA(1);
    if (!(((((_la - 264) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 264)) & 26388279066625) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Case_itemContext ------------------------------------------------------------------

SV3_1aParser::Case_itemContext::Case_itemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<SV3_1aParser::ExpressionContext *> SV3_1aParser::Case_itemContext::expression() {
  return getRuleContexts<SV3_1aParser::ExpressionContext>();
}

SV3_1aParser::ExpressionContext* SV3_1aParser::Case_itemContext::expression(size_t i) {
  return getRuleContext<SV3_1aParser::ExpressionContext>(i);
}

tree::TerminalNode* SV3_1aParser::Case_itemContext::COLON() {
  return getToken(SV3_1aParser::COLON, 0);
}

SV3_1aParser::Statement_or_nullContext* SV3_1aParser::Case_itemContext::statement_or_null() {
  return getRuleContext<SV3_1aParser::Statement_or_nullContext>(0);
}

std::vector<tree::TerminalNode *> SV3_1aParser::Case_itemContext::COMMA() {
  return getTokens(SV3_1aParser::COMMA);
}

tree::TerminalNode* SV3_1aParser::Case_itemContext::COMMA(size_t i) {
  return getToken(SV3_1aParser::COMMA, i);
}

tree::TerminalNode* SV3_1aParser::Case_itemContext::DEFAULT() {
  return getToken(SV3_1aParser::DEFAULT, 0);
}


size_t SV3_1aParser::Case_itemContext::getRuleIndex() const {
  return SV3_1aParser::RuleCase_item;
}

void SV3_1aParser::Case_itemContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCase_item(this);
}

void SV3_1aParser::Case_itemContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCase_item(this);
}

SV3_1aParser::Case_itemContext* SV3_1aParser::case_item() {
  Case_itemContext *_localctx = _tracker.createInstance<Case_itemContext>(_ctx, getState());
  enterRule(_localctx, 832, SV3_1aParser::RuleCase_item);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(6924);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SV3_1aParser::TICK_b0:
      case SV3_1aParser::TICK_b1:
      case SV3_1aParser::TICK_B0:
      case SV3_1aParser::TICK_B1:
      case SV3_1aParser::TICK_0:
      case SV3_1aParser::TICK_1:
      case SV3_1aParser::ONE_TICK_b0:
      case SV3_1aParser::ONE_TICK_b1:
      case SV3_1aParser::ONE_TICK_bx:
      case SV3_1aParser::ONE_TICK_bX:
      case SV3_1aParser::ONE_TICK_B0:
      case SV3_1aParser::ONE_TICK_B1:
      case SV3_1aParser::ONE_TICK_Bx:
      case SV3_1aParser::ONE_TICK_BX:
      case SV3_1aParser::Integral_number:
      case SV3_1aParser::Real_number:
      case SV3_1aParser::String:
      case SV3_1aParser::OPEN_PARENS:
      case SV3_1aParser::TYPE:
      case SV3_1aParser::CONST:
      case SV3_1aParser::LOCAL:
      case SV3_1aParser::SUPER:
      case SV3_1aParser::OPEN_CURLY:
      case SV3_1aParser::STRING:
      case SV3_1aParser::BYTE:
      case SV3_1aParser::SHORTINT:
      case SV3_1aParser::INT:
      case SV3_1aParser::LONGINT:
      case SV3_1aParser::INTEGER:
      case SV3_1aParser::TIME:
      case SV3_1aParser::BIT:
      case SV3_1aParser::LOGIC:
      case SV3_1aParser::REG:
      case SV3_1aParser::SHORTREAL:
      case SV3_1aParser::REAL:
      case SV3_1aParser::REALTIME:
      case SV3_1aParser::SIGNED:
      case SV3_1aParser::UNSIGNED:
      case SV3_1aParser::DOLLAR:
      case SV3_1aParser::PLUSPLUS:
      case SV3_1aParser::PLUS:
      case SV3_1aParser::MINUSMINUS:
      case SV3_1aParser::MINUS:
      case SV3_1aParser::DOLLAR_UNIT:
      case SV3_1aParser::BANG:
      case SV3_1aParser::TAGGED:
      case SV3_1aParser::TICK:
      case SV3_1aParser::NULL_KEYWORD:
      case SV3_1aParser::THIS:
      case SV3_1aParser::DOLLAR_ROOT:
      case SV3_1aParser::RANDOMIZE:
      case SV3_1aParser::SAMPLE:
      case SV3_1aParser::BITW_AND:
      case SV3_1aParser::BITW_OR:
      case SV3_1aParser::REDUCTION_NOR:
      case SV3_1aParser::REDUCTION_NAND:
      case SV3_1aParser::REDUCTION_XNOR1:
      case SV3_1aParser::Escaped_identifier:
      case SV3_1aParser::TILDA:
      case SV3_1aParser::BITW_XOR:
      case SV3_1aParser::REDUCTION_XNOR2:
      case SV3_1aParser::Simple_identifier: {
        enterOuterAlt(_localctx, 1);
        setState(6908);
        expression(0);
        setState(6913);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == SV3_1aParser::COMMA) {
          setState(6909);
          match(SV3_1aParser::COMMA);
          setState(6910);
          expression(0);
          setState(6915);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(6916);
        match(SV3_1aParser::COLON);
        setState(6917);
        statement_or_null();
        break;
      }

      case SV3_1aParser::DEFAULT: {
        enterOuterAlt(_localctx, 2);
        setState(6919);
        match(SV3_1aParser::DEFAULT);
        setState(6921);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == SV3_1aParser::COLON) {
          setState(6920);
          match(SV3_1aParser::COLON);
        }
        setState(6923);
        statement_or_null();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Case_pattern_itemContext ------------------------------------------------------------------

SV3_1aParser::Case_pattern_itemContext::Case_pattern_itemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::PatternContext* SV3_1aParser::Case_pattern_itemContext::pattern() {
  return getRuleContext<SV3_1aParser::PatternContext>(0);
}

tree::TerminalNode* SV3_1aParser::Case_pattern_itemContext::COLON() {
  return getToken(SV3_1aParser::COLON, 0);
}

SV3_1aParser::Statement_or_nullContext* SV3_1aParser::Case_pattern_itemContext::statement_or_null() {
  return getRuleContext<SV3_1aParser::Statement_or_nullContext>(0);
}

tree::TerminalNode* SV3_1aParser::Case_pattern_itemContext::COND_PRED_OP() {
  return getToken(SV3_1aParser::COND_PRED_OP, 0);
}

SV3_1aParser::ExpressionContext* SV3_1aParser::Case_pattern_itemContext::expression() {
  return getRuleContext<SV3_1aParser::ExpressionContext>(0);
}

tree::TerminalNode* SV3_1aParser::Case_pattern_itemContext::DEFAULT() {
  return getToken(SV3_1aParser::DEFAULT, 0);
}


size_t SV3_1aParser::Case_pattern_itemContext::getRuleIndex() const {
  return SV3_1aParser::RuleCase_pattern_item;
}

void SV3_1aParser::Case_pattern_itemContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCase_pattern_item(this);
}

void SV3_1aParser::Case_pattern_itemContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCase_pattern_item(this);
}

SV3_1aParser::Case_pattern_itemContext* SV3_1aParser::case_pattern_item() {
  Case_pattern_itemContext *_localctx = _tracker.createInstance<Case_pattern_itemContext>(_ctx, getState());
  enterRule(_localctx, 834, SV3_1aParser::RuleCase_pattern_item);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(6939);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SV3_1aParser::TICK_b0:
      case SV3_1aParser::TICK_b1:
      case SV3_1aParser::TICK_B0:
      case SV3_1aParser::TICK_B1:
      case SV3_1aParser::TICK_0:
      case SV3_1aParser::TICK_1:
      case SV3_1aParser::ONE_TICK_b0:
      case SV3_1aParser::ONE_TICK_b1:
      case SV3_1aParser::ONE_TICK_bx:
      case SV3_1aParser::ONE_TICK_bX:
      case SV3_1aParser::ONE_TICK_B0:
      case SV3_1aParser::ONE_TICK_B1:
      case SV3_1aParser::ONE_TICK_Bx:
      case SV3_1aParser::ONE_TICK_BX:
      case SV3_1aParser::Integral_number:
      case SV3_1aParser::Real_number:
      case SV3_1aParser::String:
      case SV3_1aParser::DOT:
      case SV3_1aParser::OPEN_PARENS:
      case SV3_1aParser::TYPE:
      case SV3_1aParser::CONST:
      case SV3_1aParser::LOCAL:
      case SV3_1aParser::SUPER:
      case SV3_1aParser::OPEN_CURLY:
      case SV3_1aParser::STRING:
      case SV3_1aParser::BYTE:
      case SV3_1aParser::SHORTINT:
      case SV3_1aParser::INT:
      case SV3_1aParser::LONGINT:
      case SV3_1aParser::INTEGER:
      case SV3_1aParser::TIME:
      case SV3_1aParser::BIT:
      case SV3_1aParser::LOGIC:
      case SV3_1aParser::REG:
      case SV3_1aParser::SHORTREAL:
      case SV3_1aParser::REAL:
      case SV3_1aParser::REALTIME:
      case SV3_1aParser::SIGNED:
      case SV3_1aParser::UNSIGNED:
      case SV3_1aParser::DOLLAR:
      case SV3_1aParser::PLUS:
      case SV3_1aParser::MINUS:
      case SV3_1aParser::DOLLAR_UNIT:
      case SV3_1aParser::BANG:
      case SV3_1aParser::DOTSTAR:
      case SV3_1aParser::TAGGED:
      case SV3_1aParser::TICK:
      case SV3_1aParser::THIS:
      case SV3_1aParser::DOLLAR_ROOT:
      case SV3_1aParser::RANDOMIZE:
      case SV3_1aParser::SAMPLE:
      case SV3_1aParser::BITW_AND:
      case SV3_1aParser::BITW_OR:
      case SV3_1aParser::REDUCTION_NOR:
      case SV3_1aParser::REDUCTION_NAND:
      case SV3_1aParser::REDUCTION_XNOR1:
      case SV3_1aParser::Escaped_identifier:
      case SV3_1aParser::TILDA:
      case SV3_1aParser::BITW_XOR:
      case SV3_1aParser::REDUCTION_XNOR2:
      case SV3_1aParser::Simple_identifier: {
        enterOuterAlt(_localctx, 1);
        setState(6926);
        pattern();
        setState(6929);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == SV3_1aParser::COND_PRED_OP) {
          setState(6927);
          match(SV3_1aParser::COND_PRED_OP);
          setState(6928);
          expression(0);
        }
        setState(6931);
        match(SV3_1aParser::COLON);
        setState(6932);
        statement_or_null();
        break;
      }

      case SV3_1aParser::DEFAULT: {
        enterOuterAlt(_localctx, 2);
        setState(6934);
        match(SV3_1aParser::DEFAULT);
        setState(6936);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == SV3_1aParser::COLON) {
          setState(6935);
          match(SV3_1aParser::COLON);
        }
        setState(6938);
        statement_or_null();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Case_inside_itemContext ------------------------------------------------------------------

SV3_1aParser::Case_inside_itemContext::Case_inside_itemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::Open_range_listContext* SV3_1aParser::Case_inside_itemContext::open_range_list() {
  return getRuleContext<SV3_1aParser::Open_range_listContext>(0);
}

tree::TerminalNode* SV3_1aParser::Case_inside_itemContext::COLON() {
  return getToken(SV3_1aParser::COLON, 0);
}

SV3_1aParser::Statement_or_nullContext* SV3_1aParser::Case_inside_itemContext::statement_or_null() {
  return getRuleContext<SV3_1aParser::Statement_or_nullContext>(0);
}

tree::TerminalNode* SV3_1aParser::Case_inside_itemContext::DEFAULT() {
  return getToken(SV3_1aParser::DEFAULT, 0);
}


size_t SV3_1aParser::Case_inside_itemContext::getRuleIndex() const {
  return SV3_1aParser::RuleCase_inside_item;
}

void SV3_1aParser::Case_inside_itemContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCase_inside_item(this);
}

void SV3_1aParser::Case_inside_itemContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCase_inside_item(this);
}

SV3_1aParser::Case_inside_itemContext* SV3_1aParser::case_inside_item() {
  Case_inside_itemContext *_localctx = _tracker.createInstance<Case_inside_itemContext>(_ctx, getState());
  enterRule(_localctx, 836, SV3_1aParser::RuleCase_inside_item);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(6950);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SV3_1aParser::TICK_b0:
      case SV3_1aParser::TICK_b1:
      case SV3_1aParser::TICK_B0:
      case SV3_1aParser::TICK_B1:
      case SV3_1aParser::TICK_0:
      case SV3_1aParser::TICK_1:
      case SV3_1aParser::ONE_TICK_b0:
      case SV3_1aParser::ONE_TICK_b1:
      case SV3_1aParser::ONE_TICK_bx:
      case SV3_1aParser::ONE_TICK_bX:
      case SV3_1aParser::ONE_TICK_B0:
      case SV3_1aParser::ONE_TICK_B1:
      case SV3_1aParser::ONE_TICK_Bx:
      case SV3_1aParser::ONE_TICK_BX:
      case SV3_1aParser::Integral_number:
      case SV3_1aParser::Real_number:
      case SV3_1aParser::String:
      case SV3_1aParser::OPEN_PARENS:
      case SV3_1aParser::TYPE:
      case SV3_1aParser::CONST:
      case SV3_1aParser::LOCAL:
      case SV3_1aParser::SUPER:
      case SV3_1aParser::OPEN_CURLY:
      case SV3_1aParser::STRING:
      case SV3_1aParser::OPEN_BRACKET:
      case SV3_1aParser::BYTE:
      case SV3_1aParser::SHORTINT:
      case SV3_1aParser::INT:
      case SV3_1aParser::LONGINT:
      case SV3_1aParser::INTEGER:
      case SV3_1aParser::TIME:
      case SV3_1aParser::BIT:
      case SV3_1aParser::LOGIC:
      case SV3_1aParser::REG:
      case SV3_1aParser::SHORTREAL:
      case SV3_1aParser::REAL:
      case SV3_1aParser::REALTIME:
      case SV3_1aParser::SIGNED:
      case SV3_1aParser::UNSIGNED:
      case SV3_1aParser::DOLLAR:
      case SV3_1aParser::PLUSPLUS:
      case SV3_1aParser::PLUS:
      case SV3_1aParser::MINUSMINUS:
      case SV3_1aParser::MINUS:
      case SV3_1aParser::DOLLAR_UNIT:
      case SV3_1aParser::BANG:
      case SV3_1aParser::TAGGED:
      case SV3_1aParser::TICK:
      case SV3_1aParser::NULL_KEYWORD:
      case SV3_1aParser::THIS:
      case SV3_1aParser::DOLLAR_ROOT:
      case SV3_1aParser::RANDOMIZE:
      case SV3_1aParser::SAMPLE:
      case SV3_1aParser::BITW_AND:
      case SV3_1aParser::BITW_OR:
      case SV3_1aParser::REDUCTION_NOR:
      case SV3_1aParser::REDUCTION_NAND:
      case SV3_1aParser::REDUCTION_XNOR1:
      case SV3_1aParser::Escaped_identifier:
      case SV3_1aParser::TILDA:
      case SV3_1aParser::BITW_XOR:
      case SV3_1aParser::REDUCTION_XNOR2:
      case SV3_1aParser::Simple_identifier: {
        enterOuterAlt(_localctx, 1);
        setState(6941);
        open_range_list();
        setState(6942);
        match(SV3_1aParser::COLON);
        setState(6943);
        statement_or_null();
        break;
      }

      case SV3_1aParser::DEFAULT: {
        enterOuterAlt(_localctx, 2);
        setState(6945);
        match(SV3_1aParser::DEFAULT);
        setState(6947);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == SV3_1aParser::COLON) {
          setState(6946);
          match(SV3_1aParser::COLON);
        }
        setState(6949);
        statement_or_null();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Randcase_statementContext ------------------------------------------------------------------

SV3_1aParser::Randcase_statementContext::Randcase_statementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Randcase_statementContext::RANDCASE() {
  return getToken(SV3_1aParser::RANDCASE, 0);
}

std::vector<SV3_1aParser::Randcase_itemContext *> SV3_1aParser::Randcase_statementContext::randcase_item() {
  return getRuleContexts<SV3_1aParser::Randcase_itemContext>();
}

SV3_1aParser::Randcase_itemContext* SV3_1aParser::Randcase_statementContext::randcase_item(size_t i) {
  return getRuleContext<SV3_1aParser::Randcase_itemContext>(i);
}

tree::TerminalNode* SV3_1aParser::Randcase_statementContext::ENDCASE() {
  return getToken(SV3_1aParser::ENDCASE, 0);
}


size_t SV3_1aParser::Randcase_statementContext::getRuleIndex() const {
  return SV3_1aParser::RuleRandcase_statement;
}

void SV3_1aParser::Randcase_statementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRandcase_statement(this);
}

void SV3_1aParser::Randcase_statementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRandcase_statement(this);
}

SV3_1aParser::Randcase_statementContext* SV3_1aParser::randcase_statement() {
  Randcase_statementContext *_localctx = _tracker.createInstance<Randcase_statementContext>(_ctx, getState());
  enterRule(_localctx, 838, SV3_1aParser::RuleRandcase_statement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6952);
    match(SV3_1aParser::RANDCASE);
    setState(6953);
    randcase_item();
    setState(6957);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 8796094922748) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 64)) & 1152648825725551617) != 0) || ((((_la - 147) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 147)) & 2199527096323) != 0) || _la == SV3_1aParser::BANG || ((((_la - 310) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 310)) & 559537073624154177) != 0)) {
      setState(6954);
      randcase_item();
      setState(6959);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(6960);
    match(SV3_1aParser::ENDCASE);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Randcase_itemContext ------------------------------------------------------------------

SV3_1aParser::Randcase_itemContext::Randcase_itemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::ExpressionContext* SV3_1aParser::Randcase_itemContext::expression() {
  return getRuleContext<SV3_1aParser::ExpressionContext>(0);
}

tree::TerminalNode* SV3_1aParser::Randcase_itemContext::COLON() {
  return getToken(SV3_1aParser::COLON, 0);
}

SV3_1aParser::Statement_or_nullContext* SV3_1aParser::Randcase_itemContext::statement_or_null() {
  return getRuleContext<SV3_1aParser::Statement_or_nullContext>(0);
}


size_t SV3_1aParser::Randcase_itemContext::getRuleIndex() const {
  return SV3_1aParser::RuleRandcase_item;
}

void SV3_1aParser::Randcase_itemContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRandcase_item(this);
}

void SV3_1aParser::Randcase_itemContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRandcase_item(this);
}

SV3_1aParser::Randcase_itemContext* SV3_1aParser::randcase_item() {
  Randcase_itemContext *_localctx = _tracker.createInstance<Randcase_itemContext>(_ctx, getState());
  enterRule(_localctx, 840, SV3_1aParser::RuleRandcase_item);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6962);
    expression(0);
    setState(6963);
    match(SV3_1aParser::COLON);
    setState(6964);
    statement_or_null();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PatternContext ------------------------------------------------------------------

SV3_1aParser::PatternContext::PatternContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::PatternContext::DOT() {
  return getToken(SV3_1aParser::DOT, 0);
}

std::vector<SV3_1aParser::IdentifierContext *> SV3_1aParser::PatternContext::identifier() {
  return getRuleContexts<SV3_1aParser::IdentifierContext>();
}

SV3_1aParser::IdentifierContext* SV3_1aParser::PatternContext::identifier(size_t i) {
  return getRuleContext<SV3_1aParser::IdentifierContext>(i);
}

tree::TerminalNode* SV3_1aParser::PatternContext::DOTSTAR() {
  return getToken(SV3_1aParser::DOTSTAR, 0);
}

SV3_1aParser::Constant_expressionContext* SV3_1aParser::PatternContext::constant_expression() {
  return getRuleContext<SV3_1aParser::Constant_expressionContext>(0);
}

tree::TerminalNode* SV3_1aParser::PatternContext::TAGGED() {
  return getToken(SV3_1aParser::TAGGED, 0);
}

std::vector<SV3_1aParser::PatternContext *> SV3_1aParser::PatternContext::pattern() {
  return getRuleContexts<SV3_1aParser::PatternContext>();
}

SV3_1aParser::PatternContext* SV3_1aParser::PatternContext::pattern(size_t i) {
  return getRuleContext<SV3_1aParser::PatternContext>(i);
}

tree::TerminalNode* SV3_1aParser::PatternContext::TICK() {
  return getToken(SV3_1aParser::TICK, 0);
}

tree::TerminalNode* SV3_1aParser::PatternContext::OPEN_CURLY() {
  return getToken(SV3_1aParser::OPEN_CURLY, 0);
}

tree::TerminalNode* SV3_1aParser::PatternContext::CLOSE_CURLY() {
  return getToken(SV3_1aParser::CLOSE_CURLY, 0);
}

std::vector<tree::TerminalNode *> SV3_1aParser::PatternContext::COMMA() {
  return getTokens(SV3_1aParser::COMMA);
}

tree::TerminalNode* SV3_1aParser::PatternContext::COMMA(size_t i) {
  return getToken(SV3_1aParser::COMMA, i);
}

std::vector<tree::TerminalNode *> SV3_1aParser::PatternContext::COLON() {
  return getTokens(SV3_1aParser::COLON);
}

tree::TerminalNode* SV3_1aParser::PatternContext::COLON(size_t i) {
  return getToken(SV3_1aParser::COLON, i);
}


size_t SV3_1aParser::PatternContext::getRuleIndex() const {
  return SV3_1aParser::RulePattern;
}

void SV3_1aParser::PatternContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPattern(this);
}

void SV3_1aParser::PatternContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPattern(this);
}

SV3_1aParser::PatternContext* SV3_1aParser::pattern() {
  PatternContext *_localctx = _tracker.createInstance<PatternContext>(_ctx, getState());
  enterRule(_localctx, 842, SV3_1aParser::RulePattern);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(7004);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 812, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(6966);
      match(SV3_1aParser::DOT);
      setState(6967);
      identifier();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(6968);
      match(SV3_1aParser::DOTSTAR);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(6969);
      constant_expression(0);
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(6970);
      match(SV3_1aParser::TAGGED);
      setState(6971);
      identifier();
      setState(6973);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if ((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & 8830454661116) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 64)) & 1152648825725551617) != 0) || ((((_la - 147) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 147)) & 2199359324163) != 0) || _la == SV3_1aParser::BANG

      || _la == SV3_1aParser::DOTSTAR || ((((_la - 310) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 310)) & 559537073624121409) != 0)) {
        setState(6972);
        pattern();
      }
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(6975);
      match(SV3_1aParser::TICK);
      setState(6976);
      match(SV3_1aParser::OPEN_CURLY);
      setState(6977);
      pattern();
      setState(6982);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == SV3_1aParser::COMMA) {
        setState(6978);
        match(SV3_1aParser::COMMA);
        setState(6979);
        pattern();
        setState(6984);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(6985);
      match(SV3_1aParser::CLOSE_CURLY);
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(6987);
      match(SV3_1aParser::TICK);
      setState(6988);
      match(SV3_1aParser::OPEN_CURLY);
      setState(6989);
      identifier();
      setState(6990);
      match(SV3_1aParser::COLON);
      setState(6991);
      pattern();
      setState(6999);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == SV3_1aParser::COMMA) {
        setState(6992);
        match(SV3_1aParser::COMMA);
        setState(6993);
        identifier();
        setState(6994);
        match(SV3_1aParser::COLON);
        setState(6995);
        pattern();
        setState(7001);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(7002);
      match(SV3_1aParser::CLOSE_CURLY);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Assignment_patternContext ------------------------------------------------------------------

SV3_1aParser::Assignment_patternContext::Assignment_patternContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Assignment_patternContext::TICK() {
  return getToken(SV3_1aParser::TICK, 0);
}

std::vector<tree::TerminalNode *> SV3_1aParser::Assignment_patternContext::OPEN_CURLY() {
  return getTokens(SV3_1aParser::OPEN_CURLY);
}

tree::TerminalNode* SV3_1aParser::Assignment_patternContext::OPEN_CURLY(size_t i) {
  return getToken(SV3_1aParser::OPEN_CURLY, i);
}

std::vector<SV3_1aParser::ExpressionContext *> SV3_1aParser::Assignment_patternContext::expression() {
  return getRuleContexts<SV3_1aParser::ExpressionContext>();
}

SV3_1aParser::ExpressionContext* SV3_1aParser::Assignment_patternContext::expression(size_t i) {
  return getRuleContext<SV3_1aParser::ExpressionContext>(i);
}

std::vector<tree::TerminalNode *> SV3_1aParser::Assignment_patternContext::CLOSE_CURLY() {
  return getTokens(SV3_1aParser::CLOSE_CURLY);
}

tree::TerminalNode* SV3_1aParser::Assignment_patternContext::CLOSE_CURLY(size_t i) {
  return getToken(SV3_1aParser::CLOSE_CURLY, i);
}

std::vector<tree::TerminalNode *> SV3_1aParser::Assignment_patternContext::COMMA() {
  return getTokens(SV3_1aParser::COMMA);
}

tree::TerminalNode* SV3_1aParser::Assignment_patternContext::COMMA(size_t i) {
  return getToken(SV3_1aParser::COMMA, i);
}

std::vector<SV3_1aParser::Structure_pattern_keyContext *> SV3_1aParser::Assignment_patternContext::structure_pattern_key() {
  return getRuleContexts<SV3_1aParser::Structure_pattern_keyContext>();
}

SV3_1aParser::Structure_pattern_keyContext* SV3_1aParser::Assignment_patternContext::structure_pattern_key(size_t i) {
  return getRuleContext<SV3_1aParser::Structure_pattern_keyContext>(i);
}

std::vector<tree::TerminalNode *> SV3_1aParser::Assignment_patternContext::COLON() {
  return getTokens(SV3_1aParser::COLON);
}

tree::TerminalNode* SV3_1aParser::Assignment_patternContext::COLON(size_t i) {
  return getToken(SV3_1aParser::COLON, i);
}

std::vector<SV3_1aParser::Array_pattern_keyContext *> SV3_1aParser::Assignment_patternContext::array_pattern_key() {
  return getRuleContexts<SV3_1aParser::Array_pattern_keyContext>();
}

SV3_1aParser::Array_pattern_keyContext* SV3_1aParser::Assignment_patternContext::array_pattern_key(size_t i) {
  return getRuleContext<SV3_1aParser::Array_pattern_keyContext>(i);
}

SV3_1aParser::Constant_expressionContext* SV3_1aParser::Assignment_patternContext::constant_expression() {
  return getRuleContext<SV3_1aParser::Constant_expressionContext>(0);
}


size_t SV3_1aParser::Assignment_patternContext::getRuleIndex() const {
  return SV3_1aParser::RuleAssignment_pattern;
}

void SV3_1aParser::Assignment_patternContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAssignment_pattern(this);
}

void SV3_1aParser::Assignment_patternContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAssignment_pattern(this);
}

SV3_1aParser::Assignment_patternContext* SV3_1aParser::assignment_pattern() {
  Assignment_patternContext *_localctx = _tracker.createInstance<Assignment_patternContext>(_ctx, getState());
  enterRule(_localctx, 844, SV3_1aParser::RuleAssignment_pattern);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(7080);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 819, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(7006);
      match(SV3_1aParser::TICK);
      setState(7007);
      match(SV3_1aParser::OPEN_CURLY);
      setState(7008);
      expression(0);
      setState(7013);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == SV3_1aParser::COMMA) {
        setState(7009);
        match(SV3_1aParser::COMMA);
        setState(7010);
        expression(0);
        setState(7015);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(7016);
      match(SV3_1aParser::CLOSE_CURLY);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(7018);
      match(SV3_1aParser::TICK);
      setState(7019);
      match(SV3_1aParser::OPEN_CURLY);
      setState(7020);
      structure_pattern_key();
      setState(7021);
      match(SV3_1aParser::COLON);
      setState(7022);
      expression(0);
      setState(7030);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == SV3_1aParser::COMMA) {
        setState(7023);
        match(SV3_1aParser::COMMA);
        setState(7024);
        structure_pattern_key();
        setState(7025);
        match(SV3_1aParser::COLON);
        setState(7026);
        expression(0);
        setState(7032);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(7033);
      match(SV3_1aParser::CLOSE_CURLY);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(7035);
      match(SV3_1aParser::TICK);
      setState(7036);
      match(SV3_1aParser::OPEN_CURLY);
      setState(7037);
      array_pattern_key();
      setState(7038);
      match(SV3_1aParser::COLON);
      setState(7039);
      expression(0);
      setState(7047);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == SV3_1aParser::COMMA) {
        setState(7040);
        match(SV3_1aParser::COMMA);
        setState(7041);
        array_pattern_key();
        setState(7042);
        match(SV3_1aParser::COLON);
        setState(7043);
        expression(0);
        setState(7049);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(7050);
      match(SV3_1aParser::CLOSE_CURLY);
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(7052);
      match(SV3_1aParser::TICK);
      setState(7053);
      match(SV3_1aParser::OPEN_CURLY);
      setState(7054);
      constant_expression(0);
      setState(7055);
      match(SV3_1aParser::OPEN_CURLY);
      setState(7056);
      expression(0);
      setState(7073);
      _errHandler->sync(this);
      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 818, _ctx)) {
      case 1: {
        setState(7057);
        match(SV3_1aParser::CLOSE_CURLY);
        setState(7062);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == SV3_1aParser::COMMA) {
          setState(7058);
          match(SV3_1aParser::COMMA);
          setState(7059);
          expression(0);
          setState(7064);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        break;
      }

      case 2: {
        setState(7069);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == SV3_1aParser::COMMA) {
          setState(7065);
          match(SV3_1aParser::COMMA);
          setState(7066);
          expression(0);
          setState(7071);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(7072);
        match(SV3_1aParser::CLOSE_CURLY);
        break;
      }

      default:
        break;
      }
      setState(7075);
      match(SV3_1aParser::CLOSE_CURLY);
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(7077);
      match(SV3_1aParser::TICK);
      setState(7078);
      match(SV3_1aParser::OPEN_CURLY);
      setState(7079);
      match(SV3_1aParser::CLOSE_CURLY);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Structure_pattern_keyContext ------------------------------------------------------------------

SV3_1aParser::Structure_pattern_keyContext::Structure_pattern_keyContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::IdentifierContext* SV3_1aParser::Structure_pattern_keyContext::identifier() {
  return getRuleContext<SV3_1aParser::IdentifierContext>(0);
}

SV3_1aParser::Assignment_pattern_keyContext* SV3_1aParser::Structure_pattern_keyContext::assignment_pattern_key() {
  return getRuleContext<SV3_1aParser::Assignment_pattern_keyContext>(0);
}


size_t SV3_1aParser::Structure_pattern_keyContext::getRuleIndex() const {
  return SV3_1aParser::RuleStructure_pattern_key;
}

void SV3_1aParser::Structure_pattern_keyContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterStructure_pattern_key(this);
}

void SV3_1aParser::Structure_pattern_keyContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitStructure_pattern_key(this);
}

SV3_1aParser::Structure_pattern_keyContext* SV3_1aParser::structure_pattern_key() {
  Structure_pattern_keyContext *_localctx = _tracker.createInstance<Structure_pattern_keyContext>(_ctx, getState());
  enterRule(_localctx, 846, SV3_1aParser::RuleStructure_pattern_key);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(7084);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 820, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(7082);
      identifier();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(7083);
      assignment_pattern_key();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Array_pattern_keyContext ------------------------------------------------------------------

SV3_1aParser::Array_pattern_keyContext::Array_pattern_keyContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::Constant_expressionContext* SV3_1aParser::Array_pattern_keyContext::constant_expression() {
  return getRuleContext<SV3_1aParser::Constant_expressionContext>(0);
}

SV3_1aParser::Assignment_pattern_keyContext* SV3_1aParser::Array_pattern_keyContext::assignment_pattern_key() {
  return getRuleContext<SV3_1aParser::Assignment_pattern_keyContext>(0);
}


size_t SV3_1aParser::Array_pattern_keyContext::getRuleIndex() const {
  return SV3_1aParser::RuleArray_pattern_key;
}

void SV3_1aParser::Array_pattern_keyContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterArray_pattern_key(this);
}

void SV3_1aParser::Array_pattern_keyContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitArray_pattern_key(this);
}

SV3_1aParser::Array_pattern_keyContext* SV3_1aParser::array_pattern_key() {
  Array_pattern_keyContext *_localctx = _tracker.createInstance<Array_pattern_keyContext>(_ctx, getState());
  enterRule(_localctx, 848, SV3_1aParser::RuleArray_pattern_key);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(7088);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 821, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(7086);
      constant_expression(0);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(7087);
      assignment_pattern_key();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Assignment_pattern_keyContext ------------------------------------------------------------------

SV3_1aParser::Assignment_pattern_keyContext::Assignment_pattern_keyContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::Simple_typeContext* SV3_1aParser::Assignment_pattern_keyContext::simple_type() {
  return getRuleContext<SV3_1aParser::Simple_typeContext>(0);
}

tree::TerminalNode* SV3_1aParser::Assignment_pattern_keyContext::DEFAULT() {
  return getToken(SV3_1aParser::DEFAULT, 0);
}


size_t SV3_1aParser::Assignment_pattern_keyContext::getRuleIndex() const {
  return SV3_1aParser::RuleAssignment_pattern_key;
}

void SV3_1aParser::Assignment_pattern_keyContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAssignment_pattern_key(this);
}

void SV3_1aParser::Assignment_pattern_keyContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAssignment_pattern_key(this);
}

SV3_1aParser::Assignment_pattern_keyContext* SV3_1aParser::assignment_pattern_key() {
  Assignment_pattern_keyContext *_localctx = _tracker.createInstance<Assignment_pattern_keyContext>(_ctx, getState());
  enterRule(_localctx, 850, SV3_1aParser::RuleAssignment_pattern_key);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(7092);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SV3_1aParser::LOCAL:
      case SV3_1aParser::BYTE:
      case SV3_1aParser::SHORTINT:
      case SV3_1aParser::INT:
      case SV3_1aParser::LONGINT:
      case SV3_1aParser::INTEGER:
      case SV3_1aParser::TIME:
      case SV3_1aParser::BIT:
      case SV3_1aParser::LOGIC:
      case SV3_1aParser::REG:
      case SV3_1aParser::SHORTREAL:
      case SV3_1aParser::REAL:
      case SV3_1aParser::REALTIME:
      case SV3_1aParser::DOLLAR_UNIT:
      case SV3_1aParser::THIS:
      case SV3_1aParser::RANDOMIZE:
      case SV3_1aParser::SAMPLE:
      case SV3_1aParser::Escaped_identifier:
      case SV3_1aParser::Simple_identifier: {
        enterOuterAlt(_localctx, 1);
        setState(7090);
        simple_type();
        break;
      }

      case SV3_1aParser::DEFAULT: {
        enterOuterAlt(_localctx, 2);
        setState(7091);
        match(SV3_1aParser::DEFAULT);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Assignment_pattern_expressionContext ------------------------------------------------------------------

SV3_1aParser::Assignment_pattern_expressionContext::Assignment_pattern_expressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::Assignment_patternContext* SV3_1aParser::Assignment_pattern_expressionContext::assignment_pattern() {
  return getRuleContext<SV3_1aParser::Assignment_patternContext>(0);
}

SV3_1aParser::Assignment_pattern_expression_typeContext* SV3_1aParser::Assignment_pattern_expressionContext::assignment_pattern_expression_type() {
  return getRuleContext<SV3_1aParser::Assignment_pattern_expression_typeContext>(0);
}


size_t SV3_1aParser::Assignment_pattern_expressionContext::getRuleIndex() const {
  return SV3_1aParser::RuleAssignment_pattern_expression;
}

void SV3_1aParser::Assignment_pattern_expressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAssignment_pattern_expression(this);
}

void SV3_1aParser::Assignment_pattern_expressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAssignment_pattern_expression(this);
}

SV3_1aParser::Assignment_pattern_expressionContext* SV3_1aParser::assignment_pattern_expression() {
  Assignment_pattern_expressionContext *_localctx = _tracker.createInstance<Assignment_pattern_expressionContext>(_ctx, getState());
  enterRule(_localctx, 852, SV3_1aParser::RuleAssignment_pattern_expression);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7095);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (((((_la - 64) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 64)) & 17732923532804097) != 0) || _la == SV3_1aParser::DOLLAR_UNIT || ((((_la - 326) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 326)) & 4672924483589) != 0)) {
      setState(7094);
      assignment_pattern_expression_type();
    }
    setState(7097);
    assignment_pattern();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Assignment_pattern_expression_typeContext ------------------------------------------------------------------

SV3_1aParser::Assignment_pattern_expression_typeContext::Assignment_pattern_expression_typeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::Ps_type_identifierContext* SV3_1aParser::Assignment_pattern_expression_typeContext::ps_type_identifier() {
  return getRuleContext<SV3_1aParser::Ps_type_identifierContext>(0);
}

SV3_1aParser::Ps_identifierContext* SV3_1aParser::Assignment_pattern_expression_typeContext::ps_identifier() {
  return getRuleContext<SV3_1aParser::Ps_identifierContext>(0);
}

SV3_1aParser::Integer_atom_typeContext* SV3_1aParser::Assignment_pattern_expression_typeContext::integer_atom_type() {
  return getRuleContext<SV3_1aParser::Integer_atom_typeContext>(0);
}

SV3_1aParser::Type_referenceContext* SV3_1aParser::Assignment_pattern_expression_typeContext::type_reference() {
  return getRuleContext<SV3_1aParser::Type_referenceContext>(0);
}


size_t SV3_1aParser::Assignment_pattern_expression_typeContext::getRuleIndex() const {
  return SV3_1aParser::RuleAssignment_pattern_expression_type;
}

void SV3_1aParser::Assignment_pattern_expression_typeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAssignment_pattern_expression_type(this);
}

void SV3_1aParser::Assignment_pattern_expression_typeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAssignment_pattern_expression_type(this);
}

SV3_1aParser::Assignment_pattern_expression_typeContext* SV3_1aParser::assignment_pattern_expression_type() {
  Assignment_pattern_expression_typeContext *_localctx = _tracker.createInstance<Assignment_pattern_expression_typeContext>(_ctx, getState());
  enterRule(_localctx, 854, SV3_1aParser::RuleAssignment_pattern_expression_type);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(7103);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 824, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(7099);
      ps_type_identifier();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(7100);
      ps_identifier();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(7101);
      integer_atom_type();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(7102);
      type_reference();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Constant_assignment_pattern_expressionContext ------------------------------------------------------------------

SV3_1aParser::Constant_assignment_pattern_expressionContext::Constant_assignment_pattern_expressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::Assignment_pattern_expressionContext* SV3_1aParser::Constant_assignment_pattern_expressionContext::assignment_pattern_expression() {
  return getRuleContext<SV3_1aParser::Assignment_pattern_expressionContext>(0);
}


size_t SV3_1aParser::Constant_assignment_pattern_expressionContext::getRuleIndex() const {
  return SV3_1aParser::RuleConstant_assignment_pattern_expression;
}

void SV3_1aParser::Constant_assignment_pattern_expressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterConstant_assignment_pattern_expression(this);
}

void SV3_1aParser::Constant_assignment_pattern_expressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitConstant_assignment_pattern_expression(this);
}

SV3_1aParser::Constant_assignment_pattern_expressionContext* SV3_1aParser::constant_assignment_pattern_expression() {
  Constant_assignment_pattern_expressionContext *_localctx = _tracker.createInstance<Constant_assignment_pattern_expressionContext>(_ctx, getState());
  enterRule(_localctx, 856, SV3_1aParser::RuleConstant_assignment_pattern_expression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7105);
    assignment_pattern_expression();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Assignment_pattern_net_lvalueContext ------------------------------------------------------------------

SV3_1aParser::Assignment_pattern_net_lvalueContext::Assignment_pattern_net_lvalueContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Assignment_pattern_net_lvalueContext::TICK() {
  return getToken(SV3_1aParser::TICK, 0);
}

tree::TerminalNode* SV3_1aParser::Assignment_pattern_net_lvalueContext::OPEN_CURLY() {
  return getToken(SV3_1aParser::OPEN_CURLY, 0);
}

std::vector<SV3_1aParser::Net_lvalueContext *> SV3_1aParser::Assignment_pattern_net_lvalueContext::net_lvalue() {
  return getRuleContexts<SV3_1aParser::Net_lvalueContext>();
}

SV3_1aParser::Net_lvalueContext* SV3_1aParser::Assignment_pattern_net_lvalueContext::net_lvalue(size_t i) {
  return getRuleContext<SV3_1aParser::Net_lvalueContext>(i);
}

tree::TerminalNode* SV3_1aParser::Assignment_pattern_net_lvalueContext::CLOSE_CURLY() {
  return getToken(SV3_1aParser::CLOSE_CURLY, 0);
}

std::vector<tree::TerminalNode *> SV3_1aParser::Assignment_pattern_net_lvalueContext::COMMA() {
  return getTokens(SV3_1aParser::COMMA);
}

tree::TerminalNode* SV3_1aParser::Assignment_pattern_net_lvalueContext::COMMA(size_t i) {
  return getToken(SV3_1aParser::COMMA, i);
}


size_t SV3_1aParser::Assignment_pattern_net_lvalueContext::getRuleIndex() const {
  return SV3_1aParser::RuleAssignment_pattern_net_lvalue;
}

void SV3_1aParser::Assignment_pattern_net_lvalueContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAssignment_pattern_net_lvalue(this);
}

void SV3_1aParser::Assignment_pattern_net_lvalueContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAssignment_pattern_net_lvalue(this);
}

SV3_1aParser::Assignment_pattern_net_lvalueContext* SV3_1aParser::assignment_pattern_net_lvalue() {
  Assignment_pattern_net_lvalueContext *_localctx = _tracker.createInstance<Assignment_pattern_net_lvalueContext>(_ctx, getState());
  enterRule(_localctx, 858, SV3_1aParser::RuleAssignment_pattern_net_lvalue);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7107);
    match(SV3_1aParser::TICK);
    setState(7108);
    match(SV3_1aParser::OPEN_CURLY);
    setState(7109);
    net_lvalue();
    setState(7114);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == SV3_1aParser::COMMA) {
      setState(7110);
      match(SV3_1aParser::COMMA);
      setState(7111);
      net_lvalue();
      setState(7116);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(7117);
    match(SV3_1aParser::CLOSE_CURLY);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Assignment_pattern_variable_lvalueContext ------------------------------------------------------------------

SV3_1aParser::Assignment_pattern_variable_lvalueContext::Assignment_pattern_variable_lvalueContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Assignment_pattern_variable_lvalueContext::TICK() {
  return getToken(SV3_1aParser::TICK, 0);
}

tree::TerminalNode* SV3_1aParser::Assignment_pattern_variable_lvalueContext::OPEN_CURLY() {
  return getToken(SV3_1aParser::OPEN_CURLY, 0);
}

std::vector<SV3_1aParser::Variable_lvalueContext *> SV3_1aParser::Assignment_pattern_variable_lvalueContext::variable_lvalue() {
  return getRuleContexts<SV3_1aParser::Variable_lvalueContext>();
}

SV3_1aParser::Variable_lvalueContext* SV3_1aParser::Assignment_pattern_variable_lvalueContext::variable_lvalue(size_t i) {
  return getRuleContext<SV3_1aParser::Variable_lvalueContext>(i);
}

tree::TerminalNode* SV3_1aParser::Assignment_pattern_variable_lvalueContext::CLOSE_CURLY() {
  return getToken(SV3_1aParser::CLOSE_CURLY, 0);
}

std::vector<tree::TerminalNode *> SV3_1aParser::Assignment_pattern_variable_lvalueContext::COMMA() {
  return getTokens(SV3_1aParser::COMMA);
}

tree::TerminalNode* SV3_1aParser::Assignment_pattern_variable_lvalueContext::COMMA(size_t i) {
  return getToken(SV3_1aParser::COMMA, i);
}


size_t SV3_1aParser::Assignment_pattern_variable_lvalueContext::getRuleIndex() const {
  return SV3_1aParser::RuleAssignment_pattern_variable_lvalue;
}

void SV3_1aParser::Assignment_pattern_variable_lvalueContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAssignment_pattern_variable_lvalue(this);
}

void SV3_1aParser::Assignment_pattern_variable_lvalueContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAssignment_pattern_variable_lvalue(this);
}

SV3_1aParser::Assignment_pattern_variable_lvalueContext* SV3_1aParser::assignment_pattern_variable_lvalue() {
  Assignment_pattern_variable_lvalueContext *_localctx = _tracker.createInstance<Assignment_pattern_variable_lvalueContext>(_ctx, getState());
  enterRule(_localctx, 860, SV3_1aParser::RuleAssignment_pattern_variable_lvalue);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7119);
    match(SV3_1aParser::TICK);
    setState(7120);
    match(SV3_1aParser::OPEN_CURLY);
    setState(7121);
    variable_lvalue();
    setState(7126);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == SV3_1aParser::COMMA) {
      setState(7122);
      match(SV3_1aParser::COMMA);
      setState(7123);
      variable_lvalue();
      setState(7128);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(7129);
    match(SV3_1aParser::CLOSE_CURLY);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Loop_statementContext ------------------------------------------------------------------

SV3_1aParser::Loop_statementContext::Loop_statementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Loop_statementContext::FOREVER() {
  return getToken(SV3_1aParser::FOREVER, 0);
}

SV3_1aParser::Statement_or_nullContext* SV3_1aParser::Loop_statementContext::statement_or_null() {
  return getRuleContext<SV3_1aParser::Statement_or_nullContext>(0);
}

tree::TerminalNode* SV3_1aParser::Loop_statementContext::OPEN_PARENS() {
  return getToken(SV3_1aParser::OPEN_PARENS, 0);
}

SV3_1aParser::ExpressionContext* SV3_1aParser::Loop_statementContext::expression() {
  return getRuleContext<SV3_1aParser::ExpressionContext>(0);
}

tree::TerminalNode* SV3_1aParser::Loop_statementContext::CLOSE_PARENS() {
  return getToken(SV3_1aParser::CLOSE_PARENS, 0);
}

tree::TerminalNode* SV3_1aParser::Loop_statementContext::REPEAT() {
  return getToken(SV3_1aParser::REPEAT, 0);
}

tree::TerminalNode* SV3_1aParser::Loop_statementContext::WHILE() {
  return getToken(SV3_1aParser::WHILE, 0);
}

tree::TerminalNode* SV3_1aParser::Loop_statementContext::FOR() {
  return getToken(SV3_1aParser::FOR, 0);
}

std::vector<tree::TerminalNode *> SV3_1aParser::Loop_statementContext::SEMICOLON() {
  return getTokens(SV3_1aParser::SEMICOLON);
}

tree::TerminalNode* SV3_1aParser::Loop_statementContext::SEMICOLON(size_t i) {
  return getToken(SV3_1aParser::SEMICOLON, i);
}

SV3_1aParser::For_initializationContext* SV3_1aParser::Loop_statementContext::for_initialization() {
  return getRuleContext<SV3_1aParser::For_initializationContext>(0);
}

SV3_1aParser::For_stepContext* SV3_1aParser::Loop_statementContext::for_step() {
  return getRuleContext<SV3_1aParser::For_stepContext>(0);
}

tree::TerminalNode* SV3_1aParser::Loop_statementContext::DO() {
  return getToken(SV3_1aParser::DO, 0);
}

tree::TerminalNode* SV3_1aParser::Loop_statementContext::FOREACH() {
  return getToken(SV3_1aParser::FOREACH, 0);
}

SV3_1aParser::Ps_or_hierarchical_array_identifierContext* SV3_1aParser::Loop_statementContext::ps_or_hierarchical_array_identifier() {
  return getRuleContext<SV3_1aParser::Ps_or_hierarchical_array_identifierContext>(0);
}

std::vector<tree::TerminalNode *> SV3_1aParser::Loop_statementContext::OPEN_BRACKET() {
  return getTokens(SV3_1aParser::OPEN_BRACKET);
}

tree::TerminalNode* SV3_1aParser::Loop_statementContext::OPEN_BRACKET(size_t i) {
  return getToken(SV3_1aParser::OPEN_BRACKET, i);
}

SV3_1aParser::Loop_variablesContext* SV3_1aParser::Loop_statementContext::loop_variables() {
  return getRuleContext<SV3_1aParser::Loop_variablesContext>(0);
}

std::vector<tree::TerminalNode *> SV3_1aParser::Loop_statementContext::CLOSE_BRACKET() {
  return getTokens(SV3_1aParser::CLOSE_BRACKET);
}

tree::TerminalNode* SV3_1aParser::Loop_statementContext::CLOSE_BRACKET(size_t i) {
  return getToken(SV3_1aParser::CLOSE_BRACKET, i);
}

SV3_1aParser::StatementContext* SV3_1aParser::Loop_statementContext::statement() {
  return getRuleContext<SV3_1aParser::StatementContext>(0);
}

SV3_1aParser::IdentifierContext* SV3_1aParser::Loop_statementContext::identifier() {
  return getRuleContext<SV3_1aParser::IdentifierContext>(0);
}


size_t SV3_1aParser::Loop_statementContext::getRuleIndex() const {
  return SV3_1aParser::RuleLoop_statement;
}

void SV3_1aParser::Loop_statementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLoop_statement(this);
}

void SV3_1aParser::Loop_statementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLoop_statement(this);
}

SV3_1aParser::Loop_statementContext* SV3_1aParser::loop_statement() {
  Loop_statementContext *_localctx = _tracker.createInstance<Loop_statementContext>(_ctx, getState());
  enterRule(_localctx, 862, SV3_1aParser::RuleLoop_statement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(7177);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SV3_1aParser::FOREVER: {
        enterOuterAlt(_localctx, 1);
        setState(7131);
        match(SV3_1aParser::FOREVER);
        setState(7132);
        statement_or_null();
        break;
      }

      case SV3_1aParser::REPEAT:
      case SV3_1aParser::WHILE: {
        enterOuterAlt(_localctx, 2);
        setState(7133);
        _la = _input->LA(1);
        if (!(_la == SV3_1aParser::REPEAT

        || _la == SV3_1aParser::WHILE)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        setState(7134);
        match(SV3_1aParser::OPEN_PARENS);
        setState(7135);
        expression(0);
        setState(7136);
        match(SV3_1aParser::CLOSE_PARENS);
        setState(7137);
        statement_or_null();
        break;
      }

      case SV3_1aParser::FOR: {
        enterOuterAlt(_localctx, 3);
        setState(7139);
        match(SV3_1aParser::FOR);
        setState(7140);
        match(SV3_1aParser::OPEN_PARENS);
        setState(7142);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == SV3_1aParser::VIRTUAL || ((((_la - 64) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 64)) & 1152705450574381057) != 0) || _la == SV3_1aParser::VAR

        || _la == SV3_1aParser::DOLLAR_UNIT || ((((_la - 316) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 316)) & 4785074671197185) != 0)) {
          setState(7141);
          for_initialization();
        }
        setState(7144);
        match(SV3_1aParser::SEMICOLON);
        setState(7146);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if ((((_la & ~ 0x3fULL) == 0) &&
          ((1ULL << _la) & 8796094922748) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 64)) & 1152648825725551617) != 0) || ((((_la - 147) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 147)) & 2199527096323) != 0) || _la == SV3_1aParser::BANG || ((((_la - 310) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 310)) & 559537073624154177) != 0)) {
          setState(7145);
          expression(0);
        }
        setState(7148);
        match(SV3_1aParser::SEMICOLON);
        setState(7150);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (((((_la - 64) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 64)) & 17732923535163393) != 0) || ((((_la - 166) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 166)) & 4194625) != 0) || ((((_la - 316) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 316)) & 4785074671197185) != 0)) {
          setState(7149);
          for_step();
        }
        setState(7152);
        match(SV3_1aParser::CLOSE_PARENS);
        setState(7153);
        statement_or_null();
        break;
      }

      case SV3_1aParser::DO: {
        enterOuterAlt(_localctx, 4);
        setState(7154);
        match(SV3_1aParser::DO);
        setState(7155);
        statement_or_null();
        setState(7156);
        match(SV3_1aParser::WHILE);
        setState(7157);
        match(SV3_1aParser::OPEN_PARENS);
        setState(7158);
        expression(0);
        setState(7159);
        match(SV3_1aParser::CLOSE_PARENS);
        setState(7160);
        match(SV3_1aParser::SEMICOLON);
        break;
      }

      case SV3_1aParser::FOREACH: {
        enterOuterAlt(_localctx, 5);
        setState(7162);
        match(SV3_1aParser::FOREACH);
        setState(7163);
        match(SV3_1aParser::OPEN_PARENS);
        setState(7164);
        ps_or_hierarchical_array_identifier();
        setState(7165);
        match(SV3_1aParser::OPEN_BRACKET);
        setState(7166);
        loop_variables();
        setState(7167);
        match(SV3_1aParser::CLOSE_BRACKET);
        setState(7172);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == SV3_1aParser::OPEN_BRACKET) {
          setState(7168);
          match(SV3_1aParser::OPEN_BRACKET);
          setState(7169);
          identifier();
          setState(7170);
          match(SV3_1aParser::CLOSE_BRACKET);
        }
        setState(7174);
        match(SV3_1aParser::CLOSE_PARENS);
        setState(7175);
        statement();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- For_initializationContext ------------------------------------------------------------------

SV3_1aParser::For_initializationContext::For_initializationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::List_of_variable_assignmentsContext* SV3_1aParser::For_initializationContext::list_of_variable_assignments() {
  return getRuleContext<SV3_1aParser::List_of_variable_assignmentsContext>(0);
}

std::vector<SV3_1aParser::For_variable_declarationContext *> SV3_1aParser::For_initializationContext::for_variable_declaration() {
  return getRuleContexts<SV3_1aParser::For_variable_declarationContext>();
}

SV3_1aParser::For_variable_declarationContext* SV3_1aParser::For_initializationContext::for_variable_declaration(size_t i) {
  return getRuleContext<SV3_1aParser::For_variable_declarationContext>(i);
}

std::vector<tree::TerminalNode *> SV3_1aParser::For_initializationContext::COMMA() {
  return getTokens(SV3_1aParser::COMMA);
}

tree::TerminalNode* SV3_1aParser::For_initializationContext::COMMA(size_t i) {
  return getToken(SV3_1aParser::COMMA, i);
}


size_t SV3_1aParser::For_initializationContext::getRuleIndex() const {
  return SV3_1aParser::RuleFor_initialization;
}

void SV3_1aParser::For_initializationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFor_initialization(this);
}

void SV3_1aParser::For_initializationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFor_initialization(this);
}

SV3_1aParser::For_initializationContext* SV3_1aParser::for_initialization() {
  For_initializationContext *_localctx = _tracker.createInstance<For_initializationContext>(_ctx, getState());
  enterRule(_localctx, 864, SV3_1aParser::RuleFor_initialization);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(7188);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 833, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(7179);
      list_of_variable_assignments();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(7180);
      for_variable_declaration();
      setState(7185);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == SV3_1aParser::COMMA) {
        setState(7181);
        match(SV3_1aParser::COMMA);
        setState(7182);
        for_variable_declaration();
        setState(7187);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- For_variable_declarationContext ------------------------------------------------------------------

SV3_1aParser::For_variable_declarationContext::For_variable_declarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::Data_typeContext* SV3_1aParser::For_variable_declarationContext::data_type() {
  return getRuleContext<SV3_1aParser::Data_typeContext>(0);
}

std::vector<SV3_1aParser::IdentifierContext *> SV3_1aParser::For_variable_declarationContext::identifier() {
  return getRuleContexts<SV3_1aParser::IdentifierContext>();
}

SV3_1aParser::IdentifierContext* SV3_1aParser::For_variable_declarationContext::identifier(size_t i) {
  return getRuleContext<SV3_1aParser::IdentifierContext>(i);
}

std::vector<tree::TerminalNode *> SV3_1aParser::For_variable_declarationContext::ASSIGN_OP() {
  return getTokens(SV3_1aParser::ASSIGN_OP);
}

tree::TerminalNode* SV3_1aParser::For_variable_declarationContext::ASSIGN_OP(size_t i) {
  return getToken(SV3_1aParser::ASSIGN_OP, i);
}

std::vector<SV3_1aParser::ExpressionContext *> SV3_1aParser::For_variable_declarationContext::expression() {
  return getRuleContexts<SV3_1aParser::ExpressionContext>();
}

SV3_1aParser::ExpressionContext* SV3_1aParser::For_variable_declarationContext::expression(size_t i) {
  return getRuleContext<SV3_1aParser::ExpressionContext>(i);
}

tree::TerminalNode* SV3_1aParser::For_variable_declarationContext::VAR() {
  return getToken(SV3_1aParser::VAR, 0);
}

std::vector<tree::TerminalNode *> SV3_1aParser::For_variable_declarationContext::COMMA() {
  return getTokens(SV3_1aParser::COMMA);
}

tree::TerminalNode* SV3_1aParser::For_variable_declarationContext::COMMA(size_t i) {
  return getToken(SV3_1aParser::COMMA, i);
}


size_t SV3_1aParser::For_variable_declarationContext::getRuleIndex() const {
  return SV3_1aParser::RuleFor_variable_declaration;
}

void SV3_1aParser::For_variable_declarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFor_variable_declaration(this);
}

void SV3_1aParser::For_variable_declarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFor_variable_declaration(this);
}

SV3_1aParser::For_variable_declarationContext* SV3_1aParser::for_variable_declaration() {
  For_variable_declarationContext *_localctx = _tracker.createInstance<For_variable_declarationContext>(_ctx, getState());
  enterRule(_localctx, 866, SV3_1aParser::RuleFor_variable_declaration);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(7191);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SV3_1aParser::VAR) {
      setState(7190);
      match(SV3_1aParser::VAR);
    }
    setState(7193);
    data_type();
    setState(7194);
    identifier();
    setState(7195);
    match(SV3_1aParser::ASSIGN_OP);
    setState(7196);
    expression(0);
    setState(7204);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 835, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(7197);
        match(SV3_1aParser::COMMA);
        setState(7198);
        identifier();
        setState(7199);
        match(SV3_1aParser::ASSIGN_OP);
        setState(7200);
        expression(0); 
      }
      setState(7206);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 835, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- For_stepContext ------------------------------------------------------------------

SV3_1aParser::For_stepContext::For_stepContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<SV3_1aParser::For_step_assignmentContext *> SV3_1aParser::For_stepContext::for_step_assignment() {
  return getRuleContexts<SV3_1aParser::For_step_assignmentContext>();
}

SV3_1aParser::For_step_assignmentContext* SV3_1aParser::For_stepContext::for_step_assignment(size_t i) {
  return getRuleContext<SV3_1aParser::For_step_assignmentContext>(i);
}

std::vector<tree::TerminalNode *> SV3_1aParser::For_stepContext::COMMA() {
  return getTokens(SV3_1aParser::COMMA);
}

tree::TerminalNode* SV3_1aParser::For_stepContext::COMMA(size_t i) {
  return getToken(SV3_1aParser::COMMA, i);
}


size_t SV3_1aParser::For_stepContext::getRuleIndex() const {
  return SV3_1aParser::RuleFor_step;
}

void SV3_1aParser::For_stepContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFor_step(this);
}

void SV3_1aParser::For_stepContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFor_step(this);
}

SV3_1aParser::For_stepContext* SV3_1aParser::for_step() {
  For_stepContext *_localctx = _tracker.createInstance<For_stepContext>(_ctx, getState());
  enterRule(_localctx, 868, SV3_1aParser::RuleFor_step);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7207);
    for_step_assignment();
    setState(7212);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == SV3_1aParser::COMMA) {
      setState(7208);
      match(SV3_1aParser::COMMA);
      setState(7209);
      for_step_assignment();
      setState(7214);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- For_step_assignmentContext ------------------------------------------------------------------

SV3_1aParser::For_step_assignmentContext::For_step_assignmentContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::Operator_assignmentContext* SV3_1aParser::For_step_assignmentContext::operator_assignment() {
  return getRuleContext<SV3_1aParser::Operator_assignmentContext>(0);
}

SV3_1aParser::Inc_or_dec_expressionContext* SV3_1aParser::For_step_assignmentContext::inc_or_dec_expression() {
  return getRuleContext<SV3_1aParser::Inc_or_dec_expressionContext>(0);
}

SV3_1aParser::Subroutine_callContext* SV3_1aParser::For_step_assignmentContext::subroutine_call() {
  return getRuleContext<SV3_1aParser::Subroutine_callContext>(0);
}


size_t SV3_1aParser::For_step_assignmentContext::getRuleIndex() const {
  return SV3_1aParser::RuleFor_step_assignment;
}

void SV3_1aParser::For_step_assignmentContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFor_step_assignment(this);
}

void SV3_1aParser::For_step_assignmentContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFor_step_assignment(this);
}

SV3_1aParser::For_step_assignmentContext* SV3_1aParser::for_step_assignment() {
  For_step_assignmentContext *_localctx = _tracker.createInstance<For_step_assignmentContext>(_ctx, getState());
  enterRule(_localctx, 870, SV3_1aParser::RuleFor_step_assignment);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(7218);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 837, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(7215);
      operator_assignment();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(7216);
      inc_or_dec_expression();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(7217);
      subroutine_call();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CommaContext ------------------------------------------------------------------

SV3_1aParser::CommaContext::CommaContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::CommaContext::COMMA() {
  return getToken(SV3_1aParser::COMMA, 0);
}


size_t SV3_1aParser::CommaContext::getRuleIndex() const {
  return SV3_1aParser::RuleComma;
}

void SV3_1aParser::CommaContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterComma(this);
}

void SV3_1aParser::CommaContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitComma(this);
}

SV3_1aParser::CommaContext* SV3_1aParser::comma() {
  CommaContext *_localctx = _tracker.createInstance<CommaContext>(_ctx, getState());
  enterRule(_localctx, 872, SV3_1aParser::RuleComma);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7220);
    match(SV3_1aParser::COMMA);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Loop_variablesContext ------------------------------------------------------------------

SV3_1aParser::Loop_variablesContext::Loop_variablesContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<SV3_1aParser::IdentifierContext *> SV3_1aParser::Loop_variablesContext::identifier() {
  return getRuleContexts<SV3_1aParser::IdentifierContext>();
}

SV3_1aParser::IdentifierContext* SV3_1aParser::Loop_variablesContext::identifier(size_t i) {
  return getRuleContext<SV3_1aParser::IdentifierContext>(i);
}

std::vector<SV3_1aParser::CommaContext *> SV3_1aParser::Loop_variablesContext::comma() {
  return getRuleContexts<SV3_1aParser::CommaContext>();
}

SV3_1aParser::CommaContext* SV3_1aParser::Loop_variablesContext::comma(size_t i) {
  return getRuleContext<SV3_1aParser::CommaContext>(i);
}


size_t SV3_1aParser::Loop_variablesContext::getRuleIndex() const {
  return SV3_1aParser::RuleLoop_variables;
}

void SV3_1aParser::Loop_variablesContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLoop_variables(this);
}

void SV3_1aParser::Loop_variablesContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLoop_variables(this);
}

SV3_1aParser::Loop_variablesContext* SV3_1aParser::loop_variables() {
  Loop_variablesContext *_localctx = _tracker.createInstance<Loop_variablesContext>(_ctx, getState());
  enterRule(_localctx, 874, SV3_1aParser::RuleLoop_variables);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7223);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (((((_la - 326) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 326)) & 4672924483589) != 0)) {
      setState(7222);
      identifier();
    }
    setState(7231);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == SV3_1aParser::COMMA) {
      setState(7225);
      comma();
      setState(7227);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (((((_la - 326) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 326)) & 4672924483589) != 0)) {
        setState(7226);
        identifier();
      }
      setState(7233);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Subroutine_call_statementContext ------------------------------------------------------------------

SV3_1aParser::Subroutine_call_statementContext::Subroutine_call_statementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::Subroutine_callContext* SV3_1aParser::Subroutine_call_statementContext::subroutine_call() {
  return getRuleContext<SV3_1aParser::Subroutine_callContext>(0);
}

tree::TerminalNode* SV3_1aParser::Subroutine_call_statementContext::SEMICOLON() {
  return getToken(SV3_1aParser::SEMICOLON, 0);
}

tree::TerminalNode* SV3_1aParser::Subroutine_call_statementContext::VOID() {
  return getToken(SV3_1aParser::VOID, 0);
}

tree::TerminalNode* SV3_1aParser::Subroutine_call_statementContext::TICK() {
  return getToken(SV3_1aParser::TICK, 0);
}

tree::TerminalNode* SV3_1aParser::Subroutine_call_statementContext::OPEN_PARENS() {
  return getToken(SV3_1aParser::OPEN_PARENS, 0);
}

tree::TerminalNode* SV3_1aParser::Subroutine_call_statementContext::CLOSE_PARENS() {
  return getToken(SV3_1aParser::CLOSE_PARENS, 0);
}


size_t SV3_1aParser::Subroutine_call_statementContext::getRuleIndex() const {
  return SV3_1aParser::RuleSubroutine_call_statement;
}

void SV3_1aParser::Subroutine_call_statementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSubroutine_call_statement(this);
}

void SV3_1aParser::Subroutine_call_statementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSubroutine_call_statement(this);
}

SV3_1aParser::Subroutine_call_statementContext* SV3_1aParser::subroutine_call_statement() {
  Subroutine_call_statementContext *_localctx = _tracker.createInstance<Subroutine_call_statementContext>(_ctx, getState());
  enterRule(_localctx, 876, SV3_1aParser::RuleSubroutine_call_statement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(7244);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SV3_1aParser::SUPER:
      case SV3_1aParser::DOLLAR:
      case SV3_1aParser::DOLLAR_UNIT:
      case SV3_1aParser::THIS:
      case SV3_1aParser::DOLLAR_ROOT:
      case SV3_1aParser::RANDOMIZE:
      case SV3_1aParser::SAMPLE:
      case SV3_1aParser::Escaped_identifier:
      case SV3_1aParser::Simple_identifier: {
        enterOuterAlt(_localctx, 1);
        setState(7234);
        subroutine_call();
        setState(7235);
        match(SV3_1aParser::SEMICOLON);
        break;
      }

      case SV3_1aParser::VOID: {
        enterOuterAlt(_localctx, 2);
        setState(7237);
        match(SV3_1aParser::VOID);
        setState(7238);
        match(SV3_1aParser::TICK);
        setState(7239);
        match(SV3_1aParser::OPEN_PARENS);
        setState(7240);
        subroutine_call();
        setState(7241);
        match(SV3_1aParser::CLOSE_PARENS);
        setState(7242);
        match(SV3_1aParser::SEMICOLON);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Assertion_itemContext ------------------------------------------------------------------

SV3_1aParser::Assertion_itemContext::Assertion_itemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::Concurrent_assertion_itemContext* SV3_1aParser::Assertion_itemContext::concurrent_assertion_item() {
  return getRuleContext<SV3_1aParser::Concurrent_assertion_itemContext>(0);
}

SV3_1aParser::Deferred_immediate_assertion_itemContext* SV3_1aParser::Assertion_itemContext::deferred_immediate_assertion_item() {
  return getRuleContext<SV3_1aParser::Deferred_immediate_assertion_itemContext>(0);
}


size_t SV3_1aParser::Assertion_itemContext::getRuleIndex() const {
  return SV3_1aParser::RuleAssertion_item;
}

void SV3_1aParser::Assertion_itemContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAssertion_item(this);
}

void SV3_1aParser::Assertion_itemContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAssertion_item(this);
}

SV3_1aParser::Assertion_itemContext* SV3_1aParser::assertion_item() {
  Assertion_itemContext *_localctx = _tracker.createInstance<Assertion_itemContext>(_ctx, getState());
  enterRule(_localctx, 878, SV3_1aParser::RuleAssertion_item);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(7248);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 842, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(7246);
      concurrent_assertion_item();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(7247);
      deferred_immediate_assertion_item();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Deferred_immediate_assertion_itemContext ------------------------------------------------------------------

SV3_1aParser::Deferred_immediate_assertion_itemContext::Deferred_immediate_assertion_itemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::Deferred_immediate_assertion_statementContext* SV3_1aParser::Deferred_immediate_assertion_itemContext::deferred_immediate_assertion_statement() {
  return getRuleContext<SV3_1aParser::Deferred_immediate_assertion_statementContext>(0);
}

SV3_1aParser::IdentifierContext* SV3_1aParser::Deferred_immediate_assertion_itemContext::identifier() {
  return getRuleContext<SV3_1aParser::IdentifierContext>(0);
}

tree::TerminalNode* SV3_1aParser::Deferred_immediate_assertion_itemContext::COLON() {
  return getToken(SV3_1aParser::COLON, 0);
}


size_t SV3_1aParser::Deferred_immediate_assertion_itemContext::getRuleIndex() const {
  return SV3_1aParser::RuleDeferred_immediate_assertion_item;
}

void SV3_1aParser::Deferred_immediate_assertion_itemContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDeferred_immediate_assertion_item(this);
}

void SV3_1aParser::Deferred_immediate_assertion_itemContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDeferred_immediate_assertion_item(this);
}

SV3_1aParser::Deferred_immediate_assertion_itemContext* SV3_1aParser::deferred_immediate_assertion_item() {
  Deferred_immediate_assertion_itemContext *_localctx = _tracker.createInstance<Deferred_immediate_assertion_itemContext>(_ctx, getState());
  enterRule(_localctx, 880, SV3_1aParser::RuleDeferred_immediate_assertion_item);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7253);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (((((_la - 326) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 326)) & 4672924483589) != 0)) {
      setState(7250);
      identifier();
      setState(7251);
      match(SV3_1aParser::COLON);
    }
    setState(7255);
    deferred_immediate_assertion_statement();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Procedural_assertion_statementContext ------------------------------------------------------------------

SV3_1aParser::Procedural_assertion_statementContext::Procedural_assertion_statementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::Concurrent_assertion_statementContext* SV3_1aParser::Procedural_assertion_statementContext::concurrent_assertion_statement() {
  return getRuleContext<SV3_1aParser::Concurrent_assertion_statementContext>(0);
}

SV3_1aParser::Immediate_assertion_statementContext* SV3_1aParser::Procedural_assertion_statementContext::immediate_assertion_statement() {
  return getRuleContext<SV3_1aParser::Immediate_assertion_statementContext>(0);
}

SV3_1aParser::Checker_instantiationContext* SV3_1aParser::Procedural_assertion_statementContext::checker_instantiation() {
  return getRuleContext<SV3_1aParser::Checker_instantiationContext>(0);
}


size_t SV3_1aParser::Procedural_assertion_statementContext::getRuleIndex() const {
  return SV3_1aParser::RuleProcedural_assertion_statement;
}

void SV3_1aParser::Procedural_assertion_statementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterProcedural_assertion_statement(this);
}

void SV3_1aParser::Procedural_assertion_statementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitProcedural_assertion_statement(this);
}

SV3_1aParser::Procedural_assertion_statementContext* SV3_1aParser::procedural_assertion_statement() {
  Procedural_assertion_statementContext *_localctx = _tracker.createInstance<Procedural_assertion_statementContext>(_ctx, getState());
  enterRule(_localctx, 882, SV3_1aParser::RuleProcedural_assertion_statement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(7260);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 844, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(7257);
      concurrent_assertion_statement();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(7258);
      immediate_assertion_statement();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(7259);
      checker_instantiation();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Immediate_assertion_statementContext ------------------------------------------------------------------

SV3_1aParser::Immediate_assertion_statementContext::Immediate_assertion_statementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::Simple_immediate_assertion_statementContext* SV3_1aParser::Immediate_assertion_statementContext::simple_immediate_assertion_statement() {
  return getRuleContext<SV3_1aParser::Simple_immediate_assertion_statementContext>(0);
}

SV3_1aParser::Deferred_immediate_assertion_statementContext* SV3_1aParser::Immediate_assertion_statementContext::deferred_immediate_assertion_statement() {
  return getRuleContext<SV3_1aParser::Deferred_immediate_assertion_statementContext>(0);
}


size_t SV3_1aParser::Immediate_assertion_statementContext::getRuleIndex() const {
  return SV3_1aParser::RuleImmediate_assertion_statement;
}

void SV3_1aParser::Immediate_assertion_statementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterImmediate_assertion_statement(this);
}

void SV3_1aParser::Immediate_assertion_statementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitImmediate_assertion_statement(this);
}

SV3_1aParser::Immediate_assertion_statementContext* SV3_1aParser::immediate_assertion_statement() {
  Immediate_assertion_statementContext *_localctx = _tracker.createInstance<Immediate_assertion_statementContext>(_ctx, getState());
  enterRule(_localctx, 884, SV3_1aParser::RuleImmediate_assertion_statement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(7264);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 845, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(7262);
      simple_immediate_assertion_statement();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(7263);
      deferred_immediate_assertion_statement();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Simple_immediate_assertion_statementContext ------------------------------------------------------------------

SV3_1aParser::Simple_immediate_assertion_statementContext::Simple_immediate_assertion_statementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::Simple_immediate_assert_statementContext* SV3_1aParser::Simple_immediate_assertion_statementContext::simple_immediate_assert_statement() {
  return getRuleContext<SV3_1aParser::Simple_immediate_assert_statementContext>(0);
}

SV3_1aParser::Simple_immediate_assume_statementContext* SV3_1aParser::Simple_immediate_assertion_statementContext::simple_immediate_assume_statement() {
  return getRuleContext<SV3_1aParser::Simple_immediate_assume_statementContext>(0);
}

SV3_1aParser::Simple_immediate_cover_statementContext* SV3_1aParser::Simple_immediate_assertion_statementContext::simple_immediate_cover_statement() {
  return getRuleContext<SV3_1aParser::Simple_immediate_cover_statementContext>(0);
}


size_t SV3_1aParser::Simple_immediate_assertion_statementContext::getRuleIndex() const {
  return SV3_1aParser::RuleSimple_immediate_assertion_statement;
}

void SV3_1aParser::Simple_immediate_assertion_statementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSimple_immediate_assertion_statement(this);
}

void SV3_1aParser::Simple_immediate_assertion_statementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSimple_immediate_assertion_statement(this);
}

SV3_1aParser::Simple_immediate_assertion_statementContext* SV3_1aParser::simple_immediate_assertion_statement() {
  Simple_immediate_assertion_statementContext *_localctx = _tracker.createInstance<Simple_immediate_assertion_statementContext>(_ctx, getState());
  enterRule(_localctx, 886, SV3_1aParser::RuleSimple_immediate_assertion_statement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(7269);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SV3_1aParser::ASSERT: {
        enterOuterAlt(_localctx, 1);
        setState(7266);
        simple_immediate_assert_statement();
        break;
      }

      case SV3_1aParser::ASSUME: {
        enterOuterAlt(_localctx, 2);
        setState(7267);
        simple_immediate_assume_statement();
        break;
      }

      case SV3_1aParser::COVER: {
        enterOuterAlt(_localctx, 3);
        setState(7268);
        simple_immediate_cover_statement();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Simple_immediate_assert_statementContext ------------------------------------------------------------------

SV3_1aParser::Simple_immediate_assert_statementContext::Simple_immediate_assert_statementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Simple_immediate_assert_statementContext::ASSERT() {
  return getToken(SV3_1aParser::ASSERT, 0);
}

tree::TerminalNode* SV3_1aParser::Simple_immediate_assert_statementContext::OPEN_PARENS() {
  return getToken(SV3_1aParser::OPEN_PARENS, 0);
}

SV3_1aParser::ExpressionContext* SV3_1aParser::Simple_immediate_assert_statementContext::expression() {
  return getRuleContext<SV3_1aParser::ExpressionContext>(0);
}

tree::TerminalNode* SV3_1aParser::Simple_immediate_assert_statementContext::CLOSE_PARENS() {
  return getToken(SV3_1aParser::CLOSE_PARENS, 0);
}

SV3_1aParser::Action_blockContext* SV3_1aParser::Simple_immediate_assert_statementContext::action_block() {
  return getRuleContext<SV3_1aParser::Action_blockContext>(0);
}


size_t SV3_1aParser::Simple_immediate_assert_statementContext::getRuleIndex() const {
  return SV3_1aParser::RuleSimple_immediate_assert_statement;
}

void SV3_1aParser::Simple_immediate_assert_statementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSimple_immediate_assert_statement(this);
}

void SV3_1aParser::Simple_immediate_assert_statementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSimple_immediate_assert_statement(this);
}

SV3_1aParser::Simple_immediate_assert_statementContext* SV3_1aParser::simple_immediate_assert_statement() {
  Simple_immediate_assert_statementContext *_localctx = _tracker.createInstance<Simple_immediate_assert_statementContext>(_ctx, getState());
  enterRule(_localctx, 888, SV3_1aParser::RuleSimple_immediate_assert_statement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7271);
    match(SV3_1aParser::ASSERT);
    setState(7272);
    match(SV3_1aParser::OPEN_PARENS);
    setState(7273);
    expression(0);
    setState(7274);
    match(SV3_1aParser::CLOSE_PARENS);
    setState(7275);
    action_block();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Simple_immediate_assume_statementContext ------------------------------------------------------------------

SV3_1aParser::Simple_immediate_assume_statementContext::Simple_immediate_assume_statementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Simple_immediate_assume_statementContext::ASSUME() {
  return getToken(SV3_1aParser::ASSUME, 0);
}

tree::TerminalNode* SV3_1aParser::Simple_immediate_assume_statementContext::OPEN_PARENS() {
  return getToken(SV3_1aParser::OPEN_PARENS, 0);
}

SV3_1aParser::ExpressionContext* SV3_1aParser::Simple_immediate_assume_statementContext::expression() {
  return getRuleContext<SV3_1aParser::ExpressionContext>(0);
}

tree::TerminalNode* SV3_1aParser::Simple_immediate_assume_statementContext::CLOSE_PARENS() {
  return getToken(SV3_1aParser::CLOSE_PARENS, 0);
}

SV3_1aParser::Action_blockContext* SV3_1aParser::Simple_immediate_assume_statementContext::action_block() {
  return getRuleContext<SV3_1aParser::Action_blockContext>(0);
}


size_t SV3_1aParser::Simple_immediate_assume_statementContext::getRuleIndex() const {
  return SV3_1aParser::RuleSimple_immediate_assume_statement;
}

void SV3_1aParser::Simple_immediate_assume_statementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSimple_immediate_assume_statement(this);
}

void SV3_1aParser::Simple_immediate_assume_statementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSimple_immediate_assume_statement(this);
}

SV3_1aParser::Simple_immediate_assume_statementContext* SV3_1aParser::simple_immediate_assume_statement() {
  Simple_immediate_assume_statementContext *_localctx = _tracker.createInstance<Simple_immediate_assume_statementContext>(_ctx, getState());
  enterRule(_localctx, 890, SV3_1aParser::RuleSimple_immediate_assume_statement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7277);
    match(SV3_1aParser::ASSUME);
    setState(7278);
    match(SV3_1aParser::OPEN_PARENS);
    setState(7279);
    expression(0);
    setState(7280);
    match(SV3_1aParser::CLOSE_PARENS);
    setState(7281);
    action_block();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Simple_immediate_cover_statementContext ------------------------------------------------------------------

SV3_1aParser::Simple_immediate_cover_statementContext::Simple_immediate_cover_statementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Simple_immediate_cover_statementContext::COVER() {
  return getToken(SV3_1aParser::COVER, 0);
}

tree::TerminalNode* SV3_1aParser::Simple_immediate_cover_statementContext::OPEN_PARENS() {
  return getToken(SV3_1aParser::OPEN_PARENS, 0);
}

SV3_1aParser::ExpressionContext* SV3_1aParser::Simple_immediate_cover_statementContext::expression() {
  return getRuleContext<SV3_1aParser::ExpressionContext>(0);
}

tree::TerminalNode* SV3_1aParser::Simple_immediate_cover_statementContext::CLOSE_PARENS() {
  return getToken(SV3_1aParser::CLOSE_PARENS, 0);
}

SV3_1aParser::Statement_or_nullContext* SV3_1aParser::Simple_immediate_cover_statementContext::statement_or_null() {
  return getRuleContext<SV3_1aParser::Statement_or_nullContext>(0);
}


size_t SV3_1aParser::Simple_immediate_cover_statementContext::getRuleIndex() const {
  return SV3_1aParser::RuleSimple_immediate_cover_statement;
}

void SV3_1aParser::Simple_immediate_cover_statementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSimple_immediate_cover_statement(this);
}

void SV3_1aParser::Simple_immediate_cover_statementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSimple_immediate_cover_statement(this);
}

SV3_1aParser::Simple_immediate_cover_statementContext* SV3_1aParser::simple_immediate_cover_statement() {
  Simple_immediate_cover_statementContext *_localctx = _tracker.createInstance<Simple_immediate_cover_statementContext>(_ctx, getState());
  enterRule(_localctx, 892, SV3_1aParser::RuleSimple_immediate_cover_statement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7283);
    match(SV3_1aParser::COVER);
    setState(7284);
    match(SV3_1aParser::OPEN_PARENS);
    setState(7285);
    expression(0);
    setState(7286);
    match(SV3_1aParser::CLOSE_PARENS);
    setState(7287);
    statement_or_null();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Deferred_immediate_assertion_statementContext ------------------------------------------------------------------

SV3_1aParser::Deferred_immediate_assertion_statementContext::Deferred_immediate_assertion_statementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::Deferred_immediate_assert_statementContext* SV3_1aParser::Deferred_immediate_assertion_statementContext::deferred_immediate_assert_statement() {
  return getRuleContext<SV3_1aParser::Deferred_immediate_assert_statementContext>(0);
}

SV3_1aParser::Deferred_immediate_assume_statementContext* SV3_1aParser::Deferred_immediate_assertion_statementContext::deferred_immediate_assume_statement() {
  return getRuleContext<SV3_1aParser::Deferred_immediate_assume_statementContext>(0);
}

SV3_1aParser::Deferred_immediate_cover_statementContext* SV3_1aParser::Deferred_immediate_assertion_statementContext::deferred_immediate_cover_statement() {
  return getRuleContext<SV3_1aParser::Deferred_immediate_cover_statementContext>(0);
}


size_t SV3_1aParser::Deferred_immediate_assertion_statementContext::getRuleIndex() const {
  return SV3_1aParser::RuleDeferred_immediate_assertion_statement;
}

void SV3_1aParser::Deferred_immediate_assertion_statementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDeferred_immediate_assertion_statement(this);
}

void SV3_1aParser::Deferred_immediate_assertion_statementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDeferred_immediate_assertion_statement(this);
}

SV3_1aParser::Deferred_immediate_assertion_statementContext* SV3_1aParser::deferred_immediate_assertion_statement() {
  Deferred_immediate_assertion_statementContext *_localctx = _tracker.createInstance<Deferred_immediate_assertion_statementContext>(_ctx, getState());
  enterRule(_localctx, 894, SV3_1aParser::RuleDeferred_immediate_assertion_statement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(7292);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SV3_1aParser::ASSERT: {
        enterOuterAlt(_localctx, 1);
        setState(7289);
        deferred_immediate_assert_statement();
        break;
      }

      case SV3_1aParser::ASSUME: {
        enterOuterAlt(_localctx, 2);
        setState(7290);
        deferred_immediate_assume_statement();
        break;
      }

      case SV3_1aParser::COVER: {
        enterOuterAlt(_localctx, 3);
        setState(7291);
        deferred_immediate_cover_statement();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Deferred_immediate_assert_statementContext ------------------------------------------------------------------

SV3_1aParser::Deferred_immediate_assert_statementContext::Deferred_immediate_assert_statementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Deferred_immediate_assert_statementContext::ASSERT() {
  return getToken(SV3_1aParser::ASSERT, 0);
}

tree::TerminalNode* SV3_1aParser::Deferred_immediate_assert_statementContext::OPEN_PARENS() {
  return getToken(SV3_1aParser::OPEN_PARENS, 0);
}

SV3_1aParser::ExpressionContext* SV3_1aParser::Deferred_immediate_assert_statementContext::expression() {
  return getRuleContext<SV3_1aParser::ExpressionContext>(0);
}

tree::TerminalNode* SV3_1aParser::Deferred_immediate_assert_statementContext::CLOSE_PARENS() {
  return getToken(SV3_1aParser::CLOSE_PARENS, 0);
}

SV3_1aParser::Action_blockContext* SV3_1aParser::Deferred_immediate_assert_statementContext::action_block() {
  return getRuleContext<SV3_1aParser::Action_blockContext>(0);
}

tree::TerminalNode* SV3_1aParser::Deferred_immediate_assert_statementContext::Pound_Pound_delay() {
  return getToken(SV3_1aParser::Pound_Pound_delay, 0);
}

tree::TerminalNode* SV3_1aParser::Deferred_immediate_assert_statementContext::Pound_delay() {
  return getToken(SV3_1aParser::Pound_delay, 0);
}

tree::TerminalNode* SV3_1aParser::Deferred_immediate_assert_statementContext::FINAL() {
  return getToken(SV3_1aParser::FINAL, 0);
}


size_t SV3_1aParser::Deferred_immediate_assert_statementContext::getRuleIndex() const {
  return SV3_1aParser::RuleDeferred_immediate_assert_statement;
}

void SV3_1aParser::Deferred_immediate_assert_statementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDeferred_immediate_assert_statement(this);
}

void SV3_1aParser::Deferred_immediate_assert_statementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDeferred_immediate_assert_statement(this);
}

SV3_1aParser::Deferred_immediate_assert_statementContext* SV3_1aParser::deferred_immediate_assert_statement() {
  Deferred_immediate_assert_statementContext *_localctx = _tracker.createInstance<Deferred_immediate_assert_statementContext>(_ctx, getState());
  enterRule(_localctx, 896, SV3_1aParser::RuleDeferred_immediate_assert_statement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(7306);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 848, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(7294);
      match(SV3_1aParser::ASSERT);
      setState(7295);
      _la = _input->LA(1);
      if (!(_la == SV3_1aParser::Pound_Pound_delay

      || _la == SV3_1aParser::Pound_delay)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(7296);
      match(SV3_1aParser::OPEN_PARENS);
      setState(7297);
      expression(0);
      setState(7298);
      match(SV3_1aParser::CLOSE_PARENS);
      setState(7299);
      action_block();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(7301);
      match(SV3_1aParser::ASSERT);
      setState(7302);
      match(SV3_1aParser::FINAL);

      setState(7303);
      expression(0);
      setState(7304);
      action_block();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Deferred_immediate_assume_statementContext ------------------------------------------------------------------

SV3_1aParser::Deferred_immediate_assume_statementContext::Deferred_immediate_assume_statementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Deferred_immediate_assume_statementContext::ASSUME() {
  return getToken(SV3_1aParser::ASSUME, 0);
}

tree::TerminalNode* SV3_1aParser::Deferred_immediate_assume_statementContext::OPEN_PARENS() {
  return getToken(SV3_1aParser::OPEN_PARENS, 0);
}

SV3_1aParser::ExpressionContext* SV3_1aParser::Deferred_immediate_assume_statementContext::expression() {
  return getRuleContext<SV3_1aParser::ExpressionContext>(0);
}

tree::TerminalNode* SV3_1aParser::Deferred_immediate_assume_statementContext::CLOSE_PARENS() {
  return getToken(SV3_1aParser::CLOSE_PARENS, 0);
}

SV3_1aParser::Action_blockContext* SV3_1aParser::Deferred_immediate_assume_statementContext::action_block() {
  return getRuleContext<SV3_1aParser::Action_blockContext>(0);
}

tree::TerminalNode* SV3_1aParser::Deferred_immediate_assume_statementContext::Pound_Pound_delay() {
  return getToken(SV3_1aParser::Pound_Pound_delay, 0);
}

tree::TerminalNode* SV3_1aParser::Deferred_immediate_assume_statementContext::Pound_delay() {
  return getToken(SV3_1aParser::Pound_delay, 0);
}

tree::TerminalNode* SV3_1aParser::Deferred_immediate_assume_statementContext::FINAL() {
  return getToken(SV3_1aParser::FINAL, 0);
}


size_t SV3_1aParser::Deferred_immediate_assume_statementContext::getRuleIndex() const {
  return SV3_1aParser::RuleDeferred_immediate_assume_statement;
}

void SV3_1aParser::Deferred_immediate_assume_statementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDeferred_immediate_assume_statement(this);
}

void SV3_1aParser::Deferred_immediate_assume_statementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDeferred_immediate_assume_statement(this);
}

SV3_1aParser::Deferred_immediate_assume_statementContext* SV3_1aParser::deferred_immediate_assume_statement() {
  Deferred_immediate_assume_statementContext *_localctx = _tracker.createInstance<Deferred_immediate_assume_statementContext>(_ctx, getState());
  enterRule(_localctx, 898, SV3_1aParser::RuleDeferred_immediate_assume_statement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(7322);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 849, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(7308);
      match(SV3_1aParser::ASSUME);
      setState(7309);
      _la = _input->LA(1);
      if (!(_la == SV3_1aParser::Pound_Pound_delay

      || _la == SV3_1aParser::Pound_delay)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(7310);
      match(SV3_1aParser::OPEN_PARENS);
      setState(7311);
      expression(0);
      setState(7312);
      match(SV3_1aParser::CLOSE_PARENS);
      setState(7313);
      action_block();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(7315);
      match(SV3_1aParser::ASSUME);
      setState(7316);
      match(SV3_1aParser::FINAL);
      setState(7317);
      match(SV3_1aParser::OPEN_PARENS);
      setState(7318);
      expression(0);
      setState(7319);
      match(SV3_1aParser::CLOSE_PARENS);
      setState(7320);
      action_block();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Deferred_immediate_cover_statementContext ------------------------------------------------------------------

SV3_1aParser::Deferred_immediate_cover_statementContext::Deferred_immediate_cover_statementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Deferred_immediate_cover_statementContext::COVER() {
  return getToken(SV3_1aParser::COVER, 0);
}

tree::TerminalNode* SV3_1aParser::Deferred_immediate_cover_statementContext::OPEN_PARENS() {
  return getToken(SV3_1aParser::OPEN_PARENS, 0);
}

SV3_1aParser::ExpressionContext* SV3_1aParser::Deferred_immediate_cover_statementContext::expression() {
  return getRuleContext<SV3_1aParser::ExpressionContext>(0);
}

tree::TerminalNode* SV3_1aParser::Deferred_immediate_cover_statementContext::CLOSE_PARENS() {
  return getToken(SV3_1aParser::CLOSE_PARENS, 0);
}

SV3_1aParser::Statement_or_nullContext* SV3_1aParser::Deferred_immediate_cover_statementContext::statement_or_null() {
  return getRuleContext<SV3_1aParser::Statement_or_nullContext>(0);
}

tree::TerminalNode* SV3_1aParser::Deferred_immediate_cover_statementContext::Pound_Pound_delay() {
  return getToken(SV3_1aParser::Pound_Pound_delay, 0);
}

tree::TerminalNode* SV3_1aParser::Deferred_immediate_cover_statementContext::Pound_delay() {
  return getToken(SV3_1aParser::Pound_delay, 0);
}

tree::TerminalNode* SV3_1aParser::Deferred_immediate_cover_statementContext::FINAL() {
  return getToken(SV3_1aParser::FINAL, 0);
}


size_t SV3_1aParser::Deferred_immediate_cover_statementContext::getRuleIndex() const {
  return SV3_1aParser::RuleDeferred_immediate_cover_statement;
}

void SV3_1aParser::Deferred_immediate_cover_statementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDeferred_immediate_cover_statement(this);
}

void SV3_1aParser::Deferred_immediate_cover_statementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDeferred_immediate_cover_statement(this);
}

SV3_1aParser::Deferred_immediate_cover_statementContext* SV3_1aParser::deferred_immediate_cover_statement() {
  Deferred_immediate_cover_statementContext *_localctx = _tracker.createInstance<Deferred_immediate_cover_statementContext>(_ctx, getState());
  enterRule(_localctx, 900, SV3_1aParser::RuleDeferred_immediate_cover_statement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(7338);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 850, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(7324);
      match(SV3_1aParser::COVER);
      setState(7325);
      _la = _input->LA(1);
      if (!(_la == SV3_1aParser::Pound_Pound_delay

      || _la == SV3_1aParser::Pound_delay)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(7326);
      match(SV3_1aParser::OPEN_PARENS);
      setState(7327);
      expression(0);
      setState(7328);
      match(SV3_1aParser::CLOSE_PARENS);
      setState(7329);
      statement_or_null();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(7331);
      match(SV3_1aParser::COVER);
      setState(7332);
      match(SV3_1aParser::FINAL);
      setState(7333);
      match(SV3_1aParser::OPEN_PARENS);
      setState(7334);
      expression(0);
      setState(7335);
      match(SV3_1aParser::CLOSE_PARENS);
      setState(7336);
      statement_or_null();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Clocking_declarationContext ------------------------------------------------------------------

SV3_1aParser::Clocking_declarationContext::Clocking_declarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Clocking_declarationContext::CLOCKING() {
  return getToken(SV3_1aParser::CLOCKING, 0);
}

SV3_1aParser::Clocking_eventContext* SV3_1aParser::Clocking_declarationContext::clocking_event() {
  return getRuleContext<SV3_1aParser::Clocking_eventContext>(0);
}

tree::TerminalNode* SV3_1aParser::Clocking_declarationContext::SEMICOLON() {
  return getToken(SV3_1aParser::SEMICOLON, 0);
}

tree::TerminalNode* SV3_1aParser::Clocking_declarationContext::ENDCLOCKING() {
  return getToken(SV3_1aParser::ENDCLOCKING, 0);
}

tree::TerminalNode* SV3_1aParser::Clocking_declarationContext::DEFAULT() {
  return getToken(SV3_1aParser::DEFAULT, 0);
}

std::vector<SV3_1aParser::IdentifierContext *> SV3_1aParser::Clocking_declarationContext::identifier() {
  return getRuleContexts<SV3_1aParser::IdentifierContext>();
}

SV3_1aParser::IdentifierContext* SV3_1aParser::Clocking_declarationContext::identifier(size_t i) {
  return getRuleContext<SV3_1aParser::IdentifierContext>(i);
}

std::vector<SV3_1aParser::Clocking_itemContext *> SV3_1aParser::Clocking_declarationContext::clocking_item() {
  return getRuleContexts<SV3_1aParser::Clocking_itemContext>();
}

SV3_1aParser::Clocking_itemContext* SV3_1aParser::Clocking_declarationContext::clocking_item(size_t i) {
  return getRuleContext<SV3_1aParser::Clocking_itemContext>(i);
}

tree::TerminalNode* SV3_1aParser::Clocking_declarationContext::COLON() {
  return getToken(SV3_1aParser::COLON, 0);
}

tree::TerminalNode* SV3_1aParser::Clocking_declarationContext::GLOBAL() {
  return getToken(SV3_1aParser::GLOBAL, 0);
}


size_t SV3_1aParser::Clocking_declarationContext::getRuleIndex() const {
  return SV3_1aParser::RuleClocking_declaration;
}

void SV3_1aParser::Clocking_declarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterClocking_declaration(this);
}

void SV3_1aParser::Clocking_declarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitClocking_declaration(this);
}

SV3_1aParser::Clocking_declarationContext* SV3_1aParser::clocking_declaration() {
  Clocking_declarationContext *_localctx = _tracker.createInstance<Clocking_declarationContext>(_ctx, getState());
  enterRule(_localctx, 902, SV3_1aParser::RuleClocking_declaration);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(7372);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SV3_1aParser::DEFAULT:
      case SV3_1aParser::CLOCKING: {
        enterOuterAlt(_localctx, 1);
        setState(7341);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == SV3_1aParser::DEFAULT) {
          setState(7340);
          match(SV3_1aParser::DEFAULT);
        }
        setState(7343);
        match(SV3_1aParser::CLOCKING);
        setState(7345);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (((((_la - 326) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 326)) & 4672924483589) != 0)) {
          setState(7344);
          identifier();
        }
        setState(7347);
        clocking_event();
        setState(7348);
        match(SV3_1aParser::SEMICOLON);
        setState(7352);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (((((_la - 36) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 36)) & 7516192769) != 0) || ((((_la - 189) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 189)) & 32777) != 0)) {
          setState(7349);
          clocking_item();
          setState(7354);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(7355);
        match(SV3_1aParser::ENDCLOCKING);
        setState(7358);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 854, _ctx)) {
        case 1: {
          setState(7356);
          match(SV3_1aParser::COLON);
          setState(7357);
          identifier();
          break;
        }

        default:
          break;
        }
        break;
      }

      case SV3_1aParser::GLOBAL: {
        enterOuterAlt(_localctx, 2);
        setState(7360);
        match(SV3_1aParser::GLOBAL);
        setState(7361);
        match(SV3_1aParser::CLOCKING);
        setState(7363);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (((((_la - 326) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 326)) & 4672924483589) != 0)) {
          setState(7362);
          identifier();
        }
        setState(7365);
        clocking_event();
        setState(7366);
        match(SV3_1aParser::SEMICOLON);
        setState(7367);
        match(SV3_1aParser::ENDCLOCKING);
        setState(7370);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 856, _ctx)) {
        case 1: {
          setState(7368);
          match(SV3_1aParser::COLON);
          setState(7369);
          identifier();
          break;
        }

        default:
          break;
        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Clocking_eventContext ------------------------------------------------------------------

SV3_1aParser::Clocking_eventContext::Clocking_eventContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Clocking_eventContext::AT() {
  return getToken(SV3_1aParser::AT, 0);
}

SV3_1aParser::IdentifierContext* SV3_1aParser::Clocking_eventContext::identifier() {
  return getRuleContext<SV3_1aParser::IdentifierContext>(0);
}

tree::TerminalNode* SV3_1aParser::Clocking_eventContext::OPEN_PARENS() {
  return getToken(SV3_1aParser::OPEN_PARENS, 0);
}

SV3_1aParser::Event_expressionContext* SV3_1aParser::Clocking_eventContext::event_expression() {
  return getRuleContext<SV3_1aParser::Event_expressionContext>(0);
}

tree::TerminalNode* SV3_1aParser::Clocking_eventContext::CLOSE_PARENS() {
  return getToken(SV3_1aParser::CLOSE_PARENS, 0);
}


size_t SV3_1aParser::Clocking_eventContext::getRuleIndex() const {
  return SV3_1aParser::RuleClocking_event;
}

void SV3_1aParser::Clocking_eventContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterClocking_event(this);
}

void SV3_1aParser::Clocking_eventContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitClocking_event(this);
}

SV3_1aParser::Clocking_eventContext* SV3_1aParser::clocking_event() {
  Clocking_eventContext *_localctx = _tracker.createInstance<Clocking_eventContext>(_ctx, getState());
  enterRule(_localctx, 904, SV3_1aParser::RuleClocking_event);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(7381);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 858, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(7374);
      match(SV3_1aParser::AT);
      setState(7375);
      identifier();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(7376);
      match(SV3_1aParser::AT);
      setState(7377);
      match(SV3_1aParser::OPEN_PARENS);
      setState(7378);
      event_expression(0);
      setState(7379);
      match(SV3_1aParser::CLOSE_PARENS);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Clocking_itemContext ------------------------------------------------------------------

SV3_1aParser::Clocking_itemContext::Clocking_itemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Clocking_itemContext::DEFAULT() {
  return getToken(SV3_1aParser::DEFAULT, 0);
}

SV3_1aParser::Default_skewContext* SV3_1aParser::Clocking_itemContext::default_skew() {
  return getRuleContext<SV3_1aParser::Default_skewContext>(0);
}

tree::TerminalNode* SV3_1aParser::Clocking_itemContext::SEMICOLON() {
  return getToken(SV3_1aParser::SEMICOLON, 0);
}

SV3_1aParser::Clocking_directionContext* SV3_1aParser::Clocking_itemContext::clocking_direction() {
  return getRuleContext<SV3_1aParser::Clocking_directionContext>(0);
}

SV3_1aParser::List_of_clocking_decl_assignContext* SV3_1aParser::Clocking_itemContext::list_of_clocking_decl_assign() {
  return getRuleContext<SV3_1aParser::List_of_clocking_decl_assignContext>(0);
}

SV3_1aParser::Concurrent_assertion_item_declarationContext* SV3_1aParser::Clocking_itemContext::concurrent_assertion_item_declaration() {
  return getRuleContext<SV3_1aParser::Concurrent_assertion_item_declarationContext>(0);
}

std::vector<SV3_1aParser::Attribute_instanceContext *> SV3_1aParser::Clocking_itemContext::attribute_instance() {
  return getRuleContexts<SV3_1aParser::Attribute_instanceContext>();
}

SV3_1aParser::Attribute_instanceContext* SV3_1aParser::Clocking_itemContext::attribute_instance(size_t i) {
  return getRuleContext<SV3_1aParser::Attribute_instanceContext>(i);
}


size_t SV3_1aParser::Clocking_itemContext::getRuleIndex() const {
  return SV3_1aParser::RuleClocking_item;
}

void SV3_1aParser::Clocking_itemContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterClocking_item(this);
}

void SV3_1aParser::Clocking_itemContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitClocking_item(this);
}

SV3_1aParser::Clocking_itemContext* SV3_1aParser::clocking_item() {
  Clocking_itemContext *_localctx = _tracker.createInstance<Clocking_itemContext>(_ctx, getState());
  enterRule(_localctx, 906, SV3_1aParser::RuleClocking_item);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(7398);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SV3_1aParser::DEFAULT: {
        enterOuterAlt(_localctx, 1);
        setState(7383);
        match(SV3_1aParser::DEFAULT);
        setState(7384);
        default_skew();
        setState(7385);
        match(SV3_1aParser::SEMICOLON);
        break;
      }

      case SV3_1aParser::INPUT:
      case SV3_1aParser::OUTPUT:
      case SV3_1aParser::INOUT: {
        enterOuterAlt(_localctx, 2);
        setState(7387);
        clocking_direction();
        setState(7388);
        list_of_clocking_decl_assign();
        setState(7389);
        match(SV3_1aParser::SEMICOLON);
        break;
      }

      case SV3_1aParser::OPEN_PARENS_STAR:
      case SV3_1aParser::PROPERTY:
      case SV3_1aParser::SEQUENCE: {
        enterOuterAlt(_localctx, 3);
        setState(7394);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == SV3_1aParser::OPEN_PARENS_STAR) {
          setState(7391);
          attribute_instance();
          setState(7396);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(7397);
        concurrent_assertion_item_declaration();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Default_skewContext ------------------------------------------------------------------

SV3_1aParser::Default_skewContext::Default_skewContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t SV3_1aParser::Default_skewContext::getRuleIndex() const {
  return SV3_1aParser::RuleDefault_skew;
}

void SV3_1aParser::Default_skewContext::copyFrom(Default_skewContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- DefaultSkew_IntputOutputContext ------------------------------------------------------------------

tree::TerminalNode* SV3_1aParser::DefaultSkew_IntputOutputContext::INPUT() {
  return getToken(SV3_1aParser::INPUT, 0);
}

std::vector<SV3_1aParser::Clocking_skewContext *> SV3_1aParser::DefaultSkew_IntputOutputContext::clocking_skew() {
  return getRuleContexts<SV3_1aParser::Clocking_skewContext>();
}

SV3_1aParser::Clocking_skewContext* SV3_1aParser::DefaultSkew_IntputOutputContext::clocking_skew(size_t i) {
  return getRuleContext<SV3_1aParser::Clocking_skewContext>(i);
}

tree::TerminalNode* SV3_1aParser::DefaultSkew_IntputOutputContext::OUTPUT() {
  return getToken(SV3_1aParser::OUTPUT, 0);
}

SV3_1aParser::DefaultSkew_IntputOutputContext::DefaultSkew_IntputOutputContext(Default_skewContext *ctx) { copyFrom(ctx); }

void SV3_1aParser::DefaultSkew_IntputOutputContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDefaultSkew_IntputOutput(this);
}
void SV3_1aParser::DefaultSkew_IntputOutputContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDefaultSkew_IntputOutput(this);
}
//----------------- DefaultSkew_OutputContext ------------------------------------------------------------------

tree::TerminalNode* SV3_1aParser::DefaultSkew_OutputContext::OUTPUT() {
  return getToken(SV3_1aParser::OUTPUT, 0);
}

SV3_1aParser::Clocking_skewContext* SV3_1aParser::DefaultSkew_OutputContext::clocking_skew() {
  return getRuleContext<SV3_1aParser::Clocking_skewContext>(0);
}

SV3_1aParser::DefaultSkew_OutputContext::DefaultSkew_OutputContext(Default_skewContext *ctx) { copyFrom(ctx); }

void SV3_1aParser::DefaultSkew_OutputContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDefaultSkew_Output(this);
}
void SV3_1aParser::DefaultSkew_OutputContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDefaultSkew_Output(this);
}
//----------------- DefaultSkew_IntputContext ------------------------------------------------------------------

tree::TerminalNode* SV3_1aParser::DefaultSkew_IntputContext::INPUT() {
  return getToken(SV3_1aParser::INPUT, 0);
}

SV3_1aParser::Clocking_skewContext* SV3_1aParser::DefaultSkew_IntputContext::clocking_skew() {
  return getRuleContext<SV3_1aParser::Clocking_skewContext>(0);
}

SV3_1aParser::DefaultSkew_IntputContext::DefaultSkew_IntputContext(Default_skewContext *ctx) { copyFrom(ctx); }

void SV3_1aParser::DefaultSkew_IntputContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDefaultSkew_Intput(this);
}
void SV3_1aParser::DefaultSkew_IntputContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDefaultSkew_Intput(this);
}
SV3_1aParser::Default_skewContext* SV3_1aParser::default_skew() {
  Default_skewContext *_localctx = _tracker.createInstance<Default_skewContext>(_ctx, getState());
  enterRule(_localctx, 908, SV3_1aParser::RuleDefault_skew);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(7409);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 861, _ctx)) {
    case 1: {
      _localctx = _tracker.createInstance<SV3_1aParser::DefaultSkew_IntputContext>(_localctx);
      enterOuterAlt(_localctx, 1);
      setState(7400);
      match(SV3_1aParser::INPUT);
      setState(7401);
      clocking_skew();
      break;
    }

    case 2: {
      _localctx = _tracker.createInstance<SV3_1aParser::DefaultSkew_OutputContext>(_localctx);
      enterOuterAlt(_localctx, 2);
      setState(7402);
      match(SV3_1aParser::OUTPUT);
      setState(7403);
      clocking_skew();
      break;
    }

    case 3: {
      _localctx = _tracker.createInstance<SV3_1aParser::DefaultSkew_IntputOutputContext>(_localctx);
      enterOuterAlt(_localctx, 3);
      setState(7404);
      match(SV3_1aParser::INPUT);
      setState(7405);
      clocking_skew();
      setState(7406);
      match(SV3_1aParser::OUTPUT);
      setState(7407);
      clocking_skew();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Clocking_directionContext ------------------------------------------------------------------

SV3_1aParser::Clocking_directionContext::Clocking_directionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t SV3_1aParser::Clocking_directionContext::getRuleIndex() const {
  return SV3_1aParser::RuleClocking_direction;
}

void SV3_1aParser::Clocking_directionContext::copyFrom(Clocking_directionContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- ClockingDir_InputOutputContext ------------------------------------------------------------------

tree::TerminalNode* SV3_1aParser::ClockingDir_InputOutputContext::INPUT() {
  return getToken(SV3_1aParser::INPUT, 0);
}

tree::TerminalNode* SV3_1aParser::ClockingDir_InputOutputContext::OUTPUT() {
  return getToken(SV3_1aParser::OUTPUT, 0);
}

std::vector<SV3_1aParser::Clocking_skewContext *> SV3_1aParser::ClockingDir_InputOutputContext::clocking_skew() {
  return getRuleContexts<SV3_1aParser::Clocking_skewContext>();
}

SV3_1aParser::Clocking_skewContext* SV3_1aParser::ClockingDir_InputOutputContext::clocking_skew(size_t i) {
  return getRuleContext<SV3_1aParser::Clocking_skewContext>(i);
}

SV3_1aParser::ClockingDir_InputOutputContext::ClockingDir_InputOutputContext(Clocking_directionContext *ctx) { copyFrom(ctx); }

void SV3_1aParser::ClockingDir_InputOutputContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterClockingDir_InputOutput(this);
}
void SV3_1aParser::ClockingDir_InputOutputContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitClockingDir_InputOutput(this);
}
//----------------- ClockingDir_InputContext ------------------------------------------------------------------

tree::TerminalNode* SV3_1aParser::ClockingDir_InputContext::INPUT() {
  return getToken(SV3_1aParser::INPUT, 0);
}

SV3_1aParser::Clocking_skewContext* SV3_1aParser::ClockingDir_InputContext::clocking_skew() {
  return getRuleContext<SV3_1aParser::Clocking_skewContext>(0);
}

SV3_1aParser::ClockingDir_InputContext::ClockingDir_InputContext(Clocking_directionContext *ctx) { copyFrom(ctx); }

void SV3_1aParser::ClockingDir_InputContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterClockingDir_Input(this);
}
void SV3_1aParser::ClockingDir_InputContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitClockingDir_Input(this);
}
//----------------- ClockingDir_OutputContext ------------------------------------------------------------------

tree::TerminalNode* SV3_1aParser::ClockingDir_OutputContext::OUTPUT() {
  return getToken(SV3_1aParser::OUTPUT, 0);
}

SV3_1aParser::Clocking_skewContext* SV3_1aParser::ClockingDir_OutputContext::clocking_skew() {
  return getRuleContext<SV3_1aParser::Clocking_skewContext>(0);
}

SV3_1aParser::ClockingDir_OutputContext::ClockingDir_OutputContext(Clocking_directionContext *ctx) { copyFrom(ctx); }

void SV3_1aParser::ClockingDir_OutputContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterClockingDir_Output(this);
}
void SV3_1aParser::ClockingDir_OutputContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitClockingDir_Output(this);
}
//----------------- ClockingDir_InoutContext ------------------------------------------------------------------

tree::TerminalNode* SV3_1aParser::ClockingDir_InoutContext::INOUT() {
  return getToken(SV3_1aParser::INOUT, 0);
}

SV3_1aParser::ClockingDir_InoutContext::ClockingDir_InoutContext(Clocking_directionContext *ctx) { copyFrom(ctx); }

void SV3_1aParser::ClockingDir_InoutContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterClockingDir_Inout(this);
}
void SV3_1aParser::ClockingDir_InoutContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitClockingDir_Inout(this);
}
SV3_1aParser::Clocking_directionContext* SV3_1aParser::clocking_direction() {
  Clocking_directionContext *_localctx = _tracker.createInstance<Clocking_directionContext>(_ctx, getState());
  enterRule(_localctx, 910, SV3_1aParser::RuleClocking_direction);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(7428);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 866, _ctx)) {
    case 1: {
      _localctx = _tracker.createInstance<SV3_1aParser::ClockingDir_InputContext>(_localctx);
      enterOuterAlt(_localctx, 1);
      setState(7411);
      match(SV3_1aParser::INPUT);
      setState(7413);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == SV3_1aParser::Pound_Pound_delay

      || _la == SV3_1aParser::Pound_delay || _la == SV3_1aParser::POUND || ((((_la - 333) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 333)) & 1027) != 0)) {
        setState(7412);
        clocking_skew();
      }
      break;
    }

    case 2: {
      _localctx = _tracker.createInstance<SV3_1aParser::ClockingDir_OutputContext>(_localctx);
      enterOuterAlt(_localctx, 2);
      setState(7415);
      match(SV3_1aParser::OUTPUT);
      setState(7417);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == SV3_1aParser::Pound_Pound_delay

      || _la == SV3_1aParser::Pound_delay || _la == SV3_1aParser::POUND || ((((_la - 333) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 333)) & 1027) != 0)) {
        setState(7416);
        clocking_skew();
      }
      break;
    }

    case 3: {
      _localctx = _tracker.createInstance<SV3_1aParser::ClockingDir_InputOutputContext>(_localctx);
      enterOuterAlt(_localctx, 3);
      setState(7419);
      match(SV3_1aParser::INPUT);
      setState(7421);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == SV3_1aParser::Pound_Pound_delay

      || _la == SV3_1aParser::Pound_delay || _la == SV3_1aParser::POUND || ((((_la - 333) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 333)) & 1027) != 0)) {
        setState(7420);
        clocking_skew();
      }
      setState(7423);
      match(SV3_1aParser::OUTPUT);
      setState(7425);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == SV3_1aParser::Pound_Pound_delay

      || _la == SV3_1aParser::Pound_delay || _la == SV3_1aParser::POUND || ((((_la - 333) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 333)) & 1027) != 0)) {
        setState(7424);
        clocking_skew();
      }
      break;
    }

    case 4: {
      _localctx = _tracker.createInstance<SV3_1aParser::ClockingDir_InoutContext>(_localctx);
      enterOuterAlt(_localctx, 4);
      setState(7427);
      match(SV3_1aParser::INOUT);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- List_of_clocking_decl_assignContext ------------------------------------------------------------------

SV3_1aParser::List_of_clocking_decl_assignContext::List_of_clocking_decl_assignContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<SV3_1aParser::Clocking_decl_assignContext *> SV3_1aParser::List_of_clocking_decl_assignContext::clocking_decl_assign() {
  return getRuleContexts<SV3_1aParser::Clocking_decl_assignContext>();
}

SV3_1aParser::Clocking_decl_assignContext* SV3_1aParser::List_of_clocking_decl_assignContext::clocking_decl_assign(size_t i) {
  return getRuleContext<SV3_1aParser::Clocking_decl_assignContext>(i);
}

std::vector<tree::TerminalNode *> SV3_1aParser::List_of_clocking_decl_assignContext::COMMA() {
  return getTokens(SV3_1aParser::COMMA);
}

tree::TerminalNode* SV3_1aParser::List_of_clocking_decl_assignContext::COMMA(size_t i) {
  return getToken(SV3_1aParser::COMMA, i);
}


size_t SV3_1aParser::List_of_clocking_decl_assignContext::getRuleIndex() const {
  return SV3_1aParser::RuleList_of_clocking_decl_assign;
}

void SV3_1aParser::List_of_clocking_decl_assignContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterList_of_clocking_decl_assign(this);
}

void SV3_1aParser::List_of_clocking_decl_assignContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitList_of_clocking_decl_assign(this);
}

SV3_1aParser::List_of_clocking_decl_assignContext* SV3_1aParser::list_of_clocking_decl_assign() {
  List_of_clocking_decl_assignContext *_localctx = _tracker.createInstance<List_of_clocking_decl_assignContext>(_ctx, getState());
  enterRule(_localctx, 912, SV3_1aParser::RuleList_of_clocking_decl_assign);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7430);
    clocking_decl_assign();
    setState(7435);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == SV3_1aParser::COMMA) {
      setState(7431);
      match(SV3_1aParser::COMMA);
      setState(7432);
      clocking_decl_assign();
      setState(7437);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Clocking_decl_assignContext ------------------------------------------------------------------

SV3_1aParser::Clocking_decl_assignContext::Clocking_decl_assignContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::IdentifierContext* SV3_1aParser::Clocking_decl_assignContext::identifier() {
  return getRuleContext<SV3_1aParser::IdentifierContext>(0);
}

tree::TerminalNode* SV3_1aParser::Clocking_decl_assignContext::ASSIGN_OP() {
  return getToken(SV3_1aParser::ASSIGN_OP, 0);
}

SV3_1aParser::ExpressionContext* SV3_1aParser::Clocking_decl_assignContext::expression() {
  return getRuleContext<SV3_1aParser::ExpressionContext>(0);
}


size_t SV3_1aParser::Clocking_decl_assignContext::getRuleIndex() const {
  return SV3_1aParser::RuleClocking_decl_assign;
}

void SV3_1aParser::Clocking_decl_assignContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterClocking_decl_assign(this);
}

void SV3_1aParser::Clocking_decl_assignContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitClocking_decl_assign(this);
}

SV3_1aParser::Clocking_decl_assignContext* SV3_1aParser::clocking_decl_assign() {
  Clocking_decl_assignContext *_localctx = _tracker.createInstance<Clocking_decl_assignContext>(_ctx, getState());
  enterRule(_localctx, 914, SV3_1aParser::RuleClocking_decl_assign);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7438);
    identifier();
    setState(7441);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SV3_1aParser::ASSIGN_OP) {
      setState(7439);
      match(SV3_1aParser::ASSIGN_OP);
      setState(7440);
      expression(0);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Clocking_skewContext ------------------------------------------------------------------

SV3_1aParser::Clocking_skewContext::Clocking_skewContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::Edge_identifierContext* SV3_1aParser::Clocking_skewContext::edge_identifier() {
  return getRuleContext<SV3_1aParser::Edge_identifierContext>(0);
}

SV3_1aParser::Delay_controlContext* SV3_1aParser::Clocking_skewContext::delay_control() {
  return getRuleContext<SV3_1aParser::Delay_controlContext>(0);
}


size_t SV3_1aParser::Clocking_skewContext::getRuleIndex() const {
  return SV3_1aParser::RuleClocking_skew;
}

void SV3_1aParser::Clocking_skewContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterClocking_skew(this);
}

void SV3_1aParser::Clocking_skewContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitClocking_skew(this);
}

SV3_1aParser::Clocking_skewContext* SV3_1aParser::clocking_skew() {
  Clocking_skewContext *_localctx = _tracker.createInstance<Clocking_skewContext>(_ctx, getState());
  enterRule(_localctx, 916, SV3_1aParser::RuleClocking_skew);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(7448);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SV3_1aParser::POSEDGE:
      case SV3_1aParser::NEGEDGE:
      case SV3_1aParser::EDGE: {
        enterOuterAlt(_localctx, 1);
        setState(7443);
        edge_identifier();
        setState(7445);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == SV3_1aParser::Pound_Pound_delay

        || _la == SV3_1aParser::Pound_delay || _la == SV3_1aParser::POUND) {
          setState(7444);
          delay_control();
        }
        break;
      }

      case SV3_1aParser::Pound_Pound_delay:
      case SV3_1aParser::Pound_delay:
      case SV3_1aParser::POUND: {
        enterOuterAlt(_localctx, 2);
        setState(7447);
        delay_control();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Edge_identifierContext ------------------------------------------------------------------

SV3_1aParser::Edge_identifierContext::Edge_identifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Edge_identifierContext::POSEDGE() {
  return getToken(SV3_1aParser::POSEDGE, 0);
}

tree::TerminalNode* SV3_1aParser::Edge_identifierContext::NEGEDGE() {
  return getToken(SV3_1aParser::NEGEDGE, 0);
}

tree::TerminalNode* SV3_1aParser::Edge_identifierContext::EDGE() {
  return getToken(SV3_1aParser::EDGE, 0);
}


size_t SV3_1aParser::Edge_identifierContext::getRuleIndex() const {
  return SV3_1aParser::RuleEdge_identifier;
}

void SV3_1aParser::Edge_identifierContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterEdge_identifier(this);
}

void SV3_1aParser::Edge_identifierContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitEdge_identifier(this);
}

SV3_1aParser::Edge_identifierContext* SV3_1aParser::edge_identifier() {
  Edge_identifierContext *_localctx = _tracker.createInstance<Edge_identifierContext>(_ctx, getState());
  enterRule(_localctx, 918, SV3_1aParser::RuleEdge_identifier);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7450);
    _la = _input->LA(1);
    if (!(((((_la - 333) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 333)) & 1027) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Clocking_driveContext ------------------------------------------------------------------

SV3_1aParser::Clocking_driveContext::Clocking_driveContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::Clockvar_expressionContext* SV3_1aParser::Clocking_driveContext::clockvar_expression() {
  return getRuleContext<SV3_1aParser::Clockvar_expressionContext>(0);
}

tree::TerminalNode* SV3_1aParser::Clocking_driveContext::LESS_EQUAL() {
  return getToken(SV3_1aParser::LESS_EQUAL, 0);
}

SV3_1aParser::ExpressionContext* SV3_1aParser::Clocking_driveContext::expression() {
  return getRuleContext<SV3_1aParser::ExpressionContext>(0);
}

SV3_1aParser::Cycle_delayContext* SV3_1aParser::Clocking_driveContext::cycle_delay() {
  return getRuleContext<SV3_1aParser::Cycle_delayContext>(0);
}


size_t SV3_1aParser::Clocking_driveContext::getRuleIndex() const {
  return SV3_1aParser::RuleClocking_drive;
}

void SV3_1aParser::Clocking_driveContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterClocking_drive(this);
}

void SV3_1aParser::Clocking_driveContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitClocking_drive(this);
}

SV3_1aParser::Clocking_driveContext* SV3_1aParser::clocking_drive() {
  Clocking_driveContext *_localctx = _tracker.createInstance<Clocking_driveContext>(_ctx, getState());
  enterRule(_localctx, 920, SV3_1aParser::RuleClocking_drive);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(7464);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SV3_1aParser::THIS:
      case SV3_1aParser::DOLLAR_ROOT:
      case SV3_1aParser::RANDOMIZE:
      case SV3_1aParser::SAMPLE:
      case SV3_1aParser::Escaped_identifier:
      case SV3_1aParser::Simple_identifier: {
        enterOuterAlt(_localctx, 1);
        setState(7452);
        clockvar_expression();
        setState(7453);
        match(SV3_1aParser::LESS_EQUAL);
        setState(7455);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == SV3_1aParser::Pound_Pound_delay || _la == SV3_1aParser::POUNDPOUND) {
          setState(7454);
          cycle_delay();
        }
        setState(7457);
        expression(0);
        break;
      }

      case SV3_1aParser::Pound_Pound_delay:
      case SV3_1aParser::POUNDPOUND: {
        enterOuterAlt(_localctx, 2);
        setState(7459);
        cycle_delay();
        setState(7460);
        clockvar_expression();
        setState(7461);
        match(SV3_1aParser::LESS_EQUAL);
        setState(7462);
        expression(0);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Cycle_delayContext ------------------------------------------------------------------

SV3_1aParser::Cycle_delayContext::Cycle_delayContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Cycle_delayContext::POUNDPOUND() {
  return getToken(SV3_1aParser::POUNDPOUND, 0);
}

tree::TerminalNode* SV3_1aParser::Cycle_delayContext::Integral_number() {
  return getToken(SV3_1aParser::Integral_number, 0);
}

tree::TerminalNode* SV3_1aParser::Cycle_delayContext::Pound_Pound_delay() {
  return getToken(SV3_1aParser::Pound_Pound_delay, 0);
}

SV3_1aParser::IdentifierContext* SV3_1aParser::Cycle_delayContext::identifier() {
  return getRuleContext<SV3_1aParser::IdentifierContext>(0);
}

tree::TerminalNode* SV3_1aParser::Cycle_delayContext::OPEN_PARENS() {
  return getToken(SV3_1aParser::OPEN_PARENS, 0);
}

SV3_1aParser::ExpressionContext* SV3_1aParser::Cycle_delayContext::expression() {
  return getRuleContext<SV3_1aParser::ExpressionContext>(0);
}

tree::TerminalNode* SV3_1aParser::Cycle_delayContext::CLOSE_PARENS() {
  return getToken(SV3_1aParser::CLOSE_PARENS, 0);
}


size_t SV3_1aParser::Cycle_delayContext::getRuleIndex() const {
  return SV3_1aParser::RuleCycle_delay;
}

void SV3_1aParser::Cycle_delayContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCycle_delay(this);
}

void SV3_1aParser::Cycle_delayContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCycle_delay(this);
}

SV3_1aParser::Cycle_delayContext* SV3_1aParser::cycle_delay() {
  Cycle_delayContext *_localctx = _tracker.createInstance<Cycle_delayContext>(_ctx, getState());
  enterRule(_localctx, 922, SV3_1aParser::RuleCycle_delay);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(7476);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 873, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(7466);
      match(SV3_1aParser::POUNDPOUND);
      setState(7467);
      match(SV3_1aParser::Integral_number);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(7468);
      match(SV3_1aParser::Pound_Pound_delay);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(7469);
      match(SV3_1aParser::POUNDPOUND);
      setState(7470);
      identifier();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(7471);
      match(SV3_1aParser::POUNDPOUND);
      setState(7472);
      match(SV3_1aParser::OPEN_PARENS);
      setState(7473);
      expression(0);
      setState(7474);
      match(SV3_1aParser::CLOSE_PARENS);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ClockvarContext ------------------------------------------------------------------

SV3_1aParser::ClockvarContext::ClockvarContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<SV3_1aParser::IdentifierContext *> SV3_1aParser::ClockvarContext::identifier() {
  return getRuleContexts<SV3_1aParser::IdentifierContext>();
}

SV3_1aParser::IdentifierContext* SV3_1aParser::ClockvarContext::identifier(size_t i) {
  return getRuleContext<SV3_1aParser::IdentifierContext>(i);
}

SV3_1aParser::Dollar_root_keywordContext* SV3_1aParser::ClockvarContext::dollar_root_keyword() {
  return getRuleContext<SV3_1aParser::Dollar_root_keywordContext>(0);
}

std::vector<tree::TerminalNode *> SV3_1aParser::ClockvarContext::DOT() {
  return getTokens(SV3_1aParser::DOT);
}

tree::TerminalNode* SV3_1aParser::ClockvarContext::DOT(size_t i) {
  return getToken(SV3_1aParser::DOT, i);
}

std::vector<tree::TerminalNode *> SV3_1aParser::ClockvarContext::OPEN_BRACKET() {
  return getTokens(SV3_1aParser::OPEN_BRACKET);
}

tree::TerminalNode* SV3_1aParser::ClockvarContext::OPEN_BRACKET(size_t i) {
  return getToken(SV3_1aParser::OPEN_BRACKET, i);
}

std::vector<SV3_1aParser::Constant_expressionContext *> SV3_1aParser::ClockvarContext::constant_expression() {
  return getRuleContexts<SV3_1aParser::Constant_expressionContext>();
}

SV3_1aParser::Constant_expressionContext* SV3_1aParser::ClockvarContext::constant_expression(size_t i) {
  return getRuleContext<SV3_1aParser::Constant_expressionContext>(i);
}

std::vector<tree::TerminalNode *> SV3_1aParser::ClockvarContext::CLOSE_BRACKET() {
  return getTokens(SV3_1aParser::CLOSE_BRACKET);
}

tree::TerminalNode* SV3_1aParser::ClockvarContext::CLOSE_BRACKET(size_t i) {
  return getToken(SV3_1aParser::CLOSE_BRACKET, i);
}


size_t SV3_1aParser::ClockvarContext::getRuleIndex() const {
  return SV3_1aParser::RuleClockvar;
}

void SV3_1aParser::ClockvarContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterClockvar(this);
}

void SV3_1aParser::ClockvarContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitClockvar(this);
}

SV3_1aParser::ClockvarContext* SV3_1aParser::clockvar() {
  ClockvarContext *_localctx = _tracker.createInstance<ClockvarContext>(_ctx, getState());
  enterRule(_localctx, 924, SV3_1aParser::RuleClockvar);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(7479);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SV3_1aParser::DOLLAR_ROOT) {
      setState(7478);
      dollar_root_keyword();
    }
    setState(7481);
    identifier();
    setState(7495);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 876, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(7488);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == SV3_1aParser::OPEN_BRACKET) {
          setState(7482);
          match(SV3_1aParser::OPEN_BRACKET);
          setState(7483);
          constant_expression(0);
          setState(7484);
          match(SV3_1aParser::CLOSE_BRACKET);
          setState(7490);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(7491);
        match(SV3_1aParser::DOT);
        setState(7492);
        identifier(); 
      }
      setState(7497);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 876, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Clockvar_expressionContext ------------------------------------------------------------------

SV3_1aParser::Clockvar_expressionContext::Clockvar_expressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::ClockvarContext* SV3_1aParser::Clockvar_expressionContext::clockvar() {
  return getRuleContext<SV3_1aParser::ClockvarContext>(0);
}

SV3_1aParser::SelectContext* SV3_1aParser::Clockvar_expressionContext::select() {
  return getRuleContext<SV3_1aParser::SelectContext>(0);
}


size_t SV3_1aParser::Clockvar_expressionContext::getRuleIndex() const {
  return SV3_1aParser::RuleClockvar_expression;
}

void SV3_1aParser::Clockvar_expressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterClockvar_expression(this);
}

void SV3_1aParser::Clockvar_expressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitClockvar_expression(this);
}

SV3_1aParser::Clockvar_expressionContext* SV3_1aParser::clockvar_expression() {
  Clockvar_expressionContext *_localctx = _tracker.createInstance<Clockvar_expressionContext>(_ctx, getState());
  enterRule(_localctx, 926, SV3_1aParser::RuleClockvar_expression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7498);
    clockvar();
    setState(7499);
    select();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Randsequence_statementContext ------------------------------------------------------------------

SV3_1aParser::Randsequence_statementContext::Randsequence_statementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Randsequence_statementContext::RANDSEQUENCE() {
  return getToken(SV3_1aParser::RANDSEQUENCE, 0);
}

tree::TerminalNode* SV3_1aParser::Randsequence_statementContext::OPEN_PARENS() {
  return getToken(SV3_1aParser::OPEN_PARENS, 0);
}

tree::TerminalNode* SV3_1aParser::Randsequence_statementContext::CLOSE_PARENS() {
  return getToken(SV3_1aParser::CLOSE_PARENS, 0);
}

std::vector<SV3_1aParser::ProductionContext *> SV3_1aParser::Randsequence_statementContext::production() {
  return getRuleContexts<SV3_1aParser::ProductionContext>();
}

SV3_1aParser::ProductionContext* SV3_1aParser::Randsequence_statementContext::production(size_t i) {
  return getRuleContext<SV3_1aParser::ProductionContext>(i);
}

tree::TerminalNode* SV3_1aParser::Randsequence_statementContext::ENDSEQUENCE() {
  return getToken(SV3_1aParser::ENDSEQUENCE, 0);
}

SV3_1aParser::IdentifierContext* SV3_1aParser::Randsequence_statementContext::identifier() {
  return getRuleContext<SV3_1aParser::IdentifierContext>(0);
}


size_t SV3_1aParser::Randsequence_statementContext::getRuleIndex() const {
  return SV3_1aParser::RuleRandsequence_statement;
}

void SV3_1aParser::Randsequence_statementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRandsequence_statement(this);
}

void SV3_1aParser::Randsequence_statementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRandsequence_statement(this);
}

SV3_1aParser::Randsequence_statementContext* SV3_1aParser::randsequence_statement() {
  Randsequence_statementContext *_localctx = _tracker.createInstance<Randsequence_statementContext>(_ctx, getState());
  enterRule(_localctx, 928, SV3_1aParser::RuleRandsequence_statement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7501);
    match(SV3_1aParser::RANDSEQUENCE);
    setState(7502);
    match(SV3_1aParser::OPEN_PARENS);
    setState(7504);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (((((_la - 326) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 326)) & 4672924483589) != 0)) {
      setState(7503);
      identifier();
    }
    setState(7506);
    match(SV3_1aParser::CLOSE_PARENS);
    setState(7507);
    production();
    setState(7511);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == SV3_1aParser::VIRTUAL || ((((_la - 64) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 64)) & 1152705450571988993) != 0) || _la == SV3_1aParser::VOID

    || _la == SV3_1aParser::DOLLAR_UNIT || ((((_la - 326) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 326)) & 4672924483589) != 0)) {
      setState(7508);
      production();
      setState(7513);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(7514);
    match(SV3_1aParser::ENDSEQUENCE);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ProductionContext ------------------------------------------------------------------

SV3_1aParser::ProductionContext::ProductionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::IdentifierContext* SV3_1aParser::ProductionContext::identifier() {
  return getRuleContext<SV3_1aParser::IdentifierContext>(0);
}

tree::TerminalNode* SV3_1aParser::ProductionContext::COLON() {
  return getToken(SV3_1aParser::COLON, 0);
}

std::vector<SV3_1aParser::Rs_ruleContext *> SV3_1aParser::ProductionContext::rs_rule() {
  return getRuleContexts<SV3_1aParser::Rs_ruleContext>();
}

SV3_1aParser::Rs_ruleContext* SV3_1aParser::ProductionContext::rs_rule(size_t i) {
  return getRuleContext<SV3_1aParser::Rs_ruleContext>(i);
}

tree::TerminalNode* SV3_1aParser::ProductionContext::SEMICOLON() {
  return getToken(SV3_1aParser::SEMICOLON, 0);
}

SV3_1aParser::Function_data_typeContext* SV3_1aParser::ProductionContext::function_data_type() {
  return getRuleContext<SV3_1aParser::Function_data_typeContext>(0);
}

tree::TerminalNode* SV3_1aParser::ProductionContext::OPEN_PARENS() {
  return getToken(SV3_1aParser::OPEN_PARENS, 0);
}

SV3_1aParser::Tf_port_listContext* SV3_1aParser::ProductionContext::tf_port_list() {
  return getRuleContext<SV3_1aParser::Tf_port_listContext>(0);
}

tree::TerminalNode* SV3_1aParser::ProductionContext::CLOSE_PARENS() {
  return getToken(SV3_1aParser::CLOSE_PARENS, 0);
}

std::vector<tree::TerminalNode *> SV3_1aParser::ProductionContext::BITW_OR() {
  return getTokens(SV3_1aParser::BITW_OR);
}

tree::TerminalNode* SV3_1aParser::ProductionContext::BITW_OR(size_t i) {
  return getToken(SV3_1aParser::BITW_OR, i);
}


size_t SV3_1aParser::ProductionContext::getRuleIndex() const {
  return SV3_1aParser::RuleProduction;
}

void SV3_1aParser::ProductionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterProduction(this);
}

void SV3_1aParser::ProductionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitProduction(this);
}

SV3_1aParser::ProductionContext* SV3_1aParser::production() {
  ProductionContext *_localctx = _tracker.createInstance<ProductionContext>(_ctx, getState());
  enterRule(_localctx, 930, SV3_1aParser::RuleProduction);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7517);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 879, _ctx)) {
    case 1: {
      setState(7516);
      function_data_type();
      break;
    }

    default:
      break;
    }
    setState(7519);
    identifier();
    setState(7524);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SV3_1aParser::OPEN_PARENS) {
      setState(7520);
      match(SV3_1aParser::OPEN_PARENS);
      setState(7521);
      tf_port_list();
      setState(7522);
      match(SV3_1aParser::CLOSE_PARENS);
    }
    setState(7526);
    match(SV3_1aParser::COLON);
    setState(7527);
    rs_rule();
    setState(7532);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == SV3_1aParser::BITW_OR) {
      setState(7528);
      match(SV3_1aParser::BITW_OR);
      setState(7529);
      rs_rule();
      setState(7534);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(7535);
    match(SV3_1aParser::SEMICOLON);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Rs_ruleContext ------------------------------------------------------------------

SV3_1aParser::Rs_ruleContext::Rs_ruleContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::Rs_production_listContext* SV3_1aParser::Rs_ruleContext::rs_production_list() {
  return getRuleContext<SV3_1aParser::Rs_production_listContext>(0);
}

tree::TerminalNode* SV3_1aParser::Rs_ruleContext::ASSIGN_VALUE() {
  return getToken(SV3_1aParser::ASSIGN_VALUE, 0);
}

SV3_1aParser::ExpressionContext* SV3_1aParser::Rs_ruleContext::expression() {
  return getRuleContext<SV3_1aParser::ExpressionContext>(0);
}

SV3_1aParser::Rs_code_blockContext* SV3_1aParser::Rs_ruleContext::rs_code_block() {
  return getRuleContext<SV3_1aParser::Rs_code_blockContext>(0);
}


size_t SV3_1aParser::Rs_ruleContext::getRuleIndex() const {
  return SV3_1aParser::RuleRs_rule;
}

void SV3_1aParser::Rs_ruleContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRs_rule(this);
}

void SV3_1aParser::Rs_ruleContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRs_rule(this);
}

SV3_1aParser::Rs_ruleContext* SV3_1aParser::rs_rule() {
  Rs_ruleContext *_localctx = _tracker.createInstance<Rs_ruleContext>(_ctx, getState());
  enterRule(_localctx, 932, SV3_1aParser::RuleRs_rule);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7537);
    rs_production_list();
    setState(7543);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SV3_1aParser::ASSIGN_VALUE) {
      setState(7538);
      match(SV3_1aParser::ASSIGN_VALUE);
      setState(7539);
      expression(0);
      setState(7541);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == SV3_1aParser::OPEN_CURLY) {
        setState(7540);
        rs_code_block();
      }
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Rs_production_listContext ------------------------------------------------------------------

SV3_1aParser::Rs_production_listContext::Rs_production_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<SV3_1aParser::Rs_prodContext *> SV3_1aParser::Rs_production_listContext::rs_prod() {
  return getRuleContexts<SV3_1aParser::Rs_prodContext>();
}

SV3_1aParser::Rs_prodContext* SV3_1aParser::Rs_production_listContext::rs_prod(size_t i) {
  return getRuleContext<SV3_1aParser::Rs_prodContext>(i);
}

tree::TerminalNode* SV3_1aParser::Rs_production_listContext::RAND() {
  return getToken(SV3_1aParser::RAND, 0);
}

tree::TerminalNode* SV3_1aParser::Rs_production_listContext::JOIN() {
  return getToken(SV3_1aParser::JOIN, 0);
}

std::vector<SV3_1aParser::Production_itemContext *> SV3_1aParser::Rs_production_listContext::production_item() {
  return getRuleContexts<SV3_1aParser::Production_itemContext>();
}

SV3_1aParser::Production_itemContext* SV3_1aParser::Rs_production_listContext::production_item(size_t i) {
  return getRuleContext<SV3_1aParser::Production_itemContext>(i);
}

tree::TerminalNode* SV3_1aParser::Rs_production_listContext::OPEN_PARENS() {
  return getToken(SV3_1aParser::OPEN_PARENS, 0);
}

SV3_1aParser::ExpressionContext* SV3_1aParser::Rs_production_listContext::expression() {
  return getRuleContext<SV3_1aParser::ExpressionContext>(0);
}

tree::TerminalNode* SV3_1aParser::Rs_production_listContext::CLOSE_PARENS() {
  return getToken(SV3_1aParser::CLOSE_PARENS, 0);
}


size_t SV3_1aParser::Rs_production_listContext::getRuleIndex() const {
  return SV3_1aParser::RuleRs_production_list;
}

void SV3_1aParser::Rs_production_listContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRs_production_list(this);
}

void SV3_1aParser::Rs_production_listContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRs_production_list(this);
}

SV3_1aParser::Rs_production_listContext* SV3_1aParser::rs_production_list() {
  Rs_production_listContext *_localctx = _tracker.createInstance<Rs_production_listContext>(_ctx, getState());
  enterRule(_localctx, 934, SV3_1aParser::RuleRs_production_list);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(7568);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SV3_1aParser::OPEN_CURLY:
      case SV3_1aParser::IF:
      case SV3_1aParser::CASE:
      case SV3_1aParser::REPEAT:
      case SV3_1aParser::THIS:
      case SV3_1aParser::RANDOMIZE:
      case SV3_1aParser::SAMPLE:
      case SV3_1aParser::Escaped_identifier:
      case SV3_1aParser::Simple_identifier: {
        enterOuterAlt(_localctx, 1);
        setState(7545);
        rs_prod();
        setState(7549);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == SV3_1aParser::OPEN_CURLY

        || _la == SV3_1aParser::IF || ((((_la - 264) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 264)) & 4611686022722355201) != 0) || ((((_la - 328) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 328)) & 1168231120897) != 0)) {
          setState(7546);
          rs_prod();
          setState(7551);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        break;
      }

      case SV3_1aParser::RAND: {
        enterOuterAlt(_localctx, 2);
        setState(7552);
        match(SV3_1aParser::RAND);
        setState(7553);
        match(SV3_1aParser::JOIN);
        setState(7558);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == SV3_1aParser::OPEN_PARENS) {
          setState(7554);
          match(SV3_1aParser::OPEN_PARENS);
          setState(7555);
          expression(0);
          setState(7556);
          match(SV3_1aParser::CLOSE_PARENS);
        }
        setState(7560);
        production_item();
        setState(7561);
        production_item();
        setState(7565);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (((((_la - 326) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 326)) & 4672924483589) != 0)) {
          setState(7562);
          production_item();
          setState(7567);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Rs_code_blockContext ------------------------------------------------------------------

SV3_1aParser::Rs_code_blockContext::Rs_code_blockContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Rs_code_blockContext::OPEN_CURLY() {
  return getToken(SV3_1aParser::OPEN_CURLY, 0);
}

tree::TerminalNode* SV3_1aParser::Rs_code_blockContext::CLOSE_CURLY() {
  return getToken(SV3_1aParser::CLOSE_CURLY, 0);
}

std::vector<SV3_1aParser::Data_declarationContext *> SV3_1aParser::Rs_code_blockContext::data_declaration() {
  return getRuleContexts<SV3_1aParser::Data_declarationContext>();
}

SV3_1aParser::Data_declarationContext* SV3_1aParser::Rs_code_blockContext::data_declaration(size_t i) {
  return getRuleContext<SV3_1aParser::Data_declarationContext>(i);
}

std::vector<SV3_1aParser::Statement_or_nullContext *> SV3_1aParser::Rs_code_blockContext::statement_or_null() {
  return getRuleContexts<SV3_1aParser::Statement_or_nullContext>();
}

SV3_1aParser::Statement_or_nullContext* SV3_1aParser::Rs_code_blockContext::statement_or_null(size_t i) {
  return getRuleContext<SV3_1aParser::Statement_or_nullContext>(i);
}


size_t SV3_1aParser::Rs_code_blockContext::getRuleIndex() const {
  return SV3_1aParser::RuleRs_code_block;
}

void SV3_1aParser::Rs_code_blockContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRs_code_block(this);
}

void SV3_1aParser::Rs_code_blockContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRs_code_block(this);
}

SV3_1aParser::Rs_code_blockContext* SV3_1aParser::rs_code_block() {
  Rs_code_blockContext *_localctx = _tracker.createInstance<Rs_code_blockContext>(_ctx, getState());
  enterRule(_localctx, 936, SV3_1aParser::RuleRs_code_block);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(7570);
    match(SV3_1aParser::OPEN_CURLY);
    setState(7574);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 888, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(7571);
        data_declaration(); 
      }
      setState(7576);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 888, _ctx);
    }
    setState(7580);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 2198011904) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 64)) & 17732923904262145) != 0) || ((((_la - 151) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 151)) & 5188249437639573505) != 0) || ((((_la - 223) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 223)) & 1136895023120385) != 0) || ((((_la - 289) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 289)) & 45036959082348431) != 0) || ((((_la - 364) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 364)) & 8796093022225) != 0)) {
      setState(7577);
      statement_or_null();
      setState(7582);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(7583);
    match(SV3_1aParser::CLOSE_CURLY);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Rs_prodContext ------------------------------------------------------------------

SV3_1aParser::Rs_prodContext::Rs_prodContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::Production_itemContext* SV3_1aParser::Rs_prodContext::production_item() {
  return getRuleContext<SV3_1aParser::Production_itemContext>(0);
}

SV3_1aParser::Rs_code_blockContext* SV3_1aParser::Rs_prodContext::rs_code_block() {
  return getRuleContext<SV3_1aParser::Rs_code_blockContext>(0);
}

SV3_1aParser::Rs_if_elseContext* SV3_1aParser::Rs_prodContext::rs_if_else() {
  return getRuleContext<SV3_1aParser::Rs_if_elseContext>(0);
}

SV3_1aParser::Rs_repeatContext* SV3_1aParser::Rs_prodContext::rs_repeat() {
  return getRuleContext<SV3_1aParser::Rs_repeatContext>(0);
}

SV3_1aParser::Rs_caseContext* SV3_1aParser::Rs_prodContext::rs_case() {
  return getRuleContext<SV3_1aParser::Rs_caseContext>(0);
}


size_t SV3_1aParser::Rs_prodContext::getRuleIndex() const {
  return SV3_1aParser::RuleRs_prod;
}

void SV3_1aParser::Rs_prodContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRs_prod(this);
}

void SV3_1aParser::Rs_prodContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRs_prod(this);
}

SV3_1aParser::Rs_prodContext* SV3_1aParser::rs_prod() {
  Rs_prodContext *_localctx = _tracker.createInstance<Rs_prodContext>(_ctx, getState());
  enterRule(_localctx, 938, SV3_1aParser::RuleRs_prod);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(7590);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SV3_1aParser::THIS:
      case SV3_1aParser::RANDOMIZE:
      case SV3_1aParser::SAMPLE:
      case SV3_1aParser::Escaped_identifier:
      case SV3_1aParser::Simple_identifier: {
        enterOuterAlt(_localctx, 1);
        setState(7585);
        production_item();
        break;
      }

      case SV3_1aParser::OPEN_CURLY: {
        enterOuterAlt(_localctx, 2);
        setState(7586);
        rs_code_block();
        break;
      }

      case SV3_1aParser::IF: {
        enterOuterAlt(_localctx, 3);
        setState(7587);
        rs_if_else();
        break;
      }

      case SV3_1aParser::REPEAT: {
        enterOuterAlt(_localctx, 4);
        setState(7588);
        rs_repeat();
        break;
      }

      case SV3_1aParser::CASE: {
        enterOuterAlt(_localctx, 5);
        setState(7589);
        rs_case();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Production_itemContext ------------------------------------------------------------------

SV3_1aParser::Production_itemContext::Production_itemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::IdentifierContext* SV3_1aParser::Production_itemContext::identifier() {
  return getRuleContext<SV3_1aParser::IdentifierContext>(0);
}

tree::TerminalNode* SV3_1aParser::Production_itemContext::OPEN_PARENS() {
  return getToken(SV3_1aParser::OPEN_PARENS, 0);
}

SV3_1aParser::List_of_argumentsContext* SV3_1aParser::Production_itemContext::list_of_arguments() {
  return getRuleContext<SV3_1aParser::List_of_argumentsContext>(0);
}

tree::TerminalNode* SV3_1aParser::Production_itemContext::CLOSE_PARENS() {
  return getToken(SV3_1aParser::CLOSE_PARENS, 0);
}


size_t SV3_1aParser::Production_itemContext::getRuleIndex() const {
  return SV3_1aParser::RuleProduction_item;
}

void SV3_1aParser::Production_itemContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterProduction_item(this);
}

void SV3_1aParser::Production_itemContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitProduction_item(this);
}

SV3_1aParser::Production_itemContext* SV3_1aParser::production_item() {
  Production_itemContext *_localctx = _tracker.createInstance<Production_itemContext>(_ctx, getState());
  enterRule(_localctx, 940, SV3_1aParser::RuleProduction_item);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7592);
    identifier();
    setState(7597);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 891, _ctx)) {
    case 1: {
      setState(7593);
      match(SV3_1aParser::OPEN_PARENS);
      setState(7594);
      list_of_arguments();
      setState(7595);
      match(SV3_1aParser::CLOSE_PARENS);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Rs_if_elseContext ------------------------------------------------------------------

SV3_1aParser::Rs_if_elseContext::Rs_if_elseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Rs_if_elseContext::IF() {
  return getToken(SV3_1aParser::IF, 0);
}

tree::TerminalNode* SV3_1aParser::Rs_if_elseContext::OPEN_PARENS() {
  return getToken(SV3_1aParser::OPEN_PARENS, 0);
}

SV3_1aParser::ExpressionContext* SV3_1aParser::Rs_if_elseContext::expression() {
  return getRuleContext<SV3_1aParser::ExpressionContext>(0);
}

tree::TerminalNode* SV3_1aParser::Rs_if_elseContext::CLOSE_PARENS() {
  return getToken(SV3_1aParser::CLOSE_PARENS, 0);
}

std::vector<SV3_1aParser::Production_itemContext *> SV3_1aParser::Rs_if_elseContext::production_item() {
  return getRuleContexts<SV3_1aParser::Production_itemContext>();
}

SV3_1aParser::Production_itemContext* SV3_1aParser::Rs_if_elseContext::production_item(size_t i) {
  return getRuleContext<SV3_1aParser::Production_itemContext>(i);
}

tree::TerminalNode* SV3_1aParser::Rs_if_elseContext::ELSE() {
  return getToken(SV3_1aParser::ELSE, 0);
}


size_t SV3_1aParser::Rs_if_elseContext::getRuleIndex() const {
  return SV3_1aParser::RuleRs_if_else;
}

void SV3_1aParser::Rs_if_elseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRs_if_else(this);
}

void SV3_1aParser::Rs_if_elseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRs_if_else(this);
}

SV3_1aParser::Rs_if_elseContext* SV3_1aParser::rs_if_else() {
  Rs_if_elseContext *_localctx = _tracker.createInstance<Rs_if_elseContext>(_ctx, getState());
  enterRule(_localctx, 942, SV3_1aParser::RuleRs_if_else);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7599);
    match(SV3_1aParser::IF);
    setState(7600);
    match(SV3_1aParser::OPEN_PARENS);
    setState(7601);
    expression(0);
    setState(7602);
    match(SV3_1aParser::CLOSE_PARENS);
    setState(7603);
    production_item();
    setState(7606);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SV3_1aParser::ELSE) {
      setState(7604);
      match(SV3_1aParser::ELSE);
      setState(7605);
      production_item();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Rs_repeatContext ------------------------------------------------------------------

SV3_1aParser::Rs_repeatContext::Rs_repeatContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Rs_repeatContext::REPEAT() {
  return getToken(SV3_1aParser::REPEAT, 0);
}

tree::TerminalNode* SV3_1aParser::Rs_repeatContext::OPEN_PARENS() {
  return getToken(SV3_1aParser::OPEN_PARENS, 0);
}

SV3_1aParser::ExpressionContext* SV3_1aParser::Rs_repeatContext::expression() {
  return getRuleContext<SV3_1aParser::ExpressionContext>(0);
}

tree::TerminalNode* SV3_1aParser::Rs_repeatContext::CLOSE_PARENS() {
  return getToken(SV3_1aParser::CLOSE_PARENS, 0);
}

SV3_1aParser::Production_itemContext* SV3_1aParser::Rs_repeatContext::production_item() {
  return getRuleContext<SV3_1aParser::Production_itemContext>(0);
}


size_t SV3_1aParser::Rs_repeatContext::getRuleIndex() const {
  return SV3_1aParser::RuleRs_repeat;
}

void SV3_1aParser::Rs_repeatContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRs_repeat(this);
}

void SV3_1aParser::Rs_repeatContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRs_repeat(this);
}

SV3_1aParser::Rs_repeatContext* SV3_1aParser::rs_repeat() {
  Rs_repeatContext *_localctx = _tracker.createInstance<Rs_repeatContext>(_ctx, getState());
  enterRule(_localctx, 944, SV3_1aParser::RuleRs_repeat);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7608);
    match(SV3_1aParser::REPEAT);
    setState(7609);
    match(SV3_1aParser::OPEN_PARENS);
    setState(7610);
    expression(0);
    setState(7611);
    match(SV3_1aParser::CLOSE_PARENS);
    setState(7612);
    production_item();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Rs_caseContext ------------------------------------------------------------------

SV3_1aParser::Rs_caseContext::Rs_caseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Rs_caseContext::CASE() {
  return getToken(SV3_1aParser::CASE, 0);
}

tree::TerminalNode* SV3_1aParser::Rs_caseContext::OPEN_PARENS() {
  return getToken(SV3_1aParser::OPEN_PARENS, 0);
}

SV3_1aParser::ExpressionContext* SV3_1aParser::Rs_caseContext::expression() {
  return getRuleContext<SV3_1aParser::ExpressionContext>(0);
}

tree::TerminalNode* SV3_1aParser::Rs_caseContext::CLOSE_PARENS() {
  return getToken(SV3_1aParser::CLOSE_PARENS, 0);
}

std::vector<SV3_1aParser::Rs_case_itemContext *> SV3_1aParser::Rs_caseContext::rs_case_item() {
  return getRuleContexts<SV3_1aParser::Rs_case_itemContext>();
}

SV3_1aParser::Rs_case_itemContext* SV3_1aParser::Rs_caseContext::rs_case_item(size_t i) {
  return getRuleContext<SV3_1aParser::Rs_case_itemContext>(i);
}

tree::TerminalNode* SV3_1aParser::Rs_caseContext::ENDCASE() {
  return getToken(SV3_1aParser::ENDCASE, 0);
}


size_t SV3_1aParser::Rs_caseContext::getRuleIndex() const {
  return SV3_1aParser::RuleRs_case;
}

void SV3_1aParser::Rs_caseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRs_case(this);
}

void SV3_1aParser::Rs_caseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRs_case(this);
}

SV3_1aParser::Rs_caseContext* SV3_1aParser::rs_case() {
  Rs_caseContext *_localctx = _tracker.createInstance<Rs_caseContext>(_ctx, getState());
  enterRule(_localctx, 946, SV3_1aParser::RuleRs_case);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7614);
    match(SV3_1aParser::CASE);
    setState(7615);
    match(SV3_1aParser::OPEN_PARENS);
    setState(7616);
    expression(0);
    setState(7617);
    match(SV3_1aParser::CLOSE_PARENS);
    setState(7618);
    rs_case_item();
    setState(7622);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 8864814399484) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 64)) & 1152648825725551617) != 0) || ((((_la - 147) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 147)) & 2199527096323) != 0) || _la == SV3_1aParser::BANG || ((((_la - 310) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 310)) & 559537073624154177) != 0)) {
      setState(7619);
      rs_case_item();
      setState(7624);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(7625);
    match(SV3_1aParser::ENDCASE);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Rs_case_itemContext ------------------------------------------------------------------

SV3_1aParser::Rs_case_itemContext::Rs_case_itemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<SV3_1aParser::ExpressionContext *> SV3_1aParser::Rs_case_itemContext::expression() {
  return getRuleContexts<SV3_1aParser::ExpressionContext>();
}

SV3_1aParser::ExpressionContext* SV3_1aParser::Rs_case_itemContext::expression(size_t i) {
  return getRuleContext<SV3_1aParser::ExpressionContext>(i);
}

tree::TerminalNode* SV3_1aParser::Rs_case_itemContext::COLON() {
  return getToken(SV3_1aParser::COLON, 0);
}

SV3_1aParser::Production_itemContext* SV3_1aParser::Rs_case_itemContext::production_item() {
  return getRuleContext<SV3_1aParser::Production_itemContext>(0);
}

std::vector<tree::TerminalNode *> SV3_1aParser::Rs_case_itemContext::COMMA() {
  return getTokens(SV3_1aParser::COMMA);
}

tree::TerminalNode* SV3_1aParser::Rs_case_itemContext::COMMA(size_t i) {
  return getToken(SV3_1aParser::COMMA, i);
}

tree::TerminalNode* SV3_1aParser::Rs_case_itemContext::DEFAULT() {
  return getToken(SV3_1aParser::DEFAULT, 0);
}


size_t SV3_1aParser::Rs_case_itemContext::getRuleIndex() const {
  return SV3_1aParser::RuleRs_case_item;
}

void SV3_1aParser::Rs_case_itemContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRs_case_item(this);
}

void SV3_1aParser::Rs_case_itemContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRs_case_item(this);
}

SV3_1aParser::Rs_case_itemContext* SV3_1aParser::rs_case_item() {
  Rs_case_itemContext *_localctx = _tracker.createInstance<Rs_case_itemContext>(_ctx, getState());
  enterRule(_localctx, 948, SV3_1aParser::RuleRs_case_item);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(7643);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SV3_1aParser::TICK_b0:
      case SV3_1aParser::TICK_b1:
      case SV3_1aParser::TICK_B0:
      case SV3_1aParser::TICK_B1:
      case SV3_1aParser::TICK_0:
      case SV3_1aParser::TICK_1:
      case SV3_1aParser::ONE_TICK_b0:
      case SV3_1aParser::ONE_TICK_b1:
      case SV3_1aParser::ONE_TICK_bx:
      case SV3_1aParser::ONE_TICK_bX:
      case SV3_1aParser::ONE_TICK_B0:
      case SV3_1aParser::ONE_TICK_B1:
      case SV3_1aParser::ONE_TICK_Bx:
      case SV3_1aParser::ONE_TICK_BX:
      case SV3_1aParser::Integral_number:
      case SV3_1aParser::Real_number:
      case SV3_1aParser::String:
      case SV3_1aParser::OPEN_PARENS:
      case SV3_1aParser::TYPE:
      case SV3_1aParser::CONST:
      case SV3_1aParser::LOCAL:
      case SV3_1aParser::SUPER:
      case SV3_1aParser::OPEN_CURLY:
      case SV3_1aParser::STRING:
      case SV3_1aParser::BYTE:
      case SV3_1aParser::SHORTINT:
      case SV3_1aParser::INT:
      case SV3_1aParser::LONGINT:
      case SV3_1aParser::INTEGER:
      case SV3_1aParser::TIME:
      case SV3_1aParser::BIT:
      case SV3_1aParser::LOGIC:
      case SV3_1aParser::REG:
      case SV3_1aParser::SHORTREAL:
      case SV3_1aParser::REAL:
      case SV3_1aParser::REALTIME:
      case SV3_1aParser::SIGNED:
      case SV3_1aParser::UNSIGNED:
      case SV3_1aParser::DOLLAR:
      case SV3_1aParser::PLUSPLUS:
      case SV3_1aParser::PLUS:
      case SV3_1aParser::MINUSMINUS:
      case SV3_1aParser::MINUS:
      case SV3_1aParser::DOLLAR_UNIT:
      case SV3_1aParser::BANG:
      case SV3_1aParser::TAGGED:
      case SV3_1aParser::TICK:
      case SV3_1aParser::NULL_KEYWORD:
      case SV3_1aParser::THIS:
      case SV3_1aParser::DOLLAR_ROOT:
      case SV3_1aParser::RANDOMIZE:
      case SV3_1aParser::SAMPLE:
      case SV3_1aParser::BITW_AND:
      case SV3_1aParser::BITW_OR:
      case SV3_1aParser::REDUCTION_NOR:
      case SV3_1aParser::REDUCTION_NAND:
      case SV3_1aParser::REDUCTION_XNOR1:
      case SV3_1aParser::Escaped_identifier:
      case SV3_1aParser::TILDA:
      case SV3_1aParser::BITW_XOR:
      case SV3_1aParser::REDUCTION_XNOR2:
      case SV3_1aParser::Simple_identifier: {
        enterOuterAlt(_localctx, 1);
        setState(7627);
        expression(0);
        setState(7632);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == SV3_1aParser::COMMA) {
          setState(7628);
          match(SV3_1aParser::COMMA);
          setState(7629);
          expression(0);
          setState(7634);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(7635);
        match(SV3_1aParser::COLON);
        setState(7636);
        production_item();
        break;
      }

      case SV3_1aParser::DEFAULT: {
        enterOuterAlt(_localctx, 2);
        setState(7638);
        match(SV3_1aParser::DEFAULT);
        setState(7640);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == SV3_1aParser::COLON) {
          setState(7639);
          match(SV3_1aParser::COLON);
        }
        setState(7642);
        production_item();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Specify_blockContext ------------------------------------------------------------------

SV3_1aParser::Specify_blockContext::Specify_blockContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Specify_blockContext::SPECIFY() {
  return getToken(SV3_1aParser::SPECIFY, 0);
}

tree::TerminalNode* SV3_1aParser::Specify_blockContext::ENDSPECIFY() {
  return getToken(SV3_1aParser::ENDSPECIFY, 0);
}

std::vector<SV3_1aParser::Specify_itemContext *> SV3_1aParser::Specify_blockContext::specify_item() {
  return getRuleContexts<SV3_1aParser::Specify_itemContext>();
}

SV3_1aParser::Specify_itemContext* SV3_1aParser::Specify_blockContext::specify_item(size_t i) {
  return getRuleContext<SV3_1aParser::Specify_itemContext>(i);
}


size_t SV3_1aParser::Specify_blockContext::getRuleIndex() const {
  return SV3_1aParser::RuleSpecify_block;
}

void SV3_1aParser::Specify_blockContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSpecify_block(this);
}

void SV3_1aParser::Specify_blockContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSpecify_block(this);
}

SV3_1aParser::Specify_blockContext* SV3_1aParser::specify_block() {
  Specify_blockContext *_localctx = _tracker.createInstance<Specify_blockContext>(_ctx, getState());
  enterRule(_localctx, 950, SV3_1aParser::RuleSpecify_block);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7645);
    match(SV3_1aParser::SPECIFY);
    setState(7649);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (((((_la - 43) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 43)) & 18155135997837313) != 0) || _la == SV3_1aParser::DOLLAR || ((((_la - 337) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 337)) & 31) != 0)) {
      setState(7646);
      specify_item();
      setState(7651);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(7652);
    match(SV3_1aParser::ENDSPECIFY);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Specify_itemContext ------------------------------------------------------------------

SV3_1aParser::Specify_itemContext::Specify_itemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::Specparam_declarationContext* SV3_1aParser::Specify_itemContext::specparam_declaration() {
  return getRuleContext<SV3_1aParser::Specparam_declarationContext>(0);
}

SV3_1aParser::Pulsestyle_declarationContext* SV3_1aParser::Specify_itemContext::pulsestyle_declaration() {
  return getRuleContext<SV3_1aParser::Pulsestyle_declarationContext>(0);
}

SV3_1aParser::Showcancelled_declarationContext* SV3_1aParser::Specify_itemContext::showcancelled_declaration() {
  return getRuleContext<SV3_1aParser::Showcancelled_declarationContext>(0);
}

SV3_1aParser::Path_declarationContext* SV3_1aParser::Specify_itemContext::path_declaration() {
  return getRuleContext<SV3_1aParser::Path_declarationContext>(0);
}

SV3_1aParser::System_timing_checkContext* SV3_1aParser::Specify_itemContext::system_timing_check() {
  return getRuleContext<SV3_1aParser::System_timing_checkContext>(0);
}


size_t SV3_1aParser::Specify_itemContext::getRuleIndex() const {
  return SV3_1aParser::RuleSpecify_item;
}

void SV3_1aParser::Specify_itemContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSpecify_item(this);
}

void SV3_1aParser::Specify_itemContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSpecify_item(this);
}

SV3_1aParser::Specify_itemContext* SV3_1aParser::specify_item() {
  Specify_itemContext *_localctx = _tracker.createInstance<Specify_itemContext>(_ctx, getState());
  enterRule(_localctx, 952, SV3_1aParser::RuleSpecify_item);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(7659);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SV3_1aParser::SPECPARAM: {
        enterOuterAlt(_localctx, 1);
        setState(7654);
        specparam_declaration();
        break;
      }

      case SV3_1aParser::PULSESTYLE_ONEVENT:
      case SV3_1aParser::PULSESTYLE_ONDETECT: {
        enterOuterAlt(_localctx, 2);
        setState(7655);
        pulsestyle_declaration();
        break;
      }

      case SV3_1aParser::SHOWCANCELLED:
      case SV3_1aParser::NOSHOWCANCELLED: {
        enterOuterAlt(_localctx, 3);
        setState(7656);
        showcancelled_declaration();
        break;
      }

      case SV3_1aParser::OPEN_PARENS:
      case SV3_1aParser::IF:
      case SV3_1aParser::IFNONE: {
        enterOuterAlt(_localctx, 4);
        setState(7657);
        path_declaration();
        break;
      }

      case SV3_1aParser::DOLLAR: {
        enterOuterAlt(_localctx, 5);
        setState(7658);
        system_timing_check();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Pulsestyle_declarationContext ------------------------------------------------------------------

SV3_1aParser::Pulsestyle_declarationContext::Pulsestyle_declarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Pulsestyle_declarationContext::PULSESTYLE_ONEVENT() {
  return getToken(SV3_1aParser::PULSESTYLE_ONEVENT, 0);
}

SV3_1aParser::List_of_path_outputsContext* SV3_1aParser::Pulsestyle_declarationContext::list_of_path_outputs() {
  return getRuleContext<SV3_1aParser::List_of_path_outputsContext>(0);
}

tree::TerminalNode* SV3_1aParser::Pulsestyle_declarationContext::SEMICOLON() {
  return getToken(SV3_1aParser::SEMICOLON, 0);
}

tree::TerminalNode* SV3_1aParser::Pulsestyle_declarationContext::PULSESTYLE_ONDETECT() {
  return getToken(SV3_1aParser::PULSESTYLE_ONDETECT, 0);
}


size_t SV3_1aParser::Pulsestyle_declarationContext::getRuleIndex() const {
  return SV3_1aParser::RulePulsestyle_declaration;
}

void SV3_1aParser::Pulsestyle_declarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPulsestyle_declaration(this);
}

void SV3_1aParser::Pulsestyle_declarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPulsestyle_declaration(this);
}

SV3_1aParser::Pulsestyle_declarationContext* SV3_1aParser::pulsestyle_declaration() {
  Pulsestyle_declarationContext *_localctx = _tracker.createInstance<Pulsestyle_declarationContext>(_ctx, getState());
  enterRule(_localctx, 954, SV3_1aParser::RulePulsestyle_declaration);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(7669);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SV3_1aParser::PULSESTYLE_ONEVENT: {
        enterOuterAlt(_localctx, 1);
        setState(7661);
        match(SV3_1aParser::PULSESTYLE_ONEVENT);
        setState(7662);
        list_of_path_outputs();
        setState(7663);
        match(SV3_1aParser::SEMICOLON);
        break;
      }

      case SV3_1aParser::PULSESTYLE_ONDETECT: {
        enterOuterAlt(_localctx, 2);
        setState(7665);
        match(SV3_1aParser::PULSESTYLE_ONDETECT);
        setState(7666);
        list_of_path_outputs();
        setState(7667);
        match(SV3_1aParser::SEMICOLON);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Showcancelled_declarationContext ------------------------------------------------------------------

SV3_1aParser::Showcancelled_declarationContext::Showcancelled_declarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Showcancelled_declarationContext::SHOWCANCELLED() {
  return getToken(SV3_1aParser::SHOWCANCELLED, 0);
}

SV3_1aParser::List_of_path_outputsContext* SV3_1aParser::Showcancelled_declarationContext::list_of_path_outputs() {
  return getRuleContext<SV3_1aParser::List_of_path_outputsContext>(0);
}

tree::TerminalNode* SV3_1aParser::Showcancelled_declarationContext::SEMICOLON() {
  return getToken(SV3_1aParser::SEMICOLON, 0);
}

tree::TerminalNode* SV3_1aParser::Showcancelled_declarationContext::NOSHOWCANCELLED() {
  return getToken(SV3_1aParser::NOSHOWCANCELLED, 0);
}


size_t SV3_1aParser::Showcancelled_declarationContext::getRuleIndex() const {
  return SV3_1aParser::RuleShowcancelled_declaration;
}

void SV3_1aParser::Showcancelled_declarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterShowcancelled_declaration(this);
}

void SV3_1aParser::Showcancelled_declarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitShowcancelled_declaration(this);
}

SV3_1aParser::Showcancelled_declarationContext* SV3_1aParser::showcancelled_declaration() {
  Showcancelled_declarationContext *_localctx = _tracker.createInstance<Showcancelled_declarationContext>(_ctx, getState());
  enterRule(_localctx, 956, SV3_1aParser::RuleShowcancelled_declaration);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(7679);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SV3_1aParser::SHOWCANCELLED: {
        enterOuterAlt(_localctx, 1);
        setState(7671);
        match(SV3_1aParser::SHOWCANCELLED);
        setState(7672);
        list_of_path_outputs();
        setState(7673);
        match(SV3_1aParser::SEMICOLON);
        break;
      }

      case SV3_1aParser::NOSHOWCANCELLED: {
        enterOuterAlt(_localctx, 2);
        setState(7675);
        match(SV3_1aParser::NOSHOWCANCELLED);
        setState(7676);
        list_of_path_outputs();
        setState(7677);
        match(SV3_1aParser::SEMICOLON);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Path_declarationContext ------------------------------------------------------------------

SV3_1aParser::Path_declarationContext::Path_declarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::Simple_path_declarationContext* SV3_1aParser::Path_declarationContext::simple_path_declaration() {
  return getRuleContext<SV3_1aParser::Simple_path_declarationContext>(0);
}

tree::TerminalNode* SV3_1aParser::Path_declarationContext::SEMICOLON() {
  return getToken(SV3_1aParser::SEMICOLON, 0);
}

SV3_1aParser::Edge_sensitive_path_declarationContext* SV3_1aParser::Path_declarationContext::edge_sensitive_path_declaration() {
  return getRuleContext<SV3_1aParser::Edge_sensitive_path_declarationContext>(0);
}

SV3_1aParser::State_dependent_path_declarationContext* SV3_1aParser::Path_declarationContext::state_dependent_path_declaration() {
  return getRuleContext<SV3_1aParser::State_dependent_path_declarationContext>(0);
}


size_t SV3_1aParser::Path_declarationContext::getRuleIndex() const {
  return SV3_1aParser::RulePath_declaration;
}

void SV3_1aParser::Path_declarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPath_declaration(this);
}

void SV3_1aParser::Path_declarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPath_declaration(this);
}

SV3_1aParser::Path_declarationContext* SV3_1aParser::path_declaration() {
  Path_declarationContext *_localctx = _tracker.createInstance<Path_declarationContext>(_ctx, getState());
  enterRule(_localctx, 958, SV3_1aParser::RulePath_declaration);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(7690);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 901, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(7681);
      simple_path_declaration();
      setState(7682);
      match(SV3_1aParser::SEMICOLON);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(7684);
      edge_sensitive_path_declaration();
      setState(7685);
      match(SV3_1aParser::SEMICOLON);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(7687);
      state_dependent_path_declaration();
      setState(7688);
      match(SV3_1aParser::SEMICOLON);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Simple_path_declarationContext ------------------------------------------------------------------

SV3_1aParser::Simple_path_declarationContext::Simple_path_declarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::Parallel_path_descriptionContext* SV3_1aParser::Simple_path_declarationContext::parallel_path_description() {
  return getRuleContext<SV3_1aParser::Parallel_path_descriptionContext>(0);
}

tree::TerminalNode* SV3_1aParser::Simple_path_declarationContext::ASSIGN_OP() {
  return getToken(SV3_1aParser::ASSIGN_OP, 0);
}

SV3_1aParser::Path_delay_valueContext* SV3_1aParser::Simple_path_declarationContext::path_delay_value() {
  return getRuleContext<SV3_1aParser::Path_delay_valueContext>(0);
}

SV3_1aParser::Full_path_descriptionContext* SV3_1aParser::Simple_path_declarationContext::full_path_description() {
  return getRuleContext<SV3_1aParser::Full_path_descriptionContext>(0);
}


size_t SV3_1aParser::Simple_path_declarationContext::getRuleIndex() const {
  return SV3_1aParser::RuleSimple_path_declaration;
}

void SV3_1aParser::Simple_path_declarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSimple_path_declaration(this);
}

void SV3_1aParser::Simple_path_declarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSimple_path_declaration(this);
}

SV3_1aParser::Simple_path_declarationContext* SV3_1aParser::simple_path_declaration() {
  Simple_path_declarationContext *_localctx = _tracker.createInstance<Simple_path_declarationContext>(_ctx, getState());
  enterRule(_localctx, 960, SV3_1aParser::RuleSimple_path_declaration);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(7700);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 902, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(7692);
      parallel_path_description();
      setState(7693);
      match(SV3_1aParser::ASSIGN_OP);
      setState(7694);
      path_delay_value();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(7696);
      full_path_description();
      setState(7697);
      match(SV3_1aParser::ASSIGN_OP);
      setState(7698);
      path_delay_value();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Parallel_path_descriptionContext ------------------------------------------------------------------

SV3_1aParser::Parallel_path_descriptionContext::Parallel_path_descriptionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Parallel_path_descriptionContext::OPEN_PARENS() {
  return getToken(SV3_1aParser::OPEN_PARENS, 0);
}

SV3_1aParser::Specify_input_terminal_descriptorContext* SV3_1aParser::Parallel_path_descriptionContext::specify_input_terminal_descriptor() {
  return getRuleContext<SV3_1aParser::Specify_input_terminal_descriptorContext>(0);
}

tree::TerminalNode* SV3_1aParser::Parallel_path_descriptionContext::TRANSITION_OP() {
  return getToken(SV3_1aParser::TRANSITION_OP, 0);
}

SV3_1aParser::Specify_output_terminal_descriptorContext* SV3_1aParser::Parallel_path_descriptionContext::specify_output_terminal_descriptor() {
  return getRuleContext<SV3_1aParser::Specify_output_terminal_descriptorContext>(0);
}

tree::TerminalNode* SV3_1aParser::Parallel_path_descriptionContext::CLOSE_PARENS() {
  return getToken(SV3_1aParser::CLOSE_PARENS, 0);
}

tree::TerminalNode* SV3_1aParser::Parallel_path_descriptionContext::PLUS() {
  return getToken(SV3_1aParser::PLUS, 0);
}

tree::TerminalNode* SV3_1aParser::Parallel_path_descriptionContext::MINUS() {
  return getToken(SV3_1aParser::MINUS, 0);
}


size_t SV3_1aParser::Parallel_path_descriptionContext::getRuleIndex() const {
  return SV3_1aParser::RuleParallel_path_description;
}

void SV3_1aParser::Parallel_path_descriptionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterParallel_path_description(this);
}

void SV3_1aParser::Parallel_path_descriptionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitParallel_path_description(this);
}

SV3_1aParser::Parallel_path_descriptionContext* SV3_1aParser::parallel_path_description() {
  Parallel_path_descriptionContext *_localctx = _tracker.createInstance<Parallel_path_descriptionContext>(_ctx, getState());
  enterRule(_localctx, 962, SV3_1aParser::RuleParallel_path_description);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7702);
    match(SV3_1aParser::OPEN_PARENS);
    setState(7703);
    specify_input_terminal_descriptor();
    setState(7705);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SV3_1aParser::PLUS

    || _la == SV3_1aParser::MINUS) {
      setState(7704);
      _la = _input->LA(1);
      if (!(_la == SV3_1aParser::PLUS

      || _la == SV3_1aParser::MINUS)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
    }
    setState(7707);
    match(SV3_1aParser::TRANSITION_OP);
    setState(7708);
    specify_output_terminal_descriptor();
    setState(7709);
    match(SV3_1aParser::CLOSE_PARENS);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Full_path_descriptionContext ------------------------------------------------------------------

SV3_1aParser::Full_path_descriptionContext::Full_path_descriptionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Full_path_descriptionContext::OPEN_PARENS() {
  return getToken(SV3_1aParser::OPEN_PARENS, 0);
}

SV3_1aParser::List_of_path_inputsContext* SV3_1aParser::Full_path_descriptionContext::list_of_path_inputs() {
  return getRuleContext<SV3_1aParser::List_of_path_inputsContext>(0);
}

tree::TerminalNode* SV3_1aParser::Full_path_descriptionContext::FULL_CONN_OP() {
  return getToken(SV3_1aParser::FULL_CONN_OP, 0);
}

SV3_1aParser::List_of_path_outputsContext* SV3_1aParser::Full_path_descriptionContext::list_of_path_outputs() {
  return getRuleContext<SV3_1aParser::List_of_path_outputsContext>(0);
}

tree::TerminalNode* SV3_1aParser::Full_path_descriptionContext::CLOSE_PARENS() {
  return getToken(SV3_1aParser::CLOSE_PARENS, 0);
}

tree::TerminalNode* SV3_1aParser::Full_path_descriptionContext::PLUS() {
  return getToken(SV3_1aParser::PLUS, 0);
}

tree::TerminalNode* SV3_1aParser::Full_path_descriptionContext::MINUS() {
  return getToken(SV3_1aParser::MINUS, 0);
}


size_t SV3_1aParser::Full_path_descriptionContext::getRuleIndex() const {
  return SV3_1aParser::RuleFull_path_description;
}

void SV3_1aParser::Full_path_descriptionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFull_path_description(this);
}

void SV3_1aParser::Full_path_descriptionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFull_path_description(this);
}

SV3_1aParser::Full_path_descriptionContext* SV3_1aParser::full_path_description() {
  Full_path_descriptionContext *_localctx = _tracker.createInstance<Full_path_descriptionContext>(_ctx, getState());
  enterRule(_localctx, 964, SV3_1aParser::RuleFull_path_description);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7711);
    match(SV3_1aParser::OPEN_PARENS);
    setState(7712);
    list_of_path_inputs();
    setState(7714);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SV3_1aParser::PLUS

    || _la == SV3_1aParser::MINUS) {
      setState(7713);
      _la = _input->LA(1);
      if (!(_la == SV3_1aParser::PLUS

      || _la == SV3_1aParser::MINUS)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
    }
    setState(7716);
    match(SV3_1aParser::FULL_CONN_OP);
    setState(7717);
    list_of_path_outputs();
    setState(7718);
    match(SV3_1aParser::CLOSE_PARENS);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- List_of_path_inputsContext ------------------------------------------------------------------

SV3_1aParser::List_of_path_inputsContext::List_of_path_inputsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<SV3_1aParser::Specify_input_terminal_descriptorContext *> SV3_1aParser::List_of_path_inputsContext::specify_input_terminal_descriptor() {
  return getRuleContexts<SV3_1aParser::Specify_input_terminal_descriptorContext>();
}

SV3_1aParser::Specify_input_terminal_descriptorContext* SV3_1aParser::List_of_path_inputsContext::specify_input_terminal_descriptor(size_t i) {
  return getRuleContext<SV3_1aParser::Specify_input_terminal_descriptorContext>(i);
}

std::vector<tree::TerminalNode *> SV3_1aParser::List_of_path_inputsContext::COMMA() {
  return getTokens(SV3_1aParser::COMMA);
}

tree::TerminalNode* SV3_1aParser::List_of_path_inputsContext::COMMA(size_t i) {
  return getToken(SV3_1aParser::COMMA, i);
}


size_t SV3_1aParser::List_of_path_inputsContext::getRuleIndex() const {
  return SV3_1aParser::RuleList_of_path_inputs;
}

void SV3_1aParser::List_of_path_inputsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterList_of_path_inputs(this);
}

void SV3_1aParser::List_of_path_inputsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitList_of_path_inputs(this);
}

SV3_1aParser::List_of_path_inputsContext* SV3_1aParser::list_of_path_inputs() {
  List_of_path_inputsContext *_localctx = _tracker.createInstance<List_of_path_inputsContext>(_ctx, getState());
  enterRule(_localctx, 966, SV3_1aParser::RuleList_of_path_inputs);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7720);
    specify_input_terminal_descriptor();
    setState(7725);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == SV3_1aParser::COMMA) {
      setState(7721);
      match(SV3_1aParser::COMMA);
      setState(7722);
      specify_input_terminal_descriptor();
      setState(7727);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- List_of_path_outputsContext ------------------------------------------------------------------

SV3_1aParser::List_of_path_outputsContext::List_of_path_outputsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<SV3_1aParser::Specify_output_terminal_descriptorContext *> SV3_1aParser::List_of_path_outputsContext::specify_output_terminal_descriptor() {
  return getRuleContexts<SV3_1aParser::Specify_output_terminal_descriptorContext>();
}

SV3_1aParser::Specify_output_terminal_descriptorContext* SV3_1aParser::List_of_path_outputsContext::specify_output_terminal_descriptor(size_t i) {
  return getRuleContext<SV3_1aParser::Specify_output_terminal_descriptorContext>(i);
}

std::vector<tree::TerminalNode *> SV3_1aParser::List_of_path_outputsContext::COMMA() {
  return getTokens(SV3_1aParser::COMMA);
}

tree::TerminalNode* SV3_1aParser::List_of_path_outputsContext::COMMA(size_t i) {
  return getToken(SV3_1aParser::COMMA, i);
}


size_t SV3_1aParser::List_of_path_outputsContext::getRuleIndex() const {
  return SV3_1aParser::RuleList_of_path_outputs;
}

void SV3_1aParser::List_of_path_outputsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterList_of_path_outputs(this);
}

void SV3_1aParser::List_of_path_outputsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitList_of_path_outputs(this);
}

SV3_1aParser::List_of_path_outputsContext* SV3_1aParser::list_of_path_outputs() {
  List_of_path_outputsContext *_localctx = _tracker.createInstance<List_of_path_outputsContext>(_ctx, getState());
  enterRule(_localctx, 968, SV3_1aParser::RuleList_of_path_outputs);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7728);
    specify_output_terminal_descriptor();
    setState(7733);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == SV3_1aParser::COMMA) {
      setState(7729);
      match(SV3_1aParser::COMMA);
      setState(7730);
      specify_output_terminal_descriptor();
      setState(7735);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Specify_input_terminal_descriptorContext ------------------------------------------------------------------

SV3_1aParser::Specify_input_terminal_descriptorContext::Specify_input_terminal_descriptorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::IdentifierContext* SV3_1aParser::Specify_input_terminal_descriptorContext::identifier() {
  return getRuleContext<SV3_1aParser::IdentifierContext>(0);
}

SV3_1aParser::Interface_identifierContext* SV3_1aParser::Specify_input_terminal_descriptorContext::interface_identifier() {
  return getRuleContext<SV3_1aParser::Interface_identifierContext>(0);
}

tree::TerminalNode* SV3_1aParser::Specify_input_terminal_descriptorContext::DOT() {
  return getToken(SV3_1aParser::DOT, 0);
}

tree::TerminalNode* SV3_1aParser::Specify_input_terminal_descriptorContext::OPEN_BRACKET() {
  return getToken(SV3_1aParser::OPEN_BRACKET, 0);
}

SV3_1aParser::Constant_range_expressionContext* SV3_1aParser::Specify_input_terminal_descriptorContext::constant_range_expression() {
  return getRuleContext<SV3_1aParser::Constant_range_expressionContext>(0);
}

tree::TerminalNode* SV3_1aParser::Specify_input_terminal_descriptorContext::CLOSE_BRACKET() {
  return getToken(SV3_1aParser::CLOSE_BRACKET, 0);
}


size_t SV3_1aParser::Specify_input_terminal_descriptorContext::getRuleIndex() const {
  return SV3_1aParser::RuleSpecify_input_terminal_descriptor;
}

void SV3_1aParser::Specify_input_terminal_descriptorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSpecify_input_terminal_descriptor(this);
}

void SV3_1aParser::Specify_input_terminal_descriptorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSpecify_input_terminal_descriptor(this);
}

SV3_1aParser::Specify_input_terminal_descriptorContext* SV3_1aParser::specify_input_terminal_descriptor() {
  Specify_input_terminal_descriptorContext *_localctx = _tracker.createInstance<Specify_input_terminal_descriptorContext>(_ctx, getState());
  enterRule(_localctx, 970, SV3_1aParser::RuleSpecify_input_terminal_descriptor);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7741);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 907, _ctx)) {
    case 1: {
      setState(7736);
      identifier();
      break;
    }

    case 2: {
      setState(7737);
      interface_identifier();
      setState(7738);
      match(SV3_1aParser::DOT);
      setState(7739);
      identifier();
      break;
    }

    default:
      break;
    }
    setState(7747);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SV3_1aParser::OPEN_BRACKET) {
      setState(7743);
      match(SV3_1aParser::OPEN_BRACKET);
      setState(7744);
      constant_range_expression();
      setState(7745);
      match(SV3_1aParser::CLOSE_BRACKET);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Specify_output_terminal_descriptorContext ------------------------------------------------------------------

SV3_1aParser::Specify_output_terminal_descriptorContext::Specify_output_terminal_descriptorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::IdentifierContext* SV3_1aParser::Specify_output_terminal_descriptorContext::identifier() {
  return getRuleContext<SV3_1aParser::IdentifierContext>(0);
}

SV3_1aParser::Interface_identifierContext* SV3_1aParser::Specify_output_terminal_descriptorContext::interface_identifier() {
  return getRuleContext<SV3_1aParser::Interface_identifierContext>(0);
}

tree::TerminalNode* SV3_1aParser::Specify_output_terminal_descriptorContext::DOT() {
  return getToken(SV3_1aParser::DOT, 0);
}

tree::TerminalNode* SV3_1aParser::Specify_output_terminal_descriptorContext::OPEN_BRACKET() {
  return getToken(SV3_1aParser::OPEN_BRACKET, 0);
}

SV3_1aParser::Constant_range_expressionContext* SV3_1aParser::Specify_output_terminal_descriptorContext::constant_range_expression() {
  return getRuleContext<SV3_1aParser::Constant_range_expressionContext>(0);
}

tree::TerminalNode* SV3_1aParser::Specify_output_terminal_descriptorContext::CLOSE_BRACKET() {
  return getToken(SV3_1aParser::CLOSE_BRACKET, 0);
}


size_t SV3_1aParser::Specify_output_terminal_descriptorContext::getRuleIndex() const {
  return SV3_1aParser::RuleSpecify_output_terminal_descriptor;
}

void SV3_1aParser::Specify_output_terminal_descriptorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSpecify_output_terminal_descriptor(this);
}

void SV3_1aParser::Specify_output_terminal_descriptorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSpecify_output_terminal_descriptor(this);
}

SV3_1aParser::Specify_output_terminal_descriptorContext* SV3_1aParser::specify_output_terminal_descriptor() {
  Specify_output_terminal_descriptorContext *_localctx = _tracker.createInstance<Specify_output_terminal_descriptorContext>(_ctx, getState());
  enterRule(_localctx, 972, SV3_1aParser::RuleSpecify_output_terminal_descriptor);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7754);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 909, _ctx)) {
    case 1: {
      setState(7749);
      identifier();
      break;
    }

    case 2: {
      setState(7750);
      interface_identifier();
      setState(7751);
      match(SV3_1aParser::DOT);
      setState(7752);
      identifier();
      break;
    }

    default:
      break;
    }
    setState(7760);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SV3_1aParser::OPEN_BRACKET) {
      setState(7756);
      match(SV3_1aParser::OPEN_BRACKET);
      setState(7757);
      constant_range_expression();
      setState(7758);
      match(SV3_1aParser::CLOSE_BRACKET);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Path_delay_valueContext ------------------------------------------------------------------

SV3_1aParser::Path_delay_valueContext::Path_delay_valueContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::List_of_path_delay_expressionsContext* SV3_1aParser::Path_delay_valueContext::list_of_path_delay_expressions() {
  return getRuleContext<SV3_1aParser::List_of_path_delay_expressionsContext>(0);
}

tree::TerminalNode* SV3_1aParser::Path_delay_valueContext::OPEN_PARENS() {
  return getToken(SV3_1aParser::OPEN_PARENS, 0);
}

tree::TerminalNode* SV3_1aParser::Path_delay_valueContext::CLOSE_PARENS() {
  return getToken(SV3_1aParser::CLOSE_PARENS, 0);
}


size_t SV3_1aParser::Path_delay_valueContext::getRuleIndex() const {
  return SV3_1aParser::RulePath_delay_value;
}

void SV3_1aParser::Path_delay_valueContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPath_delay_value(this);
}

void SV3_1aParser::Path_delay_valueContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPath_delay_value(this);
}

SV3_1aParser::Path_delay_valueContext* SV3_1aParser::path_delay_value() {
  Path_delay_valueContext *_localctx = _tracker.createInstance<Path_delay_valueContext>(_ctx, getState());
  enterRule(_localctx, 974, SV3_1aParser::RulePath_delay_value);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(7767);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 911, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(7762);
      list_of_path_delay_expressions();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(7763);
      match(SV3_1aParser::OPEN_PARENS);
      setState(7764);
      list_of_path_delay_expressions();
      setState(7765);
      match(SV3_1aParser::CLOSE_PARENS);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- List_of_path_delay_expressionsContext ------------------------------------------------------------------

SV3_1aParser::List_of_path_delay_expressionsContext::List_of_path_delay_expressionsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::T_path_delay_expressionContext* SV3_1aParser::List_of_path_delay_expressionsContext::t_path_delay_expression() {
  return getRuleContext<SV3_1aParser::T_path_delay_expressionContext>(0);
}

SV3_1aParser::Trise_path_delay_expressionContext* SV3_1aParser::List_of_path_delay_expressionsContext::trise_path_delay_expression() {
  return getRuleContext<SV3_1aParser::Trise_path_delay_expressionContext>(0);
}

std::vector<tree::TerminalNode *> SV3_1aParser::List_of_path_delay_expressionsContext::COMMA() {
  return getTokens(SV3_1aParser::COMMA);
}

tree::TerminalNode* SV3_1aParser::List_of_path_delay_expressionsContext::COMMA(size_t i) {
  return getToken(SV3_1aParser::COMMA, i);
}

SV3_1aParser::Tfall_path_delay_expressionContext* SV3_1aParser::List_of_path_delay_expressionsContext::tfall_path_delay_expression() {
  return getRuleContext<SV3_1aParser::Tfall_path_delay_expressionContext>(0);
}

SV3_1aParser::Tz_path_delay_expressionContext* SV3_1aParser::List_of_path_delay_expressionsContext::tz_path_delay_expression() {
  return getRuleContext<SV3_1aParser::Tz_path_delay_expressionContext>(0);
}

SV3_1aParser::T01_path_delay_expressionContext* SV3_1aParser::List_of_path_delay_expressionsContext::t01_path_delay_expression() {
  return getRuleContext<SV3_1aParser::T01_path_delay_expressionContext>(0);
}

SV3_1aParser::T10_path_delay_expressionContext* SV3_1aParser::List_of_path_delay_expressionsContext::t10_path_delay_expression() {
  return getRuleContext<SV3_1aParser::T10_path_delay_expressionContext>(0);
}

SV3_1aParser::T0z_path_delay_expressionContext* SV3_1aParser::List_of_path_delay_expressionsContext::t0z_path_delay_expression() {
  return getRuleContext<SV3_1aParser::T0z_path_delay_expressionContext>(0);
}

SV3_1aParser::Tz1_path_delay_expressionContext* SV3_1aParser::List_of_path_delay_expressionsContext::tz1_path_delay_expression() {
  return getRuleContext<SV3_1aParser::Tz1_path_delay_expressionContext>(0);
}

SV3_1aParser::T1z_path_delay_expressionContext* SV3_1aParser::List_of_path_delay_expressionsContext::t1z_path_delay_expression() {
  return getRuleContext<SV3_1aParser::T1z_path_delay_expressionContext>(0);
}

SV3_1aParser::Tz0_path_delay_expressionContext* SV3_1aParser::List_of_path_delay_expressionsContext::tz0_path_delay_expression() {
  return getRuleContext<SV3_1aParser::Tz0_path_delay_expressionContext>(0);
}

SV3_1aParser::T0x_path_delay_expressionContext* SV3_1aParser::List_of_path_delay_expressionsContext::t0x_path_delay_expression() {
  return getRuleContext<SV3_1aParser::T0x_path_delay_expressionContext>(0);
}

SV3_1aParser::Tx1_path_delay_expressionContext* SV3_1aParser::List_of_path_delay_expressionsContext::tx1_path_delay_expression() {
  return getRuleContext<SV3_1aParser::Tx1_path_delay_expressionContext>(0);
}

SV3_1aParser::T1x_path_delay_expressionContext* SV3_1aParser::List_of_path_delay_expressionsContext::t1x_path_delay_expression() {
  return getRuleContext<SV3_1aParser::T1x_path_delay_expressionContext>(0);
}

SV3_1aParser::Tx0_path_delay_expressionContext* SV3_1aParser::List_of_path_delay_expressionsContext::tx0_path_delay_expression() {
  return getRuleContext<SV3_1aParser::Tx0_path_delay_expressionContext>(0);
}

SV3_1aParser::Txz_path_delay_expressionContext* SV3_1aParser::List_of_path_delay_expressionsContext::txz_path_delay_expression() {
  return getRuleContext<SV3_1aParser::Txz_path_delay_expressionContext>(0);
}

SV3_1aParser::Tzx_path_delay_expressionContext* SV3_1aParser::List_of_path_delay_expressionsContext::tzx_path_delay_expression() {
  return getRuleContext<SV3_1aParser::Tzx_path_delay_expressionContext>(0);
}


size_t SV3_1aParser::List_of_path_delay_expressionsContext::getRuleIndex() const {
  return SV3_1aParser::RuleList_of_path_delay_expressions;
}

void SV3_1aParser::List_of_path_delay_expressionsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterList_of_path_delay_expressions(this);
}

void SV3_1aParser::List_of_path_delay_expressionsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitList_of_path_delay_expressions(this);
}

SV3_1aParser::List_of_path_delay_expressionsContext* SV3_1aParser::list_of_path_delay_expressions() {
  List_of_path_delay_expressionsContext *_localctx = _tracker.createInstance<List_of_path_delay_expressionsContext>(_ctx, getState());
  enterRule(_localctx, 976, SV3_1aParser::RuleList_of_path_delay_expressions);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(7816);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 912, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(7769);
      t_path_delay_expression();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(7770);
      trise_path_delay_expression();
      setState(7771);
      match(SV3_1aParser::COMMA);
      setState(7772);
      tfall_path_delay_expression();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(7774);
      trise_path_delay_expression();
      setState(7775);
      match(SV3_1aParser::COMMA);
      setState(7776);
      tfall_path_delay_expression();
      setState(7777);
      match(SV3_1aParser::COMMA);
      setState(7778);
      tz_path_delay_expression();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(7780);
      t01_path_delay_expression();
      setState(7781);
      match(SV3_1aParser::COMMA);
      setState(7782);
      t10_path_delay_expression();
      setState(7783);
      match(SV3_1aParser::COMMA);
      setState(7784);
      t0z_path_delay_expression();
      setState(7785);
      match(SV3_1aParser::COMMA);
      setState(7786);
      tz1_path_delay_expression();
      setState(7787);
      match(SV3_1aParser::COMMA);
      setState(7788);
      t1z_path_delay_expression();
      setState(7789);
      match(SV3_1aParser::COMMA);
      setState(7790);
      tz0_path_delay_expression();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(7792);
      t01_path_delay_expression();
      setState(7793);
      match(SV3_1aParser::COMMA);
      setState(7794);
      t10_path_delay_expression();
      setState(7795);
      match(SV3_1aParser::COMMA);
      setState(7796);
      t0z_path_delay_expression();
      setState(7797);
      match(SV3_1aParser::COMMA);
      setState(7798);
      tz1_path_delay_expression();
      setState(7799);
      match(SV3_1aParser::COMMA);
      setState(7800);
      t1z_path_delay_expression();
      setState(7801);
      match(SV3_1aParser::COMMA);
      setState(7802);
      tz0_path_delay_expression();
      setState(7803);
      match(SV3_1aParser::COMMA);
      setState(7804);
      t0x_path_delay_expression();
      setState(7805);
      match(SV3_1aParser::COMMA);
      setState(7806);
      tx1_path_delay_expression();
      setState(7807);
      match(SV3_1aParser::COMMA);
      setState(7808);
      t1x_path_delay_expression();
      setState(7809);
      match(SV3_1aParser::COMMA);
      setState(7810);
      tx0_path_delay_expression();
      setState(7811);
      match(SV3_1aParser::COMMA);
      setState(7812);
      txz_path_delay_expression();
      setState(7813);
      match(SV3_1aParser::COMMA);
      setState(7814);
      tzx_path_delay_expression();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- T_path_delay_expressionContext ------------------------------------------------------------------

SV3_1aParser::T_path_delay_expressionContext::T_path_delay_expressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::Path_delay_expressionContext* SV3_1aParser::T_path_delay_expressionContext::path_delay_expression() {
  return getRuleContext<SV3_1aParser::Path_delay_expressionContext>(0);
}


size_t SV3_1aParser::T_path_delay_expressionContext::getRuleIndex() const {
  return SV3_1aParser::RuleT_path_delay_expression;
}

void SV3_1aParser::T_path_delay_expressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterT_path_delay_expression(this);
}

void SV3_1aParser::T_path_delay_expressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitT_path_delay_expression(this);
}

SV3_1aParser::T_path_delay_expressionContext* SV3_1aParser::t_path_delay_expression() {
  T_path_delay_expressionContext *_localctx = _tracker.createInstance<T_path_delay_expressionContext>(_ctx, getState());
  enterRule(_localctx, 978, SV3_1aParser::RuleT_path_delay_expression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7818);
    path_delay_expression();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Trise_path_delay_expressionContext ------------------------------------------------------------------

SV3_1aParser::Trise_path_delay_expressionContext::Trise_path_delay_expressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::Path_delay_expressionContext* SV3_1aParser::Trise_path_delay_expressionContext::path_delay_expression() {
  return getRuleContext<SV3_1aParser::Path_delay_expressionContext>(0);
}


size_t SV3_1aParser::Trise_path_delay_expressionContext::getRuleIndex() const {
  return SV3_1aParser::RuleTrise_path_delay_expression;
}

void SV3_1aParser::Trise_path_delay_expressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTrise_path_delay_expression(this);
}

void SV3_1aParser::Trise_path_delay_expressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTrise_path_delay_expression(this);
}

SV3_1aParser::Trise_path_delay_expressionContext* SV3_1aParser::trise_path_delay_expression() {
  Trise_path_delay_expressionContext *_localctx = _tracker.createInstance<Trise_path_delay_expressionContext>(_ctx, getState());
  enterRule(_localctx, 980, SV3_1aParser::RuleTrise_path_delay_expression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7820);
    path_delay_expression();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Tfall_path_delay_expressionContext ------------------------------------------------------------------

SV3_1aParser::Tfall_path_delay_expressionContext::Tfall_path_delay_expressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::Path_delay_expressionContext* SV3_1aParser::Tfall_path_delay_expressionContext::path_delay_expression() {
  return getRuleContext<SV3_1aParser::Path_delay_expressionContext>(0);
}


size_t SV3_1aParser::Tfall_path_delay_expressionContext::getRuleIndex() const {
  return SV3_1aParser::RuleTfall_path_delay_expression;
}

void SV3_1aParser::Tfall_path_delay_expressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTfall_path_delay_expression(this);
}

void SV3_1aParser::Tfall_path_delay_expressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTfall_path_delay_expression(this);
}

SV3_1aParser::Tfall_path_delay_expressionContext* SV3_1aParser::tfall_path_delay_expression() {
  Tfall_path_delay_expressionContext *_localctx = _tracker.createInstance<Tfall_path_delay_expressionContext>(_ctx, getState());
  enterRule(_localctx, 982, SV3_1aParser::RuleTfall_path_delay_expression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7822);
    path_delay_expression();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Tz_path_delay_expressionContext ------------------------------------------------------------------

SV3_1aParser::Tz_path_delay_expressionContext::Tz_path_delay_expressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::Path_delay_expressionContext* SV3_1aParser::Tz_path_delay_expressionContext::path_delay_expression() {
  return getRuleContext<SV3_1aParser::Path_delay_expressionContext>(0);
}


size_t SV3_1aParser::Tz_path_delay_expressionContext::getRuleIndex() const {
  return SV3_1aParser::RuleTz_path_delay_expression;
}

void SV3_1aParser::Tz_path_delay_expressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTz_path_delay_expression(this);
}

void SV3_1aParser::Tz_path_delay_expressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTz_path_delay_expression(this);
}

SV3_1aParser::Tz_path_delay_expressionContext* SV3_1aParser::tz_path_delay_expression() {
  Tz_path_delay_expressionContext *_localctx = _tracker.createInstance<Tz_path_delay_expressionContext>(_ctx, getState());
  enterRule(_localctx, 984, SV3_1aParser::RuleTz_path_delay_expression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7824);
    path_delay_expression();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- T01_path_delay_expressionContext ------------------------------------------------------------------

SV3_1aParser::T01_path_delay_expressionContext::T01_path_delay_expressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::Path_delay_expressionContext* SV3_1aParser::T01_path_delay_expressionContext::path_delay_expression() {
  return getRuleContext<SV3_1aParser::Path_delay_expressionContext>(0);
}


size_t SV3_1aParser::T01_path_delay_expressionContext::getRuleIndex() const {
  return SV3_1aParser::RuleT01_path_delay_expression;
}

void SV3_1aParser::T01_path_delay_expressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterT01_path_delay_expression(this);
}

void SV3_1aParser::T01_path_delay_expressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitT01_path_delay_expression(this);
}

SV3_1aParser::T01_path_delay_expressionContext* SV3_1aParser::t01_path_delay_expression() {
  T01_path_delay_expressionContext *_localctx = _tracker.createInstance<T01_path_delay_expressionContext>(_ctx, getState());
  enterRule(_localctx, 986, SV3_1aParser::RuleT01_path_delay_expression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7826);
    path_delay_expression();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- T10_path_delay_expressionContext ------------------------------------------------------------------

SV3_1aParser::T10_path_delay_expressionContext::T10_path_delay_expressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::Path_delay_expressionContext* SV3_1aParser::T10_path_delay_expressionContext::path_delay_expression() {
  return getRuleContext<SV3_1aParser::Path_delay_expressionContext>(0);
}


size_t SV3_1aParser::T10_path_delay_expressionContext::getRuleIndex() const {
  return SV3_1aParser::RuleT10_path_delay_expression;
}

void SV3_1aParser::T10_path_delay_expressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterT10_path_delay_expression(this);
}

void SV3_1aParser::T10_path_delay_expressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitT10_path_delay_expression(this);
}

SV3_1aParser::T10_path_delay_expressionContext* SV3_1aParser::t10_path_delay_expression() {
  T10_path_delay_expressionContext *_localctx = _tracker.createInstance<T10_path_delay_expressionContext>(_ctx, getState());
  enterRule(_localctx, 988, SV3_1aParser::RuleT10_path_delay_expression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7828);
    path_delay_expression();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- T0z_path_delay_expressionContext ------------------------------------------------------------------

SV3_1aParser::T0z_path_delay_expressionContext::T0z_path_delay_expressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::Path_delay_expressionContext* SV3_1aParser::T0z_path_delay_expressionContext::path_delay_expression() {
  return getRuleContext<SV3_1aParser::Path_delay_expressionContext>(0);
}


size_t SV3_1aParser::T0z_path_delay_expressionContext::getRuleIndex() const {
  return SV3_1aParser::RuleT0z_path_delay_expression;
}

void SV3_1aParser::T0z_path_delay_expressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterT0z_path_delay_expression(this);
}

void SV3_1aParser::T0z_path_delay_expressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitT0z_path_delay_expression(this);
}

SV3_1aParser::T0z_path_delay_expressionContext* SV3_1aParser::t0z_path_delay_expression() {
  T0z_path_delay_expressionContext *_localctx = _tracker.createInstance<T0z_path_delay_expressionContext>(_ctx, getState());
  enterRule(_localctx, 990, SV3_1aParser::RuleT0z_path_delay_expression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7830);
    path_delay_expression();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Tz1_path_delay_expressionContext ------------------------------------------------------------------

SV3_1aParser::Tz1_path_delay_expressionContext::Tz1_path_delay_expressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::Path_delay_expressionContext* SV3_1aParser::Tz1_path_delay_expressionContext::path_delay_expression() {
  return getRuleContext<SV3_1aParser::Path_delay_expressionContext>(0);
}


size_t SV3_1aParser::Tz1_path_delay_expressionContext::getRuleIndex() const {
  return SV3_1aParser::RuleTz1_path_delay_expression;
}

void SV3_1aParser::Tz1_path_delay_expressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTz1_path_delay_expression(this);
}

void SV3_1aParser::Tz1_path_delay_expressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTz1_path_delay_expression(this);
}

SV3_1aParser::Tz1_path_delay_expressionContext* SV3_1aParser::tz1_path_delay_expression() {
  Tz1_path_delay_expressionContext *_localctx = _tracker.createInstance<Tz1_path_delay_expressionContext>(_ctx, getState());
  enterRule(_localctx, 992, SV3_1aParser::RuleTz1_path_delay_expression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7832);
    path_delay_expression();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- T1z_path_delay_expressionContext ------------------------------------------------------------------

SV3_1aParser::T1z_path_delay_expressionContext::T1z_path_delay_expressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::Path_delay_expressionContext* SV3_1aParser::T1z_path_delay_expressionContext::path_delay_expression() {
  return getRuleContext<SV3_1aParser::Path_delay_expressionContext>(0);
}


size_t SV3_1aParser::T1z_path_delay_expressionContext::getRuleIndex() const {
  return SV3_1aParser::RuleT1z_path_delay_expression;
}

void SV3_1aParser::T1z_path_delay_expressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterT1z_path_delay_expression(this);
}

void SV3_1aParser::T1z_path_delay_expressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitT1z_path_delay_expression(this);
}

SV3_1aParser::T1z_path_delay_expressionContext* SV3_1aParser::t1z_path_delay_expression() {
  T1z_path_delay_expressionContext *_localctx = _tracker.createInstance<T1z_path_delay_expressionContext>(_ctx, getState());
  enterRule(_localctx, 994, SV3_1aParser::RuleT1z_path_delay_expression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7834);
    path_delay_expression();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Tz0_path_delay_expressionContext ------------------------------------------------------------------

SV3_1aParser::Tz0_path_delay_expressionContext::Tz0_path_delay_expressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::Path_delay_expressionContext* SV3_1aParser::Tz0_path_delay_expressionContext::path_delay_expression() {
  return getRuleContext<SV3_1aParser::Path_delay_expressionContext>(0);
}


size_t SV3_1aParser::Tz0_path_delay_expressionContext::getRuleIndex() const {
  return SV3_1aParser::RuleTz0_path_delay_expression;
}

void SV3_1aParser::Tz0_path_delay_expressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTz0_path_delay_expression(this);
}

void SV3_1aParser::Tz0_path_delay_expressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTz0_path_delay_expression(this);
}

SV3_1aParser::Tz0_path_delay_expressionContext* SV3_1aParser::tz0_path_delay_expression() {
  Tz0_path_delay_expressionContext *_localctx = _tracker.createInstance<Tz0_path_delay_expressionContext>(_ctx, getState());
  enterRule(_localctx, 996, SV3_1aParser::RuleTz0_path_delay_expression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7836);
    path_delay_expression();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- T0x_path_delay_expressionContext ------------------------------------------------------------------

SV3_1aParser::T0x_path_delay_expressionContext::T0x_path_delay_expressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::Path_delay_expressionContext* SV3_1aParser::T0x_path_delay_expressionContext::path_delay_expression() {
  return getRuleContext<SV3_1aParser::Path_delay_expressionContext>(0);
}


size_t SV3_1aParser::T0x_path_delay_expressionContext::getRuleIndex() const {
  return SV3_1aParser::RuleT0x_path_delay_expression;
}

void SV3_1aParser::T0x_path_delay_expressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterT0x_path_delay_expression(this);
}

void SV3_1aParser::T0x_path_delay_expressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitT0x_path_delay_expression(this);
}

SV3_1aParser::T0x_path_delay_expressionContext* SV3_1aParser::t0x_path_delay_expression() {
  T0x_path_delay_expressionContext *_localctx = _tracker.createInstance<T0x_path_delay_expressionContext>(_ctx, getState());
  enterRule(_localctx, 998, SV3_1aParser::RuleT0x_path_delay_expression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7838);
    path_delay_expression();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Tx1_path_delay_expressionContext ------------------------------------------------------------------

SV3_1aParser::Tx1_path_delay_expressionContext::Tx1_path_delay_expressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::Path_delay_expressionContext* SV3_1aParser::Tx1_path_delay_expressionContext::path_delay_expression() {
  return getRuleContext<SV3_1aParser::Path_delay_expressionContext>(0);
}


size_t SV3_1aParser::Tx1_path_delay_expressionContext::getRuleIndex() const {
  return SV3_1aParser::RuleTx1_path_delay_expression;
}

void SV3_1aParser::Tx1_path_delay_expressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTx1_path_delay_expression(this);
}

void SV3_1aParser::Tx1_path_delay_expressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTx1_path_delay_expression(this);
}

SV3_1aParser::Tx1_path_delay_expressionContext* SV3_1aParser::tx1_path_delay_expression() {
  Tx1_path_delay_expressionContext *_localctx = _tracker.createInstance<Tx1_path_delay_expressionContext>(_ctx, getState());
  enterRule(_localctx, 1000, SV3_1aParser::RuleTx1_path_delay_expression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7840);
    path_delay_expression();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- T1x_path_delay_expressionContext ------------------------------------------------------------------

SV3_1aParser::T1x_path_delay_expressionContext::T1x_path_delay_expressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::Path_delay_expressionContext* SV3_1aParser::T1x_path_delay_expressionContext::path_delay_expression() {
  return getRuleContext<SV3_1aParser::Path_delay_expressionContext>(0);
}


size_t SV3_1aParser::T1x_path_delay_expressionContext::getRuleIndex() const {
  return SV3_1aParser::RuleT1x_path_delay_expression;
}

void SV3_1aParser::T1x_path_delay_expressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterT1x_path_delay_expression(this);
}

void SV3_1aParser::T1x_path_delay_expressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitT1x_path_delay_expression(this);
}

SV3_1aParser::T1x_path_delay_expressionContext* SV3_1aParser::t1x_path_delay_expression() {
  T1x_path_delay_expressionContext *_localctx = _tracker.createInstance<T1x_path_delay_expressionContext>(_ctx, getState());
  enterRule(_localctx, 1002, SV3_1aParser::RuleT1x_path_delay_expression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7842);
    path_delay_expression();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Tx0_path_delay_expressionContext ------------------------------------------------------------------

SV3_1aParser::Tx0_path_delay_expressionContext::Tx0_path_delay_expressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::Path_delay_expressionContext* SV3_1aParser::Tx0_path_delay_expressionContext::path_delay_expression() {
  return getRuleContext<SV3_1aParser::Path_delay_expressionContext>(0);
}


size_t SV3_1aParser::Tx0_path_delay_expressionContext::getRuleIndex() const {
  return SV3_1aParser::RuleTx0_path_delay_expression;
}

void SV3_1aParser::Tx0_path_delay_expressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTx0_path_delay_expression(this);
}

void SV3_1aParser::Tx0_path_delay_expressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTx0_path_delay_expression(this);
}

SV3_1aParser::Tx0_path_delay_expressionContext* SV3_1aParser::tx0_path_delay_expression() {
  Tx0_path_delay_expressionContext *_localctx = _tracker.createInstance<Tx0_path_delay_expressionContext>(_ctx, getState());
  enterRule(_localctx, 1004, SV3_1aParser::RuleTx0_path_delay_expression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7844);
    path_delay_expression();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Txz_path_delay_expressionContext ------------------------------------------------------------------

SV3_1aParser::Txz_path_delay_expressionContext::Txz_path_delay_expressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::Path_delay_expressionContext* SV3_1aParser::Txz_path_delay_expressionContext::path_delay_expression() {
  return getRuleContext<SV3_1aParser::Path_delay_expressionContext>(0);
}


size_t SV3_1aParser::Txz_path_delay_expressionContext::getRuleIndex() const {
  return SV3_1aParser::RuleTxz_path_delay_expression;
}

void SV3_1aParser::Txz_path_delay_expressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTxz_path_delay_expression(this);
}

void SV3_1aParser::Txz_path_delay_expressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTxz_path_delay_expression(this);
}

SV3_1aParser::Txz_path_delay_expressionContext* SV3_1aParser::txz_path_delay_expression() {
  Txz_path_delay_expressionContext *_localctx = _tracker.createInstance<Txz_path_delay_expressionContext>(_ctx, getState());
  enterRule(_localctx, 1006, SV3_1aParser::RuleTxz_path_delay_expression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7846);
    path_delay_expression();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Tzx_path_delay_expressionContext ------------------------------------------------------------------

SV3_1aParser::Tzx_path_delay_expressionContext::Tzx_path_delay_expressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::Path_delay_expressionContext* SV3_1aParser::Tzx_path_delay_expressionContext::path_delay_expression() {
  return getRuleContext<SV3_1aParser::Path_delay_expressionContext>(0);
}


size_t SV3_1aParser::Tzx_path_delay_expressionContext::getRuleIndex() const {
  return SV3_1aParser::RuleTzx_path_delay_expression;
}

void SV3_1aParser::Tzx_path_delay_expressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTzx_path_delay_expression(this);
}

void SV3_1aParser::Tzx_path_delay_expressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTzx_path_delay_expression(this);
}

SV3_1aParser::Tzx_path_delay_expressionContext* SV3_1aParser::tzx_path_delay_expression() {
  Tzx_path_delay_expressionContext *_localctx = _tracker.createInstance<Tzx_path_delay_expressionContext>(_ctx, getState());
  enterRule(_localctx, 1008, SV3_1aParser::RuleTzx_path_delay_expression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7848);
    path_delay_expression();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Path_delay_expressionContext ------------------------------------------------------------------

SV3_1aParser::Path_delay_expressionContext::Path_delay_expressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::Constant_mintypmax_expressionContext* SV3_1aParser::Path_delay_expressionContext::constant_mintypmax_expression() {
  return getRuleContext<SV3_1aParser::Constant_mintypmax_expressionContext>(0);
}


size_t SV3_1aParser::Path_delay_expressionContext::getRuleIndex() const {
  return SV3_1aParser::RulePath_delay_expression;
}

void SV3_1aParser::Path_delay_expressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPath_delay_expression(this);
}

void SV3_1aParser::Path_delay_expressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPath_delay_expression(this);
}

SV3_1aParser::Path_delay_expressionContext* SV3_1aParser::path_delay_expression() {
  Path_delay_expressionContext *_localctx = _tracker.createInstance<Path_delay_expressionContext>(_ctx, getState());
  enterRule(_localctx, 1010, SV3_1aParser::RulePath_delay_expression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7850);
    constant_mintypmax_expression();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Edge_sensitive_path_declarationContext ------------------------------------------------------------------

SV3_1aParser::Edge_sensitive_path_declarationContext::Edge_sensitive_path_declarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::Parallel_edge_sensitive_path_descriptionContext* SV3_1aParser::Edge_sensitive_path_declarationContext::parallel_edge_sensitive_path_description() {
  return getRuleContext<SV3_1aParser::Parallel_edge_sensitive_path_descriptionContext>(0);
}

tree::TerminalNode* SV3_1aParser::Edge_sensitive_path_declarationContext::ASSIGN_OP() {
  return getToken(SV3_1aParser::ASSIGN_OP, 0);
}

SV3_1aParser::Path_delay_valueContext* SV3_1aParser::Edge_sensitive_path_declarationContext::path_delay_value() {
  return getRuleContext<SV3_1aParser::Path_delay_valueContext>(0);
}

SV3_1aParser::Full_edge_sensitive_path_descriptionContext* SV3_1aParser::Edge_sensitive_path_declarationContext::full_edge_sensitive_path_description() {
  return getRuleContext<SV3_1aParser::Full_edge_sensitive_path_descriptionContext>(0);
}


size_t SV3_1aParser::Edge_sensitive_path_declarationContext::getRuleIndex() const {
  return SV3_1aParser::RuleEdge_sensitive_path_declaration;
}

void SV3_1aParser::Edge_sensitive_path_declarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterEdge_sensitive_path_declaration(this);
}

void SV3_1aParser::Edge_sensitive_path_declarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitEdge_sensitive_path_declaration(this);
}

SV3_1aParser::Edge_sensitive_path_declarationContext* SV3_1aParser::edge_sensitive_path_declaration() {
  Edge_sensitive_path_declarationContext *_localctx = _tracker.createInstance<Edge_sensitive_path_declarationContext>(_ctx, getState());
  enterRule(_localctx, 1012, SV3_1aParser::RuleEdge_sensitive_path_declaration);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(7860);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 913, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(7852);
      parallel_edge_sensitive_path_description();
      setState(7853);
      match(SV3_1aParser::ASSIGN_OP);
      setState(7854);
      path_delay_value();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(7856);
      full_edge_sensitive_path_description();
      setState(7857);
      match(SV3_1aParser::ASSIGN_OP);
      setState(7858);
      path_delay_value();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Parallel_edge_sensitive_path_descriptionContext ------------------------------------------------------------------

SV3_1aParser::Parallel_edge_sensitive_path_descriptionContext::Parallel_edge_sensitive_path_descriptionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> SV3_1aParser::Parallel_edge_sensitive_path_descriptionContext::OPEN_PARENS() {
  return getTokens(SV3_1aParser::OPEN_PARENS);
}

tree::TerminalNode* SV3_1aParser::Parallel_edge_sensitive_path_descriptionContext::OPEN_PARENS(size_t i) {
  return getToken(SV3_1aParser::OPEN_PARENS, i);
}

SV3_1aParser::Specify_input_terminal_descriptorContext* SV3_1aParser::Parallel_edge_sensitive_path_descriptionContext::specify_input_terminal_descriptor() {
  return getRuleContext<SV3_1aParser::Specify_input_terminal_descriptorContext>(0);
}

tree::TerminalNode* SV3_1aParser::Parallel_edge_sensitive_path_descriptionContext::TRANSITION_OP() {
  return getToken(SV3_1aParser::TRANSITION_OP, 0);
}

SV3_1aParser::Specify_output_terminal_descriptorContext* SV3_1aParser::Parallel_edge_sensitive_path_descriptionContext::specify_output_terminal_descriptor() {
  return getRuleContext<SV3_1aParser::Specify_output_terminal_descriptorContext>(0);
}

SV3_1aParser::Part_select_op_colonContext* SV3_1aParser::Parallel_edge_sensitive_path_descriptionContext::part_select_op_colon() {
  return getRuleContext<SV3_1aParser::Part_select_op_colonContext>(0);
}

SV3_1aParser::ExpressionContext* SV3_1aParser::Parallel_edge_sensitive_path_descriptionContext::expression() {
  return getRuleContext<SV3_1aParser::ExpressionContext>(0);
}

std::vector<tree::TerminalNode *> SV3_1aParser::Parallel_edge_sensitive_path_descriptionContext::CLOSE_PARENS() {
  return getTokens(SV3_1aParser::CLOSE_PARENS);
}

tree::TerminalNode* SV3_1aParser::Parallel_edge_sensitive_path_descriptionContext::CLOSE_PARENS(size_t i) {
  return getToken(SV3_1aParser::CLOSE_PARENS, i);
}

SV3_1aParser::Edge_identifierContext* SV3_1aParser::Parallel_edge_sensitive_path_descriptionContext::edge_identifier() {
  return getRuleContext<SV3_1aParser::Edge_identifierContext>(0);
}


size_t SV3_1aParser::Parallel_edge_sensitive_path_descriptionContext::getRuleIndex() const {
  return SV3_1aParser::RuleParallel_edge_sensitive_path_description;
}

void SV3_1aParser::Parallel_edge_sensitive_path_descriptionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterParallel_edge_sensitive_path_description(this);
}

void SV3_1aParser::Parallel_edge_sensitive_path_descriptionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitParallel_edge_sensitive_path_description(this);
}

SV3_1aParser::Parallel_edge_sensitive_path_descriptionContext* SV3_1aParser::parallel_edge_sensitive_path_description() {
  Parallel_edge_sensitive_path_descriptionContext *_localctx = _tracker.createInstance<Parallel_edge_sensitive_path_descriptionContext>(_ctx, getState());
  enterRule(_localctx, 1014, SV3_1aParser::RuleParallel_edge_sensitive_path_description);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7862);
    match(SV3_1aParser::OPEN_PARENS);
    setState(7864);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (((((_la - 333) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 333)) & 1027) != 0)) {
      setState(7863);
      edge_identifier();
    }
    setState(7866);
    specify_input_terminal_descriptor();
    setState(7867);
    match(SV3_1aParser::TRANSITION_OP);
    setState(7868);
    match(SV3_1aParser::OPEN_PARENS);
    setState(7869);
    specify_output_terminal_descriptor();
    setState(7870);
    part_select_op_colon();
    setState(7871);
    expression(0);
    setState(7872);
    match(SV3_1aParser::CLOSE_PARENS);
    setState(7873);
    match(SV3_1aParser::CLOSE_PARENS);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Full_edge_sensitive_path_descriptionContext ------------------------------------------------------------------

SV3_1aParser::Full_edge_sensitive_path_descriptionContext::Full_edge_sensitive_path_descriptionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> SV3_1aParser::Full_edge_sensitive_path_descriptionContext::OPEN_PARENS() {
  return getTokens(SV3_1aParser::OPEN_PARENS);
}

tree::TerminalNode* SV3_1aParser::Full_edge_sensitive_path_descriptionContext::OPEN_PARENS(size_t i) {
  return getToken(SV3_1aParser::OPEN_PARENS, i);
}

SV3_1aParser::List_of_path_inputsContext* SV3_1aParser::Full_edge_sensitive_path_descriptionContext::list_of_path_inputs() {
  return getRuleContext<SV3_1aParser::List_of_path_inputsContext>(0);
}

tree::TerminalNode* SV3_1aParser::Full_edge_sensitive_path_descriptionContext::FULL_CONN_OP() {
  return getToken(SV3_1aParser::FULL_CONN_OP, 0);
}

SV3_1aParser::List_of_path_outputsContext* SV3_1aParser::Full_edge_sensitive_path_descriptionContext::list_of_path_outputs() {
  return getRuleContext<SV3_1aParser::List_of_path_outputsContext>(0);
}

SV3_1aParser::Part_select_op_colonContext* SV3_1aParser::Full_edge_sensitive_path_descriptionContext::part_select_op_colon() {
  return getRuleContext<SV3_1aParser::Part_select_op_colonContext>(0);
}

SV3_1aParser::ExpressionContext* SV3_1aParser::Full_edge_sensitive_path_descriptionContext::expression() {
  return getRuleContext<SV3_1aParser::ExpressionContext>(0);
}

std::vector<tree::TerminalNode *> SV3_1aParser::Full_edge_sensitive_path_descriptionContext::CLOSE_PARENS() {
  return getTokens(SV3_1aParser::CLOSE_PARENS);
}

tree::TerminalNode* SV3_1aParser::Full_edge_sensitive_path_descriptionContext::CLOSE_PARENS(size_t i) {
  return getToken(SV3_1aParser::CLOSE_PARENS, i);
}

SV3_1aParser::Edge_identifierContext* SV3_1aParser::Full_edge_sensitive_path_descriptionContext::edge_identifier() {
  return getRuleContext<SV3_1aParser::Edge_identifierContext>(0);
}


size_t SV3_1aParser::Full_edge_sensitive_path_descriptionContext::getRuleIndex() const {
  return SV3_1aParser::RuleFull_edge_sensitive_path_description;
}

void SV3_1aParser::Full_edge_sensitive_path_descriptionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFull_edge_sensitive_path_description(this);
}

void SV3_1aParser::Full_edge_sensitive_path_descriptionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFull_edge_sensitive_path_description(this);
}

SV3_1aParser::Full_edge_sensitive_path_descriptionContext* SV3_1aParser::full_edge_sensitive_path_description() {
  Full_edge_sensitive_path_descriptionContext *_localctx = _tracker.createInstance<Full_edge_sensitive_path_descriptionContext>(_ctx, getState());
  enterRule(_localctx, 1016, SV3_1aParser::RuleFull_edge_sensitive_path_description);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7875);
    match(SV3_1aParser::OPEN_PARENS);
    setState(7877);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (((((_la - 333) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 333)) & 1027) != 0)) {
      setState(7876);
      edge_identifier();
    }
    setState(7879);
    list_of_path_inputs();
    setState(7880);
    match(SV3_1aParser::FULL_CONN_OP);
    setState(7881);
    match(SV3_1aParser::OPEN_PARENS);
    setState(7882);
    list_of_path_outputs();
    setState(7883);
    part_select_op_colon();
    setState(7884);
    expression(0);
    setState(7885);
    match(SV3_1aParser::CLOSE_PARENS);
    setState(7886);
    match(SV3_1aParser::CLOSE_PARENS);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- State_dependent_path_declarationContext ------------------------------------------------------------------

SV3_1aParser::State_dependent_path_declarationContext::State_dependent_path_declarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::State_dependent_path_declarationContext::IF() {
  return getToken(SV3_1aParser::IF, 0);
}

tree::TerminalNode* SV3_1aParser::State_dependent_path_declarationContext::OPEN_PARENS() {
  return getToken(SV3_1aParser::OPEN_PARENS, 0);
}

SV3_1aParser::Module_path_expressionContext* SV3_1aParser::State_dependent_path_declarationContext::module_path_expression() {
  return getRuleContext<SV3_1aParser::Module_path_expressionContext>(0);
}

tree::TerminalNode* SV3_1aParser::State_dependent_path_declarationContext::CLOSE_PARENS() {
  return getToken(SV3_1aParser::CLOSE_PARENS, 0);
}

SV3_1aParser::Simple_path_declarationContext* SV3_1aParser::State_dependent_path_declarationContext::simple_path_declaration() {
  return getRuleContext<SV3_1aParser::Simple_path_declarationContext>(0);
}

SV3_1aParser::Edge_sensitive_path_declarationContext* SV3_1aParser::State_dependent_path_declarationContext::edge_sensitive_path_declaration() {
  return getRuleContext<SV3_1aParser::Edge_sensitive_path_declarationContext>(0);
}

tree::TerminalNode* SV3_1aParser::State_dependent_path_declarationContext::IFNONE() {
  return getToken(SV3_1aParser::IFNONE, 0);
}


size_t SV3_1aParser::State_dependent_path_declarationContext::getRuleIndex() const {
  return SV3_1aParser::RuleState_dependent_path_declaration;
}

void SV3_1aParser::State_dependent_path_declarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterState_dependent_path_declaration(this);
}

void SV3_1aParser::State_dependent_path_declarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitState_dependent_path_declaration(this);
}

SV3_1aParser::State_dependent_path_declarationContext* SV3_1aParser::state_dependent_path_declaration() {
  State_dependent_path_declarationContext *_localctx = _tracker.createInstance<State_dependent_path_declarationContext>(_ctx, getState());
  enterRule(_localctx, 1018, SV3_1aParser::RuleState_dependent_path_declaration);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(7902);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 916, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(7888);
      match(SV3_1aParser::IF);
      setState(7889);
      match(SV3_1aParser::OPEN_PARENS);
      setState(7890);
      module_path_expression(0);
      setState(7891);
      match(SV3_1aParser::CLOSE_PARENS);
      setState(7892);
      simple_path_declaration();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(7894);
      match(SV3_1aParser::IF);
      setState(7895);
      match(SV3_1aParser::OPEN_PARENS);
      setState(7896);
      module_path_expression(0);
      setState(7897);
      match(SV3_1aParser::CLOSE_PARENS);
      setState(7898);
      edge_sensitive_path_declaration();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(7900);
      match(SV3_1aParser::IFNONE);
      setState(7901);
      simple_path_declaration();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- System_timing_checkContext ------------------------------------------------------------------

SV3_1aParser::System_timing_checkContext::System_timing_checkContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::Dollar_setup_timing_checkContext* SV3_1aParser::System_timing_checkContext::dollar_setup_timing_check() {
  return getRuleContext<SV3_1aParser::Dollar_setup_timing_checkContext>(0);
}

SV3_1aParser::Dollar_hold_timing_checkContext* SV3_1aParser::System_timing_checkContext::dollar_hold_timing_check() {
  return getRuleContext<SV3_1aParser::Dollar_hold_timing_checkContext>(0);
}

SV3_1aParser::Dollar_setuphold_timing_checkContext* SV3_1aParser::System_timing_checkContext::dollar_setuphold_timing_check() {
  return getRuleContext<SV3_1aParser::Dollar_setuphold_timing_checkContext>(0);
}

SV3_1aParser::Dollar_recovery_timing_checkContext* SV3_1aParser::System_timing_checkContext::dollar_recovery_timing_check() {
  return getRuleContext<SV3_1aParser::Dollar_recovery_timing_checkContext>(0);
}

SV3_1aParser::Dollar_removal_timing_checkContext* SV3_1aParser::System_timing_checkContext::dollar_removal_timing_check() {
  return getRuleContext<SV3_1aParser::Dollar_removal_timing_checkContext>(0);
}

SV3_1aParser::Dollar_recrem_timing_checkContext* SV3_1aParser::System_timing_checkContext::dollar_recrem_timing_check() {
  return getRuleContext<SV3_1aParser::Dollar_recrem_timing_checkContext>(0);
}

SV3_1aParser::Dollar_skew_timing_checkContext* SV3_1aParser::System_timing_checkContext::dollar_skew_timing_check() {
  return getRuleContext<SV3_1aParser::Dollar_skew_timing_checkContext>(0);
}

SV3_1aParser::Dollar_timeskew_timing_checkContext* SV3_1aParser::System_timing_checkContext::dollar_timeskew_timing_check() {
  return getRuleContext<SV3_1aParser::Dollar_timeskew_timing_checkContext>(0);
}

SV3_1aParser::Dollar_fullskew_timing_checkContext* SV3_1aParser::System_timing_checkContext::dollar_fullskew_timing_check() {
  return getRuleContext<SV3_1aParser::Dollar_fullskew_timing_checkContext>(0);
}

SV3_1aParser::Dollar_period_timing_checkContext* SV3_1aParser::System_timing_checkContext::dollar_period_timing_check() {
  return getRuleContext<SV3_1aParser::Dollar_period_timing_checkContext>(0);
}

SV3_1aParser::Dollar_width_timing_checkContext* SV3_1aParser::System_timing_checkContext::dollar_width_timing_check() {
  return getRuleContext<SV3_1aParser::Dollar_width_timing_checkContext>(0);
}

SV3_1aParser::Dollar_nochange_timing_checkContext* SV3_1aParser::System_timing_checkContext::dollar_nochange_timing_check() {
  return getRuleContext<SV3_1aParser::Dollar_nochange_timing_checkContext>(0);
}


size_t SV3_1aParser::System_timing_checkContext::getRuleIndex() const {
  return SV3_1aParser::RuleSystem_timing_check;
}

void SV3_1aParser::System_timing_checkContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSystem_timing_check(this);
}

void SV3_1aParser::System_timing_checkContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSystem_timing_check(this);
}

SV3_1aParser::System_timing_checkContext* SV3_1aParser::system_timing_check() {
  System_timing_checkContext *_localctx = _tracker.createInstance<System_timing_checkContext>(_ctx, getState());
  enterRule(_localctx, 1020, SV3_1aParser::RuleSystem_timing_check);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(7916);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 917, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(7904);
      dollar_setup_timing_check();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(7905);
      dollar_hold_timing_check();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(7906);
      dollar_setuphold_timing_check();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(7907);
      dollar_recovery_timing_check();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(7908);
      dollar_removal_timing_check();
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(7909);
      dollar_recrem_timing_check();
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(7910);
      dollar_skew_timing_check();
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(7911);
      dollar_timeskew_timing_check();
      break;
    }

    case 9: {
      enterOuterAlt(_localctx, 9);
      setState(7912);
      dollar_fullskew_timing_check();
      break;
    }

    case 10: {
      enterOuterAlt(_localctx, 10);
      setState(7913);
      dollar_period_timing_check();
      break;
    }

    case 11: {
      enterOuterAlt(_localctx, 11);
      setState(7914);
      dollar_width_timing_check();
      break;
    }

    case 12: {
      enterOuterAlt(_localctx, 12);
      setState(7915);
      dollar_nochange_timing_check();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Dollar_setup_timing_checkContext ------------------------------------------------------------------

SV3_1aParser::Dollar_setup_timing_checkContext::Dollar_setup_timing_checkContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Dollar_setup_timing_checkContext::DOLLAR() {
  return getToken(SV3_1aParser::DOLLAR, 0);
}

tree::TerminalNode* SV3_1aParser::Dollar_setup_timing_checkContext::Simple_identifier() {
  return getToken(SV3_1aParser::Simple_identifier, 0);
}

tree::TerminalNode* SV3_1aParser::Dollar_setup_timing_checkContext::OPEN_PARENS() {
  return getToken(SV3_1aParser::OPEN_PARENS, 0);
}

SV3_1aParser::Timing_check_eventContext* SV3_1aParser::Dollar_setup_timing_checkContext::timing_check_event() {
  return getRuleContext<SV3_1aParser::Timing_check_eventContext>(0);
}

std::vector<tree::TerminalNode *> SV3_1aParser::Dollar_setup_timing_checkContext::COMMA() {
  return getTokens(SV3_1aParser::COMMA);
}

tree::TerminalNode* SV3_1aParser::Dollar_setup_timing_checkContext::COMMA(size_t i) {
  return getToken(SV3_1aParser::COMMA, i);
}

SV3_1aParser::Reference_eventContext* SV3_1aParser::Dollar_setup_timing_checkContext::reference_event() {
  return getRuleContext<SV3_1aParser::Reference_eventContext>(0);
}

SV3_1aParser::Timing_check_limitContext* SV3_1aParser::Dollar_setup_timing_checkContext::timing_check_limit() {
  return getRuleContext<SV3_1aParser::Timing_check_limitContext>(0);
}

tree::TerminalNode* SV3_1aParser::Dollar_setup_timing_checkContext::CLOSE_PARENS() {
  return getToken(SV3_1aParser::CLOSE_PARENS, 0);
}

tree::TerminalNode* SV3_1aParser::Dollar_setup_timing_checkContext::SEMICOLON() {
  return getToken(SV3_1aParser::SEMICOLON, 0);
}

SV3_1aParser::NotifierContext* SV3_1aParser::Dollar_setup_timing_checkContext::notifier() {
  return getRuleContext<SV3_1aParser::NotifierContext>(0);
}


size_t SV3_1aParser::Dollar_setup_timing_checkContext::getRuleIndex() const {
  return SV3_1aParser::RuleDollar_setup_timing_check;
}

void SV3_1aParser::Dollar_setup_timing_checkContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDollar_setup_timing_check(this);
}

void SV3_1aParser::Dollar_setup_timing_checkContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDollar_setup_timing_check(this);
}

SV3_1aParser::Dollar_setup_timing_checkContext* SV3_1aParser::dollar_setup_timing_check() {
  Dollar_setup_timing_checkContext *_localctx = _tracker.createInstance<Dollar_setup_timing_checkContext>(_ctx, getState());
  enterRule(_localctx, 1022, SV3_1aParser::RuleDollar_setup_timing_check);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7918);
    match(SV3_1aParser::DOLLAR);
    setState(7919);
    match(SV3_1aParser::Simple_identifier);
    setState(7920);
    match(SV3_1aParser::OPEN_PARENS);
    setState(7921);
    timing_check_event();
    setState(7922);
    match(SV3_1aParser::COMMA);
    setState(7923);
    reference_event();
    setState(7924);
    match(SV3_1aParser::COMMA);
    setState(7925);
    timing_check_limit();
    setState(7930);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SV3_1aParser::COMMA) {
      setState(7926);
      match(SV3_1aParser::COMMA);
      setState(7928);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (((((_la - 326) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 326)) & 4672924483589) != 0)) {
        setState(7927);
        notifier();
      }
    }
    setState(7932);
    match(SV3_1aParser::CLOSE_PARENS);
    setState(7933);
    match(SV3_1aParser::SEMICOLON);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Dollar_hold_timing_checkContext ------------------------------------------------------------------

SV3_1aParser::Dollar_hold_timing_checkContext::Dollar_hold_timing_checkContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Dollar_hold_timing_checkContext::DOLLAR() {
  return getToken(SV3_1aParser::DOLLAR, 0);
}

tree::TerminalNode* SV3_1aParser::Dollar_hold_timing_checkContext::Simple_identifier() {
  return getToken(SV3_1aParser::Simple_identifier, 0);
}

tree::TerminalNode* SV3_1aParser::Dollar_hold_timing_checkContext::OPEN_PARENS() {
  return getToken(SV3_1aParser::OPEN_PARENS, 0);
}

SV3_1aParser::Reference_eventContext* SV3_1aParser::Dollar_hold_timing_checkContext::reference_event() {
  return getRuleContext<SV3_1aParser::Reference_eventContext>(0);
}

std::vector<tree::TerminalNode *> SV3_1aParser::Dollar_hold_timing_checkContext::COMMA() {
  return getTokens(SV3_1aParser::COMMA);
}

tree::TerminalNode* SV3_1aParser::Dollar_hold_timing_checkContext::COMMA(size_t i) {
  return getToken(SV3_1aParser::COMMA, i);
}

SV3_1aParser::Timing_check_eventContext* SV3_1aParser::Dollar_hold_timing_checkContext::timing_check_event() {
  return getRuleContext<SV3_1aParser::Timing_check_eventContext>(0);
}

SV3_1aParser::Timing_check_limitContext* SV3_1aParser::Dollar_hold_timing_checkContext::timing_check_limit() {
  return getRuleContext<SV3_1aParser::Timing_check_limitContext>(0);
}

tree::TerminalNode* SV3_1aParser::Dollar_hold_timing_checkContext::CLOSE_PARENS() {
  return getToken(SV3_1aParser::CLOSE_PARENS, 0);
}

tree::TerminalNode* SV3_1aParser::Dollar_hold_timing_checkContext::SEMICOLON() {
  return getToken(SV3_1aParser::SEMICOLON, 0);
}

SV3_1aParser::NotifierContext* SV3_1aParser::Dollar_hold_timing_checkContext::notifier() {
  return getRuleContext<SV3_1aParser::NotifierContext>(0);
}


size_t SV3_1aParser::Dollar_hold_timing_checkContext::getRuleIndex() const {
  return SV3_1aParser::RuleDollar_hold_timing_check;
}

void SV3_1aParser::Dollar_hold_timing_checkContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDollar_hold_timing_check(this);
}

void SV3_1aParser::Dollar_hold_timing_checkContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDollar_hold_timing_check(this);
}

SV3_1aParser::Dollar_hold_timing_checkContext* SV3_1aParser::dollar_hold_timing_check() {
  Dollar_hold_timing_checkContext *_localctx = _tracker.createInstance<Dollar_hold_timing_checkContext>(_ctx, getState());
  enterRule(_localctx, 1024, SV3_1aParser::RuleDollar_hold_timing_check);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7935);
    match(SV3_1aParser::DOLLAR);
    setState(7936);
    match(SV3_1aParser::Simple_identifier);
    setState(7937);
    match(SV3_1aParser::OPEN_PARENS);
    setState(7938);
    reference_event();
    setState(7939);
    match(SV3_1aParser::COMMA);
    setState(7940);
    timing_check_event();
    setState(7941);
    match(SV3_1aParser::COMMA);
    setState(7942);
    timing_check_limit();
    setState(7947);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SV3_1aParser::COMMA) {
      setState(7943);
      match(SV3_1aParser::COMMA);
      setState(7945);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (((((_la - 326) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 326)) & 4672924483589) != 0)) {
        setState(7944);
        notifier();
      }
    }
    setState(7949);
    match(SV3_1aParser::CLOSE_PARENS);
    setState(7950);
    match(SV3_1aParser::SEMICOLON);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Dollar_setuphold_timing_checkContext ------------------------------------------------------------------

SV3_1aParser::Dollar_setuphold_timing_checkContext::Dollar_setuphold_timing_checkContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Dollar_setuphold_timing_checkContext::DOLLAR() {
  return getToken(SV3_1aParser::DOLLAR, 0);
}

tree::TerminalNode* SV3_1aParser::Dollar_setuphold_timing_checkContext::Simple_identifier() {
  return getToken(SV3_1aParser::Simple_identifier, 0);
}

tree::TerminalNode* SV3_1aParser::Dollar_setuphold_timing_checkContext::OPEN_PARENS() {
  return getToken(SV3_1aParser::OPEN_PARENS, 0);
}

SV3_1aParser::Reference_eventContext* SV3_1aParser::Dollar_setuphold_timing_checkContext::reference_event() {
  return getRuleContext<SV3_1aParser::Reference_eventContext>(0);
}

std::vector<tree::TerminalNode *> SV3_1aParser::Dollar_setuphold_timing_checkContext::COMMA() {
  return getTokens(SV3_1aParser::COMMA);
}

tree::TerminalNode* SV3_1aParser::Dollar_setuphold_timing_checkContext::COMMA(size_t i) {
  return getToken(SV3_1aParser::COMMA, i);
}

SV3_1aParser::Timing_check_eventContext* SV3_1aParser::Dollar_setuphold_timing_checkContext::timing_check_event() {
  return getRuleContext<SV3_1aParser::Timing_check_eventContext>(0);
}

std::vector<SV3_1aParser::Timing_check_limitContext *> SV3_1aParser::Dollar_setuphold_timing_checkContext::timing_check_limit() {
  return getRuleContexts<SV3_1aParser::Timing_check_limitContext>();
}

SV3_1aParser::Timing_check_limitContext* SV3_1aParser::Dollar_setuphold_timing_checkContext::timing_check_limit(size_t i) {
  return getRuleContext<SV3_1aParser::Timing_check_limitContext>(i);
}

tree::TerminalNode* SV3_1aParser::Dollar_setuphold_timing_checkContext::CLOSE_PARENS() {
  return getToken(SV3_1aParser::CLOSE_PARENS, 0);
}

tree::TerminalNode* SV3_1aParser::Dollar_setuphold_timing_checkContext::SEMICOLON() {
  return getToken(SV3_1aParser::SEMICOLON, 0);
}

SV3_1aParser::NotifierContext* SV3_1aParser::Dollar_setuphold_timing_checkContext::notifier() {
  return getRuleContext<SV3_1aParser::NotifierContext>(0);
}

SV3_1aParser::Stamptime_conditionContext* SV3_1aParser::Dollar_setuphold_timing_checkContext::stamptime_condition() {
  return getRuleContext<SV3_1aParser::Stamptime_conditionContext>(0);
}

SV3_1aParser::Mintypmax_expressionContext* SV3_1aParser::Dollar_setuphold_timing_checkContext::mintypmax_expression() {
  return getRuleContext<SV3_1aParser::Mintypmax_expressionContext>(0);
}

SV3_1aParser::Delayed_referenceContext* SV3_1aParser::Dollar_setuphold_timing_checkContext::delayed_reference() {
  return getRuleContext<SV3_1aParser::Delayed_referenceContext>(0);
}

SV3_1aParser::Delayed_dataContext* SV3_1aParser::Dollar_setuphold_timing_checkContext::delayed_data() {
  return getRuleContext<SV3_1aParser::Delayed_dataContext>(0);
}


size_t SV3_1aParser::Dollar_setuphold_timing_checkContext::getRuleIndex() const {
  return SV3_1aParser::RuleDollar_setuphold_timing_check;
}

void SV3_1aParser::Dollar_setuphold_timing_checkContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDollar_setuphold_timing_check(this);
}

void SV3_1aParser::Dollar_setuphold_timing_checkContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDollar_setuphold_timing_check(this);
}

SV3_1aParser::Dollar_setuphold_timing_checkContext* SV3_1aParser::dollar_setuphold_timing_check() {
  Dollar_setuphold_timing_checkContext *_localctx = _tracker.createInstance<Dollar_setuphold_timing_checkContext>(_ctx, getState());
  enterRule(_localctx, 1026, SV3_1aParser::RuleDollar_setuphold_timing_check);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7952);
    match(SV3_1aParser::DOLLAR);
    setState(7953);
    match(SV3_1aParser::Simple_identifier);
    setState(7954);
    match(SV3_1aParser::OPEN_PARENS);
    setState(7955);
    reference_event();
    setState(7956);
    match(SV3_1aParser::COMMA);
    setState(7957);
    timing_check_event();
    setState(7958);
    match(SV3_1aParser::COMMA);
    setState(7959);
    timing_check_limit();
    setState(7960);
    match(SV3_1aParser::COMMA);
    setState(7961);
    timing_check_limit();
    setState(7990);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SV3_1aParser::COMMA) {
      setState(7962);
      match(SV3_1aParser::COMMA);
      setState(7964);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (((((_la - 326) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 326)) & 4672924483589) != 0)) {
        setState(7963);
        notifier();
      }
      setState(7988);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == SV3_1aParser::COMMA) {
        setState(7966);
        match(SV3_1aParser::COMMA);
        setState(7968);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if ((((_la & ~ 0x3fULL) == 0) &&
          ((1ULL << _la) & 8796094922748) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 64)) & 1152648825725551617) != 0) || ((((_la - 147) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 147)) & 2199527096323) != 0) || _la == SV3_1aParser::BANG || ((((_la - 310) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 310)) & 559537073624154177) != 0)) {
          setState(7967);
          stamptime_condition();
        }
        setState(7986);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == SV3_1aParser::COMMA) {
          setState(7970);
          match(SV3_1aParser::COMMA);
          setState(7972);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if ((((_la & ~ 0x3fULL) == 0) &&
            ((1ULL << _la) & 8796094922748) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
            ((1ULL << (_la - 64)) & 1152648825725551617) != 0) || ((((_la - 147) & ~ 0x3fULL) == 0) &&
            ((1ULL << (_la - 147)) & 2199527096323) != 0) || _la == SV3_1aParser::BANG || ((((_la - 310) & ~ 0x3fULL) == 0) &&
            ((1ULL << (_la - 310)) & 559537073624154177) != 0)) {
            setState(7971);
            mintypmax_expression();
          }
          setState(7984);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if (_la == SV3_1aParser::COMMA) {
            setState(7974);
            match(SV3_1aParser::COMMA);
            setState(7976);
            _errHandler->sync(this);

            _la = _input->LA(1);
            if (((((_la - 326) & ~ 0x3fULL) == 0) &&
              ((1ULL << (_la - 326)) & 4672924483589) != 0)) {
              setState(7975);
              delayed_reference();
            }
            setState(7982);
            _errHandler->sync(this);

            _la = _input->LA(1);
            if (_la == SV3_1aParser::COMMA) {
              setState(7978);
              match(SV3_1aParser::COMMA);
              setState(7980);
              _errHandler->sync(this);

              _la = _input->LA(1);
              if (((((_la - 326) & ~ 0x3fULL) == 0) &&
                ((1ULL << (_la - 326)) & 4672924483589) != 0)) {
                setState(7979);
                delayed_data();
              }
            }
          }
        }
      }
    }
    setState(7992);
    match(SV3_1aParser::CLOSE_PARENS);
    setState(7993);
    match(SV3_1aParser::SEMICOLON);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Dollar_recovery_timing_checkContext ------------------------------------------------------------------

SV3_1aParser::Dollar_recovery_timing_checkContext::Dollar_recovery_timing_checkContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Dollar_recovery_timing_checkContext::DOLLAR() {
  return getToken(SV3_1aParser::DOLLAR, 0);
}

tree::TerminalNode* SV3_1aParser::Dollar_recovery_timing_checkContext::Simple_identifier() {
  return getToken(SV3_1aParser::Simple_identifier, 0);
}

tree::TerminalNode* SV3_1aParser::Dollar_recovery_timing_checkContext::OPEN_PARENS() {
  return getToken(SV3_1aParser::OPEN_PARENS, 0);
}

SV3_1aParser::Reference_eventContext* SV3_1aParser::Dollar_recovery_timing_checkContext::reference_event() {
  return getRuleContext<SV3_1aParser::Reference_eventContext>(0);
}

std::vector<tree::TerminalNode *> SV3_1aParser::Dollar_recovery_timing_checkContext::COMMA() {
  return getTokens(SV3_1aParser::COMMA);
}

tree::TerminalNode* SV3_1aParser::Dollar_recovery_timing_checkContext::COMMA(size_t i) {
  return getToken(SV3_1aParser::COMMA, i);
}

SV3_1aParser::Timing_check_eventContext* SV3_1aParser::Dollar_recovery_timing_checkContext::timing_check_event() {
  return getRuleContext<SV3_1aParser::Timing_check_eventContext>(0);
}

SV3_1aParser::Timing_check_limitContext* SV3_1aParser::Dollar_recovery_timing_checkContext::timing_check_limit() {
  return getRuleContext<SV3_1aParser::Timing_check_limitContext>(0);
}

tree::TerminalNode* SV3_1aParser::Dollar_recovery_timing_checkContext::CLOSE_PARENS() {
  return getToken(SV3_1aParser::CLOSE_PARENS, 0);
}

tree::TerminalNode* SV3_1aParser::Dollar_recovery_timing_checkContext::SEMICOLON() {
  return getToken(SV3_1aParser::SEMICOLON, 0);
}

SV3_1aParser::NotifierContext* SV3_1aParser::Dollar_recovery_timing_checkContext::notifier() {
  return getRuleContext<SV3_1aParser::NotifierContext>(0);
}


size_t SV3_1aParser::Dollar_recovery_timing_checkContext::getRuleIndex() const {
  return SV3_1aParser::RuleDollar_recovery_timing_check;
}

void SV3_1aParser::Dollar_recovery_timing_checkContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDollar_recovery_timing_check(this);
}

void SV3_1aParser::Dollar_recovery_timing_checkContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDollar_recovery_timing_check(this);
}

SV3_1aParser::Dollar_recovery_timing_checkContext* SV3_1aParser::dollar_recovery_timing_check() {
  Dollar_recovery_timing_checkContext *_localctx = _tracker.createInstance<Dollar_recovery_timing_checkContext>(_ctx, getState());
  enterRule(_localctx, 1028, SV3_1aParser::RuleDollar_recovery_timing_check);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7995);
    match(SV3_1aParser::DOLLAR);
    setState(7996);
    match(SV3_1aParser::Simple_identifier);
    setState(7997);
    match(SV3_1aParser::OPEN_PARENS);
    setState(7998);
    reference_event();
    setState(7999);
    match(SV3_1aParser::COMMA);
    setState(8000);
    timing_check_event();
    setState(8001);
    match(SV3_1aParser::COMMA);
    setState(8002);
    timing_check_limit();
    setState(8007);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SV3_1aParser::COMMA) {
      setState(8003);
      match(SV3_1aParser::COMMA);
      setState(8005);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (((((_la - 326) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 326)) & 4672924483589) != 0)) {
        setState(8004);
        notifier();
      }
    }
    setState(8009);
    match(SV3_1aParser::CLOSE_PARENS);
    setState(8010);
    match(SV3_1aParser::SEMICOLON);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Dollar_removal_timing_checkContext ------------------------------------------------------------------

SV3_1aParser::Dollar_removal_timing_checkContext::Dollar_removal_timing_checkContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Dollar_removal_timing_checkContext::DOLLAR() {
  return getToken(SV3_1aParser::DOLLAR, 0);
}

tree::TerminalNode* SV3_1aParser::Dollar_removal_timing_checkContext::Simple_identifier() {
  return getToken(SV3_1aParser::Simple_identifier, 0);
}

tree::TerminalNode* SV3_1aParser::Dollar_removal_timing_checkContext::OPEN_PARENS() {
  return getToken(SV3_1aParser::OPEN_PARENS, 0);
}

SV3_1aParser::Reference_eventContext* SV3_1aParser::Dollar_removal_timing_checkContext::reference_event() {
  return getRuleContext<SV3_1aParser::Reference_eventContext>(0);
}

std::vector<tree::TerminalNode *> SV3_1aParser::Dollar_removal_timing_checkContext::COMMA() {
  return getTokens(SV3_1aParser::COMMA);
}

tree::TerminalNode* SV3_1aParser::Dollar_removal_timing_checkContext::COMMA(size_t i) {
  return getToken(SV3_1aParser::COMMA, i);
}

SV3_1aParser::Timing_check_eventContext* SV3_1aParser::Dollar_removal_timing_checkContext::timing_check_event() {
  return getRuleContext<SV3_1aParser::Timing_check_eventContext>(0);
}

SV3_1aParser::Timing_check_limitContext* SV3_1aParser::Dollar_removal_timing_checkContext::timing_check_limit() {
  return getRuleContext<SV3_1aParser::Timing_check_limitContext>(0);
}

tree::TerminalNode* SV3_1aParser::Dollar_removal_timing_checkContext::CLOSE_PARENS() {
  return getToken(SV3_1aParser::CLOSE_PARENS, 0);
}

tree::TerminalNode* SV3_1aParser::Dollar_removal_timing_checkContext::SEMICOLON() {
  return getToken(SV3_1aParser::SEMICOLON, 0);
}

SV3_1aParser::NotifierContext* SV3_1aParser::Dollar_removal_timing_checkContext::notifier() {
  return getRuleContext<SV3_1aParser::NotifierContext>(0);
}


size_t SV3_1aParser::Dollar_removal_timing_checkContext::getRuleIndex() const {
  return SV3_1aParser::RuleDollar_removal_timing_check;
}

void SV3_1aParser::Dollar_removal_timing_checkContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDollar_removal_timing_check(this);
}

void SV3_1aParser::Dollar_removal_timing_checkContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDollar_removal_timing_check(this);
}

SV3_1aParser::Dollar_removal_timing_checkContext* SV3_1aParser::dollar_removal_timing_check() {
  Dollar_removal_timing_checkContext *_localctx = _tracker.createInstance<Dollar_removal_timing_checkContext>(_ctx, getState());
  enterRule(_localctx, 1030, SV3_1aParser::RuleDollar_removal_timing_check);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8012);
    match(SV3_1aParser::DOLLAR);
    setState(8013);
    match(SV3_1aParser::Simple_identifier);
    setState(8014);
    match(SV3_1aParser::OPEN_PARENS);
    setState(8015);
    reference_event();
    setState(8016);
    match(SV3_1aParser::COMMA);
    setState(8017);
    timing_check_event();
    setState(8018);
    match(SV3_1aParser::COMMA);
    setState(8019);
    timing_check_limit();
    setState(8024);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SV3_1aParser::COMMA) {
      setState(8020);
      match(SV3_1aParser::COMMA);
      setState(8022);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (((((_la - 326) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 326)) & 4672924483589) != 0)) {
        setState(8021);
        notifier();
      }
    }
    setState(8026);
    match(SV3_1aParser::CLOSE_PARENS);
    setState(8027);
    match(SV3_1aParser::SEMICOLON);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Dollar_recrem_timing_checkContext ------------------------------------------------------------------

SV3_1aParser::Dollar_recrem_timing_checkContext::Dollar_recrem_timing_checkContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Dollar_recrem_timing_checkContext::DOLLAR() {
  return getToken(SV3_1aParser::DOLLAR, 0);
}

tree::TerminalNode* SV3_1aParser::Dollar_recrem_timing_checkContext::Simple_identifier() {
  return getToken(SV3_1aParser::Simple_identifier, 0);
}

tree::TerminalNode* SV3_1aParser::Dollar_recrem_timing_checkContext::OPEN_PARENS() {
  return getToken(SV3_1aParser::OPEN_PARENS, 0);
}

SV3_1aParser::Reference_eventContext* SV3_1aParser::Dollar_recrem_timing_checkContext::reference_event() {
  return getRuleContext<SV3_1aParser::Reference_eventContext>(0);
}

std::vector<tree::TerminalNode *> SV3_1aParser::Dollar_recrem_timing_checkContext::COMMA() {
  return getTokens(SV3_1aParser::COMMA);
}

tree::TerminalNode* SV3_1aParser::Dollar_recrem_timing_checkContext::COMMA(size_t i) {
  return getToken(SV3_1aParser::COMMA, i);
}

SV3_1aParser::Timing_check_eventContext* SV3_1aParser::Dollar_recrem_timing_checkContext::timing_check_event() {
  return getRuleContext<SV3_1aParser::Timing_check_eventContext>(0);
}

std::vector<SV3_1aParser::Timing_check_limitContext *> SV3_1aParser::Dollar_recrem_timing_checkContext::timing_check_limit() {
  return getRuleContexts<SV3_1aParser::Timing_check_limitContext>();
}

SV3_1aParser::Timing_check_limitContext* SV3_1aParser::Dollar_recrem_timing_checkContext::timing_check_limit(size_t i) {
  return getRuleContext<SV3_1aParser::Timing_check_limitContext>(i);
}

tree::TerminalNode* SV3_1aParser::Dollar_recrem_timing_checkContext::CLOSE_PARENS() {
  return getToken(SV3_1aParser::CLOSE_PARENS, 0);
}

tree::TerminalNode* SV3_1aParser::Dollar_recrem_timing_checkContext::SEMICOLON() {
  return getToken(SV3_1aParser::SEMICOLON, 0);
}

SV3_1aParser::NotifierContext* SV3_1aParser::Dollar_recrem_timing_checkContext::notifier() {
  return getRuleContext<SV3_1aParser::NotifierContext>(0);
}

SV3_1aParser::Stamptime_conditionContext* SV3_1aParser::Dollar_recrem_timing_checkContext::stamptime_condition() {
  return getRuleContext<SV3_1aParser::Stamptime_conditionContext>(0);
}

SV3_1aParser::Mintypmax_expressionContext* SV3_1aParser::Dollar_recrem_timing_checkContext::mintypmax_expression() {
  return getRuleContext<SV3_1aParser::Mintypmax_expressionContext>(0);
}

SV3_1aParser::Delayed_referenceContext* SV3_1aParser::Dollar_recrem_timing_checkContext::delayed_reference() {
  return getRuleContext<SV3_1aParser::Delayed_referenceContext>(0);
}

SV3_1aParser::Delayed_dataContext* SV3_1aParser::Dollar_recrem_timing_checkContext::delayed_data() {
  return getRuleContext<SV3_1aParser::Delayed_dataContext>(0);
}


size_t SV3_1aParser::Dollar_recrem_timing_checkContext::getRuleIndex() const {
  return SV3_1aParser::RuleDollar_recrem_timing_check;
}

void SV3_1aParser::Dollar_recrem_timing_checkContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDollar_recrem_timing_check(this);
}

void SV3_1aParser::Dollar_recrem_timing_checkContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDollar_recrem_timing_check(this);
}

SV3_1aParser::Dollar_recrem_timing_checkContext* SV3_1aParser::dollar_recrem_timing_check() {
  Dollar_recrem_timing_checkContext *_localctx = _tracker.createInstance<Dollar_recrem_timing_checkContext>(_ctx, getState());
  enterRule(_localctx, 1032, SV3_1aParser::RuleDollar_recrem_timing_check);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8029);
    match(SV3_1aParser::DOLLAR);
    setState(8030);
    match(SV3_1aParser::Simple_identifier);
    setState(8031);
    match(SV3_1aParser::OPEN_PARENS);
    setState(8032);
    reference_event();
    setState(8033);
    match(SV3_1aParser::COMMA);
    setState(8034);
    timing_check_event();
    setState(8035);
    match(SV3_1aParser::COMMA);
    setState(8036);
    timing_check_limit();
    setState(8037);
    match(SV3_1aParser::COMMA);
    setState(8038);
    timing_check_limit();
    setState(8067);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SV3_1aParser::COMMA) {
      setState(8039);
      match(SV3_1aParser::COMMA);
      setState(8041);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (((((_la - 326) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 326)) & 4672924483589) != 0)) {
        setState(8040);
        notifier();
      }
      setState(8065);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == SV3_1aParser::COMMA) {
        setState(8043);
        match(SV3_1aParser::COMMA);
        setState(8045);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if ((((_la & ~ 0x3fULL) == 0) &&
          ((1ULL << _la) & 8796094922748) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 64)) & 1152648825725551617) != 0) || ((((_la - 147) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 147)) & 2199527096323) != 0) || _la == SV3_1aParser::BANG || ((((_la - 310) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 310)) & 559537073624154177) != 0)) {
          setState(8044);
          stamptime_condition();
        }
        setState(8063);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == SV3_1aParser::COMMA) {
          setState(8047);
          match(SV3_1aParser::COMMA);
          setState(8049);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if ((((_la & ~ 0x3fULL) == 0) &&
            ((1ULL << _la) & 8796094922748) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
            ((1ULL << (_la - 64)) & 1152648825725551617) != 0) || ((((_la - 147) & ~ 0x3fULL) == 0) &&
            ((1ULL << (_la - 147)) & 2199527096323) != 0) || _la == SV3_1aParser::BANG || ((((_la - 310) & ~ 0x3fULL) == 0) &&
            ((1ULL << (_la - 310)) & 559537073624154177) != 0)) {
            setState(8048);
            mintypmax_expression();
          }
          setState(8061);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if (_la == SV3_1aParser::COMMA) {
            setState(8051);
            match(SV3_1aParser::COMMA);
            setState(8053);
            _errHandler->sync(this);

            _la = _input->LA(1);
            if (((((_la - 326) & ~ 0x3fULL) == 0) &&
              ((1ULL << (_la - 326)) & 4672924483589) != 0)) {
              setState(8052);
              delayed_reference();
            }
            setState(8059);
            _errHandler->sync(this);

            _la = _input->LA(1);
            if (_la == SV3_1aParser::COMMA) {
              setState(8055);
              match(SV3_1aParser::COMMA);
              setState(8057);
              _errHandler->sync(this);

              _la = _input->LA(1);
              if (((((_la - 326) & ~ 0x3fULL) == 0) &&
                ((1ULL << (_la - 326)) & 4672924483589) != 0)) {
                setState(8056);
                delayed_data();
              }
            }
          }
        }
      }
    }
    setState(8069);
    match(SV3_1aParser::CLOSE_PARENS);
    setState(8070);
    match(SV3_1aParser::SEMICOLON);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Dollar_skew_timing_checkContext ------------------------------------------------------------------

SV3_1aParser::Dollar_skew_timing_checkContext::Dollar_skew_timing_checkContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Dollar_skew_timing_checkContext::DOLLAR() {
  return getToken(SV3_1aParser::DOLLAR, 0);
}

tree::TerminalNode* SV3_1aParser::Dollar_skew_timing_checkContext::Simple_identifier() {
  return getToken(SV3_1aParser::Simple_identifier, 0);
}

tree::TerminalNode* SV3_1aParser::Dollar_skew_timing_checkContext::OPEN_PARENS() {
  return getToken(SV3_1aParser::OPEN_PARENS, 0);
}

SV3_1aParser::Reference_eventContext* SV3_1aParser::Dollar_skew_timing_checkContext::reference_event() {
  return getRuleContext<SV3_1aParser::Reference_eventContext>(0);
}

std::vector<tree::TerminalNode *> SV3_1aParser::Dollar_skew_timing_checkContext::COMMA() {
  return getTokens(SV3_1aParser::COMMA);
}

tree::TerminalNode* SV3_1aParser::Dollar_skew_timing_checkContext::COMMA(size_t i) {
  return getToken(SV3_1aParser::COMMA, i);
}

SV3_1aParser::Timing_check_eventContext* SV3_1aParser::Dollar_skew_timing_checkContext::timing_check_event() {
  return getRuleContext<SV3_1aParser::Timing_check_eventContext>(0);
}

SV3_1aParser::Timing_check_limitContext* SV3_1aParser::Dollar_skew_timing_checkContext::timing_check_limit() {
  return getRuleContext<SV3_1aParser::Timing_check_limitContext>(0);
}

tree::TerminalNode* SV3_1aParser::Dollar_skew_timing_checkContext::CLOSE_PARENS() {
  return getToken(SV3_1aParser::CLOSE_PARENS, 0);
}

tree::TerminalNode* SV3_1aParser::Dollar_skew_timing_checkContext::SEMICOLON() {
  return getToken(SV3_1aParser::SEMICOLON, 0);
}

SV3_1aParser::NotifierContext* SV3_1aParser::Dollar_skew_timing_checkContext::notifier() {
  return getRuleContext<SV3_1aParser::NotifierContext>(0);
}


size_t SV3_1aParser::Dollar_skew_timing_checkContext::getRuleIndex() const {
  return SV3_1aParser::RuleDollar_skew_timing_check;
}

void SV3_1aParser::Dollar_skew_timing_checkContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDollar_skew_timing_check(this);
}

void SV3_1aParser::Dollar_skew_timing_checkContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDollar_skew_timing_check(this);
}

SV3_1aParser::Dollar_skew_timing_checkContext* SV3_1aParser::dollar_skew_timing_check() {
  Dollar_skew_timing_checkContext *_localctx = _tracker.createInstance<Dollar_skew_timing_checkContext>(_ctx, getState());
  enterRule(_localctx, 1034, SV3_1aParser::RuleDollar_skew_timing_check);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8072);
    match(SV3_1aParser::DOLLAR);
    setState(8073);
    match(SV3_1aParser::Simple_identifier);
    setState(8074);
    match(SV3_1aParser::OPEN_PARENS);
    setState(8075);
    reference_event();
    setState(8076);
    match(SV3_1aParser::COMMA);
    setState(8077);
    timing_check_event();
    setState(8078);
    match(SV3_1aParser::COMMA);
    setState(8079);
    timing_check_limit();
    setState(8084);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SV3_1aParser::COMMA) {
      setState(8080);
      match(SV3_1aParser::COMMA);
      setState(8082);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (((((_la - 326) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 326)) & 4672924483589) != 0)) {
        setState(8081);
        notifier();
      }
    }
    setState(8086);
    match(SV3_1aParser::CLOSE_PARENS);
    setState(8087);
    match(SV3_1aParser::SEMICOLON);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Dollar_timeskew_timing_checkContext ------------------------------------------------------------------

SV3_1aParser::Dollar_timeskew_timing_checkContext::Dollar_timeskew_timing_checkContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Dollar_timeskew_timing_checkContext::DOLLAR() {
  return getToken(SV3_1aParser::DOLLAR, 0);
}

tree::TerminalNode* SV3_1aParser::Dollar_timeskew_timing_checkContext::Simple_identifier() {
  return getToken(SV3_1aParser::Simple_identifier, 0);
}

tree::TerminalNode* SV3_1aParser::Dollar_timeskew_timing_checkContext::OPEN_PARENS() {
  return getToken(SV3_1aParser::OPEN_PARENS, 0);
}

SV3_1aParser::Reference_eventContext* SV3_1aParser::Dollar_timeskew_timing_checkContext::reference_event() {
  return getRuleContext<SV3_1aParser::Reference_eventContext>(0);
}

std::vector<tree::TerminalNode *> SV3_1aParser::Dollar_timeskew_timing_checkContext::COMMA() {
  return getTokens(SV3_1aParser::COMMA);
}

tree::TerminalNode* SV3_1aParser::Dollar_timeskew_timing_checkContext::COMMA(size_t i) {
  return getToken(SV3_1aParser::COMMA, i);
}

SV3_1aParser::Timing_check_eventContext* SV3_1aParser::Dollar_timeskew_timing_checkContext::timing_check_event() {
  return getRuleContext<SV3_1aParser::Timing_check_eventContext>(0);
}

SV3_1aParser::Timing_check_limitContext* SV3_1aParser::Dollar_timeskew_timing_checkContext::timing_check_limit() {
  return getRuleContext<SV3_1aParser::Timing_check_limitContext>(0);
}

tree::TerminalNode* SV3_1aParser::Dollar_timeskew_timing_checkContext::CLOSE_PARENS() {
  return getToken(SV3_1aParser::CLOSE_PARENS, 0);
}

tree::TerminalNode* SV3_1aParser::Dollar_timeskew_timing_checkContext::SEMICOLON() {
  return getToken(SV3_1aParser::SEMICOLON, 0);
}

SV3_1aParser::NotifierContext* SV3_1aParser::Dollar_timeskew_timing_checkContext::notifier() {
  return getRuleContext<SV3_1aParser::NotifierContext>(0);
}

SV3_1aParser::Event_based_flagContext* SV3_1aParser::Dollar_timeskew_timing_checkContext::event_based_flag() {
  return getRuleContext<SV3_1aParser::Event_based_flagContext>(0);
}

SV3_1aParser::Remain_active_flagContext* SV3_1aParser::Dollar_timeskew_timing_checkContext::remain_active_flag() {
  return getRuleContext<SV3_1aParser::Remain_active_flagContext>(0);
}


size_t SV3_1aParser::Dollar_timeskew_timing_checkContext::getRuleIndex() const {
  return SV3_1aParser::RuleDollar_timeskew_timing_check;
}

void SV3_1aParser::Dollar_timeskew_timing_checkContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDollar_timeskew_timing_check(this);
}

void SV3_1aParser::Dollar_timeskew_timing_checkContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDollar_timeskew_timing_check(this);
}

SV3_1aParser::Dollar_timeskew_timing_checkContext* SV3_1aParser::dollar_timeskew_timing_check() {
  Dollar_timeskew_timing_checkContext *_localctx = _tracker.createInstance<Dollar_timeskew_timing_checkContext>(_ctx, getState());
  enterRule(_localctx, 1036, SV3_1aParser::RuleDollar_timeskew_timing_check);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8089);
    match(SV3_1aParser::DOLLAR);
    setState(8090);
    match(SV3_1aParser::Simple_identifier);
    setState(8091);
    match(SV3_1aParser::OPEN_PARENS);
    setState(8092);
    reference_event();
    setState(8093);
    match(SV3_1aParser::COMMA);
    setState(8094);
    timing_check_event();
    setState(8095);
    match(SV3_1aParser::COMMA);
    setState(8096);
    timing_check_limit();
    setState(8113);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SV3_1aParser::COMMA) {
      setState(8097);
      match(SV3_1aParser::COMMA);
      setState(8099);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (((((_la - 326) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 326)) & 4672924483589) != 0)) {
        setState(8098);
        notifier();
      }
      setState(8111);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == SV3_1aParser::COMMA) {
        setState(8101);
        match(SV3_1aParser::COMMA);
        setState(8103);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if ((((_la & ~ 0x3fULL) == 0) &&
          ((1ULL << _la) & 8796094922748) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 64)) & 1152648825725551617) != 0) || ((((_la - 147) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 147)) & 2199359324163) != 0) || _la == SV3_1aParser::BANG || ((((_la - 316) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 316)) & 8742766775376897) != 0)) {
          setState(8102);
          event_based_flag();
        }
        setState(8109);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == SV3_1aParser::COMMA) {
          setState(8105);
          match(SV3_1aParser::COMMA);
          setState(8107);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if ((((_la & ~ 0x3fULL) == 0) &&
            ((1ULL << _la) & 8796094922748) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
            ((1ULL << (_la - 64)) & 1152648825725551617) != 0) || ((((_la - 147) & ~ 0x3fULL) == 0) &&
            ((1ULL << (_la - 147)) & 2199359324163) != 0) || _la == SV3_1aParser::BANG || ((((_la - 316) & ~ 0x3fULL) == 0) &&
            ((1ULL << (_la - 316)) & 8742766775376897) != 0)) {
            setState(8106);
            remain_active_flag();
          }
        }
      }
    }
    setState(8115);
    match(SV3_1aParser::CLOSE_PARENS);
    setState(8116);
    match(SV3_1aParser::SEMICOLON);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Dollar_fullskew_timing_checkContext ------------------------------------------------------------------

SV3_1aParser::Dollar_fullskew_timing_checkContext::Dollar_fullskew_timing_checkContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Dollar_fullskew_timing_checkContext::DOLLAR() {
  return getToken(SV3_1aParser::DOLLAR, 0);
}

tree::TerminalNode* SV3_1aParser::Dollar_fullskew_timing_checkContext::Simple_identifier() {
  return getToken(SV3_1aParser::Simple_identifier, 0);
}

tree::TerminalNode* SV3_1aParser::Dollar_fullskew_timing_checkContext::OPEN_PARENS() {
  return getToken(SV3_1aParser::OPEN_PARENS, 0);
}

SV3_1aParser::Reference_eventContext* SV3_1aParser::Dollar_fullskew_timing_checkContext::reference_event() {
  return getRuleContext<SV3_1aParser::Reference_eventContext>(0);
}

std::vector<tree::TerminalNode *> SV3_1aParser::Dollar_fullskew_timing_checkContext::COMMA() {
  return getTokens(SV3_1aParser::COMMA);
}

tree::TerminalNode* SV3_1aParser::Dollar_fullskew_timing_checkContext::COMMA(size_t i) {
  return getToken(SV3_1aParser::COMMA, i);
}

SV3_1aParser::Timing_check_eventContext* SV3_1aParser::Dollar_fullskew_timing_checkContext::timing_check_event() {
  return getRuleContext<SV3_1aParser::Timing_check_eventContext>(0);
}

std::vector<SV3_1aParser::Timing_check_limitContext *> SV3_1aParser::Dollar_fullskew_timing_checkContext::timing_check_limit() {
  return getRuleContexts<SV3_1aParser::Timing_check_limitContext>();
}

SV3_1aParser::Timing_check_limitContext* SV3_1aParser::Dollar_fullskew_timing_checkContext::timing_check_limit(size_t i) {
  return getRuleContext<SV3_1aParser::Timing_check_limitContext>(i);
}

tree::TerminalNode* SV3_1aParser::Dollar_fullskew_timing_checkContext::CLOSE_PARENS() {
  return getToken(SV3_1aParser::CLOSE_PARENS, 0);
}

tree::TerminalNode* SV3_1aParser::Dollar_fullskew_timing_checkContext::SEMICOLON() {
  return getToken(SV3_1aParser::SEMICOLON, 0);
}

SV3_1aParser::NotifierContext* SV3_1aParser::Dollar_fullskew_timing_checkContext::notifier() {
  return getRuleContext<SV3_1aParser::NotifierContext>(0);
}

SV3_1aParser::Event_based_flagContext* SV3_1aParser::Dollar_fullskew_timing_checkContext::event_based_flag() {
  return getRuleContext<SV3_1aParser::Event_based_flagContext>(0);
}

SV3_1aParser::Remain_active_flagContext* SV3_1aParser::Dollar_fullskew_timing_checkContext::remain_active_flag() {
  return getRuleContext<SV3_1aParser::Remain_active_flagContext>(0);
}


size_t SV3_1aParser::Dollar_fullskew_timing_checkContext::getRuleIndex() const {
  return SV3_1aParser::RuleDollar_fullskew_timing_check;
}

void SV3_1aParser::Dollar_fullskew_timing_checkContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDollar_fullskew_timing_check(this);
}

void SV3_1aParser::Dollar_fullskew_timing_checkContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDollar_fullskew_timing_check(this);
}

SV3_1aParser::Dollar_fullskew_timing_checkContext* SV3_1aParser::dollar_fullskew_timing_check() {
  Dollar_fullskew_timing_checkContext *_localctx = _tracker.createInstance<Dollar_fullskew_timing_checkContext>(_ctx, getState());
  enterRule(_localctx, 1038, SV3_1aParser::RuleDollar_fullskew_timing_check);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8118);
    match(SV3_1aParser::DOLLAR);
    setState(8119);
    match(SV3_1aParser::Simple_identifier);
    setState(8120);
    match(SV3_1aParser::OPEN_PARENS);
    setState(8121);
    reference_event();
    setState(8122);
    match(SV3_1aParser::COMMA);
    setState(8123);
    timing_check_event();
    setState(8124);
    match(SV3_1aParser::COMMA);
    setState(8125);
    timing_check_limit();
    setState(8126);
    match(SV3_1aParser::COMMA);
    setState(8127);
    timing_check_limit();
    setState(8144);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SV3_1aParser::COMMA) {
      setState(8128);
      match(SV3_1aParser::COMMA);
      setState(8130);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (((((_la - 326) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 326)) & 4672924483589) != 0)) {
        setState(8129);
        notifier();
      }
      setState(8142);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == SV3_1aParser::COMMA) {
        setState(8132);
        match(SV3_1aParser::COMMA);
        setState(8134);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if ((((_la & ~ 0x3fULL) == 0) &&
          ((1ULL << _la) & 8796094922748) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 64)) & 1152648825725551617) != 0) || ((((_la - 147) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 147)) & 2199359324163) != 0) || _la == SV3_1aParser::BANG || ((((_la - 316) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 316)) & 8742766775376897) != 0)) {
          setState(8133);
          event_based_flag();
        }
        setState(8140);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == SV3_1aParser::COMMA) {
          setState(8136);
          match(SV3_1aParser::COMMA);
          setState(8138);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if ((((_la & ~ 0x3fULL) == 0) &&
            ((1ULL << _la) & 8796094922748) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
            ((1ULL << (_la - 64)) & 1152648825725551617) != 0) || ((((_la - 147) & ~ 0x3fULL) == 0) &&
            ((1ULL << (_la - 147)) & 2199359324163) != 0) || _la == SV3_1aParser::BANG || ((((_la - 316) & ~ 0x3fULL) == 0) &&
            ((1ULL << (_la - 316)) & 8742766775376897) != 0)) {
            setState(8137);
            remain_active_flag();
          }
        }
      }
    }
    setState(8146);
    match(SV3_1aParser::CLOSE_PARENS);
    setState(8147);
    match(SV3_1aParser::SEMICOLON);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Dollar_period_timing_checkContext ------------------------------------------------------------------

SV3_1aParser::Dollar_period_timing_checkContext::Dollar_period_timing_checkContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Dollar_period_timing_checkContext::DOLLAR() {
  return getToken(SV3_1aParser::DOLLAR, 0);
}

tree::TerminalNode* SV3_1aParser::Dollar_period_timing_checkContext::Simple_identifier() {
  return getToken(SV3_1aParser::Simple_identifier, 0);
}

tree::TerminalNode* SV3_1aParser::Dollar_period_timing_checkContext::OPEN_PARENS() {
  return getToken(SV3_1aParser::OPEN_PARENS, 0);
}

SV3_1aParser::Controlled_timing_check_eventContext* SV3_1aParser::Dollar_period_timing_checkContext::controlled_timing_check_event() {
  return getRuleContext<SV3_1aParser::Controlled_timing_check_eventContext>(0);
}

std::vector<tree::TerminalNode *> SV3_1aParser::Dollar_period_timing_checkContext::COMMA() {
  return getTokens(SV3_1aParser::COMMA);
}

tree::TerminalNode* SV3_1aParser::Dollar_period_timing_checkContext::COMMA(size_t i) {
  return getToken(SV3_1aParser::COMMA, i);
}

SV3_1aParser::Timing_check_limitContext* SV3_1aParser::Dollar_period_timing_checkContext::timing_check_limit() {
  return getRuleContext<SV3_1aParser::Timing_check_limitContext>(0);
}

tree::TerminalNode* SV3_1aParser::Dollar_period_timing_checkContext::CLOSE_PARENS() {
  return getToken(SV3_1aParser::CLOSE_PARENS, 0);
}

tree::TerminalNode* SV3_1aParser::Dollar_period_timing_checkContext::SEMICOLON() {
  return getToken(SV3_1aParser::SEMICOLON, 0);
}

SV3_1aParser::NotifierContext* SV3_1aParser::Dollar_period_timing_checkContext::notifier() {
  return getRuleContext<SV3_1aParser::NotifierContext>(0);
}


size_t SV3_1aParser::Dollar_period_timing_checkContext::getRuleIndex() const {
  return SV3_1aParser::RuleDollar_period_timing_check;
}

void SV3_1aParser::Dollar_period_timing_checkContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDollar_period_timing_check(this);
}

void SV3_1aParser::Dollar_period_timing_checkContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDollar_period_timing_check(this);
}

SV3_1aParser::Dollar_period_timing_checkContext* SV3_1aParser::dollar_period_timing_check() {
  Dollar_period_timing_checkContext *_localctx = _tracker.createInstance<Dollar_period_timing_checkContext>(_ctx, getState());
  enterRule(_localctx, 1040, SV3_1aParser::RuleDollar_period_timing_check);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8149);
    match(SV3_1aParser::DOLLAR);
    setState(8150);
    match(SV3_1aParser::Simple_identifier);
    setState(8151);
    match(SV3_1aParser::OPEN_PARENS);
    setState(8152);
    controlled_timing_check_event();
    setState(8153);
    match(SV3_1aParser::COMMA);
    setState(8154);
    timing_check_limit();
    setState(8159);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SV3_1aParser::COMMA) {
      setState(8155);
      match(SV3_1aParser::COMMA);
      setState(8157);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (((((_la - 326) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 326)) & 4672924483589) != 0)) {
        setState(8156);
        notifier();
      }
    }
    setState(8161);
    match(SV3_1aParser::CLOSE_PARENS);
    setState(8162);
    match(SV3_1aParser::SEMICOLON);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Dollar_width_timing_checkContext ------------------------------------------------------------------

SV3_1aParser::Dollar_width_timing_checkContext::Dollar_width_timing_checkContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Dollar_width_timing_checkContext::DOLLAR() {
  return getToken(SV3_1aParser::DOLLAR, 0);
}

tree::TerminalNode* SV3_1aParser::Dollar_width_timing_checkContext::Simple_identifier() {
  return getToken(SV3_1aParser::Simple_identifier, 0);
}

tree::TerminalNode* SV3_1aParser::Dollar_width_timing_checkContext::OPEN_PARENS() {
  return getToken(SV3_1aParser::OPEN_PARENS, 0);
}

SV3_1aParser::Controlled_timing_check_eventContext* SV3_1aParser::Dollar_width_timing_checkContext::controlled_timing_check_event() {
  return getRuleContext<SV3_1aParser::Controlled_timing_check_eventContext>(0);
}

std::vector<tree::TerminalNode *> SV3_1aParser::Dollar_width_timing_checkContext::COMMA() {
  return getTokens(SV3_1aParser::COMMA);
}

tree::TerminalNode* SV3_1aParser::Dollar_width_timing_checkContext::COMMA(size_t i) {
  return getToken(SV3_1aParser::COMMA, i);
}

SV3_1aParser::Timing_check_limitContext* SV3_1aParser::Dollar_width_timing_checkContext::timing_check_limit() {
  return getRuleContext<SV3_1aParser::Timing_check_limitContext>(0);
}

SV3_1aParser::ThresholdContext* SV3_1aParser::Dollar_width_timing_checkContext::threshold() {
  return getRuleContext<SV3_1aParser::ThresholdContext>(0);
}

tree::TerminalNode* SV3_1aParser::Dollar_width_timing_checkContext::CLOSE_PARENS() {
  return getToken(SV3_1aParser::CLOSE_PARENS, 0);
}

tree::TerminalNode* SV3_1aParser::Dollar_width_timing_checkContext::SEMICOLON() {
  return getToken(SV3_1aParser::SEMICOLON, 0);
}

SV3_1aParser::NotifierContext* SV3_1aParser::Dollar_width_timing_checkContext::notifier() {
  return getRuleContext<SV3_1aParser::NotifierContext>(0);
}


size_t SV3_1aParser::Dollar_width_timing_checkContext::getRuleIndex() const {
  return SV3_1aParser::RuleDollar_width_timing_check;
}

void SV3_1aParser::Dollar_width_timing_checkContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDollar_width_timing_check(this);
}

void SV3_1aParser::Dollar_width_timing_checkContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDollar_width_timing_check(this);
}

SV3_1aParser::Dollar_width_timing_checkContext* SV3_1aParser::dollar_width_timing_check() {
  Dollar_width_timing_checkContext *_localctx = _tracker.createInstance<Dollar_width_timing_checkContext>(_ctx, getState());
  enterRule(_localctx, 1042, SV3_1aParser::RuleDollar_width_timing_check);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8164);
    match(SV3_1aParser::DOLLAR);
    setState(8165);
    match(SV3_1aParser::Simple_identifier);
    setState(8166);
    match(SV3_1aParser::OPEN_PARENS);
    setState(8167);
    controlled_timing_check_event();
    setState(8168);
    match(SV3_1aParser::COMMA);
    setState(8169);
    timing_check_limit();
    setState(8170);
    match(SV3_1aParser::COMMA);
    setState(8171);
    threshold();
    setState(8176);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SV3_1aParser::COMMA) {
      setState(8172);
      match(SV3_1aParser::COMMA);
      setState(8174);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (((((_la - 326) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 326)) & 4672924483589) != 0)) {
        setState(8173);
        notifier();
      }
    }
    setState(8178);
    match(SV3_1aParser::CLOSE_PARENS);
    setState(8179);
    match(SV3_1aParser::SEMICOLON);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Dollar_nochange_timing_checkContext ------------------------------------------------------------------

SV3_1aParser::Dollar_nochange_timing_checkContext::Dollar_nochange_timing_checkContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Dollar_nochange_timing_checkContext::DOLLAR() {
  return getToken(SV3_1aParser::DOLLAR, 0);
}

tree::TerminalNode* SV3_1aParser::Dollar_nochange_timing_checkContext::Simple_identifier() {
  return getToken(SV3_1aParser::Simple_identifier, 0);
}

tree::TerminalNode* SV3_1aParser::Dollar_nochange_timing_checkContext::OPEN_PARENS() {
  return getToken(SV3_1aParser::OPEN_PARENS, 0);
}

SV3_1aParser::Reference_eventContext* SV3_1aParser::Dollar_nochange_timing_checkContext::reference_event() {
  return getRuleContext<SV3_1aParser::Reference_eventContext>(0);
}

std::vector<tree::TerminalNode *> SV3_1aParser::Dollar_nochange_timing_checkContext::COMMA() {
  return getTokens(SV3_1aParser::COMMA);
}

tree::TerminalNode* SV3_1aParser::Dollar_nochange_timing_checkContext::COMMA(size_t i) {
  return getToken(SV3_1aParser::COMMA, i);
}

SV3_1aParser::Timing_check_eventContext* SV3_1aParser::Dollar_nochange_timing_checkContext::timing_check_event() {
  return getRuleContext<SV3_1aParser::Timing_check_eventContext>(0);
}

SV3_1aParser::Start_edge_offsetContext* SV3_1aParser::Dollar_nochange_timing_checkContext::start_edge_offset() {
  return getRuleContext<SV3_1aParser::Start_edge_offsetContext>(0);
}

SV3_1aParser::End_edge_offsetContext* SV3_1aParser::Dollar_nochange_timing_checkContext::end_edge_offset() {
  return getRuleContext<SV3_1aParser::End_edge_offsetContext>(0);
}

tree::TerminalNode* SV3_1aParser::Dollar_nochange_timing_checkContext::CLOSE_PARENS() {
  return getToken(SV3_1aParser::CLOSE_PARENS, 0);
}

tree::TerminalNode* SV3_1aParser::Dollar_nochange_timing_checkContext::SEMICOLON() {
  return getToken(SV3_1aParser::SEMICOLON, 0);
}

SV3_1aParser::NotifierContext* SV3_1aParser::Dollar_nochange_timing_checkContext::notifier() {
  return getRuleContext<SV3_1aParser::NotifierContext>(0);
}


size_t SV3_1aParser::Dollar_nochange_timing_checkContext::getRuleIndex() const {
  return SV3_1aParser::RuleDollar_nochange_timing_check;
}

void SV3_1aParser::Dollar_nochange_timing_checkContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDollar_nochange_timing_check(this);
}

void SV3_1aParser::Dollar_nochange_timing_checkContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDollar_nochange_timing_check(this);
}

SV3_1aParser::Dollar_nochange_timing_checkContext* SV3_1aParser::dollar_nochange_timing_check() {
  Dollar_nochange_timing_checkContext *_localctx = _tracker.createInstance<Dollar_nochange_timing_checkContext>(_ctx, getState());
  enterRule(_localctx, 1044, SV3_1aParser::RuleDollar_nochange_timing_check);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8181);
    match(SV3_1aParser::DOLLAR);
    setState(8182);
    match(SV3_1aParser::Simple_identifier);
    setState(8183);
    match(SV3_1aParser::OPEN_PARENS);
    setState(8184);
    reference_event();
    setState(8185);
    match(SV3_1aParser::COMMA);
    setState(8186);
    timing_check_event();
    setState(8187);
    match(SV3_1aParser::COMMA);
    setState(8188);
    start_edge_offset();
    setState(8189);
    match(SV3_1aParser::COMMA);
    setState(8190);
    end_edge_offset();
    setState(8195);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SV3_1aParser::COMMA) {
      setState(8191);
      match(SV3_1aParser::COMMA);
      setState(8193);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (((((_la - 326) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 326)) & 4672924483589) != 0)) {
        setState(8192);
        notifier();
      }
    }
    setState(8197);
    match(SV3_1aParser::CLOSE_PARENS);
    setState(8198);
    match(SV3_1aParser::SEMICOLON);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Delayed_dataContext ------------------------------------------------------------------

SV3_1aParser::Delayed_dataContext::Delayed_dataContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::IdentifierContext* SV3_1aParser::Delayed_dataContext::identifier() {
  return getRuleContext<SV3_1aParser::IdentifierContext>(0);
}

tree::TerminalNode* SV3_1aParser::Delayed_dataContext::OPEN_BRACKET() {
  return getToken(SV3_1aParser::OPEN_BRACKET, 0);
}

SV3_1aParser::Constant_mintypmax_expressionContext* SV3_1aParser::Delayed_dataContext::constant_mintypmax_expression() {
  return getRuleContext<SV3_1aParser::Constant_mintypmax_expressionContext>(0);
}

tree::TerminalNode* SV3_1aParser::Delayed_dataContext::CLOSE_BRACKET() {
  return getToken(SV3_1aParser::CLOSE_BRACKET, 0);
}


size_t SV3_1aParser::Delayed_dataContext::getRuleIndex() const {
  return SV3_1aParser::RuleDelayed_data;
}

void SV3_1aParser::Delayed_dataContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDelayed_data(this);
}

void SV3_1aParser::Delayed_dataContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDelayed_data(this);
}

SV3_1aParser::Delayed_dataContext* SV3_1aParser::delayed_data() {
  Delayed_dataContext *_localctx = _tracker.createInstance<Delayed_dataContext>(_ctx, getState());
  enterRule(_localctx, 1046, SV3_1aParser::RuleDelayed_data);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8200);
    identifier();
    setState(8205);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SV3_1aParser::OPEN_BRACKET) {
      setState(8201);
      match(SV3_1aParser::OPEN_BRACKET);
      setState(8202);
      constant_mintypmax_expression();
      setState(8203);
      match(SV3_1aParser::CLOSE_BRACKET);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Delayed_referenceContext ------------------------------------------------------------------

SV3_1aParser::Delayed_referenceContext::Delayed_referenceContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::IdentifierContext* SV3_1aParser::Delayed_referenceContext::identifier() {
  return getRuleContext<SV3_1aParser::IdentifierContext>(0);
}

tree::TerminalNode* SV3_1aParser::Delayed_referenceContext::OPEN_BRACKET() {
  return getToken(SV3_1aParser::OPEN_BRACKET, 0);
}

SV3_1aParser::Constant_mintypmax_expressionContext* SV3_1aParser::Delayed_referenceContext::constant_mintypmax_expression() {
  return getRuleContext<SV3_1aParser::Constant_mintypmax_expressionContext>(0);
}

tree::TerminalNode* SV3_1aParser::Delayed_referenceContext::CLOSE_BRACKET() {
  return getToken(SV3_1aParser::CLOSE_BRACKET, 0);
}


size_t SV3_1aParser::Delayed_referenceContext::getRuleIndex() const {
  return SV3_1aParser::RuleDelayed_reference;
}

void SV3_1aParser::Delayed_referenceContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDelayed_reference(this);
}

void SV3_1aParser::Delayed_referenceContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDelayed_reference(this);
}

SV3_1aParser::Delayed_referenceContext* SV3_1aParser::delayed_reference() {
  Delayed_referenceContext *_localctx = _tracker.createInstance<Delayed_referenceContext>(_ctx, getState());
  enterRule(_localctx, 1048, SV3_1aParser::RuleDelayed_reference);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8207);
    identifier();
    setState(8212);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SV3_1aParser::OPEN_BRACKET) {
      setState(8208);
      match(SV3_1aParser::OPEN_BRACKET);
      setState(8209);
      constant_mintypmax_expression();
      setState(8210);
      match(SV3_1aParser::CLOSE_BRACKET);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- End_edge_offsetContext ------------------------------------------------------------------

SV3_1aParser::End_edge_offsetContext::End_edge_offsetContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::Mintypmax_expressionContext* SV3_1aParser::End_edge_offsetContext::mintypmax_expression() {
  return getRuleContext<SV3_1aParser::Mintypmax_expressionContext>(0);
}


size_t SV3_1aParser::End_edge_offsetContext::getRuleIndex() const {
  return SV3_1aParser::RuleEnd_edge_offset;
}

void SV3_1aParser::End_edge_offsetContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterEnd_edge_offset(this);
}

void SV3_1aParser::End_edge_offsetContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitEnd_edge_offset(this);
}

SV3_1aParser::End_edge_offsetContext* SV3_1aParser::end_edge_offset() {
  End_edge_offsetContext *_localctx = _tracker.createInstance<End_edge_offsetContext>(_ctx, getState());
  enterRule(_localctx, 1050, SV3_1aParser::RuleEnd_edge_offset);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8214);
    mintypmax_expression();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Event_based_flagContext ------------------------------------------------------------------

SV3_1aParser::Event_based_flagContext::Event_based_flagContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::Constant_expressionContext* SV3_1aParser::Event_based_flagContext::constant_expression() {
  return getRuleContext<SV3_1aParser::Constant_expressionContext>(0);
}


size_t SV3_1aParser::Event_based_flagContext::getRuleIndex() const {
  return SV3_1aParser::RuleEvent_based_flag;
}

void SV3_1aParser::Event_based_flagContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterEvent_based_flag(this);
}

void SV3_1aParser::Event_based_flagContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitEvent_based_flag(this);
}

SV3_1aParser::Event_based_flagContext* SV3_1aParser::event_based_flag() {
  Event_based_flagContext *_localctx = _tracker.createInstance<Event_based_flagContext>(_ctx, getState());
  enterRule(_localctx, 1052, SV3_1aParser::RuleEvent_based_flag);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8216);
    constant_expression(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- NotifierContext ------------------------------------------------------------------

SV3_1aParser::NotifierContext::NotifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::IdentifierContext* SV3_1aParser::NotifierContext::identifier() {
  return getRuleContext<SV3_1aParser::IdentifierContext>(0);
}


size_t SV3_1aParser::NotifierContext::getRuleIndex() const {
  return SV3_1aParser::RuleNotifier;
}

void SV3_1aParser::NotifierContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNotifier(this);
}

void SV3_1aParser::NotifierContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNotifier(this);
}

SV3_1aParser::NotifierContext* SV3_1aParser::notifier() {
  NotifierContext *_localctx = _tracker.createInstance<NotifierContext>(_ctx, getState());
  enterRule(_localctx, 1054, SV3_1aParser::RuleNotifier);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8218);
    identifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Reference_eventContext ------------------------------------------------------------------

SV3_1aParser::Reference_eventContext::Reference_eventContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::Timing_check_eventContext* SV3_1aParser::Reference_eventContext::timing_check_event() {
  return getRuleContext<SV3_1aParser::Timing_check_eventContext>(0);
}


size_t SV3_1aParser::Reference_eventContext::getRuleIndex() const {
  return SV3_1aParser::RuleReference_event;
}

void SV3_1aParser::Reference_eventContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterReference_event(this);
}

void SV3_1aParser::Reference_eventContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitReference_event(this);
}

SV3_1aParser::Reference_eventContext* SV3_1aParser::reference_event() {
  Reference_eventContext *_localctx = _tracker.createInstance<Reference_eventContext>(_ctx, getState());
  enterRule(_localctx, 1056, SV3_1aParser::RuleReference_event);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8220);
    timing_check_event();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Remain_active_flagContext ------------------------------------------------------------------

SV3_1aParser::Remain_active_flagContext::Remain_active_flagContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::Constant_mintypmax_expressionContext* SV3_1aParser::Remain_active_flagContext::constant_mintypmax_expression() {
  return getRuleContext<SV3_1aParser::Constant_mintypmax_expressionContext>(0);
}


size_t SV3_1aParser::Remain_active_flagContext::getRuleIndex() const {
  return SV3_1aParser::RuleRemain_active_flag;
}

void SV3_1aParser::Remain_active_flagContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRemain_active_flag(this);
}

void SV3_1aParser::Remain_active_flagContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRemain_active_flag(this);
}

SV3_1aParser::Remain_active_flagContext* SV3_1aParser::remain_active_flag() {
  Remain_active_flagContext *_localctx = _tracker.createInstance<Remain_active_flagContext>(_ctx, getState());
  enterRule(_localctx, 1058, SV3_1aParser::RuleRemain_active_flag);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8222);
    constant_mintypmax_expression();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Stamptime_conditionContext ------------------------------------------------------------------

SV3_1aParser::Stamptime_conditionContext::Stamptime_conditionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::Mintypmax_expressionContext* SV3_1aParser::Stamptime_conditionContext::mintypmax_expression() {
  return getRuleContext<SV3_1aParser::Mintypmax_expressionContext>(0);
}


size_t SV3_1aParser::Stamptime_conditionContext::getRuleIndex() const {
  return SV3_1aParser::RuleStamptime_condition;
}

void SV3_1aParser::Stamptime_conditionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterStamptime_condition(this);
}

void SV3_1aParser::Stamptime_conditionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitStamptime_condition(this);
}

SV3_1aParser::Stamptime_conditionContext* SV3_1aParser::stamptime_condition() {
  Stamptime_conditionContext *_localctx = _tracker.createInstance<Stamptime_conditionContext>(_ctx, getState());
  enterRule(_localctx, 1060, SV3_1aParser::RuleStamptime_condition);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8224);
    mintypmax_expression();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Start_edge_offsetContext ------------------------------------------------------------------

SV3_1aParser::Start_edge_offsetContext::Start_edge_offsetContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::Mintypmax_expressionContext* SV3_1aParser::Start_edge_offsetContext::mintypmax_expression() {
  return getRuleContext<SV3_1aParser::Mintypmax_expressionContext>(0);
}


size_t SV3_1aParser::Start_edge_offsetContext::getRuleIndex() const {
  return SV3_1aParser::RuleStart_edge_offset;
}

void SV3_1aParser::Start_edge_offsetContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterStart_edge_offset(this);
}

void SV3_1aParser::Start_edge_offsetContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitStart_edge_offset(this);
}

SV3_1aParser::Start_edge_offsetContext* SV3_1aParser::start_edge_offset() {
  Start_edge_offsetContext *_localctx = _tracker.createInstance<Start_edge_offsetContext>(_ctx, getState());
  enterRule(_localctx, 1062, SV3_1aParser::RuleStart_edge_offset);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8226);
    mintypmax_expression();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ThresholdContext ------------------------------------------------------------------

SV3_1aParser::ThresholdContext::ThresholdContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::Constant_expressionContext* SV3_1aParser::ThresholdContext::constant_expression() {
  return getRuleContext<SV3_1aParser::Constant_expressionContext>(0);
}


size_t SV3_1aParser::ThresholdContext::getRuleIndex() const {
  return SV3_1aParser::RuleThreshold;
}

void SV3_1aParser::ThresholdContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterThreshold(this);
}

void SV3_1aParser::ThresholdContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitThreshold(this);
}

SV3_1aParser::ThresholdContext* SV3_1aParser::threshold() {
  ThresholdContext *_localctx = _tracker.createInstance<ThresholdContext>(_ctx, getState());
  enterRule(_localctx, 1064, SV3_1aParser::RuleThreshold);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8228);
    constant_expression(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Timing_check_limitContext ------------------------------------------------------------------

SV3_1aParser::Timing_check_limitContext::Timing_check_limitContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::Mintypmax_expressionContext* SV3_1aParser::Timing_check_limitContext::mintypmax_expression() {
  return getRuleContext<SV3_1aParser::Mintypmax_expressionContext>(0);
}


size_t SV3_1aParser::Timing_check_limitContext::getRuleIndex() const {
  return SV3_1aParser::RuleTiming_check_limit;
}

void SV3_1aParser::Timing_check_limitContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTiming_check_limit(this);
}

void SV3_1aParser::Timing_check_limitContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTiming_check_limit(this);
}

SV3_1aParser::Timing_check_limitContext* SV3_1aParser::timing_check_limit() {
  Timing_check_limitContext *_localctx = _tracker.createInstance<Timing_check_limitContext>(_ctx, getState());
  enterRule(_localctx, 1066, SV3_1aParser::RuleTiming_check_limit);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8230);
    mintypmax_expression();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Timing_check_eventContext ------------------------------------------------------------------

SV3_1aParser::Timing_check_eventContext::Timing_check_eventContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::Specify_terminal_descriptorContext* SV3_1aParser::Timing_check_eventContext::specify_terminal_descriptor() {
  return getRuleContext<SV3_1aParser::Specify_terminal_descriptorContext>(0);
}

SV3_1aParser::Timing_check_event_controlContext* SV3_1aParser::Timing_check_eventContext::timing_check_event_control() {
  return getRuleContext<SV3_1aParser::Timing_check_event_controlContext>(0);
}

tree::TerminalNode* SV3_1aParser::Timing_check_eventContext::COND_PRED_OP() {
  return getToken(SV3_1aParser::COND_PRED_OP, 0);
}

SV3_1aParser::Timing_check_conditionContext* SV3_1aParser::Timing_check_eventContext::timing_check_condition() {
  return getRuleContext<SV3_1aParser::Timing_check_conditionContext>(0);
}


size_t SV3_1aParser::Timing_check_eventContext::getRuleIndex() const {
  return SV3_1aParser::RuleTiming_check_event;
}

void SV3_1aParser::Timing_check_eventContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTiming_check_event(this);
}

void SV3_1aParser::Timing_check_eventContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTiming_check_event(this);
}

SV3_1aParser::Timing_check_eventContext* SV3_1aParser::timing_check_event() {
  Timing_check_eventContext *_localctx = _tracker.createInstance<Timing_check_eventContext>(_ctx, getState());
  enterRule(_localctx, 1068, SV3_1aParser::RuleTiming_check_event);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8233);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (((((_la - 333) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 333)) & 1027) != 0)) {
      setState(8232);
      timing_check_event_control();
    }
    setState(8235);
    specify_terminal_descriptor();
    setState(8238);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SV3_1aParser::COND_PRED_OP) {
      setState(8236);
      match(SV3_1aParser::COND_PRED_OP);
      setState(8237);
      timing_check_condition();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Controlled_timing_check_eventContext ------------------------------------------------------------------

SV3_1aParser::Controlled_timing_check_eventContext::Controlled_timing_check_eventContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::Timing_check_event_controlContext* SV3_1aParser::Controlled_timing_check_eventContext::timing_check_event_control() {
  return getRuleContext<SV3_1aParser::Timing_check_event_controlContext>(0);
}

SV3_1aParser::Specify_terminal_descriptorContext* SV3_1aParser::Controlled_timing_check_eventContext::specify_terminal_descriptor() {
  return getRuleContext<SV3_1aParser::Specify_terminal_descriptorContext>(0);
}

tree::TerminalNode* SV3_1aParser::Controlled_timing_check_eventContext::COND_PRED_OP() {
  return getToken(SV3_1aParser::COND_PRED_OP, 0);
}

SV3_1aParser::Timing_check_conditionContext* SV3_1aParser::Controlled_timing_check_eventContext::timing_check_condition() {
  return getRuleContext<SV3_1aParser::Timing_check_conditionContext>(0);
}


size_t SV3_1aParser::Controlled_timing_check_eventContext::getRuleIndex() const {
  return SV3_1aParser::RuleControlled_timing_check_event;
}

void SV3_1aParser::Controlled_timing_check_eventContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterControlled_timing_check_event(this);
}

void SV3_1aParser::Controlled_timing_check_eventContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitControlled_timing_check_event(this);
}

SV3_1aParser::Controlled_timing_check_eventContext* SV3_1aParser::controlled_timing_check_event() {
  Controlled_timing_check_eventContext *_localctx = _tracker.createInstance<Controlled_timing_check_eventContext>(_ctx, getState());
  enterRule(_localctx, 1070, SV3_1aParser::RuleControlled_timing_check_event);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8240);
    timing_check_event_control();
    setState(8241);
    specify_terminal_descriptor();
    setState(8244);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SV3_1aParser::COND_PRED_OP) {
      setState(8242);
      match(SV3_1aParser::COND_PRED_OP);
      setState(8243);
      timing_check_condition();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Timing_check_event_controlContext ------------------------------------------------------------------

SV3_1aParser::Timing_check_event_controlContext::Timing_check_event_controlContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t SV3_1aParser::Timing_check_event_controlContext::getRuleIndex() const {
  return SV3_1aParser::RuleTiming_check_event_control;
}

void SV3_1aParser::Timing_check_event_controlContext::copyFrom(Timing_check_event_controlContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- TimingCheckEventControl_NegedgeContext ------------------------------------------------------------------

tree::TerminalNode* SV3_1aParser::TimingCheckEventControl_NegedgeContext::NEGEDGE() {
  return getToken(SV3_1aParser::NEGEDGE, 0);
}

SV3_1aParser::TimingCheckEventControl_NegedgeContext::TimingCheckEventControl_NegedgeContext(Timing_check_event_controlContext *ctx) { copyFrom(ctx); }

void SV3_1aParser::TimingCheckEventControl_NegedgeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTimingCheckEventControl_Negedge(this);
}
void SV3_1aParser::TimingCheckEventControl_NegedgeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTimingCheckEventControl_Negedge(this);
}
//----------------- TimingCheckEventControl_PosedgeContext ------------------------------------------------------------------

tree::TerminalNode* SV3_1aParser::TimingCheckEventControl_PosedgeContext::POSEDGE() {
  return getToken(SV3_1aParser::POSEDGE, 0);
}

SV3_1aParser::TimingCheckEventControl_PosedgeContext::TimingCheckEventControl_PosedgeContext(Timing_check_event_controlContext *ctx) { copyFrom(ctx); }

void SV3_1aParser::TimingCheckEventControl_PosedgeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTimingCheckEventControl_Posedge(this);
}
void SV3_1aParser::TimingCheckEventControl_PosedgeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTimingCheckEventControl_Posedge(this);
}
//----------------- TimingCheckEventControl_EdgeContext ------------------------------------------------------------------

SV3_1aParser::Edge_control_specifierContext* SV3_1aParser::TimingCheckEventControl_EdgeContext::edge_control_specifier() {
  return getRuleContext<SV3_1aParser::Edge_control_specifierContext>(0);
}

SV3_1aParser::TimingCheckEventControl_EdgeContext::TimingCheckEventControl_EdgeContext(Timing_check_event_controlContext *ctx) { copyFrom(ctx); }

void SV3_1aParser::TimingCheckEventControl_EdgeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTimingCheckEventControl_Edge(this);
}
void SV3_1aParser::TimingCheckEventControl_EdgeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTimingCheckEventControl_Edge(this);
}
SV3_1aParser::Timing_check_event_controlContext* SV3_1aParser::timing_check_event_control() {
  Timing_check_event_controlContext *_localctx = _tracker.createInstance<Timing_check_event_controlContext>(_ctx, getState());
  enterRule(_localctx, 1072, SV3_1aParser::RuleTiming_check_event_control);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(8249);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SV3_1aParser::POSEDGE: {
        _localctx = _tracker.createInstance<SV3_1aParser::TimingCheckEventControl_PosedgeContext>(_localctx);
        enterOuterAlt(_localctx, 1);
        setState(8246);
        match(SV3_1aParser::POSEDGE);
        break;
      }

      case SV3_1aParser::NEGEDGE: {
        _localctx = _tracker.createInstance<SV3_1aParser::TimingCheckEventControl_NegedgeContext>(_localctx);
        enterOuterAlt(_localctx, 2);
        setState(8247);
        match(SV3_1aParser::NEGEDGE);
        break;
      }

      case SV3_1aParser::EDGE: {
        _localctx = _tracker.createInstance<SV3_1aParser::TimingCheckEventControl_EdgeContext>(_localctx);
        enterOuterAlt(_localctx, 3);
        setState(8248);
        edge_control_specifier();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Specify_terminal_descriptorContext ------------------------------------------------------------------

SV3_1aParser::Specify_terminal_descriptorContext::Specify_terminal_descriptorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::Specify_input_terminal_descriptorContext* SV3_1aParser::Specify_terminal_descriptorContext::specify_input_terminal_descriptor() {
  return getRuleContext<SV3_1aParser::Specify_input_terminal_descriptorContext>(0);
}

SV3_1aParser::Specify_output_terminal_descriptorContext* SV3_1aParser::Specify_terminal_descriptorContext::specify_output_terminal_descriptor() {
  return getRuleContext<SV3_1aParser::Specify_output_terminal_descriptorContext>(0);
}


size_t SV3_1aParser::Specify_terminal_descriptorContext::getRuleIndex() const {
  return SV3_1aParser::RuleSpecify_terminal_descriptor;
}

void SV3_1aParser::Specify_terminal_descriptorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSpecify_terminal_descriptor(this);
}

void SV3_1aParser::Specify_terminal_descriptorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSpecify_terminal_descriptor(this);
}

SV3_1aParser::Specify_terminal_descriptorContext* SV3_1aParser::specify_terminal_descriptor() {
  Specify_terminal_descriptorContext *_localctx = _tracker.createInstance<Specify_terminal_descriptorContext>(_ctx, getState());
  enterRule(_localctx, 1074, SV3_1aParser::RuleSpecify_terminal_descriptor);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(8253);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 972, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(8251);
      specify_input_terminal_descriptor();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(8252);
      specify_output_terminal_descriptor();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Edge_control_specifierContext ------------------------------------------------------------------

SV3_1aParser::Edge_control_specifierContext::Edge_control_specifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Edge_control_specifierContext::EDGE() {
  return getToken(SV3_1aParser::EDGE, 0);
}

tree::TerminalNode* SV3_1aParser::Edge_control_specifierContext::OPEN_BRACKET() {
  return getToken(SV3_1aParser::OPEN_BRACKET, 0);
}

std::vector<SV3_1aParser::Edge_descriptorContext *> SV3_1aParser::Edge_control_specifierContext::edge_descriptor() {
  return getRuleContexts<SV3_1aParser::Edge_descriptorContext>();
}

SV3_1aParser::Edge_descriptorContext* SV3_1aParser::Edge_control_specifierContext::edge_descriptor(size_t i) {
  return getRuleContext<SV3_1aParser::Edge_descriptorContext>(i);
}

tree::TerminalNode* SV3_1aParser::Edge_control_specifierContext::CLOSE_BRACKET() {
  return getToken(SV3_1aParser::CLOSE_BRACKET, 0);
}

std::vector<tree::TerminalNode *> SV3_1aParser::Edge_control_specifierContext::COMMA() {
  return getTokens(SV3_1aParser::COMMA);
}

tree::TerminalNode* SV3_1aParser::Edge_control_specifierContext::COMMA(size_t i) {
  return getToken(SV3_1aParser::COMMA, i);
}


size_t SV3_1aParser::Edge_control_specifierContext::getRuleIndex() const {
  return SV3_1aParser::RuleEdge_control_specifier;
}

void SV3_1aParser::Edge_control_specifierContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterEdge_control_specifier(this);
}

void SV3_1aParser::Edge_control_specifierContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitEdge_control_specifier(this);
}

SV3_1aParser::Edge_control_specifierContext* SV3_1aParser::edge_control_specifier() {
  Edge_control_specifierContext *_localctx = _tracker.createInstance<Edge_control_specifierContext>(_ctx, getState());
  enterRule(_localctx, 1076, SV3_1aParser::RuleEdge_control_specifier);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8255);
    match(SV3_1aParser::EDGE);
    setState(8256);
    match(SV3_1aParser::OPEN_BRACKET);
    setState(8257);
    edge_descriptor();
    setState(8262);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == SV3_1aParser::COMMA) {
      setState(8258);
      match(SV3_1aParser::COMMA);
      setState(8259);
      edge_descriptor();
      setState(8264);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(8265);
    match(SV3_1aParser::CLOSE_BRACKET);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Edge_descriptorContext ------------------------------------------------------------------

SV3_1aParser::Edge_descriptorContext::Edge_descriptorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Edge_descriptorContext::Integral_number() {
  return getToken(SV3_1aParser::Integral_number, 0);
}

tree::TerminalNode* SV3_1aParser::Edge_descriptorContext::Simple_identifier() {
  return getToken(SV3_1aParser::Simple_identifier, 0);
}


size_t SV3_1aParser::Edge_descriptorContext::getRuleIndex() const {
  return SV3_1aParser::RuleEdge_descriptor;
}

void SV3_1aParser::Edge_descriptorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterEdge_descriptor(this);
}

void SV3_1aParser::Edge_descriptorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitEdge_descriptor(this);
}

SV3_1aParser::Edge_descriptorContext* SV3_1aParser::edge_descriptor() {
  Edge_descriptorContext *_localctx = _tracker.createInstance<Edge_descriptorContext>(_ctx, getState());
  enterRule(_localctx, 1078, SV3_1aParser::RuleEdge_descriptor);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(8272);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 974, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(8267);
      match(SV3_1aParser::Integral_number);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(8268);
      match(SV3_1aParser::Simple_identifier);
      setState(8269);
      match(SV3_1aParser::Integral_number);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(8270);
      match(SV3_1aParser::Integral_number);
      setState(8271);
      match(SV3_1aParser::Simple_identifier);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Timing_check_conditionContext ------------------------------------------------------------------

SV3_1aParser::Timing_check_conditionContext::Timing_check_conditionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::Scalar_timing_check_conditionContext* SV3_1aParser::Timing_check_conditionContext::scalar_timing_check_condition() {
  return getRuleContext<SV3_1aParser::Scalar_timing_check_conditionContext>(0);
}

tree::TerminalNode* SV3_1aParser::Timing_check_conditionContext::OPEN_PARENS() {
  return getToken(SV3_1aParser::OPEN_PARENS, 0);
}

tree::TerminalNode* SV3_1aParser::Timing_check_conditionContext::CLOSE_PARENS() {
  return getToken(SV3_1aParser::CLOSE_PARENS, 0);
}


size_t SV3_1aParser::Timing_check_conditionContext::getRuleIndex() const {
  return SV3_1aParser::RuleTiming_check_condition;
}

void SV3_1aParser::Timing_check_conditionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTiming_check_condition(this);
}

void SV3_1aParser::Timing_check_conditionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTiming_check_condition(this);
}

SV3_1aParser::Timing_check_conditionContext* SV3_1aParser::timing_check_condition() {
  Timing_check_conditionContext *_localctx = _tracker.createInstance<Timing_check_conditionContext>(_ctx, getState());
  enterRule(_localctx, 1080, SV3_1aParser::RuleTiming_check_condition);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(8279);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 975, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(8274);
      scalar_timing_check_condition();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(8275);
      match(SV3_1aParser::OPEN_PARENS);
      setState(8276);
      scalar_timing_check_condition();
      setState(8277);
      match(SV3_1aParser::CLOSE_PARENS);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Scalar_timing_check_conditionContext ------------------------------------------------------------------

SV3_1aParser::Scalar_timing_check_conditionContext::Scalar_timing_check_conditionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::ExpressionContext* SV3_1aParser::Scalar_timing_check_conditionContext::expression() {
  return getRuleContext<SV3_1aParser::ExpressionContext>(0);
}

tree::TerminalNode* SV3_1aParser::Scalar_timing_check_conditionContext::TILDA() {
  return getToken(SV3_1aParser::TILDA, 0);
}

tree::TerminalNode* SV3_1aParser::Scalar_timing_check_conditionContext::EQUIV() {
  return getToken(SV3_1aParser::EQUIV, 0);
}

SV3_1aParser::Scalar_constantContext* SV3_1aParser::Scalar_timing_check_conditionContext::scalar_constant() {
  return getRuleContext<SV3_1aParser::Scalar_constantContext>(0);
}

tree::TerminalNode* SV3_1aParser::Scalar_timing_check_conditionContext::FOUR_STATE_LOGIC_EQUAL() {
  return getToken(SV3_1aParser::FOUR_STATE_LOGIC_EQUAL, 0);
}

tree::TerminalNode* SV3_1aParser::Scalar_timing_check_conditionContext::NOTEQUAL() {
  return getToken(SV3_1aParser::NOTEQUAL, 0);
}

tree::TerminalNode* SV3_1aParser::Scalar_timing_check_conditionContext::FOUR_STATE_LOGIC_NOTEQUAL() {
  return getToken(SV3_1aParser::FOUR_STATE_LOGIC_NOTEQUAL, 0);
}


size_t SV3_1aParser::Scalar_timing_check_conditionContext::getRuleIndex() const {
  return SV3_1aParser::RuleScalar_timing_check_condition;
}

void SV3_1aParser::Scalar_timing_check_conditionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterScalar_timing_check_condition(this);
}

void SV3_1aParser::Scalar_timing_check_conditionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitScalar_timing_check_condition(this);
}

SV3_1aParser::Scalar_timing_check_conditionContext* SV3_1aParser::scalar_timing_check_condition() {
  Scalar_timing_check_conditionContext *_localctx = _tracker.createInstance<Scalar_timing_check_conditionContext>(_ctx, getState());
  enterRule(_localctx, 1082, SV3_1aParser::RuleScalar_timing_check_condition);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(8300);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 976, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(8281);
      expression(0);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(8282);
      match(SV3_1aParser::TILDA);
      setState(8283);
      expression(0);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(8284);
      expression(0);
      setState(8285);
      match(SV3_1aParser::EQUIV);
      setState(8286);
      scalar_constant();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(8288);
      expression(0);
      setState(8289);
      match(SV3_1aParser::FOUR_STATE_LOGIC_EQUAL);
      setState(8290);
      scalar_constant();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(8292);
      expression(0);
      setState(8293);
      match(SV3_1aParser::NOTEQUAL);
      setState(8294);
      scalar_constant();
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(8296);
      expression(0);
      setState(8297);
      match(SV3_1aParser::FOUR_STATE_LOGIC_NOTEQUAL);
      setState(8298);
      scalar_constant();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Scalar_constantContext ------------------------------------------------------------------

SV3_1aParser::Scalar_constantContext::Scalar_constantContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t SV3_1aParser::Scalar_constantContext::getRuleIndex() const {
  return SV3_1aParser::RuleScalar_constant;
}

void SV3_1aParser::Scalar_constantContext::copyFrom(Scalar_constantContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- Scalar_1Tickb1Context ------------------------------------------------------------------

tree::TerminalNode* SV3_1aParser::Scalar_1Tickb1Context::ONE_TICK_b1() {
  return getToken(SV3_1aParser::ONE_TICK_b1, 0);
}

SV3_1aParser::Scalar_1Tickb1Context::Scalar_1Tickb1Context(Scalar_constantContext *ctx) { copyFrom(ctx); }

void SV3_1aParser::Scalar_1Tickb1Context::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterScalar_1Tickb1(this);
}
void SV3_1aParser::Scalar_1Tickb1Context::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitScalar_1Tickb1(this);
}
//----------------- Scalar_1TickB1Context ------------------------------------------------------------------

tree::TerminalNode* SV3_1aParser::Scalar_1TickB1Context::ONE_TICK_B1() {
  return getToken(SV3_1aParser::ONE_TICK_B1, 0);
}

SV3_1aParser::Scalar_1TickB1Context::Scalar_1TickB1Context(Scalar_constantContext *ctx) { copyFrom(ctx); }

void SV3_1aParser::Scalar_1TickB1Context::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterScalar_1TickB1(this);
}
void SV3_1aParser::Scalar_1TickB1Context::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitScalar_1TickB1(this);
}
//----------------- Scalar_1Tickb0Context ------------------------------------------------------------------

tree::TerminalNode* SV3_1aParser::Scalar_1Tickb0Context::ONE_TICK_b0() {
  return getToken(SV3_1aParser::ONE_TICK_b0, 0);
}

SV3_1aParser::Scalar_1Tickb0Context::Scalar_1Tickb0Context(Scalar_constantContext *ctx) { copyFrom(ctx); }

void SV3_1aParser::Scalar_1Tickb0Context::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterScalar_1Tickb0(this);
}
void SV3_1aParser::Scalar_1Tickb0Context::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitScalar_1Tickb0(this);
}
//----------------- Scalar_1TickB0Context ------------------------------------------------------------------

tree::TerminalNode* SV3_1aParser::Scalar_1TickB0Context::ONE_TICK_B0() {
  return getToken(SV3_1aParser::ONE_TICK_B0, 0);
}

SV3_1aParser::Scalar_1TickB0Context::Scalar_1TickB0Context(Scalar_constantContext *ctx) { copyFrom(ctx); }

void SV3_1aParser::Scalar_1TickB0Context::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterScalar_1TickB0(this);
}
void SV3_1aParser::Scalar_1TickB0Context::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitScalar_1TickB0(this);
}
//----------------- Scalar_IntegralContext ------------------------------------------------------------------

tree::TerminalNode* SV3_1aParser::Scalar_IntegralContext::Integral_number() {
  return getToken(SV3_1aParser::Integral_number, 0);
}

SV3_1aParser::Scalar_IntegralContext::Scalar_IntegralContext(Scalar_constantContext *ctx) { copyFrom(ctx); }

void SV3_1aParser::Scalar_IntegralContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterScalar_Integral(this);
}
void SV3_1aParser::Scalar_IntegralContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitScalar_Integral(this);
}
//----------------- Scalar_Tickb0Context ------------------------------------------------------------------

tree::TerminalNode* SV3_1aParser::Scalar_Tickb0Context::TICK_b0() {
  return getToken(SV3_1aParser::TICK_b0, 0);
}

SV3_1aParser::Scalar_Tickb0Context::Scalar_Tickb0Context(Scalar_constantContext *ctx) { copyFrom(ctx); }

void SV3_1aParser::Scalar_Tickb0Context::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterScalar_Tickb0(this);
}
void SV3_1aParser::Scalar_Tickb0Context::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitScalar_Tickb0(this);
}
//----------------- Scalar_TickB0Context ------------------------------------------------------------------

tree::TerminalNode* SV3_1aParser::Scalar_TickB0Context::TICK_B0() {
  return getToken(SV3_1aParser::TICK_B0, 0);
}

SV3_1aParser::Scalar_TickB0Context::Scalar_TickB0Context(Scalar_constantContext *ctx) { copyFrom(ctx); }

void SV3_1aParser::Scalar_TickB0Context::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterScalar_TickB0(this);
}
void SV3_1aParser::Scalar_TickB0Context::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitScalar_TickB0(this);
}
//----------------- Scalar_Tickb1Context ------------------------------------------------------------------

tree::TerminalNode* SV3_1aParser::Scalar_Tickb1Context::TICK_b1() {
  return getToken(SV3_1aParser::TICK_b1, 0);
}

SV3_1aParser::Scalar_Tickb1Context::Scalar_Tickb1Context(Scalar_constantContext *ctx) { copyFrom(ctx); }

void SV3_1aParser::Scalar_Tickb1Context::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterScalar_Tickb1(this);
}
void SV3_1aParser::Scalar_Tickb1Context::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitScalar_Tickb1(this);
}
//----------------- Scalar_TickB1Context ------------------------------------------------------------------

tree::TerminalNode* SV3_1aParser::Scalar_TickB1Context::TICK_B1() {
  return getToken(SV3_1aParser::TICK_B1, 0);
}

SV3_1aParser::Scalar_TickB1Context::Scalar_TickB1Context(Scalar_constantContext *ctx) { copyFrom(ctx); }

void SV3_1aParser::Scalar_TickB1Context::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterScalar_TickB1(this);
}
void SV3_1aParser::Scalar_TickB1Context::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitScalar_TickB1(this);
}
SV3_1aParser::Scalar_constantContext* SV3_1aParser::scalar_constant() {
  Scalar_constantContext *_localctx = _tracker.createInstance<Scalar_constantContext>(_ctx, getState());
  enterRule(_localctx, 1084, SV3_1aParser::RuleScalar_constant);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(8311);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SV3_1aParser::ONE_TICK_b0: {
        _localctx = _tracker.createInstance<SV3_1aParser::Scalar_1Tickb0Context>(_localctx);
        enterOuterAlt(_localctx, 1);
        setState(8302);
        match(SV3_1aParser::ONE_TICK_b0);
        break;
      }

      case SV3_1aParser::ONE_TICK_b1: {
        _localctx = _tracker.createInstance<SV3_1aParser::Scalar_1Tickb1Context>(_localctx);
        enterOuterAlt(_localctx, 2);
        setState(8303);
        match(SV3_1aParser::ONE_TICK_b1);
        break;
      }

      case SV3_1aParser::ONE_TICK_B0: {
        _localctx = _tracker.createInstance<SV3_1aParser::Scalar_1TickB0Context>(_localctx);
        enterOuterAlt(_localctx, 3);
        setState(8304);
        match(SV3_1aParser::ONE_TICK_B0);
        break;
      }

      case SV3_1aParser::ONE_TICK_B1: {
        _localctx = _tracker.createInstance<SV3_1aParser::Scalar_1TickB1Context>(_localctx);
        enterOuterAlt(_localctx, 4);
        setState(8305);
        match(SV3_1aParser::ONE_TICK_B1);
        break;
      }

      case SV3_1aParser::TICK_b0: {
        _localctx = _tracker.createInstance<SV3_1aParser::Scalar_Tickb0Context>(_localctx);
        enterOuterAlt(_localctx, 5);
        setState(8306);
        match(SV3_1aParser::TICK_b0);
        break;
      }

      case SV3_1aParser::TICK_b1: {
        _localctx = _tracker.createInstance<SV3_1aParser::Scalar_Tickb1Context>(_localctx);
        enterOuterAlt(_localctx, 6);
        setState(8307);
        match(SV3_1aParser::TICK_b1);
        break;
      }

      case SV3_1aParser::TICK_B0: {
        _localctx = _tracker.createInstance<SV3_1aParser::Scalar_TickB0Context>(_localctx);
        enterOuterAlt(_localctx, 7);
        setState(8308);
        match(SV3_1aParser::TICK_B0);
        break;
      }

      case SV3_1aParser::TICK_B1: {
        _localctx = _tracker.createInstance<SV3_1aParser::Scalar_TickB1Context>(_localctx);
        enterOuterAlt(_localctx, 8);
        setState(8309);
        match(SV3_1aParser::TICK_B1);
        break;
      }

      case SV3_1aParser::Integral_number: {
        _localctx = _tracker.createInstance<SV3_1aParser::Scalar_IntegralContext>(_localctx);
        enterOuterAlt(_localctx, 9);
        setState(8310);
        match(SV3_1aParser::Integral_number);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ConcatenationContext ------------------------------------------------------------------

SV3_1aParser::ConcatenationContext::ConcatenationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::ConcatenationContext::OPEN_CURLY() {
  return getToken(SV3_1aParser::OPEN_CURLY, 0);
}

std::vector<SV3_1aParser::ExpressionContext *> SV3_1aParser::ConcatenationContext::expression() {
  return getRuleContexts<SV3_1aParser::ExpressionContext>();
}

SV3_1aParser::ExpressionContext* SV3_1aParser::ConcatenationContext::expression(size_t i) {
  return getRuleContext<SV3_1aParser::ExpressionContext>(i);
}

tree::TerminalNode* SV3_1aParser::ConcatenationContext::CLOSE_CURLY() {
  return getToken(SV3_1aParser::CLOSE_CURLY, 0);
}

std::vector<tree::TerminalNode *> SV3_1aParser::ConcatenationContext::COMMA() {
  return getTokens(SV3_1aParser::COMMA);
}

tree::TerminalNode* SV3_1aParser::ConcatenationContext::COMMA(size_t i) {
  return getToken(SV3_1aParser::COMMA, i);
}

std::vector<SV3_1aParser::Array_member_labelContext *> SV3_1aParser::ConcatenationContext::array_member_label() {
  return getRuleContexts<SV3_1aParser::Array_member_labelContext>();
}

SV3_1aParser::Array_member_labelContext* SV3_1aParser::ConcatenationContext::array_member_label(size_t i) {
  return getRuleContext<SV3_1aParser::Array_member_labelContext>(i);
}

std::vector<tree::TerminalNode *> SV3_1aParser::ConcatenationContext::COLON() {
  return getTokens(SV3_1aParser::COLON);
}

tree::TerminalNode* SV3_1aParser::ConcatenationContext::COLON(size_t i) {
  return getToken(SV3_1aParser::COLON, i);
}


size_t SV3_1aParser::ConcatenationContext::getRuleIndex() const {
  return SV3_1aParser::RuleConcatenation;
}

void SV3_1aParser::ConcatenationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterConcatenation(this);
}

void SV3_1aParser::ConcatenationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitConcatenation(this);
}

SV3_1aParser::ConcatenationContext* SV3_1aParser::concatenation() {
  ConcatenationContext *_localctx = _tracker.createInstance<ConcatenationContext>(_ctx, getState());
  enterRule(_localctx, 1086, SV3_1aParser::RuleConcatenation);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(8340);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 980, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(8313);
      match(SV3_1aParser::OPEN_CURLY);
      setState(8314);
      expression(0);
      setState(8319);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == SV3_1aParser::COMMA) {
        setState(8315);
        match(SV3_1aParser::COMMA);
        setState(8316);
        expression(0);
        setState(8321);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(8322);
      match(SV3_1aParser::CLOSE_CURLY);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(8324);
      match(SV3_1aParser::OPEN_CURLY);
      setState(8325);
      array_member_label();
      setState(8326);
      match(SV3_1aParser::COLON);
      setState(8327);
      expression(0);
      setState(8335);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == SV3_1aParser::COMMA) {
        setState(8328);
        match(SV3_1aParser::COMMA);
        setState(8329);
        array_member_label();
        setState(8330);
        match(SV3_1aParser::COLON);
        setState(8331);
        expression(0);
        setState(8337);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(8338);
      match(SV3_1aParser::CLOSE_CURLY);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Constant_concatenationContext ------------------------------------------------------------------

SV3_1aParser::Constant_concatenationContext::Constant_concatenationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Constant_concatenationContext::OPEN_CURLY() {
  return getToken(SV3_1aParser::OPEN_CURLY, 0);
}

std::vector<SV3_1aParser::Constant_expressionContext *> SV3_1aParser::Constant_concatenationContext::constant_expression() {
  return getRuleContexts<SV3_1aParser::Constant_expressionContext>();
}

SV3_1aParser::Constant_expressionContext* SV3_1aParser::Constant_concatenationContext::constant_expression(size_t i) {
  return getRuleContext<SV3_1aParser::Constant_expressionContext>(i);
}

tree::TerminalNode* SV3_1aParser::Constant_concatenationContext::CLOSE_CURLY() {
  return getToken(SV3_1aParser::CLOSE_CURLY, 0);
}

std::vector<tree::TerminalNode *> SV3_1aParser::Constant_concatenationContext::COMMA() {
  return getTokens(SV3_1aParser::COMMA);
}

tree::TerminalNode* SV3_1aParser::Constant_concatenationContext::COMMA(size_t i) {
  return getToken(SV3_1aParser::COMMA, i);
}

std::vector<SV3_1aParser::Array_member_labelContext *> SV3_1aParser::Constant_concatenationContext::array_member_label() {
  return getRuleContexts<SV3_1aParser::Array_member_labelContext>();
}

SV3_1aParser::Array_member_labelContext* SV3_1aParser::Constant_concatenationContext::array_member_label(size_t i) {
  return getRuleContext<SV3_1aParser::Array_member_labelContext>(i);
}

std::vector<tree::TerminalNode *> SV3_1aParser::Constant_concatenationContext::COLON() {
  return getTokens(SV3_1aParser::COLON);
}

tree::TerminalNode* SV3_1aParser::Constant_concatenationContext::COLON(size_t i) {
  return getToken(SV3_1aParser::COLON, i);
}


size_t SV3_1aParser::Constant_concatenationContext::getRuleIndex() const {
  return SV3_1aParser::RuleConstant_concatenation;
}

void SV3_1aParser::Constant_concatenationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterConstant_concatenation(this);
}

void SV3_1aParser::Constant_concatenationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitConstant_concatenation(this);
}

SV3_1aParser::Constant_concatenationContext* SV3_1aParser::constant_concatenation() {
  Constant_concatenationContext *_localctx = _tracker.createInstance<Constant_concatenationContext>(_ctx, getState());
  enterRule(_localctx, 1088, SV3_1aParser::RuleConstant_concatenation);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(8369);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 983, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(8342);
      match(SV3_1aParser::OPEN_CURLY);
      setState(8343);
      constant_expression(0);
      setState(8348);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == SV3_1aParser::COMMA) {
        setState(8344);
        match(SV3_1aParser::COMMA);
        setState(8345);
        constant_expression(0);
        setState(8350);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(8351);
      match(SV3_1aParser::CLOSE_CURLY);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(8353);
      match(SV3_1aParser::OPEN_CURLY);
      setState(8354);
      array_member_label();
      setState(8355);
      match(SV3_1aParser::COLON);
      setState(8356);
      constant_expression(0);
      setState(8364);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == SV3_1aParser::COMMA) {
        setState(8357);
        match(SV3_1aParser::COMMA);
        setState(8358);
        array_member_label();
        setState(8359);
        match(SV3_1aParser::COLON);
        setState(8360);
        constant_expression(0);
        setState(8366);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(8367);
      match(SV3_1aParser::CLOSE_CURLY);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Array_member_labelContext ------------------------------------------------------------------

SV3_1aParser::Array_member_labelContext::Array_member_labelContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Array_member_labelContext::DEFAULT() {
  return getToken(SV3_1aParser::DEFAULT, 0);
}

SV3_1aParser::IdentifierContext* SV3_1aParser::Array_member_labelContext::identifier() {
  return getRuleContext<SV3_1aParser::IdentifierContext>(0);
}

SV3_1aParser::Constant_expressionContext* SV3_1aParser::Array_member_labelContext::constant_expression() {
  return getRuleContext<SV3_1aParser::Constant_expressionContext>(0);
}


size_t SV3_1aParser::Array_member_labelContext::getRuleIndex() const {
  return SV3_1aParser::RuleArray_member_label;
}

void SV3_1aParser::Array_member_labelContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterArray_member_label(this);
}

void SV3_1aParser::Array_member_labelContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitArray_member_label(this);
}

SV3_1aParser::Array_member_labelContext* SV3_1aParser::array_member_label() {
  Array_member_labelContext *_localctx = _tracker.createInstance<Array_member_labelContext>(_ctx, getState());
  enterRule(_localctx, 1090, SV3_1aParser::RuleArray_member_label);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(8374);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 984, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(8371);
      match(SV3_1aParser::DEFAULT);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(8372);
      identifier();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(8373);
      constant_expression(0);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Constant_multiple_concatenationContext ------------------------------------------------------------------

SV3_1aParser::Constant_multiple_concatenationContext::Constant_multiple_concatenationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Constant_multiple_concatenationContext::OPEN_CURLY() {
  return getToken(SV3_1aParser::OPEN_CURLY, 0);
}

SV3_1aParser::Constant_expressionContext* SV3_1aParser::Constant_multiple_concatenationContext::constant_expression() {
  return getRuleContext<SV3_1aParser::Constant_expressionContext>(0);
}

SV3_1aParser::Constant_concatenationContext* SV3_1aParser::Constant_multiple_concatenationContext::constant_concatenation() {
  return getRuleContext<SV3_1aParser::Constant_concatenationContext>(0);
}

tree::TerminalNode* SV3_1aParser::Constant_multiple_concatenationContext::CLOSE_CURLY() {
  return getToken(SV3_1aParser::CLOSE_CURLY, 0);
}


size_t SV3_1aParser::Constant_multiple_concatenationContext::getRuleIndex() const {
  return SV3_1aParser::RuleConstant_multiple_concatenation;
}

void SV3_1aParser::Constant_multiple_concatenationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterConstant_multiple_concatenation(this);
}

void SV3_1aParser::Constant_multiple_concatenationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitConstant_multiple_concatenation(this);
}

SV3_1aParser::Constant_multiple_concatenationContext* SV3_1aParser::constant_multiple_concatenation() {
  Constant_multiple_concatenationContext *_localctx = _tracker.createInstance<Constant_multiple_concatenationContext>(_ctx, getState());
  enterRule(_localctx, 1092, SV3_1aParser::RuleConstant_multiple_concatenation);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8376);
    match(SV3_1aParser::OPEN_CURLY);
    setState(8377);
    constant_expression(0);
    setState(8378);
    constant_concatenation();
    setState(8379);
    match(SV3_1aParser::CLOSE_CURLY);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Module_path_concatenationContext ------------------------------------------------------------------

SV3_1aParser::Module_path_concatenationContext::Module_path_concatenationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Module_path_concatenationContext::OPEN_CURLY() {
  return getToken(SV3_1aParser::OPEN_CURLY, 0);
}

std::vector<SV3_1aParser::Module_path_expressionContext *> SV3_1aParser::Module_path_concatenationContext::module_path_expression() {
  return getRuleContexts<SV3_1aParser::Module_path_expressionContext>();
}

SV3_1aParser::Module_path_expressionContext* SV3_1aParser::Module_path_concatenationContext::module_path_expression(size_t i) {
  return getRuleContext<SV3_1aParser::Module_path_expressionContext>(i);
}

tree::TerminalNode* SV3_1aParser::Module_path_concatenationContext::CLOSE_CURLY() {
  return getToken(SV3_1aParser::CLOSE_CURLY, 0);
}

std::vector<tree::TerminalNode *> SV3_1aParser::Module_path_concatenationContext::COMMA() {
  return getTokens(SV3_1aParser::COMMA);
}

tree::TerminalNode* SV3_1aParser::Module_path_concatenationContext::COMMA(size_t i) {
  return getToken(SV3_1aParser::COMMA, i);
}


size_t SV3_1aParser::Module_path_concatenationContext::getRuleIndex() const {
  return SV3_1aParser::RuleModule_path_concatenation;
}

void SV3_1aParser::Module_path_concatenationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterModule_path_concatenation(this);
}

void SV3_1aParser::Module_path_concatenationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitModule_path_concatenation(this);
}

SV3_1aParser::Module_path_concatenationContext* SV3_1aParser::module_path_concatenation() {
  Module_path_concatenationContext *_localctx = _tracker.createInstance<Module_path_concatenationContext>(_ctx, getState());
  enterRule(_localctx, 1094, SV3_1aParser::RuleModule_path_concatenation);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8381);
    match(SV3_1aParser::OPEN_CURLY);
    setState(8382);
    module_path_expression(0);
    setState(8387);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == SV3_1aParser::COMMA) {
      setState(8383);
      match(SV3_1aParser::COMMA);
      setState(8384);
      module_path_expression(0);
      setState(8389);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(8390);
    match(SV3_1aParser::CLOSE_CURLY);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Module_path_multiple_concatenationContext ------------------------------------------------------------------

SV3_1aParser::Module_path_multiple_concatenationContext::Module_path_multiple_concatenationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Module_path_multiple_concatenationContext::OPEN_CURLY() {
  return getToken(SV3_1aParser::OPEN_CURLY, 0);
}

SV3_1aParser::Constant_expressionContext* SV3_1aParser::Module_path_multiple_concatenationContext::constant_expression() {
  return getRuleContext<SV3_1aParser::Constant_expressionContext>(0);
}

SV3_1aParser::Module_path_concatenationContext* SV3_1aParser::Module_path_multiple_concatenationContext::module_path_concatenation() {
  return getRuleContext<SV3_1aParser::Module_path_concatenationContext>(0);
}

tree::TerminalNode* SV3_1aParser::Module_path_multiple_concatenationContext::CLOSE_CURLY() {
  return getToken(SV3_1aParser::CLOSE_CURLY, 0);
}


size_t SV3_1aParser::Module_path_multiple_concatenationContext::getRuleIndex() const {
  return SV3_1aParser::RuleModule_path_multiple_concatenation;
}

void SV3_1aParser::Module_path_multiple_concatenationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterModule_path_multiple_concatenation(this);
}

void SV3_1aParser::Module_path_multiple_concatenationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitModule_path_multiple_concatenation(this);
}

SV3_1aParser::Module_path_multiple_concatenationContext* SV3_1aParser::module_path_multiple_concatenation() {
  Module_path_multiple_concatenationContext *_localctx = _tracker.createInstance<Module_path_multiple_concatenationContext>(_ctx, getState());
  enterRule(_localctx, 1096, SV3_1aParser::RuleModule_path_multiple_concatenation);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8392);
    match(SV3_1aParser::OPEN_CURLY);
    setState(8393);
    constant_expression(0);
    setState(8394);
    module_path_concatenation();
    setState(8395);
    match(SV3_1aParser::CLOSE_CURLY);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Multiple_concatenationContext ------------------------------------------------------------------

SV3_1aParser::Multiple_concatenationContext::Multiple_concatenationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Multiple_concatenationContext::OPEN_CURLY() {
  return getToken(SV3_1aParser::OPEN_CURLY, 0);
}

SV3_1aParser::ExpressionContext* SV3_1aParser::Multiple_concatenationContext::expression() {
  return getRuleContext<SV3_1aParser::ExpressionContext>(0);
}

SV3_1aParser::ConcatenationContext* SV3_1aParser::Multiple_concatenationContext::concatenation() {
  return getRuleContext<SV3_1aParser::ConcatenationContext>(0);
}

tree::TerminalNode* SV3_1aParser::Multiple_concatenationContext::CLOSE_CURLY() {
  return getToken(SV3_1aParser::CLOSE_CURLY, 0);
}


size_t SV3_1aParser::Multiple_concatenationContext::getRuleIndex() const {
  return SV3_1aParser::RuleMultiple_concatenation;
}

void SV3_1aParser::Multiple_concatenationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterMultiple_concatenation(this);
}

void SV3_1aParser::Multiple_concatenationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitMultiple_concatenation(this);
}

SV3_1aParser::Multiple_concatenationContext* SV3_1aParser::multiple_concatenation() {
  Multiple_concatenationContext *_localctx = _tracker.createInstance<Multiple_concatenationContext>(_ctx, getState());
  enterRule(_localctx, 1098, SV3_1aParser::RuleMultiple_concatenation);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8397);
    match(SV3_1aParser::OPEN_CURLY);
    setState(8398);
    expression(0);
    setState(8399);
    concatenation();
    setState(8400);
    match(SV3_1aParser::CLOSE_CURLY);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Streaming_concatenationContext ------------------------------------------------------------------

SV3_1aParser::Streaming_concatenationContext::Streaming_concatenationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Streaming_concatenationContext::OPEN_CURLY() {
  return getToken(SV3_1aParser::OPEN_CURLY, 0);
}

SV3_1aParser::Stream_operatorContext* SV3_1aParser::Streaming_concatenationContext::stream_operator() {
  return getRuleContext<SV3_1aParser::Stream_operatorContext>(0);
}

SV3_1aParser::Stream_concatenationContext* SV3_1aParser::Streaming_concatenationContext::stream_concatenation() {
  return getRuleContext<SV3_1aParser::Stream_concatenationContext>(0);
}

tree::TerminalNode* SV3_1aParser::Streaming_concatenationContext::CLOSE_CURLY() {
  return getToken(SV3_1aParser::CLOSE_CURLY, 0);
}

SV3_1aParser::Slice_sizeContext* SV3_1aParser::Streaming_concatenationContext::slice_size() {
  return getRuleContext<SV3_1aParser::Slice_sizeContext>(0);
}


size_t SV3_1aParser::Streaming_concatenationContext::getRuleIndex() const {
  return SV3_1aParser::RuleStreaming_concatenation;
}

void SV3_1aParser::Streaming_concatenationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterStreaming_concatenation(this);
}

void SV3_1aParser::Streaming_concatenationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitStreaming_concatenation(this);
}

SV3_1aParser::Streaming_concatenationContext* SV3_1aParser::streaming_concatenation() {
  Streaming_concatenationContext *_localctx = _tracker.createInstance<Streaming_concatenationContext>(_ctx, getState());
  enterRule(_localctx, 1100, SV3_1aParser::RuleStreaming_concatenation);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8402);
    match(SV3_1aParser::OPEN_CURLY);
    setState(8403);
    stream_operator();
    setState(8405);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 986, _ctx)) {
    case 1: {
      setState(8404);
      slice_size();
      break;
    }

    default:
      break;
    }
    setState(8407);
    stream_concatenation();
    setState(8408);
    match(SV3_1aParser::CLOSE_CURLY);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Stream_operatorContext ------------------------------------------------------------------

SV3_1aParser::Stream_operatorContext::Stream_operatorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Stream_operatorContext::SHIFT_RIGHT() {
  return getToken(SV3_1aParser::SHIFT_RIGHT, 0);
}

tree::TerminalNode* SV3_1aParser::Stream_operatorContext::SHIFT_LEFT() {
  return getToken(SV3_1aParser::SHIFT_LEFT, 0);
}


size_t SV3_1aParser::Stream_operatorContext::getRuleIndex() const {
  return SV3_1aParser::RuleStream_operator;
}

void SV3_1aParser::Stream_operatorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterStream_operator(this);
}

void SV3_1aParser::Stream_operatorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitStream_operator(this);
}

SV3_1aParser::Stream_operatorContext* SV3_1aParser::stream_operator() {
  Stream_operatorContext *_localctx = _tracker.createInstance<Stream_operatorContext>(_ctx, getState());
  enterRule(_localctx, 1102, SV3_1aParser::RuleStream_operator);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8410);
    _la = _input->LA(1);
    if (!(_la == SV3_1aParser::SHIFT_RIGHT

    || _la == SV3_1aParser::SHIFT_LEFT)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Slice_sizeContext ------------------------------------------------------------------

SV3_1aParser::Slice_sizeContext::Slice_sizeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::Simple_typeContext* SV3_1aParser::Slice_sizeContext::simple_type() {
  return getRuleContext<SV3_1aParser::Simple_typeContext>(0);
}

SV3_1aParser::Constant_expressionContext* SV3_1aParser::Slice_sizeContext::constant_expression() {
  return getRuleContext<SV3_1aParser::Constant_expressionContext>(0);
}


size_t SV3_1aParser::Slice_sizeContext::getRuleIndex() const {
  return SV3_1aParser::RuleSlice_size;
}

void SV3_1aParser::Slice_sizeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSlice_size(this);
}

void SV3_1aParser::Slice_sizeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSlice_size(this);
}

SV3_1aParser::Slice_sizeContext* SV3_1aParser::slice_size() {
  Slice_sizeContext *_localctx = _tracker.createInstance<Slice_sizeContext>(_ctx, getState());
  enterRule(_localctx, 1104, SV3_1aParser::RuleSlice_size);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(8414);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 987, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(8412);
      simple_type();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(8413);
      constant_expression(0);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Stream_concatenationContext ------------------------------------------------------------------

SV3_1aParser::Stream_concatenationContext::Stream_concatenationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Stream_concatenationContext::OPEN_CURLY() {
  return getToken(SV3_1aParser::OPEN_CURLY, 0);
}

std::vector<SV3_1aParser::Stream_expressionContext *> SV3_1aParser::Stream_concatenationContext::stream_expression() {
  return getRuleContexts<SV3_1aParser::Stream_expressionContext>();
}

SV3_1aParser::Stream_expressionContext* SV3_1aParser::Stream_concatenationContext::stream_expression(size_t i) {
  return getRuleContext<SV3_1aParser::Stream_expressionContext>(i);
}

tree::TerminalNode* SV3_1aParser::Stream_concatenationContext::CLOSE_CURLY() {
  return getToken(SV3_1aParser::CLOSE_CURLY, 0);
}

std::vector<tree::TerminalNode *> SV3_1aParser::Stream_concatenationContext::COMMA() {
  return getTokens(SV3_1aParser::COMMA);
}

tree::TerminalNode* SV3_1aParser::Stream_concatenationContext::COMMA(size_t i) {
  return getToken(SV3_1aParser::COMMA, i);
}


size_t SV3_1aParser::Stream_concatenationContext::getRuleIndex() const {
  return SV3_1aParser::RuleStream_concatenation;
}

void SV3_1aParser::Stream_concatenationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterStream_concatenation(this);
}

void SV3_1aParser::Stream_concatenationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitStream_concatenation(this);
}

SV3_1aParser::Stream_concatenationContext* SV3_1aParser::stream_concatenation() {
  Stream_concatenationContext *_localctx = _tracker.createInstance<Stream_concatenationContext>(_ctx, getState());
  enterRule(_localctx, 1106, SV3_1aParser::RuleStream_concatenation);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8416);
    match(SV3_1aParser::OPEN_CURLY);
    setState(8417);
    stream_expression();
    setState(8422);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == SV3_1aParser::COMMA) {
      setState(8418);
      match(SV3_1aParser::COMMA);
      setState(8419);
      stream_expression();
      setState(8424);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(8425);
    match(SV3_1aParser::CLOSE_CURLY);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Stream_expressionContext ------------------------------------------------------------------

SV3_1aParser::Stream_expressionContext::Stream_expressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::ExpressionContext* SV3_1aParser::Stream_expressionContext::expression() {
  return getRuleContext<SV3_1aParser::ExpressionContext>(0);
}

tree::TerminalNode* SV3_1aParser::Stream_expressionContext::WITH() {
  return getToken(SV3_1aParser::WITH, 0);
}

tree::TerminalNode* SV3_1aParser::Stream_expressionContext::OPEN_BRACKET() {
  return getToken(SV3_1aParser::OPEN_BRACKET, 0);
}

SV3_1aParser::Array_range_expressionContext* SV3_1aParser::Stream_expressionContext::array_range_expression() {
  return getRuleContext<SV3_1aParser::Array_range_expressionContext>(0);
}

tree::TerminalNode* SV3_1aParser::Stream_expressionContext::CLOSE_BRACKET() {
  return getToken(SV3_1aParser::CLOSE_BRACKET, 0);
}


size_t SV3_1aParser::Stream_expressionContext::getRuleIndex() const {
  return SV3_1aParser::RuleStream_expression;
}

void SV3_1aParser::Stream_expressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterStream_expression(this);
}

void SV3_1aParser::Stream_expressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitStream_expression(this);
}

SV3_1aParser::Stream_expressionContext* SV3_1aParser::stream_expression() {
  Stream_expressionContext *_localctx = _tracker.createInstance<Stream_expressionContext>(_ctx, getState());
  enterRule(_localctx, 1108, SV3_1aParser::RuleStream_expression);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8427);
    expression(0);
    setState(8433);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SV3_1aParser::WITH) {
      setState(8428);
      match(SV3_1aParser::WITH);
      setState(8429);
      match(SV3_1aParser::OPEN_BRACKET);
      setState(8430);
      array_range_expression();
      setState(8431);
      match(SV3_1aParser::CLOSE_BRACKET);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Array_range_expressionContext ------------------------------------------------------------------

SV3_1aParser::Array_range_expressionContext::Array_range_expressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<SV3_1aParser::ExpressionContext *> SV3_1aParser::Array_range_expressionContext::expression() {
  return getRuleContexts<SV3_1aParser::ExpressionContext>();
}

SV3_1aParser::ExpressionContext* SV3_1aParser::Array_range_expressionContext::expression(size_t i) {
  return getRuleContext<SV3_1aParser::ExpressionContext>(i);
}

SV3_1aParser::Part_select_op_colonContext* SV3_1aParser::Array_range_expressionContext::part_select_op_colon() {
  return getRuleContext<SV3_1aParser::Part_select_op_colonContext>(0);
}


size_t SV3_1aParser::Array_range_expressionContext::getRuleIndex() const {
  return SV3_1aParser::RuleArray_range_expression;
}

void SV3_1aParser::Array_range_expressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterArray_range_expression(this);
}

void SV3_1aParser::Array_range_expressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitArray_range_expression(this);
}

SV3_1aParser::Array_range_expressionContext* SV3_1aParser::array_range_expression() {
  Array_range_expressionContext *_localctx = _tracker.createInstance<Array_range_expressionContext>(_ctx, getState());
  enterRule(_localctx, 1110, SV3_1aParser::RuleArray_range_expression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(8440);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 990, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(8435);
      expression(0);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(8436);
      expression(0);
      setState(8437);
      part_select_op_colon();
      setState(8438);
      expression(0);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Empty_queueContext ------------------------------------------------------------------

SV3_1aParser::Empty_queueContext::Empty_queueContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Empty_queueContext::OPEN_CURLY() {
  return getToken(SV3_1aParser::OPEN_CURLY, 0);
}

tree::TerminalNode* SV3_1aParser::Empty_queueContext::CLOSE_CURLY() {
  return getToken(SV3_1aParser::CLOSE_CURLY, 0);
}


size_t SV3_1aParser::Empty_queueContext::getRuleIndex() const {
  return SV3_1aParser::RuleEmpty_queue;
}

void SV3_1aParser::Empty_queueContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterEmpty_queue(this);
}

void SV3_1aParser::Empty_queueContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitEmpty_queue(this);
}

SV3_1aParser::Empty_queueContext* SV3_1aParser::empty_queue() {
  Empty_queueContext *_localctx = _tracker.createInstance<Empty_queueContext>(_ctx, getState());
  enterRule(_localctx, 1112, SV3_1aParser::RuleEmpty_queue);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8442);
    match(SV3_1aParser::OPEN_CURLY);
    setState(8443);
    match(SV3_1aParser::CLOSE_CURLY);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Subroutine_callContext ------------------------------------------------------------------

SV3_1aParser::Subroutine_callContext::Subroutine_callContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<SV3_1aParser::IdentifierContext *> SV3_1aParser::Subroutine_callContext::identifier() {
  return getRuleContexts<SV3_1aParser::IdentifierContext>();
}

SV3_1aParser::IdentifierContext* SV3_1aParser::Subroutine_callContext::identifier(size_t i) {
  return getRuleContext<SV3_1aParser::IdentifierContext>(i);
}

SV3_1aParser::SelectContext* SV3_1aParser::Subroutine_callContext::select() {
  return getRuleContext<SV3_1aParser::SelectContext>(0);
}

SV3_1aParser::Implicit_class_handleContext* SV3_1aParser::Subroutine_callContext::implicit_class_handle() {
  return getRuleContext<SV3_1aParser::Implicit_class_handleContext>(0);
}

std::vector<tree::TerminalNode *> SV3_1aParser::Subroutine_callContext::DOT() {
  return getTokens(SV3_1aParser::DOT);
}

tree::TerminalNode* SV3_1aParser::Subroutine_callContext::DOT(size_t i) {
  return getToken(SV3_1aParser::DOT, i);
}

SV3_1aParser::Class_scopeContext* SV3_1aParser::Subroutine_callContext::class_scope() {
  return getRuleContext<SV3_1aParser::Class_scopeContext>(0);
}

SV3_1aParser::Package_scopeContext* SV3_1aParser::Subroutine_callContext::package_scope() {
  return getRuleContext<SV3_1aParser::Package_scopeContext>(0);
}

SV3_1aParser::Dollar_keywordContext* SV3_1aParser::Subroutine_callContext::dollar_keyword() {
  return getRuleContext<SV3_1aParser::Dollar_keywordContext>(0);
}

SV3_1aParser::Dollar_root_keywordContext* SV3_1aParser::Subroutine_callContext::dollar_root_keyword() {
  return getRuleContext<SV3_1aParser::Dollar_root_keywordContext>(0);
}

std::vector<SV3_1aParser::Constant_bit_selectContext *> SV3_1aParser::Subroutine_callContext::constant_bit_select() {
  return getRuleContexts<SV3_1aParser::Constant_bit_selectContext>();
}

SV3_1aParser::Constant_bit_selectContext* SV3_1aParser::Subroutine_callContext::constant_bit_select(size_t i) {
  return getRuleContext<SV3_1aParser::Constant_bit_selectContext>(i);
}

std::vector<SV3_1aParser::Attribute_instanceContext *> SV3_1aParser::Subroutine_callContext::attribute_instance() {
  return getRuleContexts<SV3_1aParser::Attribute_instanceContext>();
}

SV3_1aParser::Attribute_instanceContext* SV3_1aParser::Subroutine_callContext::attribute_instance(size_t i) {
  return getRuleContext<SV3_1aParser::Attribute_instanceContext>(i);
}

SV3_1aParser::Method_call_bodyContext* SV3_1aParser::Subroutine_callContext::method_call_body() {
  return getRuleContext<SV3_1aParser::Method_call_bodyContext>(0);
}

tree::TerminalNode* SV3_1aParser::Subroutine_callContext::OPEN_PARENS() {
  return getToken(SV3_1aParser::OPEN_PARENS, 0);
}

SV3_1aParser::List_of_argumentsContext* SV3_1aParser::Subroutine_callContext::list_of_arguments() {
  return getRuleContext<SV3_1aParser::List_of_argumentsContext>(0);
}

tree::TerminalNode* SV3_1aParser::Subroutine_callContext::CLOSE_PARENS() {
  return getToken(SV3_1aParser::CLOSE_PARENS, 0);
}

SV3_1aParser::Randomize_callContext* SV3_1aParser::Subroutine_callContext::randomize_call() {
  return getRuleContext<SV3_1aParser::Randomize_callContext>(0);
}


size_t SV3_1aParser::Subroutine_callContext::getRuleIndex() const {
  return SV3_1aParser::RuleSubroutine_call;
}

void SV3_1aParser::Subroutine_callContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSubroutine_call(this);
}

void SV3_1aParser::Subroutine_callContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSubroutine_call(this);
}

SV3_1aParser::Subroutine_callContext* SV3_1aParser::subroutine_call() {
  Subroutine_callContext *_localctx = _tracker.createInstance<Subroutine_callContext>(_ctx, getState());
  enterRule(_localctx, 1114, SV3_1aParser::RuleSubroutine_call);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    setState(8484);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 997, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(8451);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 991, _ctx)) {
      case 1: {
        setState(8445);
        implicit_class_handle();
        setState(8446);
        match(SV3_1aParser::DOT);
        break;
      }

      case 2: {
        setState(8448);
        class_scope();
        break;
      }

      case 3: {
        setState(8449);
        package_scope();
        break;
      }

      case 4: {
        setState(8450);
        dollar_keyword();
        break;
      }

      default:
        break;
      }
      setState(8454);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == SV3_1aParser::DOLLAR_ROOT) {
        setState(8453);
        dollar_root_keyword();
      }
      setState(8456);
      identifier();
      setState(8463);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 993, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(8457);
          constant_bit_select();
          setState(8458);
          match(SV3_1aParser::DOT);
          setState(8459);
          identifier(); 
        }
        setState(8465);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 993, _ctx);
      }
      setState(8469);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 994, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(8466);
          attribute_instance(); 
        }
        setState(8471);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 994, _ctx);
      }
      setState(8477);
      _errHandler->sync(this);
      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 995, _ctx)) {
      case 1: {
        setState(8472);
        match(SV3_1aParser::OPEN_PARENS);
        setState(8473);
        list_of_arguments();
        setState(8474);
        match(SV3_1aParser::CLOSE_PARENS);
        break;
      }

      case 2: {
        setState(8476);
        select();
        break;
      }

      default:
        break;
      }
      setState(8481);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 996, _ctx)) {
      case 1: {
        setState(8479);
        match(SV3_1aParser::DOT);
        setState(8480);
        method_call_body();
        break;
      }

      default:
        break;
      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(8483);
      randomize_call();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ArgumentContext ------------------------------------------------------------------

SV3_1aParser::ArgumentContext::ArgumentContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::ExpressionContext* SV3_1aParser::ArgumentContext::expression() {
  return getRuleContext<SV3_1aParser::ExpressionContext>(0);
}


size_t SV3_1aParser::ArgumentContext::getRuleIndex() const {
  return SV3_1aParser::RuleArgument;
}

void SV3_1aParser::ArgumentContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterArgument(this);
}

void SV3_1aParser::ArgumentContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitArgument(this);
}

SV3_1aParser::ArgumentContext* SV3_1aParser::argument() {
  ArgumentContext *_localctx = _tracker.createInstance<ArgumentContext>(_ctx, getState());
  enterRule(_localctx, 1116, SV3_1aParser::RuleArgument);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8487);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 8796094922748) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 64)) & 1152648825725551617) != 0) || ((((_la - 147) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 147)) & 2199527096323) != 0) || _la == SV3_1aParser::BANG || ((((_la - 310) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 310)) & 559537073624154177) != 0)) {
      setState(8486);
      expression(0);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- List_of_argumentsContext ------------------------------------------------------------------

SV3_1aParser::List_of_argumentsContext::List_of_argumentsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<SV3_1aParser::ExpressionContext *> SV3_1aParser::List_of_argumentsContext::expression() {
  return getRuleContexts<SV3_1aParser::ExpressionContext>();
}

SV3_1aParser::ExpressionContext* SV3_1aParser::List_of_argumentsContext::expression(size_t i) {
  return getRuleContext<SV3_1aParser::ExpressionContext>(i);
}

std::vector<tree::TerminalNode *> SV3_1aParser::List_of_argumentsContext::COMMA() {
  return getTokens(SV3_1aParser::COMMA);
}

tree::TerminalNode* SV3_1aParser::List_of_argumentsContext::COMMA(size_t i) {
  return getToken(SV3_1aParser::COMMA, i);
}

std::vector<SV3_1aParser::ArgumentContext *> SV3_1aParser::List_of_argumentsContext::argument() {
  return getRuleContexts<SV3_1aParser::ArgumentContext>();
}

SV3_1aParser::ArgumentContext* SV3_1aParser::List_of_argumentsContext::argument(size_t i) {
  return getRuleContext<SV3_1aParser::ArgumentContext>(i);
}

std::vector<tree::TerminalNode *> SV3_1aParser::List_of_argumentsContext::DOT() {
  return getTokens(SV3_1aParser::DOT);
}

tree::TerminalNode* SV3_1aParser::List_of_argumentsContext::DOT(size_t i) {
  return getToken(SV3_1aParser::DOT, i);
}

std::vector<SV3_1aParser::IdentifierContext *> SV3_1aParser::List_of_argumentsContext::identifier() {
  return getRuleContexts<SV3_1aParser::IdentifierContext>();
}

SV3_1aParser::IdentifierContext* SV3_1aParser::List_of_argumentsContext::identifier(size_t i) {
  return getRuleContext<SV3_1aParser::IdentifierContext>(i);
}

std::vector<tree::TerminalNode *> SV3_1aParser::List_of_argumentsContext::OPEN_PARENS() {
  return getTokens(SV3_1aParser::OPEN_PARENS);
}

tree::TerminalNode* SV3_1aParser::List_of_argumentsContext::OPEN_PARENS(size_t i) {
  return getToken(SV3_1aParser::OPEN_PARENS, i);
}

std::vector<tree::TerminalNode *> SV3_1aParser::List_of_argumentsContext::CLOSE_PARENS() {
  return getTokens(SV3_1aParser::CLOSE_PARENS);
}

tree::TerminalNode* SV3_1aParser::List_of_argumentsContext::CLOSE_PARENS(size_t i) {
  return getToken(SV3_1aParser::CLOSE_PARENS, i);
}


size_t SV3_1aParser::List_of_argumentsContext::getRuleIndex() const {
  return SV3_1aParser::RuleList_of_arguments;
}

void SV3_1aParser::List_of_argumentsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterList_of_arguments(this);
}

void SV3_1aParser::List_of_argumentsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitList_of_arguments(this);
}

SV3_1aParser::List_of_argumentsContext* SV3_1aParser::list_of_arguments() {
  List_of_argumentsContext *_localctx = _tracker.createInstance<List_of_argumentsContext>(_ctx, getState());
  enterRule(_localctx, 1118, SV3_1aParser::RuleList_of_arguments);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    setState(8534);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SV3_1aParser::TICK_b0:
      case SV3_1aParser::TICK_b1:
      case SV3_1aParser::TICK_B0:
      case SV3_1aParser::TICK_B1:
      case SV3_1aParser::TICK_0:
      case SV3_1aParser::TICK_1:
      case SV3_1aParser::ONE_TICK_b0:
      case SV3_1aParser::ONE_TICK_b1:
      case SV3_1aParser::ONE_TICK_bx:
      case SV3_1aParser::ONE_TICK_bX:
      case SV3_1aParser::ONE_TICK_B0:
      case SV3_1aParser::ONE_TICK_B1:
      case SV3_1aParser::ONE_TICK_Bx:
      case SV3_1aParser::ONE_TICK_BX:
      case SV3_1aParser::Integral_number:
      case SV3_1aParser::Real_number:
      case SV3_1aParser::String:
      case SV3_1aParser::COMMA:
      case SV3_1aParser::OPEN_PARENS:
      case SV3_1aParser::CLOSE_PARENS:
      case SV3_1aParser::TYPE:
      case SV3_1aParser::CONST:
      case SV3_1aParser::LOCAL:
      case SV3_1aParser::SUPER:
      case SV3_1aParser::OPEN_CURLY:
      case SV3_1aParser::STRING:
      case SV3_1aParser::BYTE:
      case SV3_1aParser::SHORTINT:
      case SV3_1aParser::INT:
      case SV3_1aParser::LONGINT:
      case SV3_1aParser::INTEGER:
      case SV3_1aParser::TIME:
      case SV3_1aParser::BIT:
      case SV3_1aParser::LOGIC:
      case SV3_1aParser::REG:
      case SV3_1aParser::SHORTREAL:
      case SV3_1aParser::REAL:
      case SV3_1aParser::REALTIME:
      case SV3_1aParser::SIGNED:
      case SV3_1aParser::UNSIGNED:
      case SV3_1aParser::DOLLAR:
      case SV3_1aParser::PLUSPLUS:
      case SV3_1aParser::PLUS:
      case SV3_1aParser::MINUSMINUS:
      case SV3_1aParser::MINUS:
      case SV3_1aParser::DOLLAR_UNIT:
      case SV3_1aParser::BANG:
      case SV3_1aParser::TAGGED:
      case SV3_1aParser::TICK:
      case SV3_1aParser::NULL_KEYWORD:
      case SV3_1aParser::THIS:
      case SV3_1aParser::DOLLAR_ROOT:
      case SV3_1aParser::RANDOMIZE:
      case SV3_1aParser::SAMPLE:
      case SV3_1aParser::BITW_AND:
      case SV3_1aParser::BITW_OR:
      case SV3_1aParser::REDUCTION_NOR:
      case SV3_1aParser::REDUCTION_NAND:
      case SV3_1aParser::REDUCTION_XNOR1:
      case SV3_1aParser::Escaped_identifier:
      case SV3_1aParser::TILDA:
      case SV3_1aParser::BITW_XOR:
      case SV3_1aParser::REDUCTION_XNOR2:
      case SV3_1aParser::Simple_identifier: {
        enterOuterAlt(_localctx, 1);
        setState(8490);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if ((((_la & ~ 0x3fULL) == 0) &&
          ((1ULL << _la) & 8796094922748) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 64)) & 1152648825725551617) != 0) || ((((_la - 147) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 147)) & 2199527096323) != 0) || _la == SV3_1aParser::BANG || ((((_la - 310) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 310)) & 559537073624154177) != 0)) {
          setState(8489);
          expression(0);
        }
        setState(8496);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1000, _ctx);
        while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
          if (alt == 1) {
            setState(8492);
            match(SV3_1aParser::COMMA);
            setState(8493);
            argument(); 
          }
          setState(8498);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1000, _ctx);
        }
        setState(8510);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1002, _ctx);
        while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
          if (alt == 1) {
            setState(8499);
            match(SV3_1aParser::COMMA);
            setState(8500);
            match(SV3_1aParser::DOT);
            setState(8501);
            identifier();
            setState(8502);
            match(SV3_1aParser::OPEN_PARENS);
            setState(8504);
            _errHandler->sync(this);

            _la = _input->LA(1);
            if ((((_la & ~ 0x3fULL) == 0) &&
              ((1ULL << _la) & 8796094922748) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
              ((1ULL << (_la - 64)) & 1152648825725551617) != 0) || ((((_la - 147) & ~ 0x3fULL) == 0) &&
              ((1ULL << (_la - 147)) & 2199527096323) != 0) || _la == SV3_1aParser::BANG || ((((_la - 310) & ~ 0x3fULL) == 0) &&
              ((1ULL << (_la - 310)) & 559537073624154177) != 0)) {
              setState(8503);
              expression(0);
            }
            setState(8506);
            match(SV3_1aParser::CLOSE_PARENS); 
          }
          setState(8512);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1002, _ctx);
        }
        break;
      }

      case SV3_1aParser::DOT: {
        enterOuterAlt(_localctx, 2);
        setState(8513);
        match(SV3_1aParser::DOT);
        setState(8514);
        identifier();
        setState(8515);
        match(SV3_1aParser::OPEN_PARENS);
        setState(8517);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if ((((_la & ~ 0x3fULL) == 0) &&
          ((1ULL << _la) & 8796094922748) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 64)) & 1152648825725551617) != 0) || ((((_la - 147) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 147)) & 2199527096323) != 0) || _la == SV3_1aParser::BANG || ((((_la - 310) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 310)) & 559537073624154177) != 0)) {
          setState(8516);
          expression(0);
        }
        setState(8519);
        match(SV3_1aParser::CLOSE_PARENS);
        setState(8531);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1005, _ctx);
        while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
          if (alt == 1) {
            setState(8520);
            match(SV3_1aParser::COMMA);
            setState(8521);
            match(SV3_1aParser::DOT);
            setState(8522);
            identifier();
            setState(8523);
            match(SV3_1aParser::OPEN_PARENS);
            setState(8525);
            _errHandler->sync(this);

            _la = _input->LA(1);
            if ((((_la & ~ 0x3fULL) == 0) &&
              ((1ULL << _la) & 8796094922748) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
              ((1ULL << (_la - 64)) & 1152648825725551617) != 0) || ((((_la - 147) & ~ 0x3fULL) == 0) &&
              ((1ULL << (_la - 147)) & 2199527096323) != 0) || _la == SV3_1aParser::BANG || ((((_la - 310) & ~ 0x3fULL) == 0) &&
              ((1ULL << (_la - 310)) & 559537073624154177) != 0)) {
              setState(8524);
              expression(0);
            }
            setState(8527);
            match(SV3_1aParser::CLOSE_PARENS); 
          }
          setState(8533);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1005, _ctx);
        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Method_callContext ------------------------------------------------------------------

SV3_1aParser::Method_callContext::Method_callContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::Method_call_rootContext* SV3_1aParser::Method_callContext::method_call_root() {
  return getRuleContext<SV3_1aParser::Method_call_rootContext>(0);
}

tree::TerminalNode* SV3_1aParser::Method_callContext::DOT() {
  return getToken(SV3_1aParser::DOT, 0);
}

SV3_1aParser::Method_call_bodyContext* SV3_1aParser::Method_callContext::method_call_body() {
  return getRuleContext<SV3_1aParser::Method_call_bodyContext>(0);
}

SV3_1aParser::Class_typeContext* SV3_1aParser::Method_callContext::class_type() {
  return getRuleContext<SV3_1aParser::Class_typeContext>(0);
}

tree::TerminalNode* SV3_1aParser::Method_callContext::COLONCOLON() {
  return getToken(SV3_1aParser::COLONCOLON, 0);
}


size_t SV3_1aParser::Method_callContext::getRuleIndex() const {
  return SV3_1aParser::RuleMethod_call;
}

void SV3_1aParser::Method_callContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterMethod_call(this);
}

void SV3_1aParser::Method_callContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitMethod_call(this);
}

SV3_1aParser::Method_callContext* SV3_1aParser::method_call() {
  Method_callContext *_localctx = _tracker.createInstance<Method_callContext>(_ctx, getState());
  enterRule(_localctx, 1120, SV3_1aParser::RuleMethod_call);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(8544);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1007, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(8536);
      method_call_root();
      setState(8537);
      match(SV3_1aParser::DOT);
      setState(8538);
      method_call_body();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(8540);
      class_type();
      setState(8541);
      match(SV3_1aParser::COLONCOLON);
      setState(8542);
      method_call_body();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Method_call_bodyContext ------------------------------------------------------------------

SV3_1aParser::Method_call_bodyContext::Method_call_bodyContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::IdentifierContext* SV3_1aParser::Method_call_bodyContext::identifier() {
  return getRuleContext<SV3_1aParser::IdentifierContext>(0);
}

std::vector<SV3_1aParser::Attribute_instanceContext *> SV3_1aParser::Method_call_bodyContext::attribute_instance() {
  return getRuleContexts<SV3_1aParser::Attribute_instanceContext>();
}

SV3_1aParser::Attribute_instanceContext* SV3_1aParser::Method_call_bodyContext::attribute_instance(size_t i) {
  return getRuleContext<SV3_1aParser::Attribute_instanceContext>(i);
}

tree::TerminalNode* SV3_1aParser::Method_call_bodyContext::OPEN_PARENS() {
  return getToken(SV3_1aParser::OPEN_PARENS, 0);
}

SV3_1aParser::List_of_argumentsContext* SV3_1aParser::Method_call_bodyContext::list_of_arguments() {
  return getRuleContext<SV3_1aParser::List_of_argumentsContext>(0);
}

tree::TerminalNode* SV3_1aParser::Method_call_bodyContext::CLOSE_PARENS() {
  return getToken(SV3_1aParser::CLOSE_PARENS, 0);
}

SV3_1aParser::Built_in_method_callContext* SV3_1aParser::Method_call_bodyContext::built_in_method_call() {
  return getRuleContext<SV3_1aParser::Built_in_method_callContext>(0);
}


size_t SV3_1aParser::Method_call_bodyContext::getRuleIndex() const {
  return SV3_1aParser::RuleMethod_call_body;
}

void SV3_1aParser::Method_call_bodyContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterMethod_call_body(this);
}

void SV3_1aParser::Method_call_bodyContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitMethod_call_body(this);
}

SV3_1aParser::Method_call_bodyContext* SV3_1aParser::method_call_body() {
  Method_call_bodyContext *_localctx = _tracker.createInstance<Method_call_bodyContext>(_ctx, getState());
  enterRule(_localctx, 1122, SV3_1aParser::RuleMethod_call_body);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    setState(8560);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1010, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(8546);
      identifier();
      setState(8550);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1008, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(8547);
          attribute_instance(); 
        }
        setState(8552);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1008, _ctx);
      }
      setState(8557);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1009, _ctx)) {
      case 1: {
        setState(8553);
        match(SV3_1aParser::OPEN_PARENS);
        setState(8554);
        list_of_arguments();
        setState(8555);
        match(SV3_1aParser::CLOSE_PARENS);
        break;
      }

      default:
        break;
      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(8559);
      built_in_method_call();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Built_in_method_callContext ------------------------------------------------------------------

SV3_1aParser::Built_in_method_callContext::Built_in_method_callContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::Array_manipulation_callContext* SV3_1aParser::Built_in_method_callContext::array_manipulation_call() {
  return getRuleContext<SV3_1aParser::Array_manipulation_callContext>(0);
}

SV3_1aParser::Randomize_callContext* SV3_1aParser::Built_in_method_callContext::randomize_call() {
  return getRuleContext<SV3_1aParser::Randomize_callContext>(0);
}


size_t SV3_1aParser::Built_in_method_callContext::getRuleIndex() const {
  return SV3_1aParser::RuleBuilt_in_method_call;
}

void SV3_1aParser::Built_in_method_callContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBuilt_in_method_call(this);
}

void SV3_1aParser::Built_in_method_callContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBuilt_in_method_call(this);
}

SV3_1aParser::Built_in_method_callContext* SV3_1aParser::built_in_method_call() {
  Built_in_method_callContext *_localctx = _tracker.createInstance<Built_in_method_callContext>(_ctx, getState());
  enterRule(_localctx, 1124, SV3_1aParser::RuleBuilt_in_method_call);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(8564);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1011, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(8562);
      array_manipulation_call();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(8563);
      randomize_call();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Array_manipulation_callContext ------------------------------------------------------------------

SV3_1aParser::Array_manipulation_callContext::Array_manipulation_callContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::Array_method_nameContext* SV3_1aParser::Array_manipulation_callContext::array_method_name() {
  return getRuleContext<SV3_1aParser::Array_method_nameContext>(0);
}

std::vector<SV3_1aParser::Attribute_instanceContext *> SV3_1aParser::Array_manipulation_callContext::attribute_instance() {
  return getRuleContexts<SV3_1aParser::Attribute_instanceContext>();
}

SV3_1aParser::Attribute_instanceContext* SV3_1aParser::Array_manipulation_callContext::attribute_instance(size_t i) {
  return getRuleContext<SV3_1aParser::Attribute_instanceContext>(i);
}

std::vector<tree::TerminalNode *> SV3_1aParser::Array_manipulation_callContext::OPEN_PARENS() {
  return getTokens(SV3_1aParser::OPEN_PARENS);
}

tree::TerminalNode* SV3_1aParser::Array_manipulation_callContext::OPEN_PARENS(size_t i) {
  return getToken(SV3_1aParser::OPEN_PARENS, i);
}

SV3_1aParser::List_of_argumentsContext* SV3_1aParser::Array_manipulation_callContext::list_of_arguments() {
  return getRuleContext<SV3_1aParser::List_of_argumentsContext>(0);
}

std::vector<tree::TerminalNode *> SV3_1aParser::Array_manipulation_callContext::CLOSE_PARENS() {
  return getTokens(SV3_1aParser::CLOSE_PARENS);
}

tree::TerminalNode* SV3_1aParser::Array_manipulation_callContext::CLOSE_PARENS(size_t i) {
  return getToken(SV3_1aParser::CLOSE_PARENS, i);
}

tree::TerminalNode* SV3_1aParser::Array_manipulation_callContext::WITH() {
  return getToken(SV3_1aParser::WITH, 0);
}

SV3_1aParser::ExpressionContext* SV3_1aParser::Array_manipulation_callContext::expression() {
  return getRuleContext<SV3_1aParser::ExpressionContext>(0);
}


size_t SV3_1aParser::Array_manipulation_callContext::getRuleIndex() const {
  return SV3_1aParser::RuleArray_manipulation_call;
}

void SV3_1aParser::Array_manipulation_callContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterArray_manipulation_call(this);
}

void SV3_1aParser::Array_manipulation_callContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitArray_manipulation_call(this);
}

SV3_1aParser::Array_manipulation_callContext* SV3_1aParser::array_manipulation_call() {
  Array_manipulation_callContext *_localctx = _tracker.createInstance<Array_manipulation_callContext>(_ctx, getState());
  enterRule(_localctx, 1126, SV3_1aParser::RuleArray_manipulation_call);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(8566);
    array_method_name();
    setState(8570);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1012, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(8567);
        attribute_instance(); 
      }
      setState(8572);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1012, _ctx);
    }
    setState(8577);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1013, _ctx)) {
    case 1: {
      setState(8573);
      match(SV3_1aParser::OPEN_PARENS);
      setState(8574);
      list_of_arguments();
      setState(8575);
      match(SV3_1aParser::CLOSE_PARENS);
      break;
    }

    default:
      break;
    }
    setState(8584);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1014, _ctx)) {
    case 1: {
      setState(8579);
      match(SV3_1aParser::WITH);
      setState(8580);
      match(SV3_1aParser::OPEN_PARENS);
      setState(8581);
      expression(0);
      setState(8582);
      match(SV3_1aParser::CLOSE_PARENS);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Randomize_callContext ------------------------------------------------------------------

SV3_1aParser::Randomize_callContext::Randomize_callContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Randomize_callContext::RANDOMIZE() {
  return getToken(SV3_1aParser::RANDOMIZE, 0);
}

std::vector<SV3_1aParser::Attribute_instanceContext *> SV3_1aParser::Randomize_callContext::attribute_instance() {
  return getRuleContexts<SV3_1aParser::Attribute_instanceContext>();
}

SV3_1aParser::Attribute_instanceContext* SV3_1aParser::Randomize_callContext::attribute_instance(size_t i) {
  return getRuleContext<SV3_1aParser::Attribute_instanceContext>(i);
}

std::vector<tree::TerminalNode *> SV3_1aParser::Randomize_callContext::OPEN_PARENS() {
  return getTokens(SV3_1aParser::OPEN_PARENS);
}

tree::TerminalNode* SV3_1aParser::Randomize_callContext::OPEN_PARENS(size_t i) {
  return getToken(SV3_1aParser::OPEN_PARENS, i);
}

std::vector<tree::TerminalNode *> SV3_1aParser::Randomize_callContext::CLOSE_PARENS() {
  return getTokens(SV3_1aParser::CLOSE_PARENS);
}

tree::TerminalNode* SV3_1aParser::Randomize_callContext::CLOSE_PARENS(size_t i) {
  return getToken(SV3_1aParser::CLOSE_PARENS, i);
}

tree::TerminalNode* SV3_1aParser::Randomize_callContext::WITH() {
  return getToken(SV3_1aParser::WITH, 0);
}

SV3_1aParser::Constraint_blockContext* SV3_1aParser::Randomize_callContext::constraint_block() {
  return getRuleContext<SV3_1aParser::Constraint_blockContext>(0);
}

std::vector<SV3_1aParser::Identifier_listContext *> SV3_1aParser::Randomize_callContext::identifier_list() {
  return getRuleContexts<SV3_1aParser::Identifier_listContext>();
}

SV3_1aParser::Identifier_listContext* SV3_1aParser::Randomize_callContext::identifier_list(size_t i) {
  return getRuleContext<SV3_1aParser::Identifier_listContext>(i);
}

tree::TerminalNode* SV3_1aParser::Randomize_callContext::NULL_KEYWORD() {
  return getToken(SV3_1aParser::NULL_KEYWORD, 0);
}


size_t SV3_1aParser::Randomize_callContext::getRuleIndex() const {
  return SV3_1aParser::RuleRandomize_call;
}

void SV3_1aParser::Randomize_callContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRandomize_call(this);
}

void SV3_1aParser::Randomize_callContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRandomize_call(this);
}

SV3_1aParser::Randomize_callContext* SV3_1aParser::randomize_call() {
  Randomize_callContext *_localctx = _tracker.createInstance<Randomize_callContext>(_ctx, getState());
  enterRule(_localctx, 1128, SV3_1aParser::RuleRandomize_call);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(8586);
    match(SV3_1aParser::RANDOMIZE);
    setState(8590);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1015, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(8587);
        attribute_instance(); 
      }
      setState(8592);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1015, _ctx);
    }
    setState(8599);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1017, _ctx)) {
    case 1: {
      setState(8593);
      match(SV3_1aParser::OPEN_PARENS);
      setState(8596);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case SV3_1aParser::THIS:
        case SV3_1aParser::RANDOMIZE:
        case SV3_1aParser::SAMPLE:
        case SV3_1aParser::Escaped_identifier:
        case SV3_1aParser::Simple_identifier: {
          setState(8594);
          identifier_list();
          break;
        }

        case SV3_1aParser::NULL_KEYWORD: {
          setState(8595);
          match(SV3_1aParser::NULL_KEYWORD);
          break;
        }

        case SV3_1aParser::CLOSE_PARENS: {
          break;
        }

      default:
        break;
      }
      setState(8598);
      match(SV3_1aParser::CLOSE_PARENS);
      break;
    }

    default:
      break;
    }
    setState(8610);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1020, _ctx)) {
    case 1: {
      setState(8601);
      match(SV3_1aParser::WITH);
      setState(8607);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == SV3_1aParser::OPEN_PARENS) {
        setState(8602);
        match(SV3_1aParser::OPEN_PARENS);
        setState(8604);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (((((_la - 326) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 326)) & 4672924483589) != 0)) {
          setState(8603);
          identifier_list();
        }
        setState(8606);
        match(SV3_1aParser::CLOSE_PARENS);
      }
      setState(8609);
      constraint_block();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Method_call_rootContext ------------------------------------------------------------------

SV3_1aParser::Method_call_rootContext::Method_call_rootContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::Implicit_class_handleContext* SV3_1aParser::Method_call_rootContext::implicit_class_handle() {
  return getRuleContext<SV3_1aParser::Implicit_class_handleContext>(0);
}

std::vector<SV3_1aParser::IdentifierContext *> SV3_1aParser::Method_call_rootContext::identifier() {
  return getRuleContexts<SV3_1aParser::IdentifierContext>();
}

SV3_1aParser::IdentifierContext* SV3_1aParser::Method_call_rootContext::identifier(size_t i) {
  return getRuleContext<SV3_1aParser::IdentifierContext>(i);
}

SV3_1aParser::SelectContext* SV3_1aParser::Method_call_rootContext::select() {
  return getRuleContext<SV3_1aParser::SelectContext>(0);
}

SV3_1aParser::Class_scopeContext* SV3_1aParser::Method_call_rootContext::class_scope() {
  return getRuleContext<SV3_1aParser::Class_scopeContext>(0);
}

SV3_1aParser::Package_scopeContext* SV3_1aParser::Method_call_rootContext::package_scope() {
  return getRuleContext<SV3_1aParser::Package_scopeContext>(0);
}

SV3_1aParser::Dollar_root_keywordContext* SV3_1aParser::Method_call_rootContext::dollar_root_keyword() {
  return getRuleContext<SV3_1aParser::Dollar_root_keywordContext>(0);
}

std::vector<tree::TerminalNode *> SV3_1aParser::Method_call_rootContext::DOT() {
  return getTokens(SV3_1aParser::DOT);
}

tree::TerminalNode* SV3_1aParser::Method_call_rootContext::DOT(size_t i) {
  return getToken(SV3_1aParser::DOT, i);
}

std::vector<tree::TerminalNode *> SV3_1aParser::Method_call_rootContext::OPEN_BRACKET() {
  return getTokens(SV3_1aParser::OPEN_BRACKET);
}

tree::TerminalNode* SV3_1aParser::Method_call_rootContext::OPEN_BRACKET(size_t i) {
  return getToken(SV3_1aParser::OPEN_BRACKET, i);
}

std::vector<SV3_1aParser::Constant_expressionContext *> SV3_1aParser::Method_call_rootContext::constant_expression() {
  return getRuleContexts<SV3_1aParser::Constant_expressionContext>();
}

SV3_1aParser::Constant_expressionContext* SV3_1aParser::Method_call_rootContext::constant_expression(size_t i) {
  return getRuleContext<SV3_1aParser::Constant_expressionContext>(i);
}

std::vector<tree::TerminalNode *> SV3_1aParser::Method_call_rootContext::CLOSE_BRACKET() {
  return getTokens(SV3_1aParser::CLOSE_BRACKET);
}

tree::TerminalNode* SV3_1aParser::Method_call_rootContext::CLOSE_BRACKET(size_t i) {
  return getToken(SV3_1aParser::CLOSE_BRACKET, i);
}


size_t SV3_1aParser::Method_call_rootContext::getRuleIndex() const {
  return SV3_1aParser::RuleMethod_call_root;
}

void SV3_1aParser::Method_call_rootContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterMethod_call_root(this);
}

void SV3_1aParser::Method_call_rootContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitMethod_call_root(this);
}

SV3_1aParser::Method_call_rootContext* SV3_1aParser::method_call_root() {
  Method_call_rootContext *_localctx = _tracker.createInstance<Method_call_rootContext>(_ctx, getState());
  enterRule(_localctx, 1130, SV3_1aParser::RuleMethod_call_root);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    setState(8639);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1025, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(8612);
      implicit_class_handle();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(8615);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1021, _ctx)) {
      case 1: {
        setState(8613);
        class_scope();
        break;
      }

      case 2: {
        setState(8614);
        package_scope();
        break;
      }

      default:
        break;
      }
      setState(8618);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == SV3_1aParser::DOLLAR_ROOT) {
        setState(8617);
        dollar_root_keyword();
      }
      setState(8620);
      identifier();
      setState(8634);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1024, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(8627);
          _errHandler->sync(this);
          _la = _input->LA(1);
          while (_la == SV3_1aParser::OPEN_BRACKET) {
            setState(8621);
            match(SV3_1aParser::OPEN_BRACKET);
            setState(8622);
            constant_expression(0);
            setState(8623);
            match(SV3_1aParser::CLOSE_BRACKET);
            setState(8629);
            _errHandler->sync(this);
            _la = _input->LA(1);
          }
          setState(8630);
          match(SV3_1aParser::DOT);
          setState(8631);
          identifier(); 
        }
        setState(8636);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1024, _ctx);
      }
      setState(8637);
      select();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Array_method_nameContext ------------------------------------------------------------------

SV3_1aParser::Array_method_nameContext::Array_method_nameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::IdentifierContext* SV3_1aParser::Array_method_nameContext::identifier() {
  return getRuleContext<SV3_1aParser::IdentifierContext>(0);
}

SV3_1aParser::Unique_callContext* SV3_1aParser::Array_method_nameContext::unique_call() {
  return getRuleContext<SV3_1aParser::Unique_callContext>(0);
}

SV3_1aParser::And_callContext* SV3_1aParser::Array_method_nameContext::and_call() {
  return getRuleContext<SV3_1aParser::And_callContext>(0);
}

SV3_1aParser::Or_callContext* SV3_1aParser::Array_method_nameContext::or_call() {
  return getRuleContext<SV3_1aParser::Or_callContext>(0);
}

SV3_1aParser::Xor_callContext* SV3_1aParser::Array_method_nameContext::xor_call() {
  return getRuleContext<SV3_1aParser::Xor_callContext>(0);
}


size_t SV3_1aParser::Array_method_nameContext::getRuleIndex() const {
  return SV3_1aParser::RuleArray_method_name;
}

void SV3_1aParser::Array_method_nameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterArray_method_name(this);
}

void SV3_1aParser::Array_method_nameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitArray_method_name(this);
}

SV3_1aParser::Array_method_nameContext* SV3_1aParser::array_method_name() {
  Array_method_nameContext *_localctx = _tracker.createInstance<Array_method_nameContext>(_ctx, getState());
  enterRule(_localctx, 1132, SV3_1aParser::RuleArray_method_name);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(8646);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SV3_1aParser::THIS:
      case SV3_1aParser::RANDOMIZE:
      case SV3_1aParser::SAMPLE:
      case SV3_1aParser::Escaped_identifier:
      case SV3_1aParser::Simple_identifier: {
        enterOuterAlt(_localctx, 1);
        setState(8641);
        identifier();
        break;
      }

      case SV3_1aParser::UNIQUE: {
        enterOuterAlt(_localctx, 2);
        setState(8642);
        unique_call();
        break;
      }

      case SV3_1aParser::AND: {
        enterOuterAlt(_localctx, 3);
        setState(8643);
        and_call();
        break;
      }

      case SV3_1aParser::OR: {
        enterOuterAlt(_localctx, 4);
        setState(8644);
        or_call();
        break;
      }

      case SV3_1aParser::XOR: {
        enterOuterAlt(_localctx, 5);
        setState(8645);
        xor_call();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Unique_callContext ------------------------------------------------------------------

SV3_1aParser::Unique_callContext::Unique_callContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Unique_callContext::UNIQUE() {
  return getToken(SV3_1aParser::UNIQUE, 0);
}


size_t SV3_1aParser::Unique_callContext::getRuleIndex() const {
  return SV3_1aParser::RuleUnique_call;
}

void SV3_1aParser::Unique_callContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUnique_call(this);
}

void SV3_1aParser::Unique_callContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUnique_call(this);
}

SV3_1aParser::Unique_callContext* SV3_1aParser::unique_call() {
  Unique_callContext *_localctx = _tracker.createInstance<Unique_callContext>(_ctx, getState());
  enterRule(_localctx, 1134, SV3_1aParser::RuleUnique_call);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8648);
    match(SV3_1aParser::UNIQUE);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- And_callContext ------------------------------------------------------------------

SV3_1aParser::And_callContext::And_callContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::And_callContext::AND() {
  return getToken(SV3_1aParser::AND, 0);
}


size_t SV3_1aParser::And_callContext::getRuleIndex() const {
  return SV3_1aParser::RuleAnd_call;
}

void SV3_1aParser::And_callContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAnd_call(this);
}

void SV3_1aParser::And_callContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAnd_call(this);
}

SV3_1aParser::And_callContext* SV3_1aParser::and_call() {
  And_callContext *_localctx = _tracker.createInstance<And_callContext>(_ctx, getState());
  enterRule(_localctx, 1136, SV3_1aParser::RuleAnd_call);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8650);
    match(SV3_1aParser::AND);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Or_callContext ------------------------------------------------------------------

SV3_1aParser::Or_callContext::Or_callContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Or_callContext::OR() {
  return getToken(SV3_1aParser::OR, 0);
}


size_t SV3_1aParser::Or_callContext::getRuleIndex() const {
  return SV3_1aParser::RuleOr_call;
}

void SV3_1aParser::Or_callContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOr_call(this);
}

void SV3_1aParser::Or_callContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOr_call(this);
}

SV3_1aParser::Or_callContext* SV3_1aParser::or_call() {
  Or_callContext *_localctx = _tracker.createInstance<Or_callContext>(_ctx, getState());
  enterRule(_localctx, 1138, SV3_1aParser::RuleOr_call);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8652);
    match(SV3_1aParser::OR);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Xor_callContext ------------------------------------------------------------------

SV3_1aParser::Xor_callContext::Xor_callContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Xor_callContext::XOR() {
  return getToken(SV3_1aParser::XOR, 0);
}


size_t SV3_1aParser::Xor_callContext::getRuleIndex() const {
  return SV3_1aParser::RuleXor_call;
}

void SV3_1aParser::Xor_callContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterXor_call(this);
}

void SV3_1aParser::Xor_callContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitXor_call(this);
}

SV3_1aParser::Xor_callContext* SV3_1aParser::xor_call() {
  Xor_callContext *_localctx = _tracker.createInstance<Xor_callContext>(_ctx, getState());
  enterRule(_localctx, 1140, SV3_1aParser::RuleXor_call);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8654);
    match(SV3_1aParser::XOR);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Inc_or_dec_expressionContext ------------------------------------------------------------------

SV3_1aParser::Inc_or_dec_expressionContext::Inc_or_dec_expressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::Inc_or_dec_operatorContext* SV3_1aParser::Inc_or_dec_expressionContext::inc_or_dec_operator() {
  return getRuleContext<SV3_1aParser::Inc_or_dec_operatorContext>(0);
}

SV3_1aParser::Variable_lvalueContext* SV3_1aParser::Inc_or_dec_expressionContext::variable_lvalue() {
  return getRuleContext<SV3_1aParser::Variable_lvalueContext>(0);
}

std::vector<SV3_1aParser::Attribute_instanceContext *> SV3_1aParser::Inc_or_dec_expressionContext::attribute_instance() {
  return getRuleContexts<SV3_1aParser::Attribute_instanceContext>();
}

SV3_1aParser::Attribute_instanceContext* SV3_1aParser::Inc_or_dec_expressionContext::attribute_instance(size_t i) {
  return getRuleContext<SV3_1aParser::Attribute_instanceContext>(i);
}


size_t SV3_1aParser::Inc_or_dec_expressionContext::getRuleIndex() const {
  return SV3_1aParser::RuleInc_or_dec_expression;
}

void SV3_1aParser::Inc_or_dec_expressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInc_or_dec_expression(this);
}

void SV3_1aParser::Inc_or_dec_expressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInc_or_dec_expression(this);
}

SV3_1aParser::Inc_or_dec_expressionContext* SV3_1aParser::inc_or_dec_expression() {
  Inc_or_dec_expressionContext *_localctx = _tracker.createInstance<Inc_or_dec_expressionContext>(_ctx, getState());
  enterRule(_localctx, 1142, SV3_1aParser::RuleInc_or_dec_expression);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(8674);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SV3_1aParser::PLUSPLUS:
      case SV3_1aParser::MINUSMINUS: {
        enterOuterAlt(_localctx, 1);
        setState(8656);
        inc_or_dec_operator();
        setState(8660);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == SV3_1aParser::OPEN_PARENS_STAR) {
          setState(8657);
          attribute_instance();
          setState(8662);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(8663);
        variable_lvalue();
        break;
      }

      case SV3_1aParser::TYPE:
      case SV3_1aParser::LOCAL:
      case SV3_1aParser::SUPER:
      case SV3_1aParser::OPEN_CURLY:
      case SV3_1aParser::BYTE:
      case SV3_1aParser::SHORTINT:
      case SV3_1aParser::INT:
      case SV3_1aParser::LONGINT:
      case SV3_1aParser::INTEGER:
      case SV3_1aParser::TIME:
      case SV3_1aParser::DOLLAR_UNIT:
      case SV3_1aParser::TICK:
      case SV3_1aParser::THIS:
      case SV3_1aParser::DOLLAR_ROOT:
      case SV3_1aParser::RANDOMIZE:
      case SV3_1aParser::SAMPLE:
      case SV3_1aParser::Escaped_identifier:
      case SV3_1aParser::Simple_identifier: {
        enterOuterAlt(_localctx, 2);
        setState(8665);
        variable_lvalue();
        setState(8669);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == SV3_1aParser::OPEN_PARENS_STAR) {
          setState(8666);
          attribute_instance();
          setState(8671);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(8672);
        inc_or_dec_operator();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Constant_expressionContext ------------------------------------------------------------------

SV3_1aParser::Constant_expressionContext::Constant_expressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::Constant_primaryContext* SV3_1aParser::Constant_expressionContext::constant_primary() {
  return getRuleContext<SV3_1aParser::Constant_primaryContext>(0);
}

tree::TerminalNode* SV3_1aParser::Constant_expressionContext::PLUS() {
  return getToken(SV3_1aParser::PLUS, 0);
}

tree::TerminalNode* SV3_1aParser::Constant_expressionContext::MINUS() {
  return getToken(SV3_1aParser::MINUS, 0);
}

tree::TerminalNode* SV3_1aParser::Constant_expressionContext::BANG() {
  return getToken(SV3_1aParser::BANG, 0);
}

tree::TerminalNode* SV3_1aParser::Constant_expressionContext::TILDA() {
  return getToken(SV3_1aParser::TILDA, 0);
}

tree::TerminalNode* SV3_1aParser::Constant_expressionContext::BITW_AND() {
  return getToken(SV3_1aParser::BITW_AND, 0);
}

tree::TerminalNode* SV3_1aParser::Constant_expressionContext::BITW_OR() {
  return getToken(SV3_1aParser::BITW_OR, 0);
}

tree::TerminalNode* SV3_1aParser::Constant_expressionContext::BITW_XOR() {
  return getToken(SV3_1aParser::BITW_XOR, 0);
}

tree::TerminalNode* SV3_1aParser::Constant_expressionContext::REDUCTION_NAND() {
  return getToken(SV3_1aParser::REDUCTION_NAND, 0);
}

tree::TerminalNode* SV3_1aParser::Constant_expressionContext::REDUCTION_NOR() {
  return getToken(SV3_1aParser::REDUCTION_NOR, 0);
}

tree::TerminalNode* SV3_1aParser::Constant_expressionContext::REDUCTION_XNOR1() {
  return getToken(SV3_1aParser::REDUCTION_XNOR1, 0);
}

tree::TerminalNode* SV3_1aParser::Constant_expressionContext::REDUCTION_XNOR2() {
  return getToken(SV3_1aParser::REDUCTION_XNOR2, 0);
}

std::vector<SV3_1aParser::Attribute_instanceContext *> SV3_1aParser::Constant_expressionContext::attribute_instance() {
  return getRuleContexts<SV3_1aParser::Attribute_instanceContext>();
}

SV3_1aParser::Attribute_instanceContext* SV3_1aParser::Constant_expressionContext::attribute_instance(size_t i) {
  return getRuleContext<SV3_1aParser::Attribute_instanceContext>(i);
}

SV3_1aParser::System_taskContext* SV3_1aParser::Constant_expressionContext::system_task() {
  return getRuleContext<SV3_1aParser::System_taskContext>(0);
}

std::vector<SV3_1aParser::Constant_expressionContext *> SV3_1aParser::Constant_expressionContext::constant_expression() {
  return getRuleContexts<SV3_1aParser::Constant_expressionContext>();
}

SV3_1aParser::Constant_expressionContext* SV3_1aParser::Constant_expressionContext::constant_expression(size_t i) {
  return getRuleContext<SV3_1aParser::Constant_expressionContext>(i);
}

tree::TerminalNode* SV3_1aParser::Constant_expressionContext::STARSTAR() {
  return getToken(SV3_1aParser::STARSTAR, 0);
}

tree::TerminalNode* SV3_1aParser::Constant_expressionContext::STAR() {
  return getToken(SV3_1aParser::STAR, 0);
}

tree::TerminalNode* SV3_1aParser::Constant_expressionContext::DIV() {
  return getToken(SV3_1aParser::DIV, 0);
}

tree::TerminalNode* SV3_1aParser::Constant_expressionContext::PERCENT() {
  return getToken(SV3_1aParser::PERCENT, 0);
}

tree::TerminalNode* SV3_1aParser::Constant_expressionContext::SHIFT_RIGHT() {
  return getToken(SV3_1aParser::SHIFT_RIGHT, 0);
}

tree::TerminalNode* SV3_1aParser::Constant_expressionContext::SHIFT_LEFT() {
  return getToken(SV3_1aParser::SHIFT_LEFT, 0);
}

tree::TerminalNode* SV3_1aParser::Constant_expressionContext::ARITH_SHIFT_RIGHT() {
  return getToken(SV3_1aParser::ARITH_SHIFT_RIGHT, 0);
}

tree::TerminalNode* SV3_1aParser::Constant_expressionContext::ARITH_SHIFT_LEFT() {
  return getToken(SV3_1aParser::ARITH_SHIFT_LEFT, 0);
}

tree::TerminalNode* SV3_1aParser::Constant_expressionContext::LESS() {
  return getToken(SV3_1aParser::LESS, 0);
}

tree::TerminalNode* SV3_1aParser::Constant_expressionContext::LESS_EQUAL() {
  return getToken(SV3_1aParser::LESS_EQUAL, 0);
}

tree::TerminalNode* SV3_1aParser::Constant_expressionContext::GREATER() {
  return getToken(SV3_1aParser::GREATER, 0);
}

tree::TerminalNode* SV3_1aParser::Constant_expressionContext::GREATER_EQUAL() {
  return getToken(SV3_1aParser::GREATER_EQUAL, 0);
}

tree::TerminalNode* SV3_1aParser::Constant_expressionContext::INSIDE() {
  return getToken(SV3_1aParser::INSIDE, 0);
}

tree::TerminalNode* SV3_1aParser::Constant_expressionContext::EQUIV() {
  return getToken(SV3_1aParser::EQUIV, 0);
}

tree::TerminalNode* SV3_1aParser::Constant_expressionContext::NOTEQUAL() {
  return getToken(SV3_1aParser::NOTEQUAL, 0);
}

tree::TerminalNode* SV3_1aParser::Constant_expressionContext::BINARY_WILDCARD_EQUAL() {
  return getToken(SV3_1aParser::BINARY_WILDCARD_EQUAL, 0);
}

tree::TerminalNode* SV3_1aParser::Constant_expressionContext::BINARY_WILDCARD_NOTEQUAL() {
  return getToken(SV3_1aParser::BINARY_WILDCARD_NOTEQUAL, 0);
}

tree::TerminalNode* SV3_1aParser::Constant_expressionContext::FOUR_STATE_LOGIC_EQUAL() {
  return getToken(SV3_1aParser::FOUR_STATE_LOGIC_EQUAL, 0);
}

tree::TerminalNode* SV3_1aParser::Constant_expressionContext::FOUR_STATE_LOGIC_NOTEQUAL() {
  return getToken(SV3_1aParser::FOUR_STATE_LOGIC_NOTEQUAL, 0);
}

tree::TerminalNode* SV3_1aParser::Constant_expressionContext::WILD_EQUAL_OP() {
  return getToken(SV3_1aParser::WILD_EQUAL_OP, 0);
}

tree::TerminalNode* SV3_1aParser::Constant_expressionContext::WILD_NOTEQUAL_OP() {
  return getToken(SV3_1aParser::WILD_NOTEQUAL_OP, 0);
}

std::vector<tree::TerminalNode *> SV3_1aParser::Constant_expressionContext::LOGICAL_AND() {
  return getTokens(SV3_1aParser::LOGICAL_AND);
}

tree::TerminalNode* SV3_1aParser::Constant_expressionContext::LOGICAL_AND(size_t i) {
  return getToken(SV3_1aParser::LOGICAL_AND, i);
}

tree::TerminalNode* SV3_1aParser::Constant_expressionContext::LOGICAL_OR() {
  return getToken(SV3_1aParser::LOGICAL_OR, 0);
}

SV3_1aParser::Conditional_operatorContext* SV3_1aParser::Constant_expressionContext::conditional_operator() {
  return getRuleContext<SV3_1aParser::Conditional_operatorContext>(0);
}

std::vector<SV3_1aParser::ExpressionContext *> SV3_1aParser::Constant_expressionContext::expression() {
  return getRuleContexts<SV3_1aParser::ExpressionContext>();
}

SV3_1aParser::ExpressionContext* SV3_1aParser::Constant_expressionContext::expression(size_t i) {
  return getRuleContext<SV3_1aParser::ExpressionContext>(i);
}

tree::TerminalNode* SV3_1aParser::Constant_expressionContext::COLON() {
  return getToken(SV3_1aParser::COLON, 0);
}

tree::TerminalNode* SV3_1aParser::Constant_expressionContext::IMPLY() {
  return getToken(SV3_1aParser::IMPLY, 0);
}

tree::TerminalNode* SV3_1aParser::Constant_expressionContext::EQUIVALENCE() {
  return getToken(SV3_1aParser::EQUIVALENCE, 0);
}


size_t SV3_1aParser::Constant_expressionContext::getRuleIndex() const {
  return SV3_1aParser::RuleConstant_expression;
}

void SV3_1aParser::Constant_expressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterConstant_expression(this);
}

void SV3_1aParser::Constant_expressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitConstant_expression(this);
}


SV3_1aParser::Constant_expressionContext* SV3_1aParser::constant_expression() {
   return constant_expression(0);
}

SV3_1aParser::Constant_expressionContext* SV3_1aParser::constant_expression(int precedence) {
  ParserRuleContext *parentContext = _ctx;
  size_t parentState = getState();
  SV3_1aParser::Constant_expressionContext *_localctx = _tracker.createInstance<Constant_expressionContext>(_ctx, parentState);
  SV3_1aParser::Constant_expressionContext *previousContext = _localctx;
  (void)previousContext; // Silence compiler, in case the context is not used by generated code.
  size_t startState = 1144;
  enterRecursionRule(_localctx, 1144, SV3_1aParser::RuleConstant_expression, precedence);

    size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    unrollRecursionContexts(parentContext);
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(8687);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1031, _ctx)) {
    case 1: {
      setState(8677);
      constant_primary();
      break;
    }

    case 2: {
      setState(8678);
      _la = _input->LA(1);
      if (!(((((_la - 173) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 173)) & 144115188075855877) != 0) || ((((_la - 355) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 355)) & 7199) != 0))) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(8682);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == SV3_1aParser::OPEN_PARENS_STAR) {
        setState(8679);
        attribute_instance();
        setState(8684);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(8685);
      constant_primary();
      break;
    }

    case 3: {
      setState(8686);
      system_task();
      break;
    }

    default:
      break;
    }
    _ctx->stop = _input->LT(-1);
    setState(8818);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1047, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        if (!_parseListeners.empty())
          triggerExitRuleEvent();
        previousContext = _localctx;
        setState(8816);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1046, _ctx)) {
        case 1: {
          _localctx = _tracker.createInstance<Constant_expressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleConstant_expression);
          setState(8689);

          if (!(precpred(_ctx, 14))) throw FailedPredicateException(this, "precpred(_ctx, 14)");
          setState(8690);
          match(SV3_1aParser::STARSTAR);
          setState(8694);
          _errHandler->sync(this);
          _la = _input->LA(1);
          while (_la == SV3_1aParser::OPEN_PARENS_STAR) {
            setState(8691);
            attribute_instance();
            setState(8696);
            _errHandler->sync(this);
            _la = _input->LA(1);
          }
          setState(8697);
          constant_expression(15);
          break;
        }

        case 2: {
          _localctx = _tracker.createInstance<Constant_expressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleConstant_expression);
          setState(8698);

          if (!(precpred(_ctx, 13))) throw FailedPredicateException(this, "precpred(_ctx, 13)");
          setState(8699);
          _la = _input->LA(1);
          if (!(_la == SV3_1aParser::STAR || _la == SV3_1aParser::DIV

          || _la == SV3_1aParser::PERCENT)) {
          _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
          setState(8703);
          _errHandler->sync(this);
          _la = _input->LA(1);
          while (_la == SV3_1aParser::OPEN_PARENS_STAR) {
            setState(8700);
            attribute_instance();
            setState(8705);
            _errHandler->sync(this);
            _la = _input->LA(1);
          }
          setState(8706);
          constant_expression(14);
          break;
        }

        case 3: {
          _localctx = _tracker.createInstance<Constant_expressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleConstant_expression);
          setState(8707);

          if (!(precpred(_ctx, 12))) throw FailedPredicateException(this, "precpred(_ctx, 12)");
          setState(8708);
          _la = _input->LA(1);
          if (!(_la == SV3_1aParser::PLUS

          || _la == SV3_1aParser::MINUS)) {
          _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
          setState(8712);
          _errHandler->sync(this);
          _la = _input->LA(1);
          while (_la == SV3_1aParser::OPEN_PARENS_STAR) {
            setState(8709);
            attribute_instance();
            setState(8714);
            _errHandler->sync(this);
            _la = _input->LA(1);
          }
          setState(8715);
          constant_expression(13);
          break;
        }

        case 4: {
          _localctx = _tracker.createInstance<Constant_expressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleConstant_expression);
          setState(8716);

          if (!(precpred(_ctx, 11))) throw FailedPredicateException(this, "precpred(_ctx, 11)");
          setState(8717);
          _la = _input->LA(1);
          if (!(((((_la - 319) & ~ 0x3fULL) == 0) &&
            ((1ULL << (_la - 319)) & 201326595) != 0))) {
          _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
          setState(8721);
          _errHandler->sync(this);
          _la = _input->LA(1);
          while (_la == SV3_1aParser::OPEN_PARENS_STAR) {
            setState(8718);
            attribute_instance();
            setState(8723);
            _errHandler->sync(this);
            _la = _input->LA(1);
          }
          setState(8724);
          constant_expression(12);
          break;
        }

        case 5: {
          _localctx = _tracker.createInstance<Constant_expressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleConstant_expression);
          setState(8725);

          if (!(precpred(_ctx, 10))) throw FailedPredicateException(this, "precpred(_ctx, 10)");
          setState(8726);
          _la = _input->LA(1);
          if (!(((((_la - 182) & ~ 0x3fULL) == 0) &&
            ((1ULL << (_la - 182)) & 23) != 0) || _la == SV3_1aParser::INSIDE)) {
          _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
          setState(8730);
          _errHandler->sync(this);
          _la = _input->LA(1);
          while (_la == SV3_1aParser::OPEN_PARENS_STAR) {
            setState(8727);
            attribute_instance();
            setState(8732);
            _errHandler->sync(this);
            _la = _input->LA(1);
          }
          setState(8733);
          constant_expression(11);
          break;
        }

        case 6: {
          _localctx = _tracker.createInstance<Constant_expressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleConstant_expression);
          setState(8734);

          if (!(precpred(_ctx, 9))) throw FailedPredicateException(this, "precpred(_ctx, 9)");
          setState(8735);
          _la = _input->LA(1);
          if (!(_la == SV3_1aParser::EQUIV

          || _la == SV3_1aParser::NOTEQUAL || ((((_la - 349) & ~ 0x3fULL) == 0) &&
            ((1ULL << (_la - 349)) & 6159) != 0))) {
          _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
          setState(8739);
          _errHandler->sync(this);
          _la = _input->LA(1);
          while (_la == SV3_1aParser::OPEN_PARENS_STAR) {
            setState(8736);
            attribute_instance();
            setState(8741);
            _errHandler->sync(this);
            _la = _input->LA(1);
          }
          setState(8742);
          constant_expression(10);
          break;
        }

        case 7: {
          _localctx = _tracker.createInstance<Constant_expressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleConstant_expression);
          setState(8743);

          if (!(precpred(_ctx, 8))) throw FailedPredicateException(this, "precpred(_ctx, 8)");
          setState(8744);
          match(SV3_1aParser::BITW_AND);
          setState(8748);
          _errHandler->sync(this);
          _la = _input->LA(1);
          while (_la == SV3_1aParser::OPEN_PARENS_STAR) {
            setState(8745);
            attribute_instance();
            setState(8750);
            _errHandler->sync(this);
            _la = _input->LA(1);
          }
          setState(8751);
          constant_expression(9);
          break;
        }

        case 8: {
          _localctx = _tracker.createInstance<Constant_expressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleConstant_expression);
          setState(8752);

          if (!(precpred(_ctx, 7))) throw FailedPredicateException(this, "precpred(_ctx, 7)");
          setState(8753);
          _la = _input->LA(1);
          if (!(((((_la - 357) & ~ 0x3fULL) == 0) &&
            ((1ULL << (_la - 357)) & 1543) != 0))) {
          _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
          setState(8757);
          _errHandler->sync(this);
          _la = _input->LA(1);
          while (_la == SV3_1aParser::OPEN_PARENS_STAR) {
            setState(8754);
            attribute_instance();
            setState(8759);
            _errHandler->sync(this);
            _la = _input->LA(1);
          }
          setState(8760);
          constant_expression(8);
          break;
        }

        case 9: {
          _localctx = _tracker.createInstance<Constant_expressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleConstant_expression);
          setState(8761);

          if (!(precpred(_ctx, 6))) throw FailedPredicateException(this, "precpred(_ctx, 6)");
          setState(8762);
          match(SV3_1aParser::BITW_OR);
          setState(8766);
          _errHandler->sync(this);
          _la = _input->LA(1);
          while (_la == SV3_1aParser::OPEN_PARENS_STAR) {
            setState(8763);
            attribute_instance();
            setState(8768);
            _errHandler->sync(this);
            _la = _input->LA(1);
          }
          setState(8769);
          constant_expression(7);
          break;
        }

        case 10: {
          _localctx = _tracker.createInstance<Constant_expressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleConstant_expression);
          setState(8770);

          if (!(precpred(_ctx, 5))) throw FailedPredicateException(this, "precpred(_ctx, 5)");
          setState(8771);
          match(SV3_1aParser::LOGICAL_AND);
          setState(8775);
          _errHandler->sync(this);
          _la = _input->LA(1);
          while (_la == SV3_1aParser::OPEN_PARENS_STAR) {
            setState(8772);
            attribute_instance();
            setState(8777);
            _errHandler->sync(this);
            _la = _input->LA(1);
          }
          setState(8778);
          constant_expression(6);
          break;
        }

        case 11: {
          _localctx = _tracker.createInstance<Constant_expressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleConstant_expression);
          setState(8779);

          if (!(precpred(_ctx, 4))) throw FailedPredicateException(this, "precpred(_ctx, 4)");
          setState(8780);
          match(SV3_1aParser::LOGICAL_OR);
          setState(8784);
          _errHandler->sync(this);
          _la = _input->LA(1);
          while (_la == SV3_1aParser::OPEN_PARENS_STAR) {
            setState(8781);
            attribute_instance();
            setState(8786);
            _errHandler->sync(this);
            _la = _input->LA(1);
          }
          setState(8787);
          constant_expression(5);
          break;
        }

        case 12: {
          _localctx = _tracker.createInstance<Constant_expressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleConstant_expression);
          setState(8788);

          if (!(precpred(_ctx, 3))) throw FailedPredicateException(this, "precpred(_ctx, 3)");
          setState(8793);
          _errHandler->sync(this);
          _la = _input->LA(1);
          while (_la == SV3_1aParser::LOGICAL_AND) {
            setState(8789);
            match(SV3_1aParser::LOGICAL_AND);
            setState(8790);
            expression(0);
            setState(8795);
            _errHandler->sync(this);
            _la = _input->LA(1);
          }
          setState(8796);
          conditional_operator();
          setState(8800);
          _errHandler->sync(this);
          _la = _input->LA(1);
          while (_la == SV3_1aParser::OPEN_PARENS_STAR) {
            setState(8797);
            attribute_instance();
            setState(8802);
            _errHandler->sync(this);
            _la = _input->LA(1);
          }
          setState(8803);
          expression(0);
          setState(8804);
          match(SV3_1aParser::COLON);
          setState(8805);
          constant_expression(3);
          break;
        }

        case 13: {
          _localctx = _tracker.createInstance<Constant_expressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleConstant_expression);
          setState(8807);

          if (!(precpred(_ctx, 2))) throw FailedPredicateException(this, "precpred(_ctx, 2)");
          setState(8808);
          _la = _input->LA(1);
          if (!(_la == SV3_1aParser::IMPLY || _la == SV3_1aParser::EQUIVALENCE)) {
          _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
          setState(8812);
          _errHandler->sync(this);
          _la = _input->LA(1);
          while (_la == SV3_1aParser::OPEN_PARENS_STAR) {
            setState(8809);
            attribute_instance();
            setState(8814);
            _errHandler->sync(this);
            _la = _input->LA(1);
          }
          setState(8815);
          constant_expression(2);
          break;
        }

        default:
          break;
        } 
      }
      setState(8820);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1047, _ctx);
    }
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }
  return _localctx;
}

//----------------- Conditional_operatorContext ------------------------------------------------------------------

SV3_1aParser::Conditional_operatorContext::Conditional_operatorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Conditional_operatorContext::QMARK() {
  return getToken(SV3_1aParser::QMARK, 0);
}


size_t SV3_1aParser::Conditional_operatorContext::getRuleIndex() const {
  return SV3_1aParser::RuleConditional_operator;
}

void SV3_1aParser::Conditional_operatorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterConditional_operator(this);
}

void SV3_1aParser::Conditional_operatorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitConditional_operator(this);
}

SV3_1aParser::Conditional_operatorContext* SV3_1aParser::conditional_operator() {
  Conditional_operatorContext *_localctx = _tracker.createInstance<Conditional_operatorContext>(_ctx, getState());
  enterRule(_localctx, 1146, SV3_1aParser::RuleConditional_operator);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8821);
    match(SV3_1aParser::QMARK);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Constant_mintypmax_expressionContext ------------------------------------------------------------------

SV3_1aParser::Constant_mintypmax_expressionContext::Constant_mintypmax_expressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<SV3_1aParser::Constant_expressionContext *> SV3_1aParser::Constant_mintypmax_expressionContext::constant_expression() {
  return getRuleContexts<SV3_1aParser::Constant_expressionContext>();
}

SV3_1aParser::Constant_expressionContext* SV3_1aParser::Constant_mintypmax_expressionContext::constant_expression(size_t i) {
  return getRuleContext<SV3_1aParser::Constant_expressionContext>(i);
}

std::vector<tree::TerminalNode *> SV3_1aParser::Constant_mintypmax_expressionContext::COLON() {
  return getTokens(SV3_1aParser::COLON);
}

tree::TerminalNode* SV3_1aParser::Constant_mintypmax_expressionContext::COLON(size_t i) {
  return getToken(SV3_1aParser::COLON, i);
}


size_t SV3_1aParser::Constant_mintypmax_expressionContext::getRuleIndex() const {
  return SV3_1aParser::RuleConstant_mintypmax_expression;
}

void SV3_1aParser::Constant_mintypmax_expressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterConstant_mintypmax_expression(this);
}

void SV3_1aParser::Constant_mintypmax_expressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitConstant_mintypmax_expression(this);
}

SV3_1aParser::Constant_mintypmax_expressionContext* SV3_1aParser::constant_mintypmax_expression() {
  Constant_mintypmax_expressionContext *_localctx = _tracker.createInstance<Constant_mintypmax_expressionContext>(_ctx, getState());
  enterRule(_localctx, 1148, SV3_1aParser::RuleConstant_mintypmax_expression);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8823);
    constant_expression(0);
    setState(8829);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SV3_1aParser::COLON) {
      setState(8824);
      match(SV3_1aParser::COLON);
      setState(8825);
      constant_expression(0);
      setState(8826);
      match(SV3_1aParser::COLON);
      setState(8827);
      constant_expression(0);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Constant_param_expressionContext ------------------------------------------------------------------

SV3_1aParser::Constant_param_expressionContext::Constant_param_expressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::Constant_mintypmax_expressionContext* SV3_1aParser::Constant_param_expressionContext::constant_mintypmax_expression() {
  return getRuleContext<SV3_1aParser::Constant_mintypmax_expressionContext>(0);
}

SV3_1aParser::Data_typeContext* SV3_1aParser::Constant_param_expressionContext::data_type() {
  return getRuleContext<SV3_1aParser::Data_typeContext>(0);
}

tree::TerminalNode* SV3_1aParser::Constant_param_expressionContext::DOLLAR() {
  return getToken(SV3_1aParser::DOLLAR, 0);
}


size_t SV3_1aParser::Constant_param_expressionContext::getRuleIndex() const {
  return SV3_1aParser::RuleConstant_param_expression;
}

void SV3_1aParser::Constant_param_expressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterConstant_param_expression(this);
}

void SV3_1aParser::Constant_param_expressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitConstant_param_expression(this);
}

SV3_1aParser::Constant_param_expressionContext* SV3_1aParser::constant_param_expression() {
  Constant_param_expressionContext *_localctx = _tracker.createInstance<Constant_param_expressionContext>(_ctx, getState());
  enterRule(_localctx, 1150, SV3_1aParser::RuleConstant_param_expression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(8834);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1049, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(8831);
      constant_mintypmax_expression();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(8832);
      data_type();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(8833);
      match(SV3_1aParser::DOLLAR);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Param_expressionContext ------------------------------------------------------------------

SV3_1aParser::Param_expressionContext::Param_expressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::Mintypmax_expressionContext* SV3_1aParser::Param_expressionContext::mintypmax_expression() {
  return getRuleContext<SV3_1aParser::Mintypmax_expressionContext>(0);
}

SV3_1aParser::Data_typeContext* SV3_1aParser::Param_expressionContext::data_type() {
  return getRuleContext<SV3_1aParser::Data_typeContext>(0);
}

tree::TerminalNode* SV3_1aParser::Param_expressionContext::DOLLAR() {
  return getToken(SV3_1aParser::DOLLAR, 0);
}


size_t SV3_1aParser::Param_expressionContext::getRuleIndex() const {
  return SV3_1aParser::RuleParam_expression;
}

void SV3_1aParser::Param_expressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterParam_expression(this);
}

void SV3_1aParser::Param_expressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitParam_expression(this);
}

SV3_1aParser::Param_expressionContext* SV3_1aParser::param_expression() {
  Param_expressionContext *_localctx = _tracker.createInstance<Param_expressionContext>(_ctx, getState());
  enterRule(_localctx, 1152, SV3_1aParser::RuleParam_expression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(8839);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1050, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(8836);
      mintypmax_expression();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(8837);
      data_type();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(8838);
      match(SV3_1aParser::DOLLAR);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Constant_range_expressionContext ------------------------------------------------------------------

SV3_1aParser::Constant_range_expressionContext::Constant_range_expressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::Constant_expressionContext* SV3_1aParser::Constant_range_expressionContext::constant_expression() {
  return getRuleContext<SV3_1aParser::Constant_expressionContext>(0);
}

SV3_1aParser::Constant_part_select_rangeContext* SV3_1aParser::Constant_range_expressionContext::constant_part_select_range() {
  return getRuleContext<SV3_1aParser::Constant_part_select_rangeContext>(0);
}


size_t SV3_1aParser::Constant_range_expressionContext::getRuleIndex() const {
  return SV3_1aParser::RuleConstant_range_expression;
}

void SV3_1aParser::Constant_range_expressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterConstant_range_expression(this);
}

void SV3_1aParser::Constant_range_expressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitConstant_range_expression(this);
}

SV3_1aParser::Constant_range_expressionContext* SV3_1aParser::constant_range_expression() {
  Constant_range_expressionContext *_localctx = _tracker.createInstance<Constant_range_expressionContext>(_ctx, getState());
  enterRule(_localctx, 1154, SV3_1aParser::RuleConstant_range_expression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(8843);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1051, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(8841);
      constant_expression(0);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(8842);
      constant_part_select_range();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Constant_part_select_rangeContext ------------------------------------------------------------------

SV3_1aParser::Constant_part_select_rangeContext::Constant_part_select_rangeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::Constant_rangeContext* SV3_1aParser::Constant_part_select_rangeContext::constant_range() {
  return getRuleContext<SV3_1aParser::Constant_rangeContext>(0);
}

SV3_1aParser::Constant_indexed_rangeContext* SV3_1aParser::Constant_part_select_rangeContext::constant_indexed_range() {
  return getRuleContext<SV3_1aParser::Constant_indexed_rangeContext>(0);
}


size_t SV3_1aParser::Constant_part_select_rangeContext::getRuleIndex() const {
  return SV3_1aParser::RuleConstant_part_select_range;
}

void SV3_1aParser::Constant_part_select_rangeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterConstant_part_select_range(this);
}

void SV3_1aParser::Constant_part_select_rangeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitConstant_part_select_range(this);
}

SV3_1aParser::Constant_part_select_rangeContext* SV3_1aParser::constant_part_select_range() {
  Constant_part_select_rangeContext *_localctx = _tracker.createInstance<Constant_part_select_rangeContext>(_ctx, getState());
  enterRule(_localctx, 1156, SV3_1aParser::RuleConstant_part_select_range);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(8847);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1052, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(8845);
      constant_range();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(8846);
      constant_indexed_range();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Constant_rangeContext ------------------------------------------------------------------

SV3_1aParser::Constant_rangeContext::Constant_rangeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<SV3_1aParser::Constant_expressionContext *> SV3_1aParser::Constant_rangeContext::constant_expression() {
  return getRuleContexts<SV3_1aParser::Constant_expressionContext>();
}

SV3_1aParser::Constant_expressionContext* SV3_1aParser::Constant_rangeContext::constant_expression(size_t i) {
  return getRuleContext<SV3_1aParser::Constant_expressionContext>(i);
}

tree::TerminalNode* SV3_1aParser::Constant_rangeContext::COLON() {
  return getToken(SV3_1aParser::COLON, 0);
}


size_t SV3_1aParser::Constant_rangeContext::getRuleIndex() const {
  return SV3_1aParser::RuleConstant_range;
}

void SV3_1aParser::Constant_rangeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterConstant_range(this);
}

void SV3_1aParser::Constant_rangeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitConstant_range(this);
}

SV3_1aParser::Constant_rangeContext* SV3_1aParser::constant_range() {
  Constant_rangeContext *_localctx = _tracker.createInstance<Constant_rangeContext>(_ctx, getState());
  enterRule(_localctx, 1158, SV3_1aParser::RuleConstant_range);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8849);
    constant_expression(0);
    setState(8850);
    match(SV3_1aParser::COLON);
    setState(8851);
    constant_expression(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Constant_indexed_rangeContext ------------------------------------------------------------------

SV3_1aParser::Constant_indexed_rangeContext::Constant_indexed_rangeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<SV3_1aParser::Constant_expressionContext *> SV3_1aParser::Constant_indexed_rangeContext::constant_expression() {
  return getRuleContexts<SV3_1aParser::Constant_expressionContext>();
}

SV3_1aParser::Constant_expressionContext* SV3_1aParser::Constant_indexed_rangeContext::constant_expression(size_t i) {
  return getRuleContext<SV3_1aParser::Constant_expressionContext>(i);
}

SV3_1aParser::Part_select_opContext* SV3_1aParser::Constant_indexed_rangeContext::part_select_op() {
  return getRuleContext<SV3_1aParser::Part_select_opContext>(0);
}


size_t SV3_1aParser::Constant_indexed_rangeContext::getRuleIndex() const {
  return SV3_1aParser::RuleConstant_indexed_range;
}

void SV3_1aParser::Constant_indexed_rangeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterConstant_indexed_range(this);
}

void SV3_1aParser::Constant_indexed_rangeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitConstant_indexed_range(this);
}

SV3_1aParser::Constant_indexed_rangeContext* SV3_1aParser::constant_indexed_range() {
  Constant_indexed_rangeContext *_localctx = _tracker.createInstance<Constant_indexed_rangeContext>(_ctx, getState());
  enterRule(_localctx, 1160, SV3_1aParser::RuleConstant_indexed_range);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8853);
    constant_expression(0);
    setState(8854);
    part_select_op();
    setState(8855);
    constant_expression(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ExpressionContext ------------------------------------------------------------------

SV3_1aParser::ExpressionContext::ExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::PrimaryContext* SV3_1aParser::ExpressionContext::primary() {
  return getRuleContext<SV3_1aParser::PrimaryContext>(0);
}

tree::TerminalNode* SV3_1aParser::ExpressionContext::OPEN_PARENS() {
  return getToken(SV3_1aParser::OPEN_PARENS, 0);
}

std::vector<SV3_1aParser::ExpressionContext *> SV3_1aParser::ExpressionContext::expression() {
  return getRuleContexts<SV3_1aParser::ExpressionContext>();
}

SV3_1aParser::ExpressionContext* SV3_1aParser::ExpressionContext::expression(size_t i) {
  return getRuleContext<SV3_1aParser::ExpressionContext>(i);
}

tree::TerminalNode* SV3_1aParser::ExpressionContext::CLOSE_PARENS() {
  return getToken(SV3_1aParser::CLOSE_PARENS, 0);
}

tree::TerminalNode* SV3_1aParser::ExpressionContext::PLUS() {
  return getToken(SV3_1aParser::PLUS, 0);
}

tree::TerminalNode* SV3_1aParser::ExpressionContext::MINUS() {
  return getToken(SV3_1aParser::MINUS, 0);
}

tree::TerminalNode* SV3_1aParser::ExpressionContext::BANG() {
  return getToken(SV3_1aParser::BANG, 0);
}

tree::TerminalNode* SV3_1aParser::ExpressionContext::TILDA() {
  return getToken(SV3_1aParser::TILDA, 0);
}

tree::TerminalNode* SV3_1aParser::ExpressionContext::BITW_AND() {
  return getToken(SV3_1aParser::BITW_AND, 0);
}

tree::TerminalNode* SV3_1aParser::ExpressionContext::BITW_OR() {
  return getToken(SV3_1aParser::BITW_OR, 0);
}

tree::TerminalNode* SV3_1aParser::ExpressionContext::BITW_XOR() {
  return getToken(SV3_1aParser::BITW_XOR, 0);
}

tree::TerminalNode* SV3_1aParser::ExpressionContext::REDUCTION_NAND() {
  return getToken(SV3_1aParser::REDUCTION_NAND, 0);
}

tree::TerminalNode* SV3_1aParser::ExpressionContext::REDUCTION_NOR() {
  return getToken(SV3_1aParser::REDUCTION_NOR, 0);
}

tree::TerminalNode* SV3_1aParser::ExpressionContext::REDUCTION_XNOR1() {
  return getToken(SV3_1aParser::REDUCTION_XNOR1, 0);
}

tree::TerminalNode* SV3_1aParser::ExpressionContext::REDUCTION_XNOR2() {
  return getToken(SV3_1aParser::REDUCTION_XNOR2, 0);
}

std::vector<SV3_1aParser::Attribute_instanceContext *> SV3_1aParser::ExpressionContext::attribute_instance() {
  return getRuleContexts<SV3_1aParser::Attribute_instanceContext>();
}

SV3_1aParser::Attribute_instanceContext* SV3_1aParser::ExpressionContext::attribute_instance(size_t i) {
  return getRuleContext<SV3_1aParser::Attribute_instanceContext>(i);
}

SV3_1aParser::Variable_lvalueContext* SV3_1aParser::ExpressionContext::variable_lvalue() {
  return getRuleContext<SV3_1aParser::Variable_lvalueContext>(0);
}

tree::TerminalNode* SV3_1aParser::ExpressionContext::PLUSPLUS() {
  return getToken(SV3_1aParser::PLUSPLUS, 0);
}

tree::TerminalNode* SV3_1aParser::ExpressionContext::MINUSMINUS() {
  return getToken(SV3_1aParser::MINUSMINUS, 0);
}

tree::TerminalNode* SV3_1aParser::ExpressionContext::ASSIGN_OP() {
  return getToken(SV3_1aParser::ASSIGN_OP, 0);
}

tree::TerminalNode* SV3_1aParser::ExpressionContext::ADD_ASSIGN() {
  return getToken(SV3_1aParser::ADD_ASSIGN, 0);
}

tree::TerminalNode* SV3_1aParser::ExpressionContext::SUB_ASSIGN() {
  return getToken(SV3_1aParser::SUB_ASSIGN, 0);
}

tree::TerminalNode* SV3_1aParser::ExpressionContext::MULT_ASSIGN() {
  return getToken(SV3_1aParser::MULT_ASSIGN, 0);
}

tree::TerminalNode* SV3_1aParser::ExpressionContext::DIV_ASSIGN() {
  return getToken(SV3_1aParser::DIV_ASSIGN, 0);
}

tree::TerminalNode* SV3_1aParser::ExpressionContext::MODULO_ASSIGN() {
  return getToken(SV3_1aParser::MODULO_ASSIGN, 0);
}

tree::TerminalNode* SV3_1aParser::ExpressionContext::BITW_AND_ASSIGN() {
  return getToken(SV3_1aParser::BITW_AND_ASSIGN, 0);
}

tree::TerminalNode* SV3_1aParser::ExpressionContext::BITW_OR_ASSIGN() {
  return getToken(SV3_1aParser::BITW_OR_ASSIGN, 0);
}

tree::TerminalNode* SV3_1aParser::ExpressionContext::BITW_XOR_ASSIGN() {
  return getToken(SV3_1aParser::BITW_XOR_ASSIGN, 0);
}

tree::TerminalNode* SV3_1aParser::ExpressionContext::BITW_LEFT_SHIFT_ASSIGN() {
  return getToken(SV3_1aParser::BITW_LEFT_SHIFT_ASSIGN, 0);
}

tree::TerminalNode* SV3_1aParser::ExpressionContext::BITW_RIGHT_SHIFT_ASSIGN() {
  return getToken(SV3_1aParser::BITW_RIGHT_SHIFT_ASSIGN, 0);
}

tree::TerminalNode* SV3_1aParser::ExpressionContext::ARITH_SHIFT_LEFT_ASSIGN() {
  return getToken(SV3_1aParser::ARITH_SHIFT_LEFT_ASSIGN, 0);
}

tree::TerminalNode* SV3_1aParser::ExpressionContext::ARITH_SHIFT_RIGHT_ASSIGN() {
  return getToken(SV3_1aParser::ARITH_SHIFT_RIGHT_ASSIGN, 0);
}

tree::TerminalNode* SV3_1aParser::ExpressionContext::MATCHES() {
  return getToken(SV3_1aParser::MATCHES, 0);
}

SV3_1aParser::PatternContext* SV3_1aParser::ExpressionContext::pattern() {
  return getRuleContext<SV3_1aParser::PatternContext>(0);
}

tree::TerminalNode* SV3_1aParser::ExpressionContext::QMARK() {
  return getToken(SV3_1aParser::QMARK, 0);
}

tree::TerminalNode* SV3_1aParser::ExpressionContext::COLON() {
  return getToken(SV3_1aParser::COLON, 0);
}

std::vector<tree::TerminalNode *> SV3_1aParser::ExpressionContext::LOGICAL_AND() {
  return getTokens(SV3_1aParser::LOGICAL_AND);
}

tree::TerminalNode* SV3_1aParser::ExpressionContext::LOGICAL_AND(size_t i) {
  return getToken(SV3_1aParser::LOGICAL_AND, i);
}

tree::TerminalNode* SV3_1aParser::ExpressionContext::TAGGED() {
  return getToken(SV3_1aParser::TAGGED, 0);
}

SV3_1aParser::IdentifierContext* SV3_1aParser::ExpressionContext::identifier() {
  return getRuleContext<SV3_1aParser::IdentifierContext>(0);
}

tree::TerminalNode* SV3_1aParser::ExpressionContext::STARSTAR() {
  return getToken(SV3_1aParser::STARSTAR, 0);
}

tree::TerminalNode* SV3_1aParser::ExpressionContext::STAR() {
  return getToken(SV3_1aParser::STAR, 0);
}

tree::TerminalNode* SV3_1aParser::ExpressionContext::DIV() {
  return getToken(SV3_1aParser::DIV, 0);
}

tree::TerminalNode* SV3_1aParser::ExpressionContext::PERCENT() {
  return getToken(SV3_1aParser::PERCENT, 0);
}

tree::TerminalNode* SV3_1aParser::ExpressionContext::SHIFT_RIGHT() {
  return getToken(SV3_1aParser::SHIFT_RIGHT, 0);
}

tree::TerminalNode* SV3_1aParser::ExpressionContext::SHIFT_LEFT() {
  return getToken(SV3_1aParser::SHIFT_LEFT, 0);
}

tree::TerminalNode* SV3_1aParser::ExpressionContext::ARITH_SHIFT_RIGHT() {
  return getToken(SV3_1aParser::ARITH_SHIFT_RIGHT, 0);
}

tree::TerminalNode* SV3_1aParser::ExpressionContext::ARITH_SHIFT_LEFT() {
  return getToken(SV3_1aParser::ARITH_SHIFT_LEFT, 0);
}

tree::TerminalNode* SV3_1aParser::ExpressionContext::LESS() {
  return getToken(SV3_1aParser::LESS, 0);
}

tree::TerminalNode* SV3_1aParser::ExpressionContext::LESS_EQUAL() {
  return getToken(SV3_1aParser::LESS_EQUAL, 0);
}

tree::TerminalNode* SV3_1aParser::ExpressionContext::GREATER() {
  return getToken(SV3_1aParser::GREATER, 0);
}

tree::TerminalNode* SV3_1aParser::ExpressionContext::GREATER_EQUAL() {
  return getToken(SV3_1aParser::GREATER_EQUAL, 0);
}

tree::TerminalNode* SV3_1aParser::ExpressionContext::INSIDE() {
  return getToken(SV3_1aParser::INSIDE, 0);
}

tree::TerminalNode* SV3_1aParser::ExpressionContext::EQUIV() {
  return getToken(SV3_1aParser::EQUIV, 0);
}

tree::TerminalNode* SV3_1aParser::ExpressionContext::NOTEQUAL() {
  return getToken(SV3_1aParser::NOTEQUAL, 0);
}

tree::TerminalNode* SV3_1aParser::ExpressionContext::BINARY_WILDCARD_EQUAL() {
  return getToken(SV3_1aParser::BINARY_WILDCARD_EQUAL, 0);
}

tree::TerminalNode* SV3_1aParser::ExpressionContext::BINARY_WILDCARD_NOTEQUAL() {
  return getToken(SV3_1aParser::BINARY_WILDCARD_NOTEQUAL, 0);
}

tree::TerminalNode* SV3_1aParser::ExpressionContext::FOUR_STATE_LOGIC_EQUAL() {
  return getToken(SV3_1aParser::FOUR_STATE_LOGIC_EQUAL, 0);
}

tree::TerminalNode* SV3_1aParser::ExpressionContext::FOUR_STATE_LOGIC_NOTEQUAL() {
  return getToken(SV3_1aParser::FOUR_STATE_LOGIC_NOTEQUAL, 0);
}

tree::TerminalNode* SV3_1aParser::ExpressionContext::WILD_EQUAL_OP() {
  return getToken(SV3_1aParser::WILD_EQUAL_OP, 0);
}

tree::TerminalNode* SV3_1aParser::ExpressionContext::WILD_NOTEQUAL_OP() {
  return getToken(SV3_1aParser::WILD_NOTEQUAL_OP, 0);
}

tree::TerminalNode* SV3_1aParser::ExpressionContext::LOGICAL_OR() {
  return getToken(SV3_1aParser::LOGICAL_OR, 0);
}

tree::TerminalNode* SV3_1aParser::ExpressionContext::IMPLY() {
  return getToken(SV3_1aParser::IMPLY, 0);
}

tree::TerminalNode* SV3_1aParser::ExpressionContext::EQUIVALENCE() {
  return getToken(SV3_1aParser::EQUIVALENCE, 0);
}

tree::TerminalNode* SV3_1aParser::ExpressionContext::OPEN_CURLY() {
  return getToken(SV3_1aParser::OPEN_CURLY, 0);
}

SV3_1aParser::Open_range_listContext* SV3_1aParser::ExpressionContext::open_range_list() {
  return getRuleContext<SV3_1aParser::Open_range_listContext>(0);
}

tree::TerminalNode* SV3_1aParser::ExpressionContext::CLOSE_CURLY() {
  return getToken(SV3_1aParser::CLOSE_CURLY, 0);
}


size_t SV3_1aParser::ExpressionContext::getRuleIndex() const {
  return SV3_1aParser::RuleExpression;
}

void SV3_1aParser::ExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExpression(this);
}

void SV3_1aParser::ExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExpression(this);
}


SV3_1aParser::ExpressionContext* SV3_1aParser::expression() {
   return expression(0);
}

SV3_1aParser::ExpressionContext* SV3_1aParser::expression(int precedence) {
  ParserRuleContext *parentContext = _ctx;
  size_t parentState = getState();
  SV3_1aParser::ExpressionContext *_localctx = _tracker.createInstance<ExpressionContext>(_ctx, parentState);
  SV3_1aParser::ExpressionContext *previousContext = _localctx;
  (void)previousContext; // Silence compiler, in case the context is not used by generated code.
  size_t startState = 1162;
  enterRecursionRule(_localctx, 1162, SV3_1aParser::RuleExpression, precedence);

    size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    unrollRecursionContexts(parentContext);
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(8922);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1059, _ctx)) {
    case 1: {
      setState(8858);
      primary();
      break;
    }

    case 2: {
      setState(8859);
      match(SV3_1aParser::OPEN_PARENS);
      setState(8860);
      expression(0);
      setState(8861);
      match(SV3_1aParser::CLOSE_PARENS);
      break;
    }

    case 3: {
      setState(8863);
      _la = _input->LA(1);
      if (!(((((_la - 173) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 173)) & 144115188075855877) != 0) || ((((_la - 355) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 355)) & 7199) != 0))) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(8867);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == SV3_1aParser::OPEN_PARENS_STAR) {
        setState(8864);
        attribute_instance();
        setState(8869);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(8870);
      expression(21);
      break;
    }

    case 4: {
      setState(8871);
      _la = _input->LA(1);
      if (!(_la == SV3_1aParser::PLUSPLUS

      || _la == SV3_1aParser::MINUSMINUS)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(8875);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == SV3_1aParser::OPEN_PARENS_STAR) {
        setState(8872);
        attribute_instance();
        setState(8877);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(8878);
      variable_lvalue();
      break;
    }

    case 5: {
      setState(8879);
      variable_lvalue();
      setState(8883);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == SV3_1aParser::OPEN_PARENS_STAR) {
        setState(8880);
        attribute_instance();
        setState(8885);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(8886);
      _la = _input->LA(1);
      if (!(_la == SV3_1aParser::PLUSPLUS

      || _la == SV3_1aParser::MINUSMINUS)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      break;
    }

    case 6: {
      setState(8888);
      match(SV3_1aParser::OPEN_PARENS);
      setState(8889);
      variable_lvalue();
      setState(8890);
      _la = _input->LA(1);
      if (!(((((_la - 279) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 279)) & 1023) != 0) || ((((_la - 347) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 347)) & 32771) != 0))) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(8891);
      expression(0);
      setState(8892);
      match(SV3_1aParser::CLOSE_PARENS);
      break;
    }

    case 7: {
      setState(8894);
      match(SV3_1aParser::OPEN_PARENS);
      setState(8895);
      expression(0);
      setState(8896);
      match(SV3_1aParser::MATCHES);
      setState(8897);
      pattern();
      setState(8902);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == SV3_1aParser::LOGICAL_AND) {
        setState(8898);
        match(SV3_1aParser::LOGICAL_AND);
        setState(8899);
        expression(0);
        setState(8904);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(8905);
      match(SV3_1aParser::CLOSE_PARENS);
      setState(8906);
      match(SV3_1aParser::QMARK);
      setState(8910);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == SV3_1aParser::OPEN_PARENS_STAR) {
        setState(8907);
        attribute_instance();
        setState(8912);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(8913);
      expression(0);
      setState(8914);
      match(SV3_1aParser::COLON);
      setState(8915);
      expression(17);
      break;
    }

    case 8: {
      setState(8917);
      match(SV3_1aParser::TAGGED);
      setState(8918);
      identifier();
      setState(8920);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1058, _ctx)) {
      case 1: {
        setState(8919);
        expression(0);
        break;
      }

      default:
        break;
      }
      break;
    }

    default:
      break;
    }
    _ctx->stop = _input->LT(-1);
    setState(9080);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1077, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        if (!_parseListeners.empty())
          triggerExitRuleEvent();
        previousContext = _localctx;
        setState(9078);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1076, _ctx)) {
        case 1: {
          _localctx = _tracker.createInstance<ExpressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleExpression);
          setState(8924);

          if (!(precpred(_ctx, 15))) throw FailedPredicateException(this, "precpred(_ctx, 15)");
          setState(8925);
          match(SV3_1aParser::STARSTAR);
          setState(8929);
          _errHandler->sync(this);
          _la = _input->LA(1);
          while (_la == SV3_1aParser::OPEN_PARENS_STAR) {
            setState(8926);
            attribute_instance();
            setState(8931);
            _errHandler->sync(this);
            _la = _input->LA(1);
          }
          setState(8932);
          expression(16);
          break;
        }

        case 2: {
          _localctx = _tracker.createInstance<ExpressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleExpression);
          setState(8933);

          if (!(precpred(_ctx, 14))) throw FailedPredicateException(this, "precpred(_ctx, 14)");
          setState(8934);
          _la = _input->LA(1);
          if (!(_la == SV3_1aParser::STAR || _la == SV3_1aParser::DIV

          || _la == SV3_1aParser::PERCENT)) {
          _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
          setState(8938);
          _errHandler->sync(this);
          _la = _input->LA(1);
          while (_la == SV3_1aParser::OPEN_PARENS_STAR) {
            setState(8935);
            attribute_instance();
            setState(8940);
            _errHandler->sync(this);
            _la = _input->LA(1);
          }
          setState(8941);
          expression(15);
          break;
        }

        case 3: {
          _localctx = _tracker.createInstance<ExpressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleExpression);
          setState(8942);

          if (!(precpred(_ctx, 13))) throw FailedPredicateException(this, "precpred(_ctx, 13)");
          setState(8943);
          _la = _input->LA(1);
          if (!(_la == SV3_1aParser::PLUS

          || _la == SV3_1aParser::MINUS)) {
          _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
          setState(8947);
          _errHandler->sync(this);
          _la = _input->LA(1);
          while (_la == SV3_1aParser::OPEN_PARENS_STAR) {
            setState(8944);
            attribute_instance();
            setState(8949);
            _errHandler->sync(this);
            _la = _input->LA(1);
          }
          setState(8950);
          expression(14);
          break;
        }

        case 4: {
          _localctx = _tracker.createInstance<ExpressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleExpression);
          setState(8951);

          if (!(precpred(_ctx, 12))) throw FailedPredicateException(this, "precpred(_ctx, 12)");
          setState(8952);
          _la = _input->LA(1);
          if (!(((((_la - 319) & ~ 0x3fULL) == 0) &&
            ((1ULL << (_la - 319)) & 201326595) != 0))) {
          _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
          setState(8956);
          _errHandler->sync(this);
          _la = _input->LA(1);
          while (_la == SV3_1aParser::OPEN_PARENS_STAR) {
            setState(8953);
            attribute_instance();
            setState(8958);
            _errHandler->sync(this);
            _la = _input->LA(1);
          }
          setState(8959);
          expression(13);
          break;
        }

        case 5: {
          _localctx = _tracker.createInstance<ExpressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleExpression);
          setState(8960);

          if (!(precpred(_ctx, 11))) throw FailedPredicateException(this, "precpred(_ctx, 11)");
          setState(8961);
          _la = _input->LA(1);
          if (!(((((_la - 182) & ~ 0x3fULL) == 0) &&
            ((1ULL << (_la - 182)) & 23) != 0) || _la == SV3_1aParser::INSIDE)) {
          _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
          setState(8965);
          _errHandler->sync(this);
          _la = _input->LA(1);
          while (_la == SV3_1aParser::OPEN_PARENS_STAR) {
            setState(8962);
            attribute_instance();
            setState(8967);
            _errHandler->sync(this);
            _la = _input->LA(1);
          }
          setState(8968);
          expression(12);
          break;
        }

        case 6: {
          _localctx = _tracker.createInstance<ExpressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleExpression);
          setState(8969);

          if (!(precpred(_ctx, 10))) throw FailedPredicateException(this, "precpred(_ctx, 10)");
          setState(8970);
          _la = _input->LA(1);
          if (!(_la == SV3_1aParser::EQUIV

          || _la == SV3_1aParser::NOTEQUAL || ((((_la - 349) & ~ 0x3fULL) == 0) &&
            ((1ULL << (_la - 349)) & 6159) != 0))) {
          _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
          setState(8974);
          _errHandler->sync(this);
          _la = _input->LA(1);
          while (_la == SV3_1aParser::OPEN_PARENS_STAR) {
            setState(8971);
            attribute_instance();
            setState(8976);
            _errHandler->sync(this);
            _la = _input->LA(1);
          }
          setState(8977);
          expression(11);
          break;
        }

        case 7: {
          _localctx = _tracker.createInstance<ExpressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleExpression);
          setState(8978);

          if (!(precpred(_ctx, 9))) throw FailedPredicateException(this, "precpred(_ctx, 9)");
          setState(8979);
          match(SV3_1aParser::BITW_AND);
          setState(8983);
          _errHandler->sync(this);
          _la = _input->LA(1);
          while (_la == SV3_1aParser::OPEN_PARENS_STAR) {
            setState(8980);
            attribute_instance();
            setState(8985);
            _errHandler->sync(this);
            _la = _input->LA(1);
          }
          setState(8986);
          expression(10);
          break;
        }

        case 8: {
          _localctx = _tracker.createInstance<ExpressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleExpression);
          setState(8987);

          if (!(precpred(_ctx, 8))) throw FailedPredicateException(this, "precpred(_ctx, 8)");
          setState(8988);
          _la = _input->LA(1);
          if (!(((((_la - 357) & ~ 0x3fULL) == 0) &&
            ((1ULL << (_la - 357)) & 1543) != 0))) {
          _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
          setState(8992);
          _errHandler->sync(this);
          _la = _input->LA(1);
          while (_la == SV3_1aParser::OPEN_PARENS_STAR) {
            setState(8989);
            attribute_instance();
            setState(8994);
            _errHandler->sync(this);
            _la = _input->LA(1);
          }
          setState(8995);
          expression(9);
          break;
        }

        case 9: {
          _localctx = _tracker.createInstance<ExpressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleExpression);
          setState(8996);

          if (!(precpred(_ctx, 7))) throw FailedPredicateException(this, "precpred(_ctx, 7)");
          setState(8997);
          match(SV3_1aParser::BITW_OR);
          setState(9001);
          _errHandler->sync(this);
          _la = _input->LA(1);
          while (_la == SV3_1aParser::OPEN_PARENS_STAR) {
            setState(8998);
            attribute_instance();
            setState(9003);
            _errHandler->sync(this);
            _la = _input->LA(1);
          }
          setState(9004);
          expression(8);
          break;
        }

        case 10: {
          _localctx = _tracker.createInstance<ExpressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleExpression);
          setState(9005);

          if (!(precpred(_ctx, 6))) throw FailedPredicateException(this, "precpred(_ctx, 6)");
          setState(9006);
          match(SV3_1aParser::LOGICAL_AND);
          setState(9010);
          _errHandler->sync(this);
          _la = _input->LA(1);
          while (_la == SV3_1aParser::OPEN_PARENS_STAR) {
            setState(9007);
            attribute_instance();
            setState(9012);
            _errHandler->sync(this);
            _la = _input->LA(1);
          }
          setState(9013);
          expression(7);
          break;
        }

        case 11: {
          _localctx = _tracker.createInstance<ExpressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleExpression);
          setState(9014);

          if (!(precpred(_ctx, 5))) throw FailedPredicateException(this, "precpred(_ctx, 5)");
          setState(9015);
          match(SV3_1aParser::LOGICAL_OR);
          setState(9019);
          _errHandler->sync(this);
          _la = _input->LA(1);
          while (_la == SV3_1aParser::OPEN_PARENS_STAR) {
            setState(9016);
            attribute_instance();
            setState(9021);
            _errHandler->sync(this);
            _la = _input->LA(1);
          }
          setState(9022);
          expression(6);
          break;
        }

        case 12: {
          _localctx = _tracker.createInstance<ExpressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleExpression);
          setState(9023);

          if (!(precpred(_ctx, 4))) throw FailedPredicateException(this, "precpred(_ctx, 4)");
          setState(9028);
          _errHandler->sync(this);
          _la = _input->LA(1);
          while (_la == SV3_1aParser::LOGICAL_AND) {
            setState(9024);
            match(SV3_1aParser::LOGICAL_AND);
            setState(9025);
            expression(0);
            setState(9030);
            _errHandler->sync(this);
            _la = _input->LA(1);
          }
          setState(9031);
          match(SV3_1aParser::QMARK);
          setState(9035);
          _errHandler->sync(this);
          _la = _input->LA(1);
          while (_la == SV3_1aParser::OPEN_PARENS_STAR) {
            setState(9032);
            attribute_instance();
            setState(9037);
            _errHandler->sync(this);
            _la = _input->LA(1);
          }
          setState(9038);
          expression(0);
          setState(9039);
          match(SV3_1aParser::COLON);
          setState(9040);
          expression(4);
          break;
        }

        case 13: {
          _localctx = _tracker.createInstance<ExpressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleExpression);
          setState(9042);

          if (!(precpred(_ctx, 3))) throw FailedPredicateException(this, "precpred(_ctx, 3)");
          setState(9043);
          _la = _input->LA(1);
          if (!(_la == SV3_1aParser::IMPLY || _la == SV3_1aParser::EQUIVALENCE)) {
          _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
          setState(9047);
          _errHandler->sync(this);
          _la = _input->LA(1);
          while (_la == SV3_1aParser::OPEN_PARENS_STAR) {
            setState(9044);
            attribute_instance();
            setState(9049);
            _errHandler->sync(this);
            _la = _input->LA(1);
          }
          setState(9050);
          expression(3);
          break;
        }

        case 14: {
          _localctx = _tracker.createInstance<ExpressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleExpression);
          setState(9051);

          if (!(precpred(_ctx, 2))) throw FailedPredicateException(this, "precpred(_ctx, 2)");
          setState(9052);
          match(SV3_1aParser::MATCHES);
          setState(9053);
          pattern();
          setState(9058);
          _errHandler->sync(this);
          _la = _input->LA(1);
          while (_la == SV3_1aParser::LOGICAL_AND) {
            setState(9054);
            match(SV3_1aParser::LOGICAL_AND);
            setState(9055);
            expression(0);
            setState(9060);
            _errHandler->sync(this);
            _la = _input->LA(1);
          }
          setState(9061);
          match(SV3_1aParser::QMARK);
          setState(9065);
          _errHandler->sync(this);
          _la = _input->LA(1);
          while (_la == SV3_1aParser::OPEN_PARENS_STAR) {
            setState(9062);
            attribute_instance();
            setState(9067);
            _errHandler->sync(this);
            _la = _input->LA(1);
          }
          setState(9068);
          expression(0);
          setState(9069);
          match(SV3_1aParser::COLON);
          setState(9070);
          expression(3);
          break;
        }

        case 15: {
          _localctx = _tracker.createInstance<ExpressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleExpression);
          setState(9072);

          if (!(precpred(_ctx, 1))) throw FailedPredicateException(this, "precpred(_ctx, 1)");
          setState(9073);
          match(SV3_1aParser::INSIDE);
          setState(9074);
          match(SV3_1aParser::OPEN_CURLY);
          setState(9075);
          open_range_list();
          setState(9076);
          match(SV3_1aParser::CLOSE_CURLY);
          break;
        }

        default:
          break;
        } 
      }
      setState(9082);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1077, _ctx);
    }
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }
  return _localctx;
}

//----------------- Value_rangeContext ------------------------------------------------------------------

SV3_1aParser::Value_rangeContext::Value_rangeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<SV3_1aParser::ExpressionContext *> SV3_1aParser::Value_rangeContext::expression() {
  return getRuleContexts<SV3_1aParser::ExpressionContext>();
}

SV3_1aParser::ExpressionContext* SV3_1aParser::Value_rangeContext::expression(size_t i) {
  return getRuleContext<SV3_1aParser::ExpressionContext>(i);
}

tree::TerminalNode* SV3_1aParser::Value_rangeContext::OPEN_BRACKET() {
  return getToken(SV3_1aParser::OPEN_BRACKET, 0);
}

tree::TerminalNode* SV3_1aParser::Value_rangeContext::COLON() {
  return getToken(SV3_1aParser::COLON, 0);
}

tree::TerminalNode* SV3_1aParser::Value_rangeContext::CLOSE_BRACKET() {
  return getToken(SV3_1aParser::CLOSE_BRACKET, 0);
}


size_t SV3_1aParser::Value_rangeContext::getRuleIndex() const {
  return SV3_1aParser::RuleValue_range;
}

void SV3_1aParser::Value_rangeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterValue_range(this);
}

void SV3_1aParser::Value_rangeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitValue_range(this);
}

SV3_1aParser::Value_rangeContext* SV3_1aParser::value_range() {
  Value_rangeContext *_localctx = _tracker.createInstance<Value_rangeContext>(_ctx, getState());
  enterRule(_localctx, 1164, SV3_1aParser::RuleValue_range);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(9090);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SV3_1aParser::TICK_b0:
      case SV3_1aParser::TICK_b1:
      case SV3_1aParser::TICK_B0:
      case SV3_1aParser::TICK_B1:
      case SV3_1aParser::TICK_0:
      case SV3_1aParser::TICK_1:
      case SV3_1aParser::ONE_TICK_b0:
      case SV3_1aParser::ONE_TICK_b1:
      case SV3_1aParser::ONE_TICK_bx:
      case SV3_1aParser::ONE_TICK_bX:
      case SV3_1aParser::ONE_TICK_B0:
      case SV3_1aParser::ONE_TICK_B1:
      case SV3_1aParser::ONE_TICK_Bx:
      case SV3_1aParser::ONE_TICK_BX:
      case SV3_1aParser::Integral_number:
      case SV3_1aParser::Real_number:
      case SV3_1aParser::String:
      case SV3_1aParser::OPEN_PARENS:
      case SV3_1aParser::TYPE:
      case SV3_1aParser::CONST:
      case SV3_1aParser::LOCAL:
      case SV3_1aParser::SUPER:
      case SV3_1aParser::OPEN_CURLY:
      case SV3_1aParser::STRING:
      case SV3_1aParser::BYTE:
      case SV3_1aParser::SHORTINT:
      case SV3_1aParser::INT:
      case SV3_1aParser::LONGINT:
      case SV3_1aParser::INTEGER:
      case SV3_1aParser::TIME:
      case SV3_1aParser::BIT:
      case SV3_1aParser::LOGIC:
      case SV3_1aParser::REG:
      case SV3_1aParser::SHORTREAL:
      case SV3_1aParser::REAL:
      case SV3_1aParser::REALTIME:
      case SV3_1aParser::SIGNED:
      case SV3_1aParser::UNSIGNED:
      case SV3_1aParser::DOLLAR:
      case SV3_1aParser::PLUSPLUS:
      case SV3_1aParser::PLUS:
      case SV3_1aParser::MINUSMINUS:
      case SV3_1aParser::MINUS:
      case SV3_1aParser::DOLLAR_UNIT:
      case SV3_1aParser::BANG:
      case SV3_1aParser::TAGGED:
      case SV3_1aParser::TICK:
      case SV3_1aParser::NULL_KEYWORD:
      case SV3_1aParser::THIS:
      case SV3_1aParser::DOLLAR_ROOT:
      case SV3_1aParser::RANDOMIZE:
      case SV3_1aParser::SAMPLE:
      case SV3_1aParser::BITW_AND:
      case SV3_1aParser::BITW_OR:
      case SV3_1aParser::REDUCTION_NOR:
      case SV3_1aParser::REDUCTION_NAND:
      case SV3_1aParser::REDUCTION_XNOR1:
      case SV3_1aParser::Escaped_identifier:
      case SV3_1aParser::TILDA:
      case SV3_1aParser::BITW_XOR:
      case SV3_1aParser::REDUCTION_XNOR2:
      case SV3_1aParser::Simple_identifier: {
        enterOuterAlt(_localctx, 1);
        setState(9083);
        expression(0);
        break;
      }

      case SV3_1aParser::OPEN_BRACKET: {
        enterOuterAlt(_localctx, 2);
        setState(9084);
        match(SV3_1aParser::OPEN_BRACKET);
        setState(9085);
        expression(0);
        setState(9086);
        match(SV3_1aParser::COLON);
        setState(9087);
        expression(0);
        setState(9088);
        match(SV3_1aParser::CLOSE_BRACKET);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Mintypmax_expressionContext ------------------------------------------------------------------

SV3_1aParser::Mintypmax_expressionContext::Mintypmax_expressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<SV3_1aParser::ExpressionContext *> SV3_1aParser::Mintypmax_expressionContext::expression() {
  return getRuleContexts<SV3_1aParser::ExpressionContext>();
}

SV3_1aParser::ExpressionContext* SV3_1aParser::Mintypmax_expressionContext::expression(size_t i) {
  return getRuleContext<SV3_1aParser::ExpressionContext>(i);
}

std::vector<tree::TerminalNode *> SV3_1aParser::Mintypmax_expressionContext::COLON() {
  return getTokens(SV3_1aParser::COLON);
}

tree::TerminalNode* SV3_1aParser::Mintypmax_expressionContext::COLON(size_t i) {
  return getToken(SV3_1aParser::COLON, i);
}


size_t SV3_1aParser::Mintypmax_expressionContext::getRuleIndex() const {
  return SV3_1aParser::RuleMintypmax_expression;
}

void SV3_1aParser::Mintypmax_expressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterMintypmax_expression(this);
}

void SV3_1aParser::Mintypmax_expressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitMintypmax_expression(this);
}

SV3_1aParser::Mintypmax_expressionContext* SV3_1aParser::mintypmax_expression() {
  Mintypmax_expressionContext *_localctx = _tracker.createInstance<Mintypmax_expressionContext>(_ctx, getState());
  enterRule(_localctx, 1166, SV3_1aParser::RuleMintypmax_expression);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(9092);
    expression(0);
    setState(9098);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SV3_1aParser::COLON) {
      setState(9093);
      match(SV3_1aParser::COLON);
      setState(9094);
      expression(0);
      setState(9095);
      match(SV3_1aParser::COLON);
      setState(9096);
      expression(0);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Module_path_expressionContext ------------------------------------------------------------------

SV3_1aParser::Module_path_expressionContext::Module_path_expressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::Module_path_primaryContext* SV3_1aParser::Module_path_expressionContext::module_path_primary() {
  return getRuleContext<SV3_1aParser::Module_path_primaryContext>(0);
}

SV3_1aParser::Unary_module_path_operatorContext* SV3_1aParser::Module_path_expressionContext::unary_module_path_operator() {
  return getRuleContext<SV3_1aParser::Unary_module_path_operatorContext>(0);
}

std::vector<SV3_1aParser::Attribute_instanceContext *> SV3_1aParser::Module_path_expressionContext::attribute_instance() {
  return getRuleContexts<SV3_1aParser::Attribute_instanceContext>();
}

SV3_1aParser::Attribute_instanceContext* SV3_1aParser::Module_path_expressionContext::attribute_instance(size_t i) {
  return getRuleContext<SV3_1aParser::Attribute_instanceContext>(i);
}

std::vector<SV3_1aParser::Module_path_expressionContext *> SV3_1aParser::Module_path_expressionContext::module_path_expression() {
  return getRuleContexts<SV3_1aParser::Module_path_expressionContext>();
}

SV3_1aParser::Module_path_expressionContext* SV3_1aParser::Module_path_expressionContext::module_path_expression(size_t i) {
  return getRuleContext<SV3_1aParser::Module_path_expressionContext>(i);
}

SV3_1aParser::Binary_module_path_operatorContext* SV3_1aParser::Module_path_expressionContext::binary_module_path_operator() {
  return getRuleContext<SV3_1aParser::Binary_module_path_operatorContext>(0);
}

SV3_1aParser::Conditional_operatorContext* SV3_1aParser::Module_path_expressionContext::conditional_operator() {
  return getRuleContext<SV3_1aParser::Conditional_operatorContext>(0);
}

tree::TerminalNode* SV3_1aParser::Module_path_expressionContext::COLON() {
  return getToken(SV3_1aParser::COLON, 0);
}


size_t SV3_1aParser::Module_path_expressionContext::getRuleIndex() const {
  return SV3_1aParser::RuleModule_path_expression;
}

void SV3_1aParser::Module_path_expressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterModule_path_expression(this);
}

void SV3_1aParser::Module_path_expressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitModule_path_expression(this);
}


SV3_1aParser::Module_path_expressionContext* SV3_1aParser::module_path_expression() {
   return module_path_expression(0);
}

SV3_1aParser::Module_path_expressionContext* SV3_1aParser::module_path_expression(int precedence) {
  ParserRuleContext *parentContext = _ctx;
  size_t parentState = getState();
  SV3_1aParser::Module_path_expressionContext *_localctx = _tracker.createInstance<Module_path_expressionContext>(_ctx, parentState);
  SV3_1aParser::Module_path_expressionContext *previousContext = _localctx;
  (void)previousContext; // Silence compiler, in case the context is not used by generated code.
  size_t startState = 1168;
  enterRecursionRule(_localctx, 1168, SV3_1aParser::RuleModule_path_expression, precedence);

    size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    unrollRecursionContexts(parentContext);
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(9111);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SV3_1aParser::TICK_b0:
      case SV3_1aParser::TICK_b1:
      case SV3_1aParser::TICK_B0:
      case SV3_1aParser::TICK_B1:
      case SV3_1aParser::TICK_0:
      case SV3_1aParser::TICK_1:
      case SV3_1aParser::ONE_TICK_b0:
      case SV3_1aParser::ONE_TICK_b1:
      case SV3_1aParser::ONE_TICK_bx:
      case SV3_1aParser::ONE_TICK_bX:
      case SV3_1aParser::ONE_TICK_B0:
      case SV3_1aParser::ONE_TICK_B1:
      case SV3_1aParser::ONE_TICK_Bx:
      case SV3_1aParser::ONE_TICK_BX:
      case SV3_1aParser::Integral_number:
      case SV3_1aParser::Real_number:
      case SV3_1aParser::OPEN_PARENS:
      case SV3_1aParser::SUPER:
      case SV3_1aParser::OPEN_CURLY:
      case SV3_1aParser::DOLLAR:
      case SV3_1aParser::DOLLAR_UNIT:
      case SV3_1aParser::THIS:
      case SV3_1aParser::DOLLAR_ROOT:
      case SV3_1aParser::RANDOMIZE:
      case SV3_1aParser::SAMPLE:
      case SV3_1aParser::Escaped_identifier:
      case SV3_1aParser::Simple_identifier: {
        setState(9101);
        module_path_primary();
        break;
      }

      case SV3_1aParser::BANG:
      case SV3_1aParser::BITW_AND:
      case SV3_1aParser::BITW_OR:
      case SV3_1aParser::REDUCTION_NOR:
      case SV3_1aParser::REDUCTION_NAND:
      case SV3_1aParser::REDUCTION_XNOR1:
      case SV3_1aParser::TILDA:
      case SV3_1aParser::BITW_XOR:
      case SV3_1aParser::REDUCTION_XNOR2: {
        setState(9102);
        unary_module_path_operator();
        setState(9106);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == SV3_1aParser::OPEN_PARENS_STAR) {
          setState(9103);
          attribute_instance();
          setState(9108);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(9109);
        module_path_primary();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
    _ctx->stop = _input->LT(-1);
    setState(9137);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1085, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        if (!_parseListeners.empty())
          triggerExitRuleEvent();
        previousContext = _localctx;
        setState(9135);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1084, _ctx)) {
        case 1: {
          _localctx = _tracker.createInstance<Module_path_expressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleModule_path_expression);
          setState(9113);

          if (!(precpred(_ctx, 2))) throw FailedPredicateException(this, "precpred(_ctx, 2)");
          setState(9114);
          binary_module_path_operator();
          setState(9118);
          _errHandler->sync(this);
          _la = _input->LA(1);
          while (_la == SV3_1aParser::OPEN_PARENS_STAR) {
            setState(9115);
            attribute_instance();
            setState(9120);
            _errHandler->sync(this);
            _la = _input->LA(1);
          }
          setState(9121);
          module_path_expression(3);
          break;
        }

        case 2: {
          _localctx = _tracker.createInstance<Module_path_expressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleModule_path_expression);
          setState(9123);

          if (!(precpred(_ctx, 1))) throw FailedPredicateException(this, "precpred(_ctx, 1)");
          setState(9124);
          conditional_operator();
          setState(9128);
          _errHandler->sync(this);
          _la = _input->LA(1);
          while (_la == SV3_1aParser::OPEN_PARENS_STAR) {
            setState(9125);
            attribute_instance();
            setState(9130);
            _errHandler->sync(this);
            _la = _input->LA(1);
          }
          setState(9131);
          module_path_expression(0);
          setState(9132);
          match(SV3_1aParser::COLON);
          setState(9133);
          module_path_expression(2);
          break;
        }

        default:
          break;
        } 
      }
      setState(9139);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1085, _ctx);
    }
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }
  return _localctx;
}

//----------------- Module_path_mintypmax_expressionContext ------------------------------------------------------------------

SV3_1aParser::Module_path_mintypmax_expressionContext::Module_path_mintypmax_expressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<SV3_1aParser::Module_path_expressionContext *> SV3_1aParser::Module_path_mintypmax_expressionContext::module_path_expression() {
  return getRuleContexts<SV3_1aParser::Module_path_expressionContext>();
}

SV3_1aParser::Module_path_expressionContext* SV3_1aParser::Module_path_mintypmax_expressionContext::module_path_expression(size_t i) {
  return getRuleContext<SV3_1aParser::Module_path_expressionContext>(i);
}

std::vector<tree::TerminalNode *> SV3_1aParser::Module_path_mintypmax_expressionContext::COLON() {
  return getTokens(SV3_1aParser::COLON);
}

tree::TerminalNode* SV3_1aParser::Module_path_mintypmax_expressionContext::COLON(size_t i) {
  return getToken(SV3_1aParser::COLON, i);
}


size_t SV3_1aParser::Module_path_mintypmax_expressionContext::getRuleIndex() const {
  return SV3_1aParser::RuleModule_path_mintypmax_expression;
}

void SV3_1aParser::Module_path_mintypmax_expressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterModule_path_mintypmax_expression(this);
}

void SV3_1aParser::Module_path_mintypmax_expressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitModule_path_mintypmax_expression(this);
}

SV3_1aParser::Module_path_mintypmax_expressionContext* SV3_1aParser::module_path_mintypmax_expression() {
  Module_path_mintypmax_expressionContext *_localctx = _tracker.createInstance<Module_path_mintypmax_expressionContext>(_ctx, getState());
  enterRule(_localctx, 1170, SV3_1aParser::RuleModule_path_mintypmax_expression);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(9140);
    module_path_expression(0);
    setState(9146);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SV3_1aParser::COLON) {
      setState(9141);
      match(SV3_1aParser::COLON);
      setState(9142);
      module_path_expression(0);
      setState(9143);
      match(SV3_1aParser::COLON);
      setState(9144);
      module_path_expression(0);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Range_expressionContext ------------------------------------------------------------------

SV3_1aParser::Range_expressionContext::Range_expressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::ExpressionContext* SV3_1aParser::Range_expressionContext::expression() {
  return getRuleContext<SV3_1aParser::ExpressionContext>(0);
}

SV3_1aParser::Part_select_rangeContext* SV3_1aParser::Range_expressionContext::part_select_range() {
  return getRuleContext<SV3_1aParser::Part_select_rangeContext>(0);
}


size_t SV3_1aParser::Range_expressionContext::getRuleIndex() const {
  return SV3_1aParser::RuleRange_expression;
}

void SV3_1aParser::Range_expressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRange_expression(this);
}

void SV3_1aParser::Range_expressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRange_expression(this);
}

SV3_1aParser::Range_expressionContext* SV3_1aParser::range_expression() {
  Range_expressionContext *_localctx = _tracker.createInstance<Range_expressionContext>(_ctx, getState());
  enterRule(_localctx, 1172, SV3_1aParser::RuleRange_expression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(9150);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1087, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(9148);
      expression(0);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(9149);
      part_select_range();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Part_select_rangeContext ------------------------------------------------------------------

SV3_1aParser::Part_select_rangeContext::Part_select_rangeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::Constant_rangeContext* SV3_1aParser::Part_select_rangeContext::constant_range() {
  return getRuleContext<SV3_1aParser::Constant_rangeContext>(0);
}

SV3_1aParser::Indexed_rangeContext* SV3_1aParser::Part_select_rangeContext::indexed_range() {
  return getRuleContext<SV3_1aParser::Indexed_rangeContext>(0);
}


size_t SV3_1aParser::Part_select_rangeContext::getRuleIndex() const {
  return SV3_1aParser::RulePart_select_range;
}

void SV3_1aParser::Part_select_rangeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPart_select_range(this);
}

void SV3_1aParser::Part_select_rangeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPart_select_range(this);
}

SV3_1aParser::Part_select_rangeContext* SV3_1aParser::part_select_range() {
  Part_select_rangeContext *_localctx = _tracker.createInstance<Part_select_rangeContext>(_ctx, getState());
  enterRule(_localctx, 1174, SV3_1aParser::RulePart_select_range);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(9154);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1088, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(9152);
      constant_range();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(9153);
      indexed_range();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Part_select_opContext ------------------------------------------------------------------

SV3_1aParser::Part_select_opContext::Part_select_opContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Part_select_opContext::INC_PART_SELECT_OP() {
  return getToken(SV3_1aParser::INC_PART_SELECT_OP, 0);
}

tree::TerminalNode* SV3_1aParser::Part_select_opContext::DEC_PART_SELECT_OP() {
  return getToken(SV3_1aParser::DEC_PART_SELECT_OP, 0);
}


size_t SV3_1aParser::Part_select_opContext::getRuleIndex() const {
  return SV3_1aParser::RulePart_select_op;
}

void SV3_1aParser::Part_select_opContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPart_select_op(this);
}

void SV3_1aParser::Part_select_opContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPart_select_op(this);
}

SV3_1aParser::Part_select_opContext* SV3_1aParser::part_select_op() {
  Part_select_opContext *_localctx = _tracker.createInstance<Part_select_opContext>(_ctx, getState());
  enterRule(_localctx, 1176, SV3_1aParser::RulePart_select_op);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(9156);
    _la = _input->LA(1);
    if (!(_la == SV3_1aParser::INC_PART_SELECT_OP

    || _la == SV3_1aParser::DEC_PART_SELECT_OP)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Part_select_op_colonContext ------------------------------------------------------------------

SV3_1aParser::Part_select_op_colonContext::Part_select_op_colonContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Part_select_op_colonContext::INC_PART_SELECT_OP() {
  return getToken(SV3_1aParser::INC_PART_SELECT_OP, 0);
}

tree::TerminalNode* SV3_1aParser::Part_select_op_colonContext::DEC_PART_SELECT_OP() {
  return getToken(SV3_1aParser::DEC_PART_SELECT_OP, 0);
}

tree::TerminalNode* SV3_1aParser::Part_select_op_colonContext::COLON() {
  return getToken(SV3_1aParser::COLON, 0);
}


size_t SV3_1aParser::Part_select_op_colonContext::getRuleIndex() const {
  return SV3_1aParser::RulePart_select_op_colon;
}

void SV3_1aParser::Part_select_op_colonContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPart_select_op_colon(this);
}

void SV3_1aParser::Part_select_op_colonContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPart_select_op_colon(this);
}

SV3_1aParser::Part_select_op_colonContext* SV3_1aParser::part_select_op_colon() {
  Part_select_op_colonContext *_localctx = _tracker.createInstance<Part_select_op_colonContext>(_ctx, getState());
  enterRule(_localctx, 1178, SV3_1aParser::RulePart_select_op_colon);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(9158);
    _la = _input->LA(1);
    if (!(_la == SV3_1aParser::COLON || _la == SV3_1aParser::INC_PART_SELECT_OP

    || _la == SV3_1aParser::DEC_PART_SELECT_OP)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Indexed_rangeContext ------------------------------------------------------------------

SV3_1aParser::Indexed_rangeContext::Indexed_rangeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::ExpressionContext* SV3_1aParser::Indexed_rangeContext::expression() {
  return getRuleContext<SV3_1aParser::ExpressionContext>(0);
}

SV3_1aParser::Part_select_opContext* SV3_1aParser::Indexed_rangeContext::part_select_op() {
  return getRuleContext<SV3_1aParser::Part_select_opContext>(0);
}

SV3_1aParser::Constant_expressionContext* SV3_1aParser::Indexed_rangeContext::constant_expression() {
  return getRuleContext<SV3_1aParser::Constant_expressionContext>(0);
}


size_t SV3_1aParser::Indexed_rangeContext::getRuleIndex() const {
  return SV3_1aParser::RuleIndexed_range;
}

void SV3_1aParser::Indexed_rangeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIndexed_range(this);
}

void SV3_1aParser::Indexed_rangeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIndexed_range(this);
}

SV3_1aParser::Indexed_rangeContext* SV3_1aParser::indexed_range() {
  Indexed_rangeContext *_localctx = _tracker.createInstance<Indexed_rangeContext>(_ctx, getState());
  enterRule(_localctx, 1180, SV3_1aParser::RuleIndexed_range);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(9160);
    expression(0);
    setState(9161);
    part_select_op();
    setState(9162);
    constant_expression(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Constant_primaryContext ------------------------------------------------------------------

SV3_1aParser::Constant_primaryContext::Constant_primaryContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::Primary_literalContext* SV3_1aParser::Constant_primaryContext::primary_literal() {
  return getRuleContext<SV3_1aParser::Primary_literalContext>(0);
}

SV3_1aParser::IdentifierContext* SV3_1aParser::Constant_primaryContext::identifier() {
  return getRuleContext<SV3_1aParser::IdentifierContext>(0);
}

SV3_1aParser::Constant_selectContext* SV3_1aParser::Constant_primaryContext::constant_select() {
  return getRuleContext<SV3_1aParser::Constant_selectContext>(0);
}

SV3_1aParser::Package_scopeContext* SV3_1aParser::Constant_primaryContext::package_scope() {
  return getRuleContext<SV3_1aParser::Package_scopeContext>(0);
}

SV3_1aParser::Class_scopeContext* SV3_1aParser::Constant_primaryContext::class_scope() {
  return getRuleContext<SV3_1aParser::Class_scopeContext>(0);
}

tree::TerminalNode* SV3_1aParser::Constant_primaryContext::OPEN_BRACKET() {
  return getToken(SV3_1aParser::OPEN_BRACKET, 0);
}

SV3_1aParser::Constant_range_expressionContext* SV3_1aParser::Constant_primaryContext::constant_range_expression() {
  return getRuleContext<SV3_1aParser::Constant_range_expressionContext>(0);
}

tree::TerminalNode* SV3_1aParser::Constant_primaryContext::CLOSE_BRACKET() {
  return getToken(SV3_1aParser::CLOSE_BRACKET, 0);
}

SV3_1aParser::Constant_concatenationContext* SV3_1aParser::Constant_primaryContext::constant_concatenation() {
  return getRuleContext<SV3_1aParser::Constant_concatenationContext>(0);
}

SV3_1aParser::Constant_multiple_concatenationContext* SV3_1aParser::Constant_primaryContext::constant_multiple_concatenation() {
  return getRuleContext<SV3_1aParser::Constant_multiple_concatenationContext>(0);
}

SV3_1aParser::Subroutine_callContext* SV3_1aParser::Constant_primaryContext::subroutine_call() {
  return getRuleContext<SV3_1aParser::Subroutine_callContext>(0);
}

SV3_1aParser::Constant_castContext* SV3_1aParser::Constant_primaryContext::constant_cast() {
  return getRuleContext<SV3_1aParser::Constant_castContext>(0);
}

SV3_1aParser::Constant_assignment_pattern_expressionContext* SV3_1aParser::Constant_primaryContext::constant_assignment_pattern_expression() {
  return getRuleContext<SV3_1aParser::Constant_assignment_pattern_expressionContext>(0);
}

SV3_1aParser::Type_referenceContext* SV3_1aParser::Constant_primaryContext::type_reference() {
  return getRuleContext<SV3_1aParser::Type_referenceContext>(0);
}

SV3_1aParser::Dollar_keywordContext* SV3_1aParser::Constant_primaryContext::dollar_keyword() {
  return getRuleContext<SV3_1aParser::Dollar_keywordContext>(0);
}

tree::TerminalNode* SV3_1aParser::Constant_primaryContext::OPEN_PARENS() {
  return getToken(SV3_1aParser::OPEN_PARENS, 0);
}

std::vector<SV3_1aParser::Constant_expressionContext *> SV3_1aParser::Constant_primaryContext::constant_expression() {
  return getRuleContexts<SV3_1aParser::Constant_expressionContext>();
}

SV3_1aParser::Constant_expressionContext* SV3_1aParser::Constant_primaryContext::constant_expression(size_t i) {
  return getRuleContext<SV3_1aParser::Constant_expressionContext>(i);
}

tree::TerminalNode* SV3_1aParser::Constant_primaryContext::CLOSE_PARENS() {
  return getToken(SV3_1aParser::CLOSE_PARENS, 0);
}

std::vector<tree::TerminalNode *> SV3_1aParser::Constant_primaryContext::COLON() {
  return getTokens(SV3_1aParser::COLON);
}

tree::TerminalNode* SV3_1aParser::Constant_primaryContext::COLON(size_t i) {
  return getToken(SV3_1aParser::COLON, i);
}


size_t SV3_1aParser::Constant_primaryContext::getRuleIndex() const {
  return SV3_1aParser::RuleConstant_primary;
}

void SV3_1aParser::Constant_primaryContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterConstant_primary(this);
}

void SV3_1aParser::Constant_primaryContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitConstant_primary(this);
}

SV3_1aParser::Constant_primaryContext* SV3_1aParser::constant_primary() {
  Constant_primaryContext *_localctx = _tracker.createInstance<Constant_primaryContext>(_ctx, getState());
  enterRule(_localctx, 1182, SV3_1aParser::RuleConstant_primary);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(9207);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1094, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(9164);
      primary_literal();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(9167);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1089, _ctx)) {
      case 1: {
        setState(9165);
        package_scope();
        break;
      }

      case 2: {
        setState(9166);
        class_scope();
        break;
      }

      default:
        break;
      }
      setState(9169);
      identifier();
      setState(9170);
      constant_select();
      setState(9175);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1090, _ctx)) {
      case 1: {
        setState(9171);
        match(SV3_1aParser::OPEN_BRACKET);
        setState(9172);
        constant_range_expression();
        setState(9173);
        match(SV3_1aParser::CLOSE_BRACKET);
        break;
      }

      default:
        break;
      }
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(9177);
      constant_concatenation();
      setState(9182);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1091, _ctx)) {
      case 1: {
        setState(9178);
        match(SV3_1aParser::OPEN_BRACKET);
        setState(9179);
        constant_range_expression();
        setState(9180);
        match(SV3_1aParser::CLOSE_BRACKET);
        break;
      }

      default:
        break;
      }
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(9184);
      constant_multiple_concatenation();
      setState(9189);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1092, _ctx)) {
      case 1: {
        setState(9185);
        match(SV3_1aParser::OPEN_BRACKET);
        setState(9186);
        constant_range_expression();
        setState(9187);
        match(SV3_1aParser::CLOSE_BRACKET);
        break;
      }

      default:
        break;
      }
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(9191);
      subroutine_call();
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(9192);
      constant_cast();
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(9193);
      constant_assignment_pattern_expression();
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(9194);
      type_reference();
      break;
    }

    case 9: {
      enterOuterAlt(_localctx, 9);
      setState(9195);
      dollar_keyword();
      break;
    }

    case 10: {
      enterOuterAlt(_localctx, 10);
      setState(9196);
      match(SV3_1aParser::OPEN_PARENS);
      setState(9197);
      constant_expression(0);
      setState(9203);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == SV3_1aParser::COLON) {
        setState(9198);
        match(SV3_1aParser::COLON);
        setState(9199);
        constant_expression(0);
        setState(9200);
        match(SV3_1aParser::COLON);
        setState(9201);
        constant_expression(0);
      }
      setState(9205);
      match(SV3_1aParser::CLOSE_PARENS);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Module_path_primaryContext ------------------------------------------------------------------

SV3_1aParser::Module_path_primaryContext::Module_path_primaryContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::NumberContext* SV3_1aParser::Module_path_primaryContext::number() {
  return getRuleContext<SV3_1aParser::NumberContext>(0);
}

SV3_1aParser::IdentifierContext* SV3_1aParser::Module_path_primaryContext::identifier() {
  return getRuleContext<SV3_1aParser::IdentifierContext>(0);
}

SV3_1aParser::Module_path_concatenationContext* SV3_1aParser::Module_path_primaryContext::module_path_concatenation() {
  return getRuleContext<SV3_1aParser::Module_path_concatenationContext>(0);
}

SV3_1aParser::Module_path_multiple_concatenationContext* SV3_1aParser::Module_path_primaryContext::module_path_multiple_concatenation() {
  return getRuleContext<SV3_1aParser::Module_path_multiple_concatenationContext>(0);
}

SV3_1aParser::Subroutine_callContext* SV3_1aParser::Module_path_primaryContext::subroutine_call() {
  return getRuleContext<SV3_1aParser::Subroutine_callContext>(0);
}

tree::TerminalNode* SV3_1aParser::Module_path_primaryContext::OPEN_PARENS() {
  return getToken(SV3_1aParser::OPEN_PARENS, 0);
}

SV3_1aParser::Module_path_mintypmax_expressionContext* SV3_1aParser::Module_path_primaryContext::module_path_mintypmax_expression() {
  return getRuleContext<SV3_1aParser::Module_path_mintypmax_expressionContext>(0);
}

tree::TerminalNode* SV3_1aParser::Module_path_primaryContext::CLOSE_PARENS() {
  return getToken(SV3_1aParser::CLOSE_PARENS, 0);
}


size_t SV3_1aParser::Module_path_primaryContext::getRuleIndex() const {
  return SV3_1aParser::RuleModule_path_primary;
}

void SV3_1aParser::Module_path_primaryContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterModule_path_primary(this);
}

void SV3_1aParser::Module_path_primaryContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitModule_path_primary(this);
}

SV3_1aParser::Module_path_primaryContext* SV3_1aParser::module_path_primary() {
  Module_path_primaryContext *_localctx = _tracker.createInstance<Module_path_primaryContext>(_ctx, getState());
  enterRule(_localctx, 1184, SV3_1aParser::RuleModule_path_primary);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(9218);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1095, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(9209);
      number();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(9210);
      identifier();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(9211);
      module_path_concatenation();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(9212);
      module_path_multiple_concatenation();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(9213);
      subroutine_call();
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(9214);
      match(SV3_1aParser::OPEN_PARENS);
      setState(9215);
      module_path_mintypmax_expression();
      setState(9216);
      match(SV3_1aParser::CLOSE_PARENS);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Complex_func_callContext ------------------------------------------------------------------

SV3_1aParser::Complex_func_callContext::Complex_func_callContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<SV3_1aParser::IdentifierContext *> SV3_1aParser::Complex_func_callContext::identifier() {
  return getRuleContexts<SV3_1aParser::IdentifierContext>();
}

SV3_1aParser::IdentifierContext* SV3_1aParser::Complex_func_callContext::identifier(size_t i) {
  return getRuleContext<SV3_1aParser::IdentifierContext>(i);
}

SV3_1aParser::SelectContext* SV3_1aParser::Complex_func_callContext::select() {
  return getRuleContext<SV3_1aParser::SelectContext>(0);
}

SV3_1aParser::Implicit_class_handleContext* SV3_1aParser::Complex_func_callContext::implicit_class_handle() {
  return getRuleContext<SV3_1aParser::Implicit_class_handleContext>(0);
}

std::vector<tree::TerminalNode *> SV3_1aParser::Complex_func_callContext::DOT() {
  return getTokens(SV3_1aParser::DOT);
}

tree::TerminalNode* SV3_1aParser::Complex_func_callContext::DOT(size_t i) {
  return getToken(SV3_1aParser::DOT, i);
}

SV3_1aParser::Class_scopeContext* SV3_1aParser::Complex_func_callContext::class_scope() {
  return getRuleContext<SV3_1aParser::Class_scopeContext>(0);
}

SV3_1aParser::Package_scopeContext* SV3_1aParser::Complex_func_callContext::package_scope() {
  return getRuleContext<SV3_1aParser::Package_scopeContext>(0);
}

SV3_1aParser::Dollar_keywordContext* SV3_1aParser::Complex_func_callContext::dollar_keyword() {
  return getRuleContext<SV3_1aParser::Dollar_keywordContext>(0);
}

tree::TerminalNode* SV3_1aParser::Complex_func_callContext::LOCAL() {
  return getToken(SV3_1aParser::LOCAL, 0);
}

tree::TerminalNode* SV3_1aParser::Complex_func_callContext::COLONCOLON() {
  return getToken(SV3_1aParser::COLONCOLON, 0);
}

SV3_1aParser::Dollar_root_keywordContext* SV3_1aParser::Complex_func_callContext::dollar_root_keyword() {
  return getRuleContext<SV3_1aParser::Dollar_root_keywordContext>(0);
}

std::vector<SV3_1aParser::Attribute_instanceContext *> SV3_1aParser::Complex_func_callContext::attribute_instance() {
  return getRuleContexts<SV3_1aParser::Attribute_instanceContext>();
}

SV3_1aParser::Attribute_instanceContext* SV3_1aParser::Complex_func_callContext::attribute_instance(size_t i) {
  return getRuleContext<SV3_1aParser::Attribute_instanceContext>(i);
}

SV3_1aParser::Method_call_bodyContext* SV3_1aParser::Complex_func_callContext::method_call_body() {
  return getRuleContext<SV3_1aParser::Method_call_bodyContext>(0);
}

tree::TerminalNode* SV3_1aParser::Complex_func_callContext::OPEN_PARENS() {
  return getToken(SV3_1aParser::OPEN_PARENS, 0);
}

tree::TerminalNode* SV3_1aParser::Complex_func_callContext::CLOSE_PARENS() {
  return getToken(SV3_1aParser::CLOSE_PARENS, 0);
}

std::vector<tree::TerminalNode *> SV3_1aParser::Complex_func_callContext::OPEN_BRACKET() {
  return getTokens(SV3_1aParser::OPEN_BRACKET);
}

tree::TerminalNode* SV3_1aParser::Complex_func_callContext::OPEN_BRACKET(size_t i) {
  return getToken(SV3_1aParser::OPEN_BRACKET, i);
}

std::vector<SV3_1aParser::Constant_expressionContext *> SV3_1aParser::Complex_func_callContext::constant_expression() {
  return getRuleContexts<SV3_1aParser::Constant_expressionContext>();
}

SV3_1aParser::Constant_expressionContext* SV3_1aParser::Complex_func_callContext::constant_expression(size_t i) {
  return getRuleContext<SV3_1aParser::Constant_expressionContext>(i);
}

std::vector<tree::TerminalNode *> SV3_1aParser::Complex_func_callContext::CLOSE_BRACKET() {
  return getTokens(SV3_1aParser::CLOSE_BRACKET);
}

tree::TerminalNode* SV3_1aParser::Complex_func_callContext::CLOSE_BRACKET(size_t i) {
  return getToken(SV3_1aParser::CLOSE_BRACKET, i);
}

SV3_1aParser::List_of_argumentsContext* SV3_1aParser::Complex_func_callContext::list_of_arguments() {
  return getRuleContext<SV3_1aParser::List_of_argumentsContext>(0);
}


size_t SV3_1aParser::Complex_func_callContext::getRuleIndex() const {
  return SV3_1aParser::RuleComplex_func_call;
}

void SV3_1aParser::Complex_func_callContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterComplex_func_call(this);
}

void SV3_1aParser::Complex_func_callContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitComplex_func_call(this);
}

SV3_1aParser::Complex_func_callContext* SV3_1aParser::complex_func_call() {
  Complex_func_callContext *_localctx = _tracker.createInstance<Complex_func_callContext>(_ctx, getState());
  enterRule(_localctx, 1186, SV3_1aParser::RuleComplex_func_call);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(9228);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1096, _ctx)) {
    case 1: {
      setState(9220);
      implicit_class_handle();
      setState(9221);
      match(SV3_1aParser::DOT);
      break;
    }

    case 2: {
      setState(9223);
      class_scope();
      break;
    }

    case 3: {
      setState(9224);
      package_scope();
      break;
    }

    case 4: {
      setState(9225);
      dollar_keyword();
      break;
    }

    case 5: {
      setState(9226);
      match(SV3_1aParser::LOCAL);
      setState(9227);
      match(SV3_1aParser::COLONCOLON);
      break;
    }

    default:
      break;
    }
    setState(9231);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SV3_1aParser::DOLLAR_ROOT) {
      setState(9230);
      dollar_root_keyword();
    }
    setState(9233);
    identifier();
    setState(9247);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1099, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(9240);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == SV3_1aParser::OPEN_BRACKET) {
          setState(9234);
          match(SV3_1aParser::OPEN_BRACKET);
          setState(9235);
          constant_expression(0);
          setState(9236);
          match(SV3_1aParser::CLOSE_BRACKET);
          setState(9242);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(9243);
        match(SV3_1aParser::DOT);
        setState(9244);
        identifier(); 
      }
      setState(9249);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1099, _ctx);
    }
    setState(9253);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1100, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(9250);
        attribute_instance(); 
      }
      setState(9255);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1100, _ctx);
    }
    setState(9261);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1101, _ctx)) {
    case 1: {
      setState(9256);
      match(SV3_1aParser::OPEN_PARENS);

      setState(9257);
      list_of_arguments();
      setState(9258);
      match(SV3_1aParser::CLOSE_PARENS);
      break;
    }

    case 2: {
      setState(9260);
      select();
      break;
    }

    default:
      break;
    }
    setState(9265);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1102, _ctx)) {
    case 1: {
      setState(9263);
      match(SV3_1aParser::DOT);
      setState(9264);
      method_call_body();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PrimaryContext ------------------------------------------------------------------

SV3_1aParser::PrimaryContext::PrimaryContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::Primary_literalContext* SV3_1aParser::PrimaryContext::primary_literal() {
  return getRuleContext<SV3_1aParser::Primary_literalContext>(0);
}

SV3_1aParser::Complex_func_callContext* SV3_1aParser::PrimaryContext::complex_func_call() {
  return getRuleContext<SV3_1aParser::Complex_func_callContext>(0);
}

SV3_1aParser::ConcatenationContext* SV3_1aParser::PrimaryContext::concatenation() {
  return getRuleContext<SV3_1aParser::ConcatenationContext>(0);
}

SV3_1aParser::Multiple_concatenationContext* SV3_1aParser::PrimaryContext::multiple_concatenation() {
  return getRuleContext<SV3_1aParser::Multiple_concatenationContext>(0);
}

tree::TerminalNode* SV3_1aParser::PrimaryContext::OPEN_BRACKET() {
  return getToken(SV3_1aParser::OPEN_BRACKET, 0);
}

SV3_1aParser::Range_expressionContext* SV3_1aParser::PrimaryContext::range_expression() {
  return getRuleContext<SV3_1aParser::Range_expressionContext>(0);
}

tree::TerminalNode* SV3_1aParser::PrimaryContext::CLOSE_BRACKET() {
  return getToken(SV3_1aParser::CLOSE_BRACKET, 0);
}

SV3_1aParser::CastContext* SV3_1aParser::PrimaryContext::cast() {
  return getRuleContext<SV3_1aParser::CastContext>(0);
}

SV3_1aParser::Assignment_pattern_expressionContext* SV3_1aParser::PrimaryContext::assignment_pattern_expression() {
  return getRuleContext<SV3_1aParser::Assignment_pattern_expressionContext>(0);
}

SV3_1aParser::Streaming_concatenationContext* SV3_1aParser::PrimaryContext::streaming_concatenation() {
  return getRuleContext<SV3_1aParser::Streaming_concatenationContext>(0);
}

SV3_1aParser::System_taskContext* SV3_1aParser::PrimaryContext::system_task() {
  return getRuleContext<SV3_1aParser::System_taskContext>(0);
}

SV3_1aParser::Class_typeContext* SV3_1aParser::PrimaryContext::class_type() {
  return getRuleContext<SV3_1aParser::Class_typeContext>(0);
}

tree::TerminalNode* SV3_1aParser::PrimaryContext::COLONCOLON() {
  return getToken(SV3_1aParser::COLONCOLON, 0);
}

SV3_1aParser::Method_call_bodyContext* SV3_1aParser::PrimaryContext::method_call_body() {
  return getRuleContext<SV3_1aParser::Method_call_bodyContext>(0);
}

SV3_1aParser::This_keywordContext* SV3_1aParser::PrimaryContext::this_keyword() {
  return getRuleContext<SV3_1aParser::This_keywordContext>(0);
}

SV3_1aParser::Dollar_keywordContext* SV3_1aParser::PrimaryContext::dollar_keyword() {
  return getRuleContext<SV3_1aParser::Dollar_keywordContext>(0);
}

SV3_1aParser::Null_keywordContext* SV3_1aParser::PrimaryContext::null_keyword() {
  return getRuleContext<SV3_1aParser::Null_keywordContext>(0);
}

SV3_1aParser::Empty_queueContext* SV3_1aParser::PrimaryContext::empty_queue() {
  return getRuleContext<SV3_1aParser::Empty_queueContext>(0);
}

SV3_1aParser::Randomize_callContext* SV3_1aParser::PrimaryContext::randomize_call() {
  return getRuleContext<SV3_1aParser::Randomize_callContext>(0);
}

tree::TerminalNode* SV3_1aParser::PrimaryContext::OPEN_PARENS() {
  return getToken(SV3_1aParser::OPEN_PARENS, 0);
}

std::vector<SV3_1aParser::ExpressionContext *> SV3_1aParser::PrimaryContext::expression() {
  return getRuleContexts<SV3_1aParser::ExpressionContext>();
}

SV3_1aParser::ExpressionContext* SV3_1aParser::PrimaryContext::expression(size_t i) {
  return getRuleContext<SV3_1aParser::ExpressionContext>(i);
}

std::vector<tree::TerminalNode *> SV3_1aParser::PrimaryContext::COLON() {
  return getTokens(SV3_1aParser::COLON);
}

tree::TerminalNode* SV3_1aParser::PrimaryContext::COLON(size_t i) {
  return getToken(SV3_1aParser::COLON, i);
}

tree::TerminalNode* SV3_1aParser::PrimaryContext::CLOSE_PARENS() {
  return getToken(SV3_1aParser::CLOSE_PARENS, 0);
}


size_t SV3_1aParser::PrimaryContext::getRuleIndex() const {
  return SV3_1aParser::RulePrimary;
}

void SV3_1aParser::PrimaryContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPrimary(this);
}

void SV3_1aParser::PrimaryContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPrimary(this);
}

SV3_1aParser::PrimaryContext* SV3_1aParser::primary() {
  PrimaryContext *_localctx = _tracker.createInstance<PrimaryContext>(_ctx, getState());
  enterRule(_localctx, 1188, SV3_1aParser::RulePrimary);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(9300);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1105, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(9267);
      primary_literal();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(9268);
      complex_func_call();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(9271);
      _errHandler->sync(this);
      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1103, _ctx)) {
      case 1: {
        setState(9269);
        concatenation();
        break;
      }

      case 2: {
        setState(9270);
        multiple_concatenation();
        break;
      }

      default:
        break;
      }
      setState(9277);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1104, _ctx)) {
      case 1: {
        setState(9273);
        match(SV3_1aParser::OPEN_BRACKET);
        setState(9274);
        range_expression();
        setState(9275);
        match(SV3_1aParser::CLOSE_BRACKET);
        break;
      }

      default:
        break;
      }
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(9279);
      cast();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(9280);
      assignment_pattern_expression();
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(9281);
      streaming_concatenation();
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(9282);
      system_task();
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(9283);
      class_type();
      setState(9284);
      match(SV3_1aParser::COLONCOLON);
      setState(9285);
      method_call_body();
      break;
    }

    case 9: {
      enterOuterAlt(_localctx, 9);
      setState(9287);
      this_keyword();
      break;
    }

    case 10: {
      enterOuterAlt(_localctx, 10);
      setState(9288);
      dollar_keyword();
      break;
    }

    case 11: {
      enterOuterAlt(_localctx, 11);
      setState(9289);
      null_keyword();
      break;
    }

    case 12: {
      enterOuterAlt(_localctx, 12);
      setState(9290);
      empty_queue();
      break;
    }

    case 13: {
      enterOuterAlt(_localctx, 13);
      setState(9291);
      randomize_call();
      break;
    }

    case 14: {
      enterOuterAlt(_localctx, 14);
      setState(9292);
      match(SV3_1aParser::OPEN_PARENS);
      setState(9293);
      expression(0);
      setState(9294);
      match(SV3_1aParser::COLON);
      setState(9295);
      expression(0);
      setState(9296);
      match(SV3_1aParser::COLON);
      setState(9297);
      expression(0);
      setState(9298);
      match(SV3_1aParser::CLOSE_PARENS);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- This_keywordContext ------------------------------------------------------------------

SV3_1aParser::This_keywordContext::This_keywordContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::This_keywordContext::THIS() {
  return getToken(SV3_1aParser::THIS, 0);
}


size_t SV3_1aParser::This_keywordContext::getRuleIndex() const {
  return SV3_1aParser::RuleThis_keyword;
}

void SV3_1aParser::This_keywordContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterThis_keyword(this);
}

void SV3_1aParser::This_keywordContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitThis_keyword(this);
}

SV3_1aParser::This_keywordContext* SV3_1aParser::this_keyword() {
  This_keywordContext *_localctx = _tracker.createInstance<This_keywordContext>(_ctx, getState());
  enterRule(_localctx, 1190, SV3_1aParser::RuleThis_keyword);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(9302);
    match(SV3_1aParser::THIS);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Super_keywordContext ------------------------------------------------------------------

SV3_1aParser::Super_keywordContext::Super_keywordContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Super_keywordContext::SUPER() {
  return getToken(SV3_1aParser::SUPER, 0);
}


size_t SV3_1aParser::Super_keywordContext::getRuleIndex() const {
  return SV3_1aParser::RuleSuper_keyword;
}

void SV3_1aParser::Super_keywordContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSuper_keyword(this);
}

void SV3_1aParser::Super_keywordContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSuper_keyword(this);
}

SV3_1aParser::Super_keywordContext* SV3_1aParser::super_keyword() {
  Super_keywordContext *_localctx = _tracker.createInstance<Super_keywordContext>(_ctx, getState());
  enterRule(_localctx, 1192, SV3_1aParser::RuleSuper_keyword);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(9304);
    match(SV3_1aParser::SUPER);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Dollar_keywordContext ------------------------------------------------------------------

SV3_1aParser::Dollar_keywordContext::Dollar_keywordContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Dollar_keywordContext::DOLLAR() {
  return getToken(SV3_1aParser::DOLLAR, 0);
}


size_t SV3_1aParser::Dollar_keywordContext::getRuleIndex() const {
  return SV3_1aParser::RuleDollar_keyword;
}

void SV3_1aParser::Dollar_keywordContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDollar_keyword(this);
}

void SV3_1aParser::Dollar_keywordContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDollar_keyword(this);
}

SV3_1aParser::Dollar_keywordContext* SV3_1aParser::dollar_keyword() {
  Dollar_keywordContext *_localctx = _tracker.createInstance<Dollar_keywordContext>(_ctx, getState());
  enterRule(_localctx, 1194, SV3_1aParser::RuleDollar_keyword);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(9306);
    match(SV3_1aParser::DOLLAR);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Dollar_root_keywordContext ------------------------------------------------------------------

SV3_1aParser::Dollar_root_keywordContext::Dollar_root_keywordContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Dollar_root_keywordContext::DOLLAR_ROOT() {
  return getToken(SV3_1aParser::DOLLAR_ROOT, 0);
}

tree::TerminalNode* SV3_1aParser::Dollar_root_keywordContext::DOT() {
  return getToken(SV3_1aParser::DOT, 0);
}


size_t SV3_1aParser::Dollar_root_keywordContext::getRuleIndex() const {
  return SV3_1aParser::RuleDollar_root_keyword;
}

void SV3_1aParser::Dollar_root_keywordContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDollar_root_keyword(this);
}

void SV3_1aParser::Dollar_root_keywordContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDollar_root_keyword(this);
}

SV3_1aParser::Dollar_root_keywordContext* SV3_1aParser::dollar_root_keyword() {
  Dollar_root_keywordContext *_localctx = _tracker.createInstance<Dollar_root_keywordContext>(_ctx, getState());
  enterRule(_localctx, 1196, SV3_1aParser::RuleDollar_root_keyword);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(9308);
    match(SV3_1aParser::DOLLAR_ROOT);
    setState(9309);
    match(SV3_1aParser::DOT);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- This_dot_superContext ------------------------------------------------------------------

SV3_1aParser::This_dot_superContext::This_dot_superContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::This_dot_superContext::THIS() {
  return getToken(SV3_1aParser::THIS, 0);
}

tree::TerminalNode* SV3_1aParser::This_dot_superContext::DOT() {
  return getToken(SV3_1aParser::DOT, 0);
}

tree::TerminalNode* SV3_1aParser::This_dot_superContext::SUPER() {
  return getToken(SV3_1aParser::SUPER, 0);
}


size_t SV3_1aParser::This_dot_superContext::getRuleIndex() const {
  return SV3_1aParser::RuleThis_dot_super;
}

void SV3_1aParser::This_dot_superContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterThis_dot_super(this);
}

void SV3_1aParser::This_dot_superContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitThis_dot_super(this);
}

SV3_1aParser::This_dot_superContext* SV3_1aParser::this_dot_super() {
  This_dot_superContext *_localctx = _tracker.createInstance<This_dot_superContext>(_ctx, getState());
  enterRule(_localctx, 1198, SV3_1aParser::RuleThis_dot_super);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(9311);
    match(SV3_1aParser::THIS);
    setState(9312);
    match(SV3_1aParser::DOT);
    setState(9313);
    match(SV3_1aParser::SUPER);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Null_keywordContext ------------------------------------------------------------------

SV3_1aParser::Null_keywordContext::Null_keywordContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Null_keywordContext::NULL_KEYWORD() {
  return getToken(SV3_1aParser::NULL_KEYWORD, 0);
}


size_t SV3_1aParser::Null_keywordContext::getRuleIndex() const {
  return SV3_1aParser::RuleNull_keyword;
}

void SV3_1aParser::Null_keywordContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNull_keyword(this);
}

void SV3_1aParser::Null_keywordContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNull_keyword(this);
}

SV3_1aParser::Null_keywordContext* SV3_1aParser::null_keyword() {
  Null_keywordContext *_localctx = _tracker.createInstance<Null_keywordContext>(_ctx, getState());
  enterRule(_localctx, 1200, SV3_1aParser::RuleNull_keyword);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(9315);
    match(SV3_1aParser::NULL_KEYWORD);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Time_literalContext ------------------------------------------------------------------

SV3_1aParser::Time_literalContext::Time_literalContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Time_literalContext::Integral_number() {
  return getToken(SV3_1aParser::Integral_number, 0);
}

SV3_1aParser::Time_unitContext* SV3_1aParser::Time_literalContext::time_unit() {
  return getRuleContext<SV3_1aParser::Time_unitContext>(0);
}

tree::TerminalNode* SV3_1aParser::Time_literalContext::Real_number() {
  return getToken(SV3_1aParser::Real_number, 0);
}


size_t SV3_1aParser::Time_literalContext::getRuleIndex() const {
  return SV3_1aParser::RuleTime_literal;
}

void SV3_1aParser::Time_literalContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTime_literal(this);
}

void SV3_1aParser::Time_literalContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTime_literal(this);
}

SV3_1aParser::Time_literalContext* SV3_1aParser::time_literal() {
  Time_literalContext *_localctx = _tracker.createInstance<Time_literalContext>(_ctx, getState());
  enterRule(_localctx, 1202, SV3_1aParser::RuleTime_literal);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(9321);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SV3_1aParser::Integral_number: {
        enterOuterAlt(_localctx, 1);
        setState(9317);
        match(SV3_1aParser::Integral_number);
        setState(9318);
        time_unit();
        break;
      }

      case SV3_1aParser::Real_number: {
        enterOuterAlt(_localctx, 2);
        setState(9319);
        match(SV3_1aParser::Real_number);
        setState(9320);
        time_unit();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Time_unitContext ------------------------------------------------------------------

SV3_1aParser::Time_unitContext::Time_unitContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Time_unitContext::Simple_identifier() {
  return getToken(SV3_1aParser::Simple_identifier, 0);
}


size_t SV3_1aParser::Time_unitContext::getRuleIndex() const {
  return SV3_1aParser::RuleTime_unit;
}

void SV3_1aParser::Time_unitContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTime_unit(this);
}

void SV3_1aParser::Time_unitContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTime_unit(this);
}

SV3_1aParser::Time_unitContext* SV3_1aParser::time_unit() {
  Time_unitContext *_localctx = _tracker.createInstance<Time_unitContext>(_ctx, getState());
  enterRule(_localctx, 1204, SV3_1aParser::RuleTime_unit);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(9323);
    match(SV3_1aParser::Simple_identifier);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Implicit_class_handleContext ------------------------------------------------------------------

SV3_1aParser::Implicit_class_handleContext::Implicit_class_handleContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::This_keywordContext* SV3_1aParser::Implicit_class_handleContext::this_keyword() {
  return getRuleContext<SV3_1aParser::This_keywordContext>(0);
}

SV3_1aParser::Super_keywordContext* SV3_1aParser::Implicit_class_handleContext::super_keyword() {
  return getRuleContext<SV3_1aParser::Super_keywordContext>(0);
}

SV3_1aParser::This_dot_superContext* SV3_1aParser::Implicit_class_handleContext::this_dot_super() {
  return getRuleContext<SV3_1aParser::This_dot_superContext>(0);
}


size_t SV3_1aParser::Implicit_class_handleContext::getRuleIndex() const {
  return SV3_1aParser::RuleImplicit_class_handle;
}

void SV3_1aParser::Implicit_class_handleContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterImplicit_class_handle(this);
}

void SV3_1aParser::Implicit_class_handleContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitImplicit_class_handle(this);
}

SV3_1aParser::Implicit_class_handleContext* SV3_1aParser::implicit_class_handle() {
  Implicit_class_handleContext *_localctx = _tracker.createInstance<Implicit_class_handleContext>(_ctx, getState());
  enterRule(_localctx, 1206, SV3_1aParser::RuleImplicit_class_handle);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(9328);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1107, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(9325);
      this_keyword();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(9326);
      super_keyword();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(9327);
      this_dot_super();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Bit_selectContext ------------------------------------------------------------------

SV3_1aParser::Bit_selectContext::Bit_selectContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> SV3_1aParser::Bit_selectContext::OPEN_BRACKET() {
  return getTokens(SV3_1aParser::OPEN_BRACKET);
}

tree::TerminalNode* SV3_1aParser::Bit_selectContext::OPEN_BRACKET(size_t i) {
  return getToken(SV3_1aParser::OPEN_BRACKET, i);
}

std::vector<SV3_1aParser::ExpressionContext *> SV3_1aParser::Bit_selectContext::expression() {
  return getRuleContexts<SV3_1aParser::ExpressionContext>();
}

SV3_1aParser::ExpressionContext* SV3_1aParser::Bit_selectContext::expression(size_t i) {
  return getRuleContext<SV3_1aParser::ExpressionContext>(i);
}

std::vector<tree::TerminalNode *> SV3_1aParser::Bit_selectContext::CLOSE_BRACKET() {
  return getTokens(SV3_1aParser::CLOSE_BRACKET);
}

tree::TerminalNode* SV3_1aParser::Bit_selectContext::CLOSE_BRACKET(size_t i) {
  return getToken(SV3_1aParser::CLOSE_BRACKET, i);
}


size_t SV3_1aParser::Bit_selectContext::getRuleIndex() const {
  return SV3_1aParser::RuleBit_select;
}

void SV3_1aParser::Bit_selectContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBit_select(this);
}

void SV3_1aParser::Bit_selectContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBit_select(this);
}

SV3_1aParser::Bit_selectContext* SV3_1aParser::bit_select() {
  Bit_selectContext *_localctx = _tracker.createInstance<Bit_selectContext>(_ctx, getState());
  enterRule(_localctx, 1208, SV3_1aParser::RuleBit_select);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(9336);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1108, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(9330);
        match(SV3_1aParser::OPEN_BRACKET);
        setState(9331);
        expression(0);
        setState(9332);
        match(SV3_1aParser::CLOSE_BRACKET); 
      }
      setState(9338);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1108, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SelectContext ------------------------------------------------------------------

SV3_1aParser::SelectContext::SelectContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<SV3_1aParser::Bit_selectContext *> SV3_1aParser::SelectContext::bit_select() {
  return getRuleContexts<SV3_1aParser::Bit_selectContext>();
}

SV3_1aParser::Bit_selectContext* SV3_1aParser::SelectContext::bit_select(size_t i) {
  return getRuleContext<SV3_1aParser::Bit_selectContext>(i);
}

std::vector<tree::TerminalNode *> SV3_1aParser::SelectContext::DOT() {
  return getTokens(SV3_1aParser::DOT);
}

tree::TerminalNode* SV3_1aParser::SelectContext::DOT(size_t i) {
  return getToken(SV3_1aParser::DOT, i);
}

std::vector<SV3_1aParser::IdentifierContext *> SV3_1aParser::SelectContext::identifier() {
  return getRuleContexts<SV3_1aParser::IdentifierContext>();
}

SV3_1aParser::IdentifierContext* SV3_1aParser::SelectContext::identifier(size_t i) {
  return getRuleContext<SV3_1aParser::IdentifierContext>(i);
}

tree::TerminalNode* SV3_1aParser::SelectContext::OPEN_BRACKET() {
  return getToken(SV3_1aParser::OPEN_BRACKET, 0);
}

SV3_1aParser::Part_select_rangeContext* SV3_1aParser::SelectContext::part_select_range() {
  return getRuleContext<SV3_1aParser::Part_select_rangeContext>(0);
}

tree::TerminalNode* SV3_1aParser::SelectContext::CLOSE_BRACKET() {
  return getToken(SV3_1aParser::CLOSE_BRACKET, 0);
}


size_t SV3_1aParser::SelectContext::getRuleIndex() const {
  return SV3_1aParser::RuleSelect;
}

void SV3_1aParser::SelectContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSelect(this);
}

void SV3_1aParser::SelectContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSelect(this);
}

SV3_1aParser::SelectContext* SV3_1aParser::select() {
  SelectContext *_localctx = _tracker.createInstance<SelectContext>(_ctx, getState());
  enterRule(_localctx, 1210, SV3_1aParser::RuleSelect);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(9350);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1110, _ctx)) {
    case 1: {
      setState(9345);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1109, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(9339);
          match(SV3_1aParser::DOT);
          setState(9340);
          identifier();
          setState(9341);
          bit_select(); 
        }
        setState(9347);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1109, _ctx);
      }
      setState(9348);
      match(SV3_1aParser::DOT);
      setState(9349);
      identifier();
      break;
    }

    default:
      break;
    }
    setState(9352);
    bit_select();
    setState(9357);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1111, _ctx)) {
    case 1: {
      setState(9353);
      match(SV3_1aParser::OPEN_BRACKET);
      setState(9354);
      part_select_range();
      setState(9355);
      match(SV3_1aParser::CLOSE_BRACKET);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Nonrange_selectContext ------------------------------------------------------------------

SV3_1aParser::Nonrange_selectContext::Nonrange_selectContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<SV3_1aParser::Bit_selectContext *> SV3_1aParser::Nonrange_selectContext::bit_select() {
  return getRuleContexts<SV3_1aParser::Bit_selectContext>();
}

SV3_1aParser::Bit_selectContext* SV3_1aParser::Nonrange_selectContext::bit_select(size_t i) {
  return getRuleContext<SV3_1aParser::Bit_selectContext>(i);
}

std::vector<tree::TerminalNode *> SV3_1aParser::Nonrange_selectContext::DOT() {
  return getTokens(SV3_1aParser::DOT);
}

tree::TerminalNode* SV3_1aParser::Nonrange_selectContext::DOT(size_t i) {
  return getToken(SV3_1aParser::DOT, i);
}

std::vector<SV3_1aParser::IdentifierContext *> SV3_1aParser::Nonrange_selectContext::identifier() {
  return getRuleContexts<SV3_1aParser::IdentifierContext>();
}

SV3_1aParser::IdentifierContext* SV3_1aParser::Nonrange_selectContext::identifier(size_t i) {
  return getRuleContext<SV3_1aParser::IdentifierContext>(i);
}


size_t SV3_1aParser::Nonrange_selectContext::getRuleIndex() const {
  return SV3_1aParser::RuleNonrange_select;
}

void SV3_1aParser::Nonrange_selectContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNonrange_select(this);
}

void SV3_1aParser::Nonrange_selectContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNonrange_select(this);
}

SV3_1aParser::Nonrange_selectContext* SV3_1aParser::nonrange_select() {
  Nonrange_selectContext *_localctx = _tracker.createInstance<Nonrange_selectContext>(_ctx, getState());
  enterRule(_localctx, 1212, SV3_1aParser::RuleNonrange_select);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(9370);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SV3_1aParser::DOT) {
      setState(9365);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1112, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(9359);
          match(SV3_1aParser::DOT);
          setState(9360);
          identifier();
          setState(9361);
          bit_select(); 
        }
        setState(9367);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1112, _ctx);
      }
      setState(9368);
      match(SV3_1aParser::DOT);
      setState(9369);
      identifier();
    }
    setState(9372);
    bit_select();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Constant_bit_selectContext ------------------------------------------------------------------

SV3_1aParser::Constant_bit_selectContext::Constant_bit_selectContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> SV3_1aParser::Constant_bit_selectContext::OPEN_BRACKET() {
  return getTokens(SV3_1aParser::OPEN_BRACKET);
}

tree::TerminalNode* SV3_1aParser::Constant_bit_selectContext::OPEN_BRACKET(size_t i) {
  return getToken(SV3_1aParser::OPEN_BRACKET, i);
}

std::vector<SV3_1aParser::Constant_expressionContext *> SV3_1aParser::Constant_bit_selectContext::constant_expression() {
  return getRuleContexts<SV3_1aParser::Constant_expressionContext>();
}

SV3_1aParser::Constant_expressionContext* SV3_1aParser::Constant_bit_selectContext::constant_expression(size_t i) {
  return getRuleContext<SV3_1aParser::Constant_expressionContext>(i);
}

std::vector<tree::TerminalNode *> SV3_1aParser::Constant_bit_selectContext::CLOSE_BRACKET() {
  return getTokens(SV3_1aParser::CLOSE_BRACKET);
}

tree::TerminalNode* SV3_1aParser::Constant_bit_selectContext::CLOSE_BRACKET(size_t i) {
  return getToken(SV3_1aParser::CLOSE_BRACKET, i);
}


size_t SV3_1aParser::Constant_bit_selectContext::getRuleIndex() const {
  return SV3_1aParser::RuleConstant_bit_select;
}

void SV3_1aParser::Constant_bit_selectContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterConstant_bit_select(this);
}

void SV3_1aParser::Constant_bit_selectContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitConstant_bit_select(this);
}

SV3_1aParser::Constant_bit_selectContext* SV3_1aParser::constant_bit_select() {
  Constant_bit_selectContext *_localctx = _tracker.createInstance<Constant_bit_selectContext>(_ctx, getState());
  enterRule(_localctx, 1214, SV3_1aParser::RuleConstant_bit_select);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(9380);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1114, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(9374);
        match(SV3_1aParser::OPEN_BRACKET);
        setState(9375);
        constant_expression(0);
        setState(9376);
        match(SV3_1aParser::CLOSE_BRACKET); 
      }
      setState(9382);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1114, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Constant_selectContext ------------------------------------------------------------------

SV3_1aParser::Constant_selectContext::Constant_selectContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<SV3_1aParser::Constant_bit_selectContext *> SV3_1aParser::Constant_selectContext::constant_bit_select() {
  return getRuleContexts<SV3_1aParser::Constant_bit_selectContext>();
}

SV3_1aParser::Constant_bit_selectContext* SV3_1aParser::Constant_selectContext::constant_bit_select(size_t i) {
  return getRuleContext<SV3_1aParser::Constant_bit_selectContext>(i);
}

std::vector<tree::TerminalNode *> SV3_1aParser::Constant_selectContext::DOT() {
  return getTokens(SV3_1aParser::DOT);
}

tree::TerminalNode* SV3_1aParser::Constant_selectContext::DOT(size_t i) {
  return getToken(SV3_1aParser::DOT, i);
}

std::vector<SV3_1aParser::IdentifierContext *> SV3_1aParser::Constant_selectContext::identifier() {
  return getRuleContexts<SV3_1aParser::IdentifierContext>();
}

SV3_1aParser::IdentifierContext* SV3_1aParser::Constant_selectContext::identifier(size_t i) {
  return getRuleContext<SV3_1aParser::IdentifierContext>(i);
}

tree::TerminalNode* SV3_1aParser::Constant_selectContext::OPEN_BRACKET() {
  return getToken(SV3_1aParser::OPEN_BRACKET, 0);
}

SV3_1aParser::Constant_part_select_rangeContext* SV3_1aParser::Constant_selectContext::constant_part_select_range() {
  return getRuleContext<SV3_1aParser::Constant_part_select_rangeContext>(0);
}

tree::TerminalNode* SV3_1aParser::Constant_selectContext::CLOSE_BRACKET() {
  return getToken(SV3_1aParser::CLOSE_BRACKET, 0);
}


size_t SV3_1aParser::Constant_selectContext::getRuleIndex() const {
  return SV3_1aParser::RuleConstant_select;
}

void SV3_1aParser::Constant_selectContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterConstant_select(this);
}

void SV3_1aParser::Constant_selectContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitConstant_select(this);
}

SV3_1aParser::Constant_selectContext* SV3_1aParser::constant_select() {
  Constant_selectContext *_localctx = _tracker.createInstance<Constant_selectContext>(_ctx, getState());
  enterRule(_localctx, 1216, SV3_1aParser::RuleConstant_select);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(9394);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1116, _ctx)) {
    case 1: {
      setState(9389);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1115, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(9383);
          match(SV3_1aParser::DOT);
          setState(9384);
          identifier();
          setState(9385);
          constant_bit_select(); 
        }
        setState(9391);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1115, _ctx);
      }
      setState(9392);
      match(SV3_1aParser::DOT);
      setState(9393);
      identifier();
      break;
    }

    default:
      break;
    }
    setState(9396);
    constant_bit_select();
    setState(9401);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1117, _ctx)) {
    case 1: {
      setState(9397);
      match(SV3_1aParser::OPEN_BRACKET);
      setState(9398);
      constant_part_select_range();
      setState(9399);
      match(SV3_1aParser::CLOSE_BRACKET);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Primary_literalContext ------------------------------------------------------------------

SV3_1aParser::Primary_literalContext::Primary_literalContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::NumberContext* SV3_1aParser::Primary_literalContext::number() {
  return getRuleContext<SV3_1aParser::NumberContext>(0);
}

SV3_1aParser::Time_literalContext* SV3_1aParser::Primary_literalContext::time_literal() {
  return getRuleContext<SV3_1aParser::Time_literalContext>(0);
}

SV3_1aParser::Unbased_unsized_literalContext* SV3_1aParser::Primary_literalContext::unbased_unsized_literal() {
  return getRuleContext<SV3_1aParser::Unbased_unsized_literalContext>(0);
}

SV3_1aParser::String_valueContext* SV3_1aParser::Primary_literalContext::string_value() {
  return getRuleContext<SV3_1aParser::String_valueContext>(0);
}

SV3_1aParser::IdentifierContext* SV3_1aParser::Primary_literalContext::identifier() {
  return getRuleContext<SV3_1aParser::IdentifierContext>(0);
}


size_t SV3_1aParser::Primary_literalContext::getRuleIndex() const {
  return SV3_1aParser::RulePrimary_literal;
}

void SV3_1aParser::Primary_literalContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPrimary_literal(this);
}

void SV3_1aParser::Primary_literalContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPrimary_literal(this);
}

SV3_1aParser::Primary_literalContext* SV3_1aParser::primary_literal() {
  Primary_literalContext *_localctx = _tracker.createInstance<Primary_literalContext>(_ctx, getState());
  enterRule(_localctx, 1218, SV3_1aParser::RulePrimary_literal);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(9408);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1118, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(9403);
      number();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(9404);
      time_literal();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(9405);
      unbased_unsized_literal();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(9406);
      string_value();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(9407);
      identifier();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Constant_castContext ------------------------------------------------------------------

SV3_1aParser::Constant_castContext::Constant_castContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::Casting_typeContext* SV3_1aParser::Constant_castContext::casting_type() {
  return getRuleContext<SV3_1aParser::Casting_typeContext>(0);
}

tree::TerminalNode* SV3_1aParser::Constant_castContext::TICK() {
  return getToken(SV3_1aParser::TICK, 0);
}

tree::TerminalNode* SV3_1aParser::Constant_castContext::OPEN_PARENS() {
  return getToken(SV3_1aParser::OPEN_PARENS, 0);
}

SV3_1aParser::Constant_expressionContext* SV3_1aParser::Constant_castContext::constant_expression() {
  return getRuleContext<SV3_1aParser::Constant_expressionContext>(0);
}

tree::TerminalNode* SV3_1aParser::Constant_castContext::CLOSE_PARENS() {
  return getToken(SV3_1aParser::CLOSE_PARENS, 0);
}

SV3_1aParser::Constant_concatenationContext* SV3_1aParser::Constant_castContext::constant_concatenation() {
  return getRuleContext<SV3_1aParser::Constant_concatenationContext>(0);
}

SV3_1aParser::Constant_multiple_concatenationContext* SV3_1aParser::Constant_castContext::constant_multiple_concatenation() {
  return getRuleContext<SV3_1aParser::Constant_multiple_concatenationContext>(0);
}


size_t SV3_1aParser::Constant_castContext::getRuleIndex() const {
  return SV3_1aParser::RuleConstant_cast;
}

void SV3_1aParser::Constant_castContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterConstant_cast(this);
}

void SV3_1aParser::Constant_castContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitConstant_cast(this);
}

SV3_1aParser::Constant_castContext* SV3_1aParser::constant_cast() {
  Constant_castContext *_localctx = _tracker.createInstance<Constant_castContext>(_ctx, getState());
  enterRule(_localctx, 1220, SV3_1aParser::RuleConstant_cast);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(9410);
    casting_type();
    setState(9411);
    match(SV3_1aParser::TICK);
    setState(9418);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1119, _ctx)) {
    case 1: {
      setState(9412);
      match(SV3_1aParser::OPEN_PARENS);
      setState(9413);
      constant_expression(0);
      setState(9414);
      match(SV3_1aParser::CLOSE_PARENS);
      break;
    }

    case 2: {
      setState(9416);
      constant_concatenation();
      break;
    }

    case 3: {
      setState(9417);
      constant_multiple_concatenation();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CastContext ------------------------------------------------------------------

SV3_1aParser::CastContext::CastContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::Casting_typeContext* SV3_1aParser::CastContext::casting_type() {
  return getRuleContext<SV3_1aParser::Casting_typeContext>(0);
}

tree::TerminalNode* SV3_1aParser::CastContext::TICK() {
  return getToken(SV3_1aParser::TICK, 0);
}

tree::TerminalNode* SV3_1aParser::CastContext::OPEN_PARENS() {
  return getToken(SV3_1aParser::OPEN_PARENS, 0);
}

SV3_1aParser::ExpressionContext* SV3_1aParser::CastContext::expression() {
  return getRuleContext<SV3_1aParser::ExpressionContext>(0);
}

tree::TerminalNode* SV3_1aParser::CastContext::CLOSE_PARENS() {
  return getToken(SV3_1aParser::CLOSE_PARENS, 0);
}

SV3_1aParser::ConcatenationContext* SV3_1aParser::CastContext::concatenation() {
  return getRuleContext<SV3_1aParser::ConcatenationContext>(0);
}

SV3_1aParser::Multiple_concatenationContext* SV3_1aParser::CastContext::multiple_concatenation() {
  return getRuleContext<SV3_1aParser::Multiple_concatenationContext>(0);
}


size_t SV3_1aParser::CastContext::getRuleIndex() const {
  return SV3_1aParser::RuleCast;
}

void SV3_1aParser::CastContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCast(this);
}

void SV3_1aParser::CastContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCast(this);
}

SV3_1aParser::CastContext* SV3_1aParser::cast() {
  CastContext *_localctx = _tracker.createInstance<CastContext>(_ctx, getState());
  enterRule(_localctx, 1222, SV3_1aParser::RuleCast);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(9420);
    casting_type();
    setState(9421);
    match(SV3_1aParser::TICK);
    setState(9428);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1120, _ctx)) {
    case 1: {
      setState(9422);
      match(SV3_1aParser::OPEN_PARENS);
      setState(9423);
      expression(0);
      setState(9424);
      match(SV3_1aParser::CLOSE_PARENS);
      break;
    }

    case 2: {
      setState(9426);
      concatenation();
      break;
    }

    case 3: {
      setState(9427);
      multiple_concatenation();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Net_lvalueContext ------------------------------------------------------------------

SV3_1aParser::Net_lvalueContext::Net_lvalueContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::Ps_or_hierarchical_identifierContext* SV3_1aParser::Net_lvalueContext::ps_or_hierarchical_identifier() {
  return getRuleContext<SV3_1aParser::Ps_or_hierarchical_identifierContext>(0);
}

SV3_1aParser::Constant_selectContext* SV3_1aParser::Net_lvalueContext::constant_select() {
  return getRuleContext<SV3_1aParser::Constant_selectContext>(0);
}

tree::TerminalNode* SV3_1aParser::Net_lvalueContext::OPEN_CURLY() {
  return getToken(SV3_1aParser::OPEN_CURLY, 0);
}

std::vector<SV3_1aParser::Net_lvalueContext *> SV3_1aParser::Net_lvalueContext::net_lvalue() {
  return getRuleContexts<SV3_1aParser::Net_lvalueContext>();
}

SV3_1aParser::Net_lvalueContext* SV3_1aParser::Net_lvalueContext::net_lvalue(size_t i) {
  return getRuleContext<SV3_1aParser::Net_lvalueContext>(i);
}

tree::TerminalNode* SV3_1aParser::Net_lvalueContext::CLOSE_CURLY() {
  return getToken(SV3_1aParser::CLOSE_CURLY, 0);
}

std::vector<tree::TerminalNode *> SV3_1aParser::Net_lvalueContext::COMMA() {
  return getTokens(SV3_1aParser::COMMA);
}

tree::TerminalNode* SV3_1aParser::Net_lvalueContext::COMMA(size_t i) {
  return getToken(SV3_1aParser::COMMA, i);
}

SV3_1aParser::Assignment_pattern_net_lvalueContext* SV3_1aParser::Net_lvalueContext::assignment_pattern_net_lvalue() {
  return getRuleContext<SV3_1aParser::Assignment_pattern_net_lvalueContext>(0);
}

SV3_1aParser::Assignment_pattern_expression_typeContext* SV3_1aParser::Net_lvalueContext::assignment_pattern_expression_type() {
  return getRuleContext<SV3_1aParser::Assignment_pattern_expression_typeContext>(0);
}


size_t SV3_1aParser::Net_lvalueContext::getRuleIndex() const {
  return SV3_1aParser::RuleNet_lvalue;
}

void SV3_1aParser::Net_lvalueContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNet_lvalue(this);
}

void SV3_1aParser::Net_lvalueContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNet_lvalue(this);
}

SV3_1aParser::Net_lvalueContext* SV3_1aParser::net_lvalue() {
  Net_lvalueContext *_localctx = _tracker.createInstance<Net_lvalueContext>(_ctx, getState());
  enterRule(_localctx, 1224, SV3_1aParser::RuleNet_lvalue);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(9448);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1123, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(9430);
      ps_or_hierarchical_identifier();
      setState(9431);
      constant_select();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(9433);
      match(SV3_1aParser::OPEN_CURLY);
      setState(9434);
      net_lvalue();
      setState(9439);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == SV3_1aParser::COMMA) {
        setState(9435);
        match(SV3_1aParser::COMMA);
        setState(9436);
        net_lvalue();
        setState(9441);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(9442);
      match(SV3_1aParser::CLOSE_CURLY);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(9445);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (((((_la - 64) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 64)) & 17732923532804097) != 0) || _la == SV3_1aParser::DOLLAR_UNIT || ((((_la - 326) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 326)) & 4672924483589) != 0)) {
        setState(9444);
        assignment_pattern_expression_type();
      }
      setState(9447);
      assignment_pattern_net_lvalue();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Variable_lvalueContext ------------------------------------------------------------------

SV3_1aParser::Variable_lvalueContext::Variable_lvalueContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::Ps_or_hierarchical_identifierContext* SV3_1aParser::Variable_lvalueContext::ps_or_hierarchical_identifier() {
  return getRuleContext<SV3_1aParser::Ps_or_hierarchical_identifierContext>(0);
}

SV3_1aParser::SelectContext* SV3_1aParser::Variable_lvalueContext::select() {
  return getRuleContext<SV3_1aParser::SelectContext>(0);
}

SV3_1aParser::Implicit_class_handleContext* SV3_1aParser::Variable_lvalueContext::implicit_class_handle() {
  return getRuleContext<SV3_1aParser::Implicit_class_handleContext>(0);
}

tree::TerminalNode* SV3_1aParser::Variable_lvalueContext::DOT() {
  return getToken(SV3_1aParser::DOT, 0);
}

SV3_1aParser::Package_scopeContext* SV3_1aParser::Variable_lvalueContext::package_scope() {
  return getRuleContext<SV3_1aParser::Package_scopeContext>(0);
}

tree::TerminalNode* SV3_1aParser::Variable_lvalueContext::OPEN_CURLY() {
  return getToken(SV3_1aParser::OPEN_CURLY, 0);
}

std::vector<SV3_1aParser::Variable_lvalueContext *> SV3_1aParser::Variable_lvalueContext::variable_lvalue() {
  return getRuleContexts<SV3_1aParser::Variable_lvalueContext>();
}

SV3_1aParser::Variable_lvalueContext* SV3_1aParser::Variable_lvalueContext::variable_lvalue(size_t i) {
  return getRuleContext<SV3_1aParser::Variable_lvalueContext>(i);
}

tree::TerminalNode* SV3_1aParser::Variable_lvalueContext::CLOSE_CURLY() {
  return getToken(SV3_1aParser::CLOSE_CURLY, 0);
}

std::vector<tree::TerminalNode *> SV3_1aParser::Variable_lvalueContext::COMMA() {
  return getTokens(SV3_1aParser::COMMA);
}

tree::TerminalNode* SV3_1aParser::Variable_lvalueContext::COMMA(size_t i) {
  return getToken(SV3_1aParser::COMMA, i);
}

SV3_1aParser::Assignment_pattern_variable_lvalueContext* SV3_1aParser::Variable_lvalueContext::assignment_pattern_variable_lvalue() {
  return getRuleContext<SV3_1aParser::Assignment_pattern_variable_lvalueContext>(0);
}

SV3_1aParser::Assignment_pattern_expression_typeContext* SV3_1aParser::Variable_lvalueContext::assignment_pattern_expression_type() {
  return getRuleContext<SV3_1aParser::Assignment_pattern_expression_typeContext>(0);
}

SV3_1aParser::Streaming_concatenationContext* SV3_1aParser::Variable_lvalueContext::streaming_concatenation() {
  return getRuleContext<SV3_1aParser::Streaming_concatenationContext>(0);
}


size_t SV3_1aParser::Variable_lvalueContext::getRuleIndex() const {
  return SV3_1aParser::RuleVariable_lvalue;
}

void SV3_1aParser::Variable_lvalueContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterVariable_lvalue(this);
}

void SV3_1aParser::Variable_lvalueContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitVariable_lvalue(this);
}

SV3_1aParser::Variable_lvalueContext* SV3_1aParser::variable_lvalue() {
  Variable_lvalueContext *_localctx = _tracker.createInstance<Variable_lvalueContext>(_ctx, getState());
  enterRule(_localctx, 1226, SV3_1aParser::RuleVariable_lvalue);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(9475);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1127, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(9454);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1124, _ctx)) {
      case 1: {
        setState(9450);
        implicit_class_handle();
        setState(9451);
        match(SV3_1aParser::DOT);
        break;
      }

      case 2: {
        setState(9453);
        package_scope();
        break;
      }

      default:
        break;
      }
      setState(9456);
      ps_or_hierarchical_identifier();
      setState(9457);
      select();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(9459);
      match(SV3_1aParser::OPEN_CURLY);
      setState(9460);
      variable_lvalue();
      setState(9465);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == SV3_1aParser::COMMA) {
        setState(9461);
        match(SV3_1aParser::COMMA);
        setState(9462);
        variable_lvalue();
        setState(9467);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(9468);
      match(SV3_1aParser::CLOSE_CURLY);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(9471);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (((((_la - 64) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 64)) & 17732923532804097) != 0) || _la == SV3_1aParser::DOLLAR_UNIT || ((((_la - 326) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 326)) & 4672924483589) != 0)) {
        setState(9470);
        assignment_pattern_expression_type();
      }
      setState(9473);
      assignment_pattern_variable_lvalue();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(9474);
      streaming_concatenation();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Nonrange_variable_lvalueContext ------------------------------------------------------------------

SV3_1aParser::Nonrange_variable_lvalueContext::Nonrange_variable_lvalueContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::Nonrange_selectContext* SV3_1aParser::Nonrange_variable_lvalueContext::nonrange_select() {
  return getRuleContext<SV3_1aParser::Nonrange_selectContext>(0);
}

SV3_1aParser::IdentifierContext* SV3_1aParser::Nonrange_variable_lvalueContext::identifier() {
  return getRuleContext<SV3_1aParser::IdentifierContext>(0);
}

SV3_1aParser::Hierarchical_identifierContext* SV3_1aParser::Nonrange_variable_lvalueContext::hierarchical_identifier() {
  return getRuleContext<SV3_1aParser::Hierarchical_identifierContext>(0);
}

SV3_1aParser::Implicit_class_handleContext* SV3_1aParser::Nonrange_variable_lvalueContext::implicit_class_handle() {
  return getRuleContext<SV3_1aParser::Implicit_class_handleContext>(0);
}

tree::TerminalNode* SV3_1aParser::Nonrange_variable_lvalueContext::DOT() {
  return getToken(SV3_1aParser::DOT, 0);
}

SV3_1aParser::Package_scopeContext* SV3_1aParser::Nonrange_variable_lvalueContext::package_scope() {
  return getRuleContext<SV3_1aParser::Package_scopeContext>(0);
}


size_t SV3_1aParser::Nonrange_variable_lvalueContext::getRuleIndex() const {
  return SV3_1aParser::RuleNonrange_variable_lvalue;
}

void SV3_1aParser::Nonrange_variable_lvalueContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNonrange_variable_lvalue(this);
}

void SV3_1aParser::Nonrange_variable_lvalueContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNonrange_variable_lvalue(this);
}

SV3_1aParser::Nonrange_variable_lvalueContext* SV3_1aParser::nonrange_variable_lvalue() {
  Nonrange_variable_lvalueContext *_localctx = _tracker.createInstance<Nonrange_variable_lvalueContext>(_ctx, getState());
  enterRule(_localctx, 1228, SV3_1aParser::RuleNonrange_variable_lvalue);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(9481);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1128, _ctx)) {
    case 1: {
      setState(9477);
      implicit_class_handle();
      setState(9478);
      match(SV3_1aParser::DOT);
      break;
    }

    case 2: {
      setState(9480);
      package_scope();
      break;
    }

    default:
      break;
    }
    setState(9485);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1129, _ctx)) {
    case 1: {
      setState(9483);
      identifier();
      break;
    }

    case 2: {
      setState(9484);
      hierarchical_identifier();
      break;
    }

    default:
      break;
    }
    setState(9487);
    nonrange_select();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Inc_or_dec_operatorContext ------------------------------------------------------------------

SV3_1aParser::Inc_or_dec_operatorContext::Inc_or_dec_operatorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Inc_or_dec_operatorContext::PLUSPLUS() {
  return getToken(SV3_1aParser::PLUSPLUS, 0);
}

tree::TerminalNode* SV3_1aParser::Inc_or_dec_operatorContext::MINUSMINUS() {
  return getToken(SV3_1aParser::MINUSMINUS, 0);
}


size_t SV3_1aParser::Inc_or_dec_operatorContext::getRuleIndex() const {
  return SV3_1aParser::RuleInc_or_dec_operator;
}

void SV3_1aParser::Inc_or_dec_operatorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInc_or_dec_operator(this);
}

void SV3_1aParser::Inc_or_dec_operatorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInc_or_dec_operator(this);
}

SV3_1aParser::Inc_or_dec_operatorContext* SV3_1aParser::inc_or_dec_operator() {
  Inc_or_dec_operatorContext *_localctx = _tracker.createInstance<Inc_or_dec_operatorContext>(_ctx, getState());
  enterRule(_localctx, 1230, SV3_1aParser::RuleInc_or_dec_operator);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(9489);
    _la = _input->LA(1);
    if (!(_la == SV3_1aParser::PLUSPLUS

    || _la == SV3_1aParser::MINUSMINUS)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Unary_module_path_operatorContext ------------------------------------------------------------------

SV3_1aParser::Unary_module_path_operatorContext::Unary_module_path_operatorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t SV3_1aParser::Unary_module_path_operatorContext::getRuleIndex() const {
  return SV3_1aParser::RuleUnary_module_path_operator;
}

void SV3_1aParser::Unary_module_path_operatorContext::copyFrom(Unary_module_path_operatorContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- UnaryModOp_ReductXnor2Context ------------------------------------------------------------------

tree::TerminalNode* SV3_1aParser::UnaryModOp_ReductXnor2Context::REDUCTION_XNOR2() {
  return getToken(SV3_1aParser::REDUCTION_XNOR2, 0);
}

SV3_1aParser::UnaryModOp_ReductXnor2Context::UnaryModOp_ReductXnor2Context(Unary_module_path_operatorContext *ctx) { copyFrom(ctx); }

void SV3_1aParser::UnaryModOp_ReductXnor2Context::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUnaryModOp_ReductXnor2(this);
}
void SV3_1aParser::UnaryModOp_ReductXnor2Context::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUnaryModOp_ReductXnor2(this);
}
//----------------- UnaryModOp_NotContext ------------------------------------------------------------------

tree::TerminalNode* SV3_1aParser::UnaryModOp_NotContext::BANG() {
  return getToken(SV3_1aParser::BANG, 0);
}

SV3_1aParser::UnaryModOp_NotContext::UnaryModOp_NotContext(Unary_module_path_operatorContext *ctx) { copyFrom(ctx); }

void SV3_1aParser::UnaryModOp_NotContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUnaryModOp_Not(this);
}
void SV3_1aParser::UnaryModOp_NotContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUnaryModOp_Not(this);
}
//----------------- UnaryModOp_ReductNandContext ------------------------------------------------------------------

tree::TerminalNode* SV3_1aParser::UnaryModOp_ReductNandContext::REDUCTION_NAND() {
  return getToken(SV3_1aParser::REDUCTION_NAND, 0);
}

SV3_1aParser::UnaryModOp_ReductNandContext::UnaryModOp_ReductNandContext(Unary_module_path_operatorContext *ctx) { copyFrom(ctx); }

void SV3_1aParser::UnaryModOp_ReductNandContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUnaryModOp_ReductNand(this);
}
void SV3_1aParser::UnaryModOp_ReductNandContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUnaryModOp_ReductNand(this);
}
//----------------- UnaryModOp_ReductXNor1Context ------------------------------------------------------------------

tree::TerminalNode* SV3_1aParser::UnaryModOp_ReductXNor1Context::REDUCTION_XNOR1() {
  return getToken(SV3_1aParser::REDUCTION_XNOR1, 0);
}

SV3_1aParser::UnaryModOp_ReductXNor1Context::UnaryModOp_ReductXNor1Context(Unary_module_path_operatorContext *ctx) { copyFrom(ctx); }

void SV3_1aParser::UnaryModOp_ReductXNor1Context::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUnaryModOp_ReductXNor1(this);
}
void SV3_1aParser::UnaryModOp_ReductXNor1Context::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUnaryModOp_ReductXNor1(this);
}
//----------------- UnaryModOp_TildaContext ------------------------------------------------------------------

tree::TerminalNode* SV3_1aParser::UnaryModOp_TildaContext::TILDA() {
  return getToken(SV3_1aParser::TILDA, 0);
}

SV3_1aParser::UnaryModOp_TildaContext::UnaryModOp_TildaContext(Unary_module_path_operatorContext *ctx) { copyFrom(ctx); }

void SV3_1aParser::UnaryModOp_TildaContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUnaryModOp_Tilda(this);
}
void SV3_1aParser::UnaryModOp_TildaContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUnaryModOp_Tilda(this);
}
//----------------- UnaryModOp_BitwOrContext ------------------------------------------------------------------

tree::TerminalNode* SV3_1aParser::UnaryModOp_BitwOrContext::BITW_OR() {
  return getToken(SV3_1aParser::BITW_OR, 0);
}

SV3_1aParser::UnaryModOp_BitwOrContext::UnaryModOp_BitwOrContext(Unary_module_path_operatorContext *ctx) { copyFrom(ctx); }

void SV3_1aParser::UnaryModOp_BitwOrContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUnaryModOp_BitwOr(this);
}
void SV3_1aParser::UnaryModOp_BitwOrContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUnaryModOp_BitwOr(this);
}
//----------------- UnaryModOp_ReductNorContext ------------------------------------------------------------------

tree::TerminalNode* SV3_1aParser::UnaryModOp_ReductNorContext::REDUCTION_NOR() {
  return getToken(SV3_1aParser::REDUCTION_NOR, 0);
}

SV3_1aParser::UnaryModOp_ReductNorContext::UnaryModOp_ReductNorContext(Unary_module_path_operatorContext *ctx) { copyFrom(ctx); }

void SV3_1aParser::UnaryModOp_ReductNorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUnaryModOp_ReductNor(this);
}
void SV3_1aParser::UnaryModOp_ReductNorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUnaryModOp_ReductNor(this);
}
//----------------- UnaryModOp_BitwXorContext ------------------------------------------------------------------

tree::TerminalNode* SV3_1aParser::UnaryModOp_BitwXorContext::BITW_XOR() {
  return getToken(SV3_1aParser::BITW_XOR, 0);
}

SV3_1aParser::UnaryModOp_BitwXorContext::UnaryModOp_BitwXorContext(Unary_module_path_operatorContext *ctx) { copyFrom(ctx); }

void SV3_1aParser::UnaryModOp_BitwXorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUnaryModOp_BitwXor(this);
}
void SV3_1aParser::UnaryModOp_BitwXorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUnaryModOp_BitwXor(this);
}
//----------------- UnaryModOp_BitwAndContext ------------------------------------------------------------------

tree::TerminalNode* SV3_1aParser::UnaryModOp_BitwAndContext::BITW_AND() {
  return getToken(SV3_1aParser::BITW_AND, 0);
}

SV3_1aParser::UnaryModOp_BitwAndContext::UnaryModOp_BitwAndContext(Unary_module_path_operatorContext *ctx) { copyFrom(ctx); }

void SV3_1aParser::UnaryModOp_BitwAndContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUnaryModOp_BitwAnd(this);
}
void SV3_1aParser::UnaryModOp_BitwAndContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUnaryModOp_BitwAnd(this);
}
SV3_1aParser::Unary_module_path_operatorContext* SV3_1aParser::unary_module_path_operator() {
  Unary_module_path_operatorContext *_localctx = _tracker.createInstance<Unary_module_path_operatorContext>(_ctx, getState());
  enterRule(_localctx, 1232, SV3_1aParser::RuleUnary_module_path_operator);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(9500);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SV3_1aParser::BANG: {
        _localctx = _tracker.createInstance<SV3_1aParser::UnaryModOp_NotContext>(_localctx);
        enterOuterAlt(_localctx, 1);
        setState(9491);
        match(SV3_1aParser::BANG);
        break;
      }

      case SV3_1aParser::TILDA: {
        _localctx = _tracker.createInstance<SV3_1aParser::UnaryModOp_TildaContext>(_localctx);
        enterOuterAlt(_localctx, 2);
        setState(9492);
        match(SV3_1aParser::TILDA);
        break;
      }

      case SV3_1aParser::BITW_AND: {
        _localctx = _tracker.createInstance<SV3_1aParser::UnaryModOp_BitwAndContext>(_localctx);
        enterOuterAlt(_localctx, 3);
        setState(9493);
        match(SV3_1aParser::BITW_AND);
        break;
      }

      case SV3_1aParser::REDUCTION_NAND: {
        _localctx = _tracker.createInstance<SV3_1aParser::UnaryModOp_ReductNandContext>(_localctx);
        enterOuterAlt(_localctx, 4);
        setState(9494);
        match(SV3_1aParser::REDUCTION_NAND);
        break;
      }

      case SV3_1aParser::BITW_OR: {
        _localctx = _tracker.createInstance<SV3_1aParser::UnaryModOp_BitwOrContext>(_localctx);
        enterOuterAlt(_localctx, 5);
        setState(9495);
        match(SV3_1aParser::BITW_OR);
        break;
      }

      case SV3_1aParser::REDUCTION_NOR: {
        _localctx = _tracker.createInstance<SV3_1aParser::UnaryModOp_ReductNorContext>(_localctx);
        enterOuterAlt(_localctx, 6);
        setState(9496);
        match(SV3_1aParser::REDUCTION_NOR);
        break;
      }

      case SV3_1aParser::BITW_XOR: {
        _localctx = _tracker.createInstance<SV3_1aParser::UnaryModOp_BitwXorContext>(_localctx);
        enterOuterAlt(_localctx, 7);
        setState(9497);
        match(SV3_1aParser::BITW_XOR);
        break;
      }

      case SV3_1aParser::REDUCTION_XNOR1: {
        _localctx = _tracker.createInstance<SV3_1aParser::UnaryModOp_ReductXNor1Context>(_localctx);
        enterOuterAlt(_localctx, 8);
        setState(9498);
        match(SV3_1aParser::REDUCTION_XNOR1);
        break;
      }

      case SV3_1aParser::REDUCTION_XNOR2: {
        _localctx = _tracker.createInstance<SV3_1aParser::UnaryModOp_ReductXnor2Context>(_localctx);
        enterOuterAlt(_localctx, 9);
        setState(9499);
        match(SV3_1aParser::REDUCTION_XNOR2);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Binary_module_path_operatorContext ------------------------------------------------------------------

SV3_1aParser::Binary_module_path_operatorContext::Binary_module_path_operatorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t SV3_1aParser::Binary_module_path_operatorContext::getRuleIndex() const {
  return SV3_1aParser::RuleBinary_module_path_operator;
}

void SV3_1aParser::Binary_module_path_operatorContext::copyFrom(Binary_module_path_operatorContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- BinModOp_EquivContext ------------------------------------------------------------------

tree::TerminalNode* SV3_1aParser::BinModOp_EquivContext::EQUIV() {
  return getToken(SV3_1aParser::EQUIV, 0);
}

SV3_1aParser::BinModOp_EquivContext::BinModOp_EquivContext(Binary_module_path_operatorContext *ctx) { copyFrom(ctx); }

void SV3_1aParser::BinModOp_EquivContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBinModOp_Equiv(this);
}
void SV3_1aParser::BinModOp_EquivContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBinModOp_Equiv(this);
}
//----------------- BinModOp_BitwXorContext ------------------------------------------------------------------

tree::TerminalNode* SV3_1aParser::BinModOp_BitwXorContext::BITW_XOR() {
  return getToken(SV3_1aParser::BITW_XOR, 0);
}

SV3_1aParser::BinModOp_BitwXorContext::BinModOp_BitwXorContext(Binary_module_path_operatorContext *ctx) { copyFrom(ctx); }

void SV3_1aParser::BinModOp_BitwXorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBinModOp_BitwXor(this);
}
void SV3_1aParser::BinModOp_BitwXorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBinModOp_BitwXor(this);
}
//----------------- BinModOp_LogicOrContext ------------------------------------------------------------------

tree::TerminalNode* SV3_1aParser::BinModOp_LogicOrContext::LOGICAL_OR() {
  return getToken(SV3_1aParser::LOGICAL_OR, 0);
}

SV3_1aParser::BinModOp_LogicOrContext::BinModOp_LogicOrContext(Binary_module_path_operatorContext *ctx) { copyFrom(ctx); }

void SV3_1aParser::BinModOp_LogicOrContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBinModOp_LogicOr(this);
}
void SV3_1aParser::BinModOp_LogicOrContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBinModOp_LogicOr(this);
}
//----------------- BinModOp_NotEqualContext ------------------------------------------------------------------

tree::TerminalNode* SV3_1aParser::BinModOp_NotEqualContext::NOTEQUAL() {
  return getToken(SV3_1aParser::NOTEQUAL, 0);
}

SV3_1aParser::BinModOp_NotEqualContext::BinModOp_NotEqualContext(Binary_module_path_operatorContext *ctx) { copyFrom(ctx); }

void SV3_1aParser::BinModOp_NotEqualContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBinModOp_NotEqual(this);
}
void SV3_1aParser::BinModOp_NotEqualContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBinModOp_NotEqual(this);
}
//----------------- BinModOp_LogicAndContext ------------------------------------------------------------------

tree::TerminalNode* SV3_1aParser::BinModOp_LogicAndContext::LOGICAL_AND() {
  return getToken(SV3_1aParser::LOGICAL_AND, 0);
}

SV3_1aParser::BinModOp_LogicAndContext::BinModOp_LogicAndContext(Binary_module_path_operatorContext *ctx) { copyFrom(ctx); }

void SV3_1aParser::BinModOp_LogicAndContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBinModOp_LogicAnd(this);
}
void SV3_1aParser::BinModOp_LogicAndContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBinModOp_LogicAnd(this);
}
//----------------- BinModOp_BitwAndContext ------------------------------------------------------------------

tree::TerminalNode* SV3_1aParser::BinModOp_BitwAndContext::BITW_AND() {
  return getToken(SV3_1aParser::BITW_AND, 0);
}

SV3_1aParser::BinModOp_BitwAndContext::BinModOp_BitwAndContext(Binary_module_path_operatorContext *ctx) { copyFrom(ctx); }

void SV3_1aParser::BinModOp_BitwAndContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBinModOp_BitwAnd(this);
}
void SV3_1aParser::BinModOp_BitwAndContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBinModOp_BitwAnd(this);
}
//----------------- BinModOp_BitwOrContext ------------------------------------------------------------------

tree::TerminalNode* SV3_1aParser::BinModOp_BitwOrContext::BITW_OR() {
  return getToken(SV3_1aParser::BITW_OR, 0);
}

SV3_1aParser::BinModOp_BitwOrContext::BinModOp_BitwOrContext(Binary_module_path_operatorContext *ctx) { copyFrom(ctx); }

void SV3_1aParser::BinModOp_BitwOrContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBinModOp_BitwOr(this);
}
void SV3_1aParser::BinModOp_BitwOrContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBinModOp_BitwOr(this);
}
//----------------- BinModOp_ReductXnor1Context ------------------------------------------------------------------

tree::TerminalNode* SV3_1aParser::BinModOp_ReductXnor1Context::REDUCTION_XNOR1() {
  return getToken(SV3_1aParser::REDUCTION_XNOR1, 0);
}

SV3_1aParser::BinModOp_ReductXnor1Context::BinModOp_ReductXnor1Context(Binary_module_path_operatorContext *ctx) { copyFrom(ctx); }

void SV3_1aParser::BinModOp_ReductXnor1Context::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBinModOp_ReductXnor1(this);
}
void SV3_1aParser::BinModOp_ReductXnor1Context::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBinModOp_ReductXnor1(this);
}
//----------------- BinModOp_ReductXnor2Context ------------------------------------------------------------------

tree::TerminalNode* SV3_1aParser::BinModOp_ReductXnor2Context::REDUCTION_XNOR2() {
  return getToken(SV3_1aParser::REDUCTION_XNOR2, 0);
}

SV3_1aParser::BinModOp_ReductXnor2Context::BinModOp_ReductXnor2Context(Binary_module_path_operatorContext *ctx) { copyFrom(ctx); }

void SV3_1aParser::BinModOp_ReductXnor2Context::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBinModOp_ReductXnor2(this);
}
void SV3_1aParser::BinModOp_ReductXnor2Context::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBinModOp_ReductXnor2(this);
}
SV3_1aParser::Binary_module_path_operatorContext* SV3_1aParser::binary_module_path_operator() {
  Binary_module_path_operatorContext *_localctx = _tracker.createInstance<Binary_module_path_operatorContext>(_ctx, getState());
  enterRule(_localctx, 1234, SV3_1aParser::RuleBinary_module_path_operator);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(9511);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SV3_1aParser::EQUIV: {
        _localctx = _tracker.createInstance<SV3_1aParser::BinModOp_EquivContext>(_localctx);
        enterOuterAlt(_localctx, 1);
        setState(9502);
        match(SV3_1aParser::EQUIV);
        break;
      }

      case SV3_1aParser::NOTEQUAL: {
        _localctx = _tracker.createInstance<SV3_1aParser::BinModOp_NotEqualContext>(_localctx);
        enterOuterAlt(_localctx, 2);
        setState(9503);
        match(SV3_1aParser::NOTEQUAL);
        break;
      }

      case SV3_1aParser::LOGICAL_AND: {
        _localctx = _tracker.createInstance<SV3_1aParser::BinModOp_LogicAndContext>(_localctx);
        enterOuterAlt(_localctx, 3);
        setState(9504);
        match(SV3_1aParser::LOGICAL_AND);
        break;
      }

      case SV3_1aParser::LOGICAL_OR: {
        _localctx = _tracker.createInstance<SV3_1aParser::BinModOp_LogicOrContext>(_localctx);
        enterOuterAlt(_localctx, 4);
        setState(9505);
        match(SV3_1aParser::LOGICAL_OR);
        break;
      }

      case SV3_1aParser::BITW_AND: {
        _localctx = _tracker.createInstance<SV3_1aParser::BinModOp_BitwAndContext>(_localctx);
        enterOuterAlt(_localctx, 5);
        setState(9506);
        match(SV3_1aParser::BITW_AND);
        break;
      }

      case SV3_1aParser::BITW_OR: {
        _localctx = _tracker.createInstance<SV3_1aParser::BinModOp_BitwOrContext>(_localctx);
        enterOuterAlt(_localctx, 6);
        setState(9507);
        match(SV3_1aParser::BITW_OR);
        break;
      }

      case SV3_1aParser::BITW_XOR: {
        _localctx = _tracker.createInstance<SV3_1aParser::BinModOp_BitwXorContext>(_localctx);
        enterOuterAlt(_localctx, 7);
        setState(9508);
        match(SV3_1aParser::BITW_XOR);
        break;
      }

      case SV3_1aParser::REDUCTION_XNOR1: {
        _localctx = _tracker.createInstance<SV3_1aParser::BinModOp_ReductXnor1Context>(_localctx);
        enterOuterAlt(_localctx, 8);
        setState(9509);
        match(SV3_1aParser::REDUCTION_XNOR1);
        break;
      }

      case SV3_1aParser::REDUCTION_XNOR2: {
        _localctx = _tracker.createInstance<SV3_1aParser::BinModOp_ReductXnor2Context>(_localctx);
        enterOuterAlt(_localctx, 9);
        setState(9510);
        match(SV3_1aParser::REDUCTION_XNOR2);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- NumberContext ------------------------------------------------------------------

SV3_1aParser::NumberContext::NumberContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::NumberContext::Integral_number() {
  return getToken(SV3_1aParser::Integral_number, 0);
}

tree::TerminalNode* SV3_1aParser::NumberContext::Real_number() {
  return getToken(SV3_1aParser::Real_number, 0);
}

tree::TerminalNode* SV3_1aParser::NumberContext::ONE_TICK_b0() {
  return getToken(SV3_1aParser::ONE_TICK_b0, 0);
}

tree::TerminalNode* SV3_1aParser::NumberContext::ONE_TICK_b1() {
  return getToken(SV3_1aParser::ONE_TICK_b1, 0);
}

tree::TerminalNode* SV3_1aParser::NumberContext::ONE_TICK_B0() {
  return getToken(SV3_1aParser::ONE_TICK_B0, 0);
}

tree::TerminalNode* SV3_1aParser::NumberContext::ONE_TICK_B1() {
  return getToken(SV3_1aParser::ONE_TICK_B1, 0);
}

tree::TerminalNode* SV3_1aParser::NumberContext::TICK_b0() {
  return getToken(SV3_1aParser::TICK_b0, 0);
}

tree::TerminalNode* SV3_1aParser::NumberContext::TICK_b1() {
  return getToken(SV3_1aParser::TICK_b1, 0);
}

tree::TerminalNode* SV3_1aParser::NumberContext::TICK_B0() {
  return getToken(SV3_1aParser::TICK_B0, 0);
}

tree::TerminalNode* SV3_1aParser::NumberContext::TICK_B1() {
  return getToken(SV3_1aParser::TICK_B1, 0);
}

tree::TerminalNode* SV3_1aParser::NumberContext::TICK_0() {
  return getToken(SV3_1aParser::TICK_0, 0);
}

tree::TerminalNode* SV3_1aParser::NumberContext::TICK_1() {
  return getToken(SV3_1aParser::TICK_1, 0);
}

tree::TerminalNode* SV3_1aParser::NumberContext::ONE_TICK_bx() {
  return getToken(SV3_1aParser::ONE_TICK_bx, 0);
}

tree::TerminalNode* SV3_1aParser::NumberContext::ONE_TICK_bX() {
  return getToken(SV3_1aParser::ONE_TICK_bX, 0);
}

tree::TerminalNode* SV3_1aParser::NumberContext::ONE_TICK_Bx() {
  return getToken(SV3_1aParser::ONE_TICK_Bx, 0);
}

tree::TerminalNode* SV3_1aParser::NumberContext::ONE_TICK_BX() {
  return getToken(SV3_1aParser::ONE_TICK_BX, 0);
}


size_t SV3_1aParser::NumberContext::getRuleIndex() const {
  return SV3_1aParser::RuleNumber;
}

void SV3_1aParser::NumberContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNumber(this);
}

void SV3_1aParser::NumberContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNumber(this);
}

SV3_1aParser::NumberContext* SV3_1aParser::number() {
  NumberContext *_localctx = _tracker.createInstance<NumberContext>(_ctx, getState());
  enterRule(_localctx, 1236, SV3_1aParser::RuleNumber);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(9513);
    _la = _input->LA(1);
    if (!((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 851964) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Unbased_unsized_literalContext ------------------------------------------------------------------

SV3_1aParser::Unbased_unsized_literalContext::Unbased_unsized_literalContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Unbased_unsized_literalContext::TICK() {
  return getToken(SV3_1aParser::TICK, 0);
}

tree::TerminalNode* SV3_1aParser::Unbased_unsized_literalContext::Simple_identifier() {
  return getToken(SV3_1aParser::Simple_identifier, 0);
}


size_t SV3_1aParser::Unbased_unsized_literalContext::getRuleIndex() const {
  return SV3_1aParser::RuleUnbased_unsized_literal;
}

void SV3_1aParser::Unbased_unsized_literalContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUnbased_unsized_literal(this);
}

void SV3_1aParser::Unbased_unsized_literalContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUnbased_unsized_literal(this);
}

SV3_1aParser::Unbased_unsized_literalContext* SV3_1aParser::unbased_unsized_literal() {
  Unbased_unsized_literalContext *_localctx = _tracker.createInstance<Unbased_unsized_literalContext>(_ctx, getState());
  enterRule(_localctx, 1238, SV3_1aParser::RuleUnbased_unsized_literal);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(9515);
    match(SV3_1aParser::TICK);
    setState(9516);
    match(SV3_1aParser::Simple_identifier);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Attribute_instanceContext ------------------------------------------------------------------

SV3_1aParser::Attribute_instanceContext::Attribute_instanceContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Attribute_instanceContext::OPEN_PARENS_STAR() {
  return getToken(SV3_1aParser::OPEN_PARENS_STAR, 0);
}

std::vector<SV3_1aParser::Attr_specContext *> SV3_1aParser::Attribute_instanceContext::attr_spec() {
  return getRuleContexts<SV3_1aParser::Attr_specContext>();
}

SV3_1aParser::Attr_specContext* SV3_1aParser::Attribute_instanceContext::attr_spec(size_t i) {
  return getRuleContext<SV3_1aParser::Attr_specContext>(i);
}

tree::TerminalNode* SV3_1aParser::Attribute_instanceContext::STAR_CLOSE_PARENS() {
  return getToken(SV3_1aParser::STAR_CLOSE_PARENS, 0);
}

std::vector<tree::TerminalNode *> SV3_1aParser::Attribute_instanceContext::COMMA() {
  return getTokens(SV3_1aParser::COMMA);
}

tree::TerminalNode* SV3_1aParser::Attribute_instanceContext::COMMA(size_t i) {
  return getToken(SV3_1aParser::COMMA, i);
}


size_t SV3_1aParser::Attribute_instanceContext::getRuleIndex() const {
  return SV3_1aParser::RuleAttribute_instance;
}

void SV3_1aParser::Attribute_instanceContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAttribute_instance(this);
}

void SV3_1aParser::Attribute_instanceContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAttribute_instance(this);
}

SV3_1aParser::Attribute_instanceContext* SV3_1aParser::attribute_instance() {
  Attribute_instanceContext *_localctx = _tracker.createInstance<Attribute_instanceContext>(_ctx, getState());
  enterRule(_localctx, 1240, SV3_1aParser::RuleAttribute_instance);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(9518);
    match(SV3_1aParser::OPEN_PARENS_STAR);
    setState(9519);
    attr_spec();
    setState(9524);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == SV3_1aParser::COMMA) {
      setState(9520);
      match(SV3_1aParser::COMMA);
      setState(9521);
      attr_spec();
      setState(9526);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(9527);
    match(SV3_1aParser::STAR_CLOSE_PARENS);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Attr_specContext ------------------------------------------------------------------

SV3_1aParser::Attr_specContext::Attr_specContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::Attr_nameContext* SV3_1aParser::Attr_specContext::attr_name() {
  return getRuleContext<SV3_1aParser::Attr_nameContext>(0);
}

tree::TerminalNode* SV3_1aParser::Attr_specContext::ASSIGN_OP() {
  return getToken(SV3_1aParser::ASSIGN_OP, 0);
}

SV3_1aParser::Constant_expressionContext* SV3_1aParser::Attr_specContext::constant_expression() {
  return getRuleContext<SV3_1aParser::Constant_expressionContext>(0);
}


size_t SV3_1aParser::Attr_specContext::getRuleIndex() const {
  return SV3_1aParser::RuleAttr_spec;
}

void SV3_1aParser::Attr_specContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAttr_spec(this);
}

void SV3_1aParser::Attr_specContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAttr_spec(this);
}

SV3_1aParser::Attr_specContext* SV3_1aParser::attr_spec() {
  Attr_specContext *_localctx = _tracker.createInstance<Attr_specContext>(_ctx, getState());
  enterRule(_localctx, 1242, SV3_1aParser::RuleAttr_spec);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(9529);
    attr_name();
    setState(9532);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SV3_1aParser::ASSIGN_OP) {
      setState(9530);
      match(SV3_1aParser::ASSIGN_OP);
      setState(9531);
      constant_expression(0);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Attr_nameContext ------------------------------------------------------------------

SV3_1aParser::Attr_nameContext::Attr_nameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::IdentifierContext* SV3_1aParser::Attr_nameContext::identifier() {
  return getRuleContext<SV3_1aParser::IdentifierContext>(0);
}


size_t SV3_1aParser::Attr_nameContext::getRuleIndex() const {
  return SV3_1aParser::RuleAttr_name;
}

void SV3_1aParser::Attr_nameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAttr_name(this);
}

void SV3_1aParser::Attr_nameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAttr_name(this);
}

SV3_1aParser::Attr_nameContext* SV3_1aParser::attr_name() {
  Attr_nameContext *_localctx = _tracker.createInstance<Attr_nameContext>(_ctx, getState());
  enterRule(_localctx, 1244, SV3_1aParser::RuleAttr_name);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(9534);
    identifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Hierarchical_identifierContext ------------------------------------------------------------------

SV3_1aParser::Hierarchical_identifierContext::Hierarchical_identifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<SV3_1aParser::IdentifierContext *> SV3_1aParser::Hierarchical_identifierContext::identifier() {
  return getRuleContexts<SV3_1aParser::IdentifierContext>();
}

SV3_1aParser::IdentifierContext* SV3_1aParser::Hierarchical_identifierContext::identifier(size_t i) {
  return getRuleContext<SV3_1aParser::IdentifierContext>(i);
}

SV3_1aParser::Dollar_root_keywordContext* SV3_1aParser::Hierarchical_identifierContext::dollar_root_keyword() {
  return getRuleContext<SV3_1aParser::Dollar_root_keywordContext>(0);
}

std::vector<tree::TerminalNode *> SV3_1aParser::Hierarchical_identifierContext::DOT() {
  return getTokens(SV3_1aParser::DOT);
}

tree::TerminalNode* SV3_1aParser::Hierarchical_identifierContext::DOT(size_t i) {
  return getToken(SV3_1aParser::DOT, i);
}

std::vector<tree::TerminalNode *> SV3_1aParser::Hierarchical_identifierContext::OPEN_BRACKET() {
  return getTokens(SV3_1aParser::OPEN_BRACKET);
}

tree::TerminalNode* SV3_1aParser::Hierarchical_identifierContext::OPEN_BRACKET(size_t i) {
  return getToken(SV3_1aParser::OPEN_BRACKET, i);
}

std::vector<SV3_1aParser::Constant_expressionContext *> SV3_1aParser::Hierarchical_identifierContext::constant_expression() {
  return getRuleContexts<SV3_1aParser::Constant_expressionContext>();
}

SV3_1aParser::Constant_expressionContext* SV3_1aParser::Hierarchical_identifierContext::constant_expression(size_t i) {
  return getRuleContext<SV3_1aParser::Constant_expressionContext>(i);
}

std::vector<tree::TerminalNode *> SV3_1aParser::Hierarchical_identifierContext::CLOSE_BRACKET() {
  return getTokens(SV3_1aParser::CLOSE_BRACKET);
}

tree::TerminalNode* SV3_1aParser::Hierarchical_identifierContext::CLOSE_BRACKET(size_t i) {
  return getToken(SV3_1aParser::CLOSE_BRACKET, i);
}


size_t SV3_1aParser::Hierarchical_identifierContext::getRuleIndex() const {
  return SV3_1aParser::RuleHierarchical_identifier;
}

void SV3_1aParser::Hierarchical_identifierContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterHierarchical_identifier(this);
}

void SV3_1aParser::Hierarchical_identifierContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitHierarchical_identifier(this);
}

SV3_1aParser::Hierarchical_identifierContext* SV3_1aParser::hierarchical_identifier() {
  Hierarchical_identifierContext *_localctx = _tracker.createInstance<Hierarchical_identifierContext>(_ctx, getState());
  enterRule(_localctx, 1246, SV3_1aParser::RuleHierarchical_identifier);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(9537);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SV3_1aParser::DOLLAR_ROOT) {
      setState(9536);
      dollar_root_keyword();
    }
    setState(9539);
    identifier();
    setState(9551); 
    _errHandler->sync(this);
    alt = 1;
    do {
      switch (alt) {
        case 1: {
              setState(9546);
              _errHandler->sync(this);
              _la = _input->LA(1);
              while (_la == SV3_1aParser::OPEN_BRACKET) {
                setState(9540);
                match(SV3_1aParser::OPEN_BRACKET);
                setState(9541);
                constant_expression(0);
                setState(9542);
                match(SV3_1aParser::CLOSE_BRACKET);
                setState(9548);
                _errHandler->sync(this);
                _la = _input->LA(1);
              }
              setState(9549);
              match(SV3_1aParser::DOT);
              setState(9550);
              identifier();
              break;
            }

      default:
        throw NoViableAltException(this);
      }
      setState(9553); 
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1136, _ctx);
    } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IdentifierContext ------------------------------------------------------------------

SV3_1aParser::IdentifierContext::IdentifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::IdentifierContext::Simple_identifier() {
  return getToken(SV3_1aParser::Simple_identifier, 0);
}

tree::TerminalNode* SV3_1aParser::IdentifierContext::Escaped_identifier() {
  return getToken(SV3_1aParser::Escaped_identifier, 0);
}

tree::TerminalNode* SV3_1aParser::IdentifierContext::THIS() {
  return getToken(SV3_1aParser::THIS, 0);
}

tree::TerminalNode* SV3_1aParser::IdentifierContext::RANDOMIZE() {
  return getToken(SV3_1aParser::RANDOMIZE, 0);
}

tree::TerminalNode* SV3_1aParser::IdentifierContext::SAMPLE() {
  return getToken(SV3_1aParser::SAMPLE, 0);
}


size_t SV3_1aParser::IdentifierContext::getRuleIndex() const {
  return SV3_1aParser::RuleIdentifier;
}

void SV3_1aParser::IdentifierContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIdentifier(this);
}

void SV3_1aParser::IdentifierContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIdentifier(this);
}

SV3_1aParser::IdentifierContext* SV3_1aParser::identifier() {
  IdentifierContext *_localctx = _tracker.createInstance<IdentifierContext>(_ctx, getState());
  enterRule(_localctx, 1248, SV3_1aParser::RuleIdentifier);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(9555);
    _la = _input->LA(1);
    if (!(((((_la - 326) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 326)) & 4672924483589) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Interface_identifierContext ------------------------------------------------------------------

SV3_1aParser::Interface_identifierContext::Interface_identifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<SV3_1aParser::IdentifierContext *> SV3_1aParser::Interface_identifierContext::identifier() {
  return getRuleContexts<SV3_1aParser::IdentifierContext>();
}

SV3_1aParser::IdentifierContext* SV3_1aParser::Interface_identifierContext::identifier(size_t i) {
  return getRuleContext<SV3_1aParser::IdentifierContext>(i);
}

SV3_1aParser::Dollar_root_keywordContext* SV3_1aParser::Interface_identifierContext::dollar_root_keyword() {
  return getRuleContext<SV3_1aParser::Dollar_root_keywordContext>(0);
}

std::vector<tree::TerminalNode *> SV3_1aParser::Interface_identifierContext::DOT() {
  return getTokens(SV3_1aParser::DOT);
}

tree::TerminalNode* SV3_1aParser::Interface_identifierContext::DOT(size_t i) {
  return getToken(SV3_1aParser::DOT, i);
}

std::vector<tree::TerminalNode *> SV3_1aParser::Interface_identifierContext::OPEN_BRACKET() {
  return getTokens(SV3_1aParser::OPEN_BRACKET);
}

tree::TerminalNode* SV3_1aParser::Interface_identifierContext::OPEN_BRACKET(size_t i) {
  return getToken(SV3_1aParser::OPEN_BRACKET, i);
}

std::vector<SV3_1aParser::Constant_expressionContext *> SV3_1aParser::Interface_identifierContext::constant_expression() {
  return getRuleContexts<SV3_1aParser::Constant_expressionContext>();
}

SV3_1aParser::Constant_expressionContext* SV3_1aParser::Interface_identifierContext::constant_expression(size_t i) {
  return getRuleContext<SV3_1aParser::Constant_expressionContext>(i);
}

std::vector<tree::TerminalNode *> SV3_1aParser::Interface_identifierContext::CLOSE_BRACKET() {
  return getTokens(SV3_1aParser::CLOSE_BRACKET);
}

tree::TerminalNode* SV3_1aParser::Interface_identifierContext::CLOSE_BRACKET(size_t i) {
  return getToken(SV3_1aParser::CLOSE_BRACKET, i);
}


size_t SV3_1aParser::Interface_identifierContext::getRuleIndex() const {
  return SV3_1aParser::RuleInterface_identifier;
}

void SV3_1aParser::Interface_identifierContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInterface_identifier(this);
}

void SV3_1aParser::Interface_identifierContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInterface_identifier(this);
}

SV3_1aParser::Interface_identifierContext* SV3_1aParser::interface_identifier() {
  Interface_identifierContext *_localctx = _tracker.createInstance<Interface_identifierContext>(_ctx, getState());
  enterRule(_localctx, 1250, SV3_1aParser::RuleInterface_identifier);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(9558);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SV3_1aParser::DOLLAR_ROOT) {
      setState(9557);
      dollar_root_keyword();
    }
    setState(9560);
    identifier();
    setState(9574);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1139, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(9567);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == SV3_1aParser::OPEN_BRACKET) {
          setState(9561);
          match(SV3_1aParser::OPEN_BRACKET);
          setState(9562);
          constant_expression(0);
          setState(9563);
          match(SV3_1aParser::CLOSE_BRACKET);
          setState(9569);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(9570);
        match(SV3_1aParser::DOT);
        setState(9571);
        identifier(); 
      }
      setState(9576);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1139, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Package_scopeContext ------------------------------------------------------------------

SV3_1aParser::Package_scopeContext::Package_scopeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Package_scopeContext::COLONCOLON() {
  return getToken(SV3_1aParser::COLONCOLON, 0);
}

tree::TerminalNode* SV3_1aParser::Package_scopeContext::Simple_identifier() {
  return getToken(SV3_1aParser::Simple_identifier, 0);
}

tree::TerminalNode* SV3_1aParser::Package_scopeContext::Escaped_identifier() {
  return getToken(SV3_1aParser::Escaped_identifier, 0);
}

tree::TerminalNode* SV3_1aParser::Package_scopeContext::THIS() {
  return getToken(SV3_1aParser::THIS, 0);
}

tree::TerminalNode* SV3_1aParser::Package_scopeContext::RANDOMIZE() {
  return getToken(SV3_1aParser::RANDOMIZE, 0);
}

tree::TerminalNode* SV3_1aParser::Package_scopeContext::SAMPLE() {
  return getToken(SV3_1aParser::SAMPLE, 0);
}

tree::TerminalNode* SV3_1aParser::Package_scopeContext::DOLLAR_UNIT() {
  return getToken(SV3_1aParser::DOLLAR_UNIT, 0);
}


size_t SV3_1aParser::Package_scopeContext::getRuleIndex() const {
  return SV3_1aParser::RulePackage_scope;
}

void SV3_1aParser::Package_scopeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPackage_scope(this);
}

void SV3_1aParser::Package_scopeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPackage_scope(this);
}

SV3_1aParser::Package_scopeContext* SV3_1aParser::package_scope() {
  Package_scopeContext *_localctx = _tracker.createInstance<Package_scopeContext>(_ctx, getState());
  enterRule(_localctx, 1252, SV3_1aParser::RulePackage_scope);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(9577);
    _la = _input->LA(1);
    if (!(_la == SV3_1aParser::DOLLAR_UNIT || ((((_la - 326) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 326)) & 4672924483589) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(9578);
    match(SV3_1aParser::COLONCOLON);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Ps_identifierContext ------------------------------------------------------------------

SV3_1aParser::Ps_identifierContext::Ps_identifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> SV3_1aParser::Ps_identifierContext::Simple_identifier() {
  return getTokens(SV3_1aParser::Simple_identifier);
}

tree::TerminalNode* SV3_1aParser::Ps_identifierContext::Simple_identifier(size_t i) {
  return getToken(SV3_1aParser::Simple_identifier, i);
}

std::vector<tree::TerminalNode *> SV3_1aParser::Ps_identifierContext::Escaped_identifier() {
  return getTokens(SV3_1aParser::Escaped_identifier);
}

tree::TerminalNode* SV3_1aParser::Ps_identifierContext::Escaped_identifier(size_t i) {
  return getToken(SV3_1aParser::Escaped_identifier, i);
}

std::vector<tree::TerminalNode *> SV3_1aParser::Ps_identifierContext::THIS() {
  return getTokens(SV3_1aParser::THIS);
}

tree::TerminalNode* SV3_1aParser::Ps_identifierContext::THIS(size_t i) {
  return getToken(SV3_1aParser::THIS, i);
}

std::vector<tree::TerminalNode *> SV3_1aParser::Ps_identifierContext::RANDOMIZE() {
  return getTokens(SV3_1aParser::RANDOMIZE);
}

tree::TerminalNode* SV3_1aParser::Ps_identifierContext::RANDOMIZE(size_t i) {
  return getToken(SV3_1aParser::RANDOMIZE, i);
}

std::vector<tree::TerminalNode *> SV3_1aParser::Ps_identifierContext::SAMPLE() {
  return getTokens(SV3_1aParser::SAMPLE);
}

tree::TerminalNode* SV3_1aParser::Ps_identifierContext::SAMPLE(size_t i) {
  return getToken(SV3_1aParser::SAMPLE, i);
}

tree::TerminalNode* SV3_1aParser::Ps_identifierContext::DOLLAR_UNIT() {
  return getToken(SV3_1aParser::DOLLAR_UNIT, 0);
}

tree::TerminalNode* SV3_1aParser::Ps_identifierContext::COLONCOLON() {
  return getToken(SV3_1aParser::COLONCOLON, 0);
}


size_t SV3_1aParser::Ps_identifierContext::getRuleIndex() const {
  return SV3_1aParser::RulePs_identifier;
}

void SV3_1aParser::Ps_identifierContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPs_identifier(this);
}

void SV3_1aParser::Ps_identifierContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPs_identifier(this);
}

SV3_1aParser::Ps_identifierContext* SV3_1aParser::ps_identifier() {
  Ps_identifierContext *_localctx = _tracker.createInstance<Ps_identifierContext>(_ctx, getState());
  enterRule(_localctx, 1254, SV3_1aParser::RulePs_identifier);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(9580);
    _la = _input->LA(1);
    if (!(_la == SV3_1aParser::DOLLAR_UNIT || ((((_la - 326) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 326)) & 4672924483589) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(9583);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SV3_1aParser::COLONCOLON) {
      setState(9581);
      match(SV3_1aParser::COLONCOLON);
      setState(9582);
      _la = _input->LA(1);
      if (!(((((_la - 326) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 326)) & 4672924483589) != 0))) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Ps_or_hierarchical_identifierContext ------------------------------------------------------------------

SV3_1aParser::Ps_or_hierarchical_identifierContext::Ps_or_hierarchical_identifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::IdentifierContext* SV3_1aParser::Ps_or_hierarchical_identifierContext::identifier() {
  return getRuleContext<SV3_1aParser::IdentifierContext>(0);
}

SV3_1aParser::Package_scopeContext* SV3_1aParser::Ps_or_hierarchical_identifierContext::package_scope() {
  return getRuleContext<SV3_1aParser::Package_scopeContext>(0);
}

SV3_1aParser::Hierarchical_identifierContext* SV3_1aParser::Ps_or_hierarchical_identifierContext::hierarchical_identifier() {
  return getRuleContext<SV3_1aParser::Hierarchical_identifierContext>(0);
}


size_t SV3_1aParser::Ps_or_hierarchical_identifierContext::getRuleIndex() const {
  return SV3_1aParser::RulePs_or_hierarchical_identifier;
}

void SV3_1aParser::Ps_or_hierarchical_identifierContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPs_or_hierarchical_identifier(this);
}

void SV3_1aParser::Ps_or_hierarchical_identifierContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPs_or_hierarchical_identifier(this);
}

SV3_1aParser::Ps_or_hierarchical_identifierContext* SV3_1aParser::ps_or_hierarchical_identifier() {
  Ps_or_hierarchical_identifierContext *_localctx = _tracker.createInstance<Ps_or_hierarchical_identifierContext>(_ctx, getState());
  enterRule(_localctx, 1256, SV3_1aParser::RulePs_or_hierarchical_identifier);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(9590);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1142, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(9586);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1141, _ctx)) {
      case 1: {
        setState(9585);
        package_scope();
        break;
      }

      default:
        break;
      }
      setState(9588);
      identifier();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(9589);
      hierarchical_identifier();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Ps_or_hierarchical_array_identifierContext ------------------------------------------------------------------

SV3_1aParser::Ps_or_hierarchical_array_identifierContext::Ps_or_hierarchical_array_identifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<SV3_1aParser::IdentifierContext *> SV3_1aParser::Ps_or_hierarchical_array_identifierContext::identifier() {
  return getRuleContexts<SV3_1aParser::IdentifierContext>();
}

SV3_1aParser::IdentifierContext* SV3_1aParser::Ps_or_hierarchical_array_identifierContext::identifier(size_t i) {
  return getRuleContext<SV3_1aParser::IdentifierContext>(i);
}

SV3_1aParser::Implicit_class_handleContext* SV3_1aParser::Ps_or_hierarchical_array_identifierContext::implicit_class_handle() {
  return getRuleContext<SV3_1aParser::Implicit_class_handleContext>(0);
}

std::vector<tree::TerminalNode *> SV3_1aParser::Ps_or_hierarchical_array_identifierContext::DOT() {
  return getTokens(SV3_1aParser::DOT);
}

tree::TerminalNode* SV3_1aParser::Ps_or_hierarchical_array_identifierContext::DOT(size_t i) {
  return getToken(SV3_1aParser::DOT, i);
}

SV3_1aParser::Class_scopeContext* SV3_1aParser::Ps_or_hierarchical_array_identifierContext::class_scope() {
  return getRuleContext<SV3_1aParser::Class_scopeContext>(0);
}

SV3_1aParser::Package_scopeContext* SV3_1aParser::Ps_or_hierarchical_array_identifierContext::package_scope() {
  return getRuleContext<SV3_1aParser::Package_scopeContext>(0);
}

SV3_1aParser::Dollar_root_keywordContext* SV3_1aParser::Ps_or_hierarchical_array_identifierContext::dollar_root_keyword() {
  return getRuleContext<SV3_1aParser::Dollar_root_keywordContext>(0);
}

std::vector<tree::TerminalNode *> SV3_1aParser::Ps_or_hierarchical_array_identifierContext::OPEN_BRACKET() {
  return getTokens(SV3_1aParser::OPEN_BRACKET);
}

tree::TerminalNode* SV3_1aParser::Ps_or_hierarchical_array_identifierContext::OPEN_BRACKET(size_t i) {
  return getToken(SV3_1aParser::OPEN_BRACKET, i);
}

std::vector<SV3_1aParser::Constant_expressionContext *> SV3_1aParser::Ps_or_hierarchical_array_identifierContext::constant_expression() {
  return getRuleContexts<SV3_1aParser::Constant_expressionContext>();
}

SV3_1aParser::Constant_expressionContext* SV3_1aParser::Ps_or_hierarchical_array_identifierContext::constant_expression(size_t i) {
  return getRuleContext<SV3_1aParser::Constant_expressionContext>(i);
}

std::vector<tree::TerminalNode *> SV3_1aParser::Ps_or_hierarchical_array_identifierContext::CLOSE_BRACKET() {
  return getTokens(SV3_1aParser::CLOSE_BRACKET);
}

tree::TerminalNode* SV3_1aParser::Ps_or_hierarchical_array_identifierContext::CLOSE_BRACKET(size_t i) {
  return getToken(SV3_1aParser::CLOSE_BRACKET, i);
}


size_t SV3_1aParser::Ps_or_hierarchical_array_identifierContext::getRuleIndex() const {
  return SV3_1aParser::RulePs_or_hierarchical_array_identifier;
}

void SV3_1aParser::Ps_or_hierarchical_array_identifierContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPs_or_hierarchical_array_identifier(this);
}

void SV3_1aParser::Ps_or_hierarchical_array_identifierContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPs_or_hierarchical_array_identifier(this);
}

SV3_1aParser::Ps_or_hierarchical_array_identifierContext* SV3_1aParser::ps_or_hierarchical_array_identifier() {
  Ps_or_hierarchical_array_identifierContext *_localctx = _tracker.createInstance<Ps_or_hierarchical_array_identifierContext>(_ctx, getState());
  enterRule(_localctx, 1258, SV3_1aParser::RulePs_or_hierarchical_array_identifier);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(9597);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1143, _ctx)) {
    case 1: {
      setState(9592);
      implicit_class_handle();
      setState(9593);
      match(SV3_1aParser::DOT);
      break;
    }

    case 2: {
      setState(9595);
      class_scope();
      break;
    }

    case 3: {
      setState(9596);
      package_scope();
      break;
    }

    default:
      break;
    }
    setState(9600);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SV3_1aParser::DOLLAR_ROOT) {
      setState(9599);
      dollar_root_keyword();
    }
    setState(9602);
    identifier();
    setState(9616);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1146, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(9609);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == SV3_1aParser::OPEN_BRACKET) {
          setState(9603);
          match(SV3_1aParser::OPEN_BRACKET);
          setState(9604);
          constant_expression(0);
          setState(9605);
          match(SV3_1aParser::CLOSE_BRACKET);
          setState(9611);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(9612);
        match(SV3_1aParser::DOT);
        setState(9613);
        identifier(); 
      }
      setState(9618);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1146, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Ps_or_hierarchical_sequence_identifierContext ------------------------------------------------------------------

SV3_1aParser::Ps_or_hierarchical_sequence_identifierContext::Ps_or_hierarchical_sequence_identifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::Ps_or_hierarchical_array_identifierContext* SV3_1aParser::Ps_or_hierarchical_sequence_identifierContext::ps_or_hierarchical_array_identifier() {
  return getRuleContext<SV3_1aParser::Ps_or_hierarchical_array_identifierContext>(0);
}


size_t SV3_1aParser::Ps_or_hierarchical_sequence_identifierContext::getRuleIndex() const {
  return SV3_1aParser::RulePs_or_hierarchical_sequence_identifier;
}

void SV3_1aParser::Ps_or_hierarchical_sequence_identifierContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPs_or_hierarchical_sequence_identifier(this);
}

void SV3_1aParser::Ps_or_hierarchical_sequence_identifierContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPs_or_hierarchical_sequence_identifier(this);
}

SV3_1aParser::Ps_or_hierarchical_sequence_identifierContext* SV3_1aParser::ps_or_hierarchical_sequence_identifier() {
  Ps_or_hierarchical_sequence_identifierContext *_localctx = _tracker.createInstance<Ps_or_hierarchical_sequence_identifierContext>(_ctx, getState());
  enterRule(_localctx, 1260, SV3_1aParser::RulePs_or_hierarchical_sequence_identifier);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(9619);
    ps_or_hierarchical_array_identifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Ps_type_identifierContext ------------------------------------------------------------------

SV3_1aParser::Ps_type_identifierContext::Ps_type_identifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::IdentifierContext* SV3_1aParser::Ps_type_identifierContext::identifier() {
  return getRuleContext<SV3_1aParser::IdentifierContext>(0);
}

tree::TerminalNode* SV3_1aParser::Ps_type_identifierContext::LOCAL() {
  return getToken(SV3_1aParser::LOCAL, 0);
}

tree::TerminalNode* SV3_1aParser::Ps_type_identifierContext::COLONCOLON() {
  return getToken(SV3_1aParser::COLONCOLON, 0);
}

SV3_1aParser::Package_scopeContext* SV3_1aParser::Ps_type_identifierContext::package_scope() {
  return getRuleContext<SV3_1aParser::Package_scopeContext>(0);
}


size_t SV3_1aParser::Ps_type_identifierContext::getRuleIndex() const {
  return SV3_1aParser::RulePs_type_identifier;
}

void SV3_1aParser::Ps_type_identifierContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPs_type_identifier(this);
}

void SV3_1aParser::Ps_type_identifierContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPs_type_identifier(this);
}

SV3_1aParser::Ps_type_identifierContext* SV3_1aParser::ps_type_identifier() {
  Ps_type_identifierContext *_localctx = _tracker.createInstance<Ps_type_identifierContext>(_ctx, getState());
  enterRule(_localctx, 1262, SV3_1aParser::RulePs_type_identifier);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(9624);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1147, _ctx)) {
    case 1: {
      setState(9621);
      match(SV3_1aParser::LOCAL);
      setState(9622);
      match(SV3_1aParser::COLONCOLON);
      break;
    }

    case 2: {
      setState(9623);
      package_scope();
      break;
    }

    default:
      break;
    }
    setState(9626);
    identifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- System_taskContext ------------------------------------------------------------------

SV3_1aParser::System_taskContext::System_taskContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::System_task_namesContext* SV3_1aParser::System_taskContext::system_task_names() {
  return getRuleContext<SV3_1aParser::System_task_namesContext>(0);
}

tree::TerminalNode* SV3_1aParser::System_taskContext::OPEN_PARENS() {
  return getToken(SV3_1aParser::OPEN_PARENS, 0);
}

tree::TerminalNode* SV3_1aParser::System_taskContext::CLOSE_PARENS() {
  return getToken(SV3_1aParser::CLOSE_PARENS, 0);
}

SV3_1aParser::List_of_argumentsContext* SV3_1aParser::System_taskContext::list_of_arguments() {
  return getRuleContext<SV3_1aParser::List_of_argumentsContext>(0);
}

SV3_1aParser::Data_typeContext* SV3_1aParser::System_taskContext::data_type() {
  return getRuleContext<SV3_1aParser::Data_typeContext>(0);
}

tree::TerminalNode* SV3_1aParser::System_taskContext::COMMA() {
  return getToken(SV3_1aParser::COMMA, 0);
}

SV3_1aParser::Clocking_eventContext* SV3_1aParser::System_taskContext::clocking_event() {
  return getRuleContext<SV3_1aParser::Clocking_eventContext>(0);
}


size_t SV3_1aParser::System_taskContext::getRuleIndex() const {
  return SV3_1aParser::RuleSystem_task;
}

void SV3_1aParser::System_taskContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSystem_task(this);
}

void SV3_1aParser::System_taskContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSystem_task(this);
}

SV3_1aParser::System_taskContext* SV3_1aParser::system_task() {
  System_taskContext *_localctx = _tracker.createInstance<System_taskContext>(_ctx, getState());
  enterRule(_localctx, 1264, SV3_1aParser::RuleSystem_task);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(9628);
    system_task_names();
    setState(9640);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1150, _ctx)) {
    case 1: {
      setState(9629);
      match(SV3_1aParser::OPEN_PARENS);
      setState(9636);
      _errHandler->sync(this);
      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1149, _ctx)) {
      case 1: {
        setState(9630);
        list_of_arguments();
        setState(9633);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == SV3_1aParser::COMMA) {
          setState(9631);
          match(SV3_1aParser::COMMA);
          setState(9632);
          clocking_event();
        }
        break;
      }

      case 2: {
        setState(9635);
        data_type();
        break;
      }

      default:
        break;
      }
      setState(9638);
      match(SV3_1aParser::CLOSE_PARENS);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- System_task_namesContext ------------------------------------------------------------------

SV3_1aParser::System_task_namesContext::System_task_namesContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> SV3_1aParser::System_task_namesContext::DOLLAR() {
  return getTokens(SV3_1aParser::DOLLAR);
}

tree::TerminalNode* SV3_1aParser::System_task_namesContext::DOLLAR(size_t i) {
  return getToken(SV3_1aParser::DOLLAR, i);
}

std::vector<tree::TerminalNode *> SV3_1aParser::System_task_namesContext::Simple_identifier() {
  return getTokens(SV3_1aParser::Simple_identifier);
}

tree::TerminalNode* SV3_1aParser::System_task_namesContext::Simple_identifier(size_t i) {
  return getToken(SV3_1aParser::Simple_identifier, i);
}

tree::TerminalNode* SV3_1aParser::System_task_namesContext::TIME() {
  return getToken(SV3_1aParser::TIME, 0);
}

tree::TerminalNode* SV3_1aParser::System_task_namesContext::REALTIME() {
  return getToken(SV3_1aParser::REALTIME, 0);
}

tree::TerminalNode* SV3_1aParser::System_task_namesContext::SIGNED() {
  return getToken(SV3_1aParser::SIGNED, 0);
}

tree::TerminalNode* SV3_1aParser::System_task_namesContext::UNSIGNED() {
  return getToken(SV3_1aParser::UNSIGNED, 0);
}

tree::TerminalNode* SV3_1aParser::System_task_namesContext::ASSERT() {
  return getToken(SV3_1aParser::ASSERT, 0);
}


size_t SV3_1aParser::System_task_namesContext::getRuleIndex() const {
  return SV3_1aParser::RuleSystem_task_names;
}

void SV3_1aParser::System_task_namesContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSystem_task_names(this);
}

void SV3_1aParser::System_task_namesContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSystem_task_names(this);
}

SV3_1aParser::System_task_namesContext* SV3_1aParser::system_task_names() {
  System_task_namesContext *_localctx = _tracker.createInstance<System_task_namesContext>(_ctx, getState());
  enterRule(_localctx, 1266, SV3_1aParser::RuleSystem_task_names);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    setState(9661);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1152, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(9642);
      match(SV3_1aParser::DOLLAR);
      setState(9643);
      match(SV3_1aParser::Simple_identifier);
      setState(9648);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1151, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(9644);
          match(SV3_1aParser::DOLLAR);
          setState(9645);
          match(SV3_1aParser::Simple_identifier); 
        }
        setState(9650);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1151, _ctx);
      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(9651);
      match(SV3_1aParser::DOLLAR);
      setState(9652);
      match(SV3_1aParser::TIME);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(9653);
      match(SV3_1aParser::DOLLAR);
      setState(9654);
      match(SV3_1aParser::REALTIME);
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(9655);
      match(SV3_1aParser::DOLLAR);
      setState(9656);
      match(SV3_1aParser::SIGNED);
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(9657);
      match(SV3_1aParser::DOLLAR);
      setState(9658);
      match(SV3_1aParser::UNSIGNED);
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(9659);
      match(SV3_1aParser::DOLLAR);
      setState(9660);
      match(SV3_1aParser::ASSERT);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Top_directivesContext ------------------------------------------------------------------

SV3_1aParser::Top_directivesContext::Top_directivesContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::Timescale_directiveContext* SV3_1aParser::Top_directivesContext::timescale_directive() {
  return getRuleContext<SV3_1aParser::Timescale_directiveContext>(0);
}

SV3_1aParser::Uselib_directiveContext* SV3_1aParser::Top_directivesContext::uselib_directive() {
  return getRuleContext<SV3_1aParser::Uselib_directiveContext>(0);
}

tree::TerminalNode* SV3_1aParser::Top_directivesContext::BACK_TICK() {
  return getToken(SV3_1aParser::BACK_TICK, 0);
}

std::vector<tree::TerminalNode *> SV3_1aParser::Top_directivesContext::Simple_identifier() {
  return getTokens(SV3_1aParser::Simple_identifier);
}

tree::TerminalNode* SV3_1aParser::Top_directivesContext::Simple_identifier(size_t i) {
  return getToken(SV3_1aParser::Simple_identifier, i);
}

SV3_1aParser::NumberContext* SV3_1aParser::Top_directivesContext::number() {
  return getRuleContext<SV3_1aParser::NumberContext>(0);
}

tree::TerminalNode* SV3_1aParser::Top_directivesContext::Real_number() {
  return getToken(SV3_1aParser::Real_number, 0);
}

SV3_1aParser::Begin_keywords_directiveContext* SV3_1aParser::Top_directivesContext::begin_keywords_directive() {
  return getRuleContext<SV3_1aParser::Begin_keywords_directiveContext>(0);
}

SV3_1aParser::End_keywords_directiveContext* SV3_1aParser::Top_directivesContext::end_keywords_directive() {
  return getRuleContext<SV3_1aParser::End_keywords_directiveContext>(0);
}

SV3_1aParser::Unconnected_drive_directiveContext* SV3_1aParser::Top_directivesContext::unconnected_drive_directive() {
  return getRuleContext<SV3_1aParser::Unconnected_drive_directiveContext>(0);
}

SV3_1aParser::Nounconnected_drive_directiveContext* SV3_1aParser::Top_directivesContext::nounconnected_drive_directive() {
  return getRuleContext<SV3_1aParser::Nounconnected_drive_directiveContext>(0);
}

SV3_1aParser::Default_nettype_directiveContext* SV3_1aParser::Top_directivesContext::default_nettype_directive() {
  return getRuleContext<SV3_1aParser::Default_nettype_directiveContext>(0);
}

SV3_1aParser::Default_decay_time_directiveContext* SV3_1aParser::Top_directivesContext::default_decay_time_directive() {
  return getRuleContext<SV3_1aParser::Default_decay_time_directiveContext>(0);
}

SV3_1aParser::Default_trireg_strenght_directiveContext* SV3_1aParser::Top_directivesContext::default_trireg_strenght_directive() {
  return getRuleContext<SV3_1aParser::Default_trireg_strenght_directiveContext>(0);
}

SV3_1aParser::Delay_mode_distributed_directiveContext* SV3_1aParser::Top_directivesContext::delay_mode_distributed_directive() {
  return getRuleContext<SV3_1aParser::Delay_mode_distributed_directiveContext>(0);
}

SV3_1aParser::Delay_mode_path_directiveContext* SV3_1aParser::Top_directivesContext::delay_mode_path_directive() {
  return getRuleContext<SV3_1aParser::Delay_mode_path_directiveContext>(0);
}

SV3_1aParser::Delay_mode_unit_directiveContext* SV3_1aParser::Top_directivesContext::delay_mode_unit_directive() {
  return getRuleContext<SV3_1aParser::Delay_mode_unit_directiveContext>(0);
}

SV3_1aParser::Delay_mode_zero_directiveContext* SV3_1aParser::Top_directivesContext::delay_mode_zero_directive() {
  return getRuleContext<SV3_1aParser::Delay_mode_zero_directiveContext>(0);
}

SV3_1aParser::Protect_directiveContext* SV3_1aParser::Top_directivesContext::protect_directive() {
  return getRuleContext<SV3_1aParser::Protect_directiveContext>(0);
}

SV3_1aParser::Endprotect_directiveContext* SV3_1aParser::Top_directivesContext::endprotect_directive() {
  return getRuleContext<SV3_1aParser::Endprotect_directiveContext>(0);
}

SV3_1aParser::Protected_directiveContext* SV3_1aParser::Top_directivesContext::protected_directive() {
  return getRuleContext<SV3_1aParser::Protected_directiveContext>(0);
}

SV3_1aParser::Endprotected_directiveContext* SV3_1aParser::Top_directivesContext::endprotected_directive() {
  return getRuleContext<SV3_1aParser::Endprotected_directiveContext>(0);
}

SV3_1aParser::Expand_vectornets_directiveContext* SV3_1aParser::Top_directivesContext::expand_vectornets_directive() {
  return getRuleContext<SV3_1aParser::Expand_vectornets_directiveContext>(0);
}

SV3_1aParser::Noexpand_vectornets_directiveContext* SV3_1aParser::Top_directivesContext::noexpand_vectornets_directive() {
  return getRuleContext<SV3_1aParser::Noexpand_vectornets_directiveContext>(0);
}

SV3_1aParser::Autoexpand_vectornets_directiveContext* SV3_1aParser::Top_directivesContext::autoexpand_vectornets_directive() {
  return getRuleContext<SV3_1aParser::Autoexpand_vectornets_directiveContext>(0);
}

SV3_1aParser::Remove_gatename_directiveContext* SV3_1aParser::Top_directivesContext::remove_gatename_directive() {
  return getRuleContext<SV3_1aParser::Remove_gatename_directiveContext>(0);
}

SV3_1aParser::Noremove_gatenames_directiveContext* SV3_1aParser::Top_directivesContext::noremove_gatenames_directive() {
  return getRuleContext<SV3_1aParser::Noremove_gatenames_directiveContext>(0);
}

SV3_1aParser::Remove_netname_directiveContext* SV3_1aParser::Top_directivesContext::remove_netname_directive() {
  return getRuleContext<SV3_1aParser::Remove_netname_directiveContext>(0);
}

SV3_1aParser::Noremove_netnames_directiveContext* SV3_1aParser::Top_directivesContext::noremove_netnames_directive() {
  return getRuleContext<SV3_1aParser::Noremove_netnames_directiveContext>(0);
}

SV3_1aParser::Accelerate_directiveContext* SV3_1aParser::Top_directivesContext::accelerate_directive() {
  return getRuleContext<SV3_1aParser::Accelerate_directiveContext>(0);
}

SV3_1aParser::Noaccelerate_directiveContext* SV3_1aParser::Top_directivesContext::noaccelerate_directive() {
  return getRuleContext<SV3_1aParser::Noaccelerate_directiveContext>(0);
}

SV3_1aParser::Disable_portfaults_directiveContext* SV3_1aParser::Top_directivesContext::disable_portfaults_directive() {
  return getRuleContext<SV3_1aParser::Disable_portfaults_directiveContext>(0);
}

SV3_1aParser::Enable_portfaults_directiveContext* SV3_1aParser::Top_directivesContext::enable_portfaults_directive() {
  return getRuleContext<SV3_1aParser::Enable_portfaults_directiveContext>(0);
}

SV3_1aParser::Nosuppress_faults_directiveContext* SV3_1aParser::Top_directivesContext::nosuppress_faults_directive() {
  return getRuleContext<SV3_1aParser::Nosuppress_faults_directiveContext>(0);
}

SV3_1aParser::Suppress_faults_directiveContext* SV3_1aParser::Top_directivesContext::suppress_faults_directive() {
  return getRuleContext<SV3_1aParser::Suppress_faults_directiveContext>(0);
}

SV3_1aParser::Signed_directiveContext* SV3_1aParser::Top_directivesContext::signed_directive() {
  return getRuleContext<SV3_1aParser::Signed_directiveContext>(0);
}

SV3_1aParser::Unsigned_directiveContext* SV3_1aParser::Top_directivesContext::unsigned_directive() {
  return getRuleContext<SV3_1aParser::Unsigned_directiveContext>(0);
}

SV3_1aParser::Celldefine_directiveContext* SV3_1aParser::Top_directivesContext::celldefine_directive() {
  return getRuleContext<SV3_1aParser::Celldefine_directiveContext>(0);
}

SV3_1aParser::Endcelldefine_directiveContext* SV3_1aParser::Top_directivesContext::endcelldefine_directive() {
  return getRuleContext<SV3_1aParser::Endcelldefine_directiveContext>(0);
}

SV3_1aParser::Pragma_directiveContext* SV3_1aParser::Top_directivesContext::pragma_directive() {
  return getRuleContext<SV3_1aParser::Pragma_directiveContext>(0);
}


size_t SV3_1aParser::Top_directivesContext::getRuleIndex() const {
  return SV3_1aParser::RuleTop_directives;
}

void SV3_1aParser::Top_directivesContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTop_directives(this);
}

void SV3_1aParser::Top_directivesContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTop_directives(this);
}

SV3_1aParser::Top_directivesContext* SV3_1aParser::top_directives() {
  Top_directivesContext *_localctx = _tracker.createInstance<Top_directivesContext>(_ctx, getState());
  enterRule(_localctx, 1268, SV3_1aParser::RuleTop_directives);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(9705);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SV3_1aParser::TICK_TIMESCALE: {
        enterOuterAlt(_localctx, 1);
        setState(9663);
        timescale_directive();
        break;
      }

      case SV3_1aParser::TICK_USELIB: {
        enterOuterAlt(_localctx, 2);
        setState(9664);
        uselib_directive();
        break;
      }

      case SV3_1aParser::BACK_TICK: {
        enterOuterAlt(_localctx, 3);
        setState(9665);
        match(SV3_1aParser::BACK_TICK);
        setState(9666);
        match(SV3_1aParser::Simple_identifier);
        setState(9670);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1153, _ctx)) {
        case 1: {
          setState(9667);
          number();
          break;
        }

        case 2: {
          setState(9668);
          match(SV3_1aParser::Simple_identifier);
          break;
        }

        case 3: {
          setState(9669);
          match(SV3_1aParser::Real_number);
          break;
        }

        default:
          break;
        }
        break;
      }

      case SV3_1aParser::TICK_BEGIN_KEYWORDS: {
        enterOuterAlt(_localctx, 4);
        setState(9672);
        begin_keywords_directive();
        break;
      }

      case SV3_1aParser::TICK_END_KEYWORDS: {
        enterOuterAlt(_localctx, 5);
        setState(9673);
        end_keywords_directive();
        break;
      }

      case SV3_1aParser::TICK_UNCONNECTED_DRIVE: {
        enterOuterAlt(_localctx, 6);
        setState(9674);
        unconnected_drive_directive();
        break;
      }

      case SV3_1aParser::TICK_NOUNCONNECTED_DRIVE: {
        enterOuterAlt(_localctx, 7);
        setState(9675);
        nounconnected_drive_directive();
        break;
      }

      case SV3_1aParser::TICK_DEFAULT_NETTYPE: {
        enterOuterAlt(_localctx, 8);
        setState(9676);
        default_nettype_directive();
        break;
      }

      case SV3_1aParser::TICK_DEFAULT_DECAY_TIME: {
        enterOuterAlt(_localctx, 9);
        setState(9677);
        default_decay_time_directive();
        break;
      }

      case SV3_1aParser::TICK_DEFAULT_TRIREG_STRENGTH: {
        enterOuterAlt(_localctx, 10);
        setState(9678);
        default_trireg_strenght_directive();
        break;
      }

      case SV3_1aParser::TICK_DELAY_MODE_DISTRIBUTED: {
        enterOuterAlt(_localctx, 11);
        setState(9679);
        delay_mode_distributed_directive();
        break;
      }

      case SV3_1aParser::TICK_DELAY_MODE_PATH: {
        enterOuterAlt(_localctx, 12);
        setState(9680);
        delay_mode_path_directive();
        break;
      }

      case SV3_1aParser::TICK_DELAY_MODE_UNIT: {
        enterOuterAlt(_localctx, 13);
        setState(9681);
        delay_mode_unit_directive();
        break;
      }

      case SV3_1aParser::TICK_DELAY_MODE_ZERO: {
        enterOuterAlt(_localctx, 14);
        setState(9682);
        delay_mode_zero_directive();
        break;
      }

      case SV3_1aParser::TICK_PROTECT: {
        enterOuterAlt(_localctx, 15);
        setState(9683);
        protect_directive();
        break;
      }

      case SV3_1aParser::TICK_ENDPROTECT: {
        enterOuterAlt(_localctx, 16);
        setState(9684);
        endprotect_directive();
        break;
      }

      case SV3_1aParser::TICK_PROTECTED: {
        enterOuterAlt(_localctx, 17);
        setState(9685);
        protected_directive();
        break;
      }

      case SV3_1aParser::TICK_ENDPROTECTED: {
        enterOuterAlt(_localctx, 18);
        setState(9686);
        endprotected_directive();
        break;
      }

      case SV3_1aParser::TICK_EXPAND_VECTORNETS: {
        enterOuterAlt(_localctx, 19);
        setState(9687);
        expand_vectornets_directive();
        break;
      }

      case SV3_1aParser::TICK_NOEXPAND_VECTORNETS: {
        enterOuterAlt(_localctx, 20);
        setState(9688);
        noexpand_vectornets_directive();
        break;
      }

      case SV3_1aParser::TICK_AUTOEXPAND_VECTORNETS: {
        enterOuterAlt(_localctx, 21);
        setState(9689);
        autoexpand_vectornets_directive();
        break;
      }

      case SV3_1aParser::TICK_REMOVE_GATENAME: {
        enterOuterAlt(_localctx, 22);
        setState(9690);
        remove_gatename_directive();
        break;
      }

      case SV3_1aParser::TICK_NOREMOVE_GATENAMES: {
        enterOuterAlt(_localctx, 23);
        setState(9691);
        noremove_gatenames_directive();
        break;
      }

      case SV3_1aParser::TICK_REMOVE_NETNAME: {
        enterOuterAlt(_localctx, 24);
        setState(9692);
        remove_netname_directive();
        break;
      }

      case SV3_1aParser::TICK_NOREMOVE_NETNAMES: {
        enterOuterAlt(_localctx, 25);
        setState(9693);
        noremove_netnames_directive();
        break;
      }

      case SV3_1aParser::TICK_ACCELERATE: {
        enterOuterAlt(_localctx, 26);
        setState(9694);
        accelerate_directive();
        break;
      }

      case SV3_1aParser::TICK_NOACCELERATE: {
        enterOuterAlt(_localctx, 27);
        setState(9695);
        noaccelerate_directive();
        break;
      }

      case SV3_1aParser::TICK_DISABLE_PORTFAULTS: {
        enterOuterAlt(_localctx, 28);
        setState(9696);
        disable_portfaults_directive();
        break;
      }

      case SV3_1aParser::TICK_ENABLE_PORTFAULTS: {
        enterOuterAlt(_localctx, 29);
        setState(9697);
        enable_portfaults_directive();
        break;
      }

      case SV3_1aParser::TICK_NOSUPPRESS_FAULTS: {
        enterOuterAlt(_localctx, 30);
        setState(9698);
        nosuppress_faults_directive();
        break;
      }

      case SV3_1aParser::TICK_SUPPRESS_FAULTS: {
        enterOuterAlt(_localctx, 31);
        setState(9699);
        suppress_faults_directive();
        break;
      }

      case SV3_1aParser::TICK_SIGNED: {
        enterOuterAlt(_localctx, 32);
        setState(9700);
        signed_directive();
        break;
      }

      case SV3_1aParser::TICK_UNSIGNED: {
        enterOuterAlt(_localctx, 33);
        setState(9701);
        unsigned_directive();
        break;
      }

      case SV3_1aParser::TICK_CELLDEFINE: {
        enterOuterAlt(_localctx, 34);
        setState(9702);
        celldefine_directive();
        break;
      }

      case SV3_1aParser::TICK_ENDCELLDEFINE: {
        enterOuterAlt(_localctx, 35);
        setState(9703);
        endcelldefine_directive();
        break;
      }

      case SV3_1aParser::TICK_PRAGMA: {
        enterOuterAlt(_localctx, 36);
        setState(9704);
        pragma_directive();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Pragma_directiveContext ------------------------------------------------------------------

SV3_1aParser::Pragma_directiveContext::Pragma_directiveContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Pragma_directiveContext::TICK_PRAGMA() {
  return getToken(SV3_1aParser::TICK_PRAGMA, 0);
}

tree::TerminalNode* SV3_1aParser::Pragma_directiveContext::Simple_identifier() {
  return getToken(SV3_1aParser::Simple_identifier, 0);
}

std::vector<SV3_1aParser::Pragma_expressionContext *> SV3_1aParser::Pragma_directiveContext::pragma_expression() {
  return getRuleContexts<SV3_1aParser::Pragma_expressionContext>();
}

SV3_1aParser::Pragma_expressionContext* SV3_1aParser::Pragma_directiveContext::pragma_expression(size_t i) {
  return getRuleContext<SV3_1aParser::Pragma_expressionContext>(i);
}

std::vector<tree::TerminalNode *> SV3_1aParser::Pragma_directiveContext::COMMA() {
  return getTokens(SV3_1aParser::COMMA);
}

tree::TerminalNode* SV3_1aParser::Pragma_directiveContext::COMMA(size_t i) {
  return getToken(SV3_1aParser::COMMA, i);
}


size_t SV3_1aParser::Pragma_directiveContext::getRuleIndex() const {
  return SV3_1aParser::RulePragma_directive;
}

void SV3_1aParser::Pragma_directiveContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPragma_directive(this);
}

void SV3_1aParser::Pragma_directiveContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPragma_directive(this);
}

SV3_1aParser::Pragma_directiveContext* SV3_1aParser::pragma_directive() {
  Pragma_directiveContext *_localctx = _tracker.createInstance<Pragma_directiveContext>(_ctx, getState());
  enterRule(_localctx, 1270, SV3_1aParser::RulePragma_directive);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(9707);
    match(SV3_1aParser::TICK_PRAGMA);
    setState(9708);
    match(SV3_1aParser::Simple_identifier);
    setState(9717);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1156, _ctx)) {
    case 1: {
      setState(9709);
      pragma_expression();
      setState(9714);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == SV3_1aParser::COMMA) {
        setState(9710);
        match(SV3_1aParser::COMMA);
        setState(9711);
        pragma_expression();
        setState(9716);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Pragma_expressionContext ------------------------------------------------------------------

SV3_1aParser::Pragma_expressionContext::Pragma_expressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Pragma_expressionContext::Simple_identifier() {
  return getToken(SV3_1aParser::Simple_identifier, 0);
}

tree::TerminalNode* SV3_1aParser::Pragma_expressionContext::ASSIGN_OP() {
  return getToken(SV3_1aParser::ASSIGN_OP, 0);
}

SV3_1aParser::Pragma_valueContext* SV3_1aParser::Pragma_expressionContext::pragma_value() {
  return getRuleContext<SV3_1aParser::Pragma_valueContext>(0);
}

tree::TerminalNode* SV3_1aParser::Pragma_expressionContext::BEGIN() {
  return getToken(SV3_1aParser::BEGIN, 0);
}

tree::TerminalNode* SV3_1aParser::Pragma_expressionContext::END() {
  return getToken(SV3_1aParser::END, 0);
}


size_t SV3_1aParser::Pragma_expressionContext::getRuleIndex() const {
  return SV3_1aParser::RulePragma_expression;
}

void SV3_1aParser::Pragma_expressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPragma_expression(this);
}

void SV3_1aParser::Pragma_expressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPragma_expression(this);
}

SV3_1aParser::Pragma_expressionContext* SV3_1aParser::pragma_expression() {
  Pragma_expressionContext *_localctx = _tracker.createInstance<Pragma_expressionContext>(_ctx, getState());
  enterRule(_localctx, 1272, SV3_1aParser::RulePragma_expression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(9726);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1157, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(9719);
      match(SV3_1aParser::Simple_identifier);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(9720);
      match(SV3_1aParser::Simple_identifier);
      setState(9721);
      match(SV3_1aParser::ASSIGN_OP);
      setState(9722);
      pragma_value();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(9723);
      pragma_value();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(9724);
      match(SV3_1aParser::BEGIN);
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(9725);
      match(SV3_1aParser::END);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Pragma_valueContext ------------------------------------------------------------------

SV3_1aParser::Pragma_valueContext::Pragma_valueContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Pragma_valueContext::OPEN_PARENS() {
  return getToken(SV3_1aParser::OPEN_PARENS, 0);
}

std::vector<SV3_1aParser::Pragma_expressionContext *> SV3_1aParser::Pragma_valueContext::pragma_expression() {
  return getRuleContexts<SV3_1aParser::Pragma_expressionContext>();
}

SV3_1aParser::Pragma_expressionContext* SV3_1aParser::Pragma_valueContext::pragma_expression(size_t i) {
  return getRuleContext<SV3_1aParser::Pragma_expressionContext>(i);
}

tree::TerminalNode* SV3_1aParser::Pragma_valueContext::CLOSE_PARENS() {
  return getToken(SV3_1aParser::CLOSE_PARENS, 0);
}

std::vector<tree::TerminalNode *> SV3_1aParser::Pragma_valueContext::COMMA() {
  return getTokens(SV3_1aParser::COMMA);
}

tree::TerminalNode* SV3_1aParser::Pragma_valueContext::COMMA(size_t i) {
  return getToken(SV3_1aParser::COMMA, i);
}

SV3_1aParser::NumberContext* SV3_1aParser::Pragma_valueContext::number() {
  return getRuleContext<SV3_1aParser::NumberContext>(0);
}

SV3_1aParser::String_valueContext* SV3_1aParser::Pragma_valueContext::string_value() {
  return getRuleContext<SV3_1aParser::String_valueContext>(0);
}

tree::TerminalNode* SV3_1aParser::Pragma_valueContext::Simple_identifier() {
  return getToken(SV3_1aParser::Simple_identifier, 0);
}


size_t SV3_1aParser::Pragma_valueContext::getRuleIndex() const {
  return SV3_1aParser::RulePragma_value;
}

void SV3_1aParser::Pragma_valueContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPragma_value(this);
}

void SV3_1aParser::Pragma_valueContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPragma_value(this);
}

SV3_1aParser::Pragma_valueContext* SV3_1aParser::pragma_value() {
  Pragma_valueContext *_localctx = _tracker.createInstance<Pragma_valueContext>(_ctx, getState());
  enterRule(_localctx, 1274, SV3_1aParser::RulePragma_value);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(9742);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SV3_1aParser::OPEN_PARENS: {
        enterOuterAlt(_localctx, 1);
        setState(9728);
        match(SV3_1aParser::OPEN_PARENS);
        setState(9729);
        pragma_expression();
        setState(9734);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == SV3_1aParser::COMMA) {
          setState(9730);
          match(SV3_1aParser::COMMA);
          setState(9731);
          pragma_expression();
          setState(9736);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(9737);
        match(SV3_1aParser::CLOSE_PARENS);
        break;
      }

      case SV3_1aParser::TICK_b0:
      case SV3_1aParser::TICK_b1:
      case SV3_1aParser::TICK_B0:
      case SV3_1aParser::TICK_B1:
      case SV3_1aParser::TICK_0:
      case SV3_1aParser::TICK_1:
      case SV3_1aParser::ONE_TICK_b0:
      case SV3_1aParser::ONE_TICK_b1:
      case SV3_1aParser::ONE_TICK_bx:
      case SV3_1aParser::ONE_TICK_bX:
      case SV3_1aParser::ONE_TICK_B0:
      case SV3_1aParser::ONE_TICK_B1:
      case SV3_1aParser::ONE_TICK_Bx:
      case SV3_1aParser::ONE_TICK_BX:
      case SV3_1aParser::Integral_number:
      case SV3_1aParser::Real_number: {
        enterOuterAlt(_localctx, 2);
        setState(9739);
        number();
        break;
      }

      case SV3_1aParser::String: {
        enterOuterAlt(_localctx, 3);
        setState(9740);
        string_value();
        break;
      }

      case SV3_1aParser::Simple_identifier: {
        enterOuterAlt(_localctx, 4);
        setState(9741);
        match(SV3_1aParser::Simple_identifier);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Timescale_directiveContext ------------------------------------------------------------------

SV3_1aParser::Timescale_directiveContext::Timescale_directiveContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Timescale_directiveContext::TICK_TIMESCALE() {
  return getToken(SV3_1aParser::TICK_TIMESCALE, 0);
}

std::vector<tree::TerminalNode *> SV3_1aParser::Timescale_directiveContext::Integral_number() {
  return getTokens(SV3_1aParser::Integral_number);
}

tree::TerminalNode* SV3_1aParser::Timescale_directiveContext::Integral_number(size_t i) {
  return getToken(SV3_1aParser::Integral_number, i);
}

std::vector<tree::TerminalNode *> SV3_1aParser::Timescale_directiveContext::Simple_identifier() {
  return getTokens(SV3_1aParser::Simple_identifier);
}

tree::TerminalNode* SV3_1aParser::Timescale_directiveContext::Simple_identifier(size_t i) {
  return getToken(SV3_1aParser::Simple_identifier, i);
}

tree::TerminalNode* SV3_1aParser::Timescale_directiveContext::DIV() {
  return getToken(SV3_1aParser::DIV, 0);
}


size_t SV3_1aParser::Timescale_directiveContext::getRuleIndex() const {
  return SV3_1aParser::RuleTimescale_directive;
}

void SV3_1aParser::Timescale_directiveContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTimescale_directive(this);
}

void SV3_1aParser::Timescale_directiveContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTimescale_directive(this);
}

SV3_1aParser::Timescale_directiveContext* SV3_1aParser::timescale_directive() {
  Timescale_directiveContext *_localctx = _tracker.createInstance<Timescale_directiveContext>(_ctx, getState());
  enterRule(_localctx, 1276, SV3_1aParser::RuleTimescale_directive);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(9744);
    match(SV3_1aParser::TICK_TIMESCALE);
    setState(9745);
    match(SV3_1aParser::Integral_number);
    setState(9746);
    match(SV3_1aParser::Simple_identifier);
    setState(9747);
    match(SV3_1aParser::DIV);
    setState(9748);
    match(SV3_1aParser::Integral_number);
    setState(9749);
    match(SV3_1aParser::Simple_identifier);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Begin_keywords_directiveContext ------------------------------------------------------------------

SV3_1aParser::Begin_keywords_directiveContext::Begin_keywords_directiveContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Begin_keywords_directiveContext::TICK_BEGIN_KEYWORDS() {
  return getToken(SV3_1aParser::TICK_BEGIN_KEYWORDS, 0);
}

tree::TerminalNode* SV3_1aParser::Begin_keywords_directiveContext::String() {
  return getToken(SV3_1aParser::String, 0);
}


size_t SV3_1aParser::Begin_keywords_directiveContext::getRuleIndex() const {
  return SV3_1aParser::RuleBegin_keywords_directive;
}

void SV3_1aParser::Begin_keywords_directiveContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBegin_keywords_directive(this);
}

void SV3_1aParser::Begin_keywords_directiveContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBegin_keywords_directive(this);
}

SV3_1aParser::Begin_keywords_directiveContext* SV3_1aParser::begin_keywords_directive() {
  Begin_keywords_directiveContext *_localctx = _tracker.createInstance<Begin_keywords_directiveContext>(_ctx, getState());
  enterRule(_localctx, 1278, SV3_1aParser::RuleBegin_keywords_directive);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(9751);
    match(SV3_1aParser::TICK_BEGIN_KEYWORDS);
    setState(9752);
    match(SV3_1aParser::String);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- End_keywords_directiveContext ------------------------------------------------------------------

SV3_1aParser::End_keywords_directiveContext::End_keywords_directiveContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::End_keywords_directiveContext::TICK_END_KEYWORDS() {
  return getToken(SV3_1aParser::TICK_END_KEYWORDS, 0);
}


size_t SV3_1aParser::End_keywords_directiveContext::getRuleIndex() const {
  return SV3_1aParser::RuleEnd_keywords_directive;
}

void SV3_1aParser::End_keywords_directiveContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterEnd_keywords_directive(this);
}

void SV3_1aParser::End_keywords_directiveContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitEnd_keywords_directive(this);
}

SV3_1aParser::End_keywords_directiveContext* SV3_1aParser::end_keywords_directive() {
  End_keywords_directiveContext *_localctx = _tracker.createInstance<End_keywords_directiveContext>(_ctx, getState());
  enterRule(_localctx, 1280, SV3_1aParser::RuleEnd_keywords_directive);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(9754);
    match(SV3_1aParser::TICK_END_KEYWORDS);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Unconnected_drive_directiveContext ------------------------------------------------------------------

SV3_1aParser::Unconnected_drive_directiveContext::Unconnected_drive_directiveContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Unconnected_drive_directiveContext::TICK_UNCONNECTED_DRIVE() {
  return getToken(SV3_1aParser::TICK_UNCONNECTED_DRIVE, 0);
}

tree::TerminalNode* SV3_1aParser::Unconnected_drive_directiveContext::Simple_identifier() {
  return getToken(SV3_1aParser::Simple_identifier, 0);
}

tree::TerminalNode* SV3_1aParser::Unconnected_drive_directiveContext::PULL0() {
  return getToken(SV3_1aParser::PULL0, 0);
}

tree::TerminalNode* SV3_1aParser::Unconnected_drive_directiveContext::PULL1() {
  return getToken(SV3_1aParser::PULL1, 0);
}


size_t SV3_1aParser::Unconnected_drive_directiveContext::getRuleIndex() const {
  return SV3_1aParser::RuleUnconnected_drive_directive;
}

void SV3_1aParser::Unconnected_drive_directiveContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUnconnected_drive_directive(this);
}

void SV3_1aParser::Unconnected_drive_directiveContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUnconnected_drive_directive(this);
}

SV3_1aParser::Unconnected_drive_directiveContext* SV3_1aParser::unconnected_drive_directive() {
  Unconnected_drive_directiveContext *_localctx = _tracker.createInstance<Unconnected_drive_directiveContext>(_ctx, getState());
  enterRule(_localctx, 1282, SV3_1aParser::RuleUnconnected_drive_directive);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(9756);
    match(SV3_1aParser::TICK_UNCONNECTED_DRIVE);
    setState(9757);
    _la = _input->LA(1);
    if (!(_la == SV3_1aParser::PULL0

    || _la == SV3_1aParser::PULL1 || _la == SV3_1aParser::Simple_identifier)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Nounconnected_drive_directiveContext ------------------------------------------------------------------

SV3_1aParser::Nounconnected_drive_directiveContext::Nounconnected_drive_directiveContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Nounconnected_drive_directiveContext::TICK_NOUNCONNECTED_DRIVE() {
  return getToken(SV3_1aParser::TICK_NOUNCONNECTED_DRIVE, 0);
}


size_t SV3_1aParser::Nounconnected_drive_directiveContext::getRuleIndex() const {
  return SV3_1aParser::RuleNounconnected_drive_directive;
}

void SV3_1aParser::Nounconnected_drive_directiveContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNounconnected_drive_directive(this);
}

void SV3_1aParser::Nounconnected_drive_directiveContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNounconnected_drive_directive(this);
}

SV3_1aParser::Nounconnected_drive_directiveContext* SV3_1aParser::nounconnected_drive_directive() {
  Nounconnected_drive_directiveContext *_localctx = _tracker.createInstance<Nounconnected_drive_directiveContext>(_ctx, getState());
  enterRule(_localctx, 1284, SV3_1aParser::RuleNounconnected_drive_directive);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(9759);
    match(SV3_1aParser::TICK_NOUNCONNECTED_DRIVE);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Default_nettype_directiveContext ------------------------------------------------------------------

SV3_1aParser::Default_nettype_directiveContext::Default_nettype_directiveContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Default_nettype_directiveContext::TICK_DEFAULT_NETTYPE() {
  return getToken(SV3_1aParser::TICK_DEFAULT_NETTYPE, 0);
}

tree::TerminalNode* SV3_1aParser::Default_nettype_directiveContext::Simple_identifier() {
  return getToken(SV3_1aParser::Simple_identifier, 0);
}

SV3_1aParser::Net_typeContext* SV3_1aParser::Default_nettype_directiveContext::net_type() {
  return getRuleContext<SV3_1aParser::Net_typeContext>(0);
}


size_t SV3_1aParser::Default_nettype_directiveContext::getRuleIndex() const {
  return SV3_1aParser::RuleDefault_nettype_directive;
}

void SV3_1aParser::Default_nettype_directiveContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDefault_nettype_directive(this);
}

void SV3_1aParser::Default_nettype_directiveContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDefault_nettype_directive(this);
}

SV3_1aParser::Default_nettype_directiveContext* SV3_1aParser::default_nettype_directive() {
  Default_nettype_directiveContext *_localctx = _tracker.createInstance<Default_nettype_directiveContext>(_ctx, getState());
  enterRule(_localctx, 1286, SV3_1aParser::RuleDefault_nettype_directive);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(9761);
    match(SV3_1aParser::TICK_DEFAULT_NETTYPE);
    setState(9764);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SV3_1aParser::Simple_identifier: {
        setState(9762);
        match(SV3_1aParser::Simple_identifier);
        break;
      }

      case SV3_1aParser::SUPPLY0:
      case SV3_1aParser::SUPPLY1:
      case SV3_1aParser::TRI:
      case SV3_1aParser::TRIAND:
      case SV3_1aParser::TRIOR:
      case SV3_1aParser::TRI0:
      case SV3_1aParser::TRI1:
      case SV3_1aParser::WIRE:
      case SV3_1aParser::UWIRE:
      case SV3_1aParser::WAND:
      case SV3_1aParser::WOR:
      case SV3_1aParser::TRIREG: {
        setState(9763);
        net_type();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Uselib_directiveContext ------------------------------------------------------------------

SV3_1aParser::Uselib_directiveContext::Uselib_directiveContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Uselib_directiveContext::TICK_USELIB() {
  return getToken(SV3_1aParser::TICK_USELIB, 0);
}


size_t SV3_1aParser::Uselib_directiveContext::getRuleIndex() const {
  return SV3_1aParser::RuleUselib_directive;
}

void SV3_1aParser::Uselib_directiveContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUselib_directive(this);
}

void SV3_1aParser::Uselib_directiveContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUselib_directive(this);
}

SV3_1aParser::Uselib_directiveContext* SV3_1aParser::uselib_directive() {
  Uselib_directiveContext *_localctx = _tracker.createInstance<Uselib_directiveContext>(_ctx, getState());
  enterRule(_localctx, 1288, SV3_1aParser::RuleUselib_directive);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(9766);
    match(SV3_1aParser::TICK_USELIB);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Celldefine_directiveContext ------------------------------------------------------------------

SV3_1aParser::Celldefine_directiveContext::Celldefine_directiveContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Celldefine_directiveContext::TICK_CELLDEFINE() {
  return getToken(SV3_1aParser::TICK_CELLDEFINE, 0);
}


size_t SV3_1aParser::Celldefine_directiveContext::getRuleIndex() const {
  return SV3_1aParser::RuleCelldefine_directive;
}

void SV3_1aParser::Celldefine_directiveContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCelldefine_directive(this);
}

void SV3_1aParser::Celldefine_directiveContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCelldefine_directive(this);
}

SV3_1aParser::Celldefine_directiveContext* SV3_1aParser::celldefine_directive() {
  Celldefine_directiveContext *_localctx = _tracker.createInstance<Celldefine_directiveContext>(_ctx, getState());
  enterRule(_localctx, 1290, SV3_1aParser::RuleCelldefine_directive);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(9768);
    match(SV3_1aParser::TICK_CELLDEFINE);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Endcelldefine_directiveContext ------------------------------------------------------------------

SV3_1aParser::Endcelldefine_directiveContext::Endcelldefine_directiveContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Endcelldefine_directiveContext::TICK_ENDCELLDEFINE() {
  return getToken(SV3_1aParser::TICK_ENDCELLDEFINE, 0);
}


size_t SV3_1aParser::Endcelldefine_directiveContext::getRuleIndex() const {
  return SV3_1aParser::RuleEndcelldefine_directive;
}

void SV3_1aParser::Endcelldefine_directiveContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterEndcelldefine_directive(this);
}

void SV3_1aParser::Endcelldefine_directiveContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitEndcelldefine_directive(this);
}

SV3_1aParser::Endcelldefine_directiveContext* SV3_1aParser::endcelldefine_directive() {
  Endcelldefine_directiveContext *_localctx = _tracker.createInstance<Endcelldefine_directiveContext>(_ctx, getState());
  enterRule(_localctx, 1292, SV3_1aParser::RuleEndcelldefine_directive);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(9770);
    match(SV3_1aParser::TICK_ENDCELLDEFINE);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Protect_directiveContext ------------------------------------------------------------------

SV3_1aParser::Protect_directiveContext::Protect_directiveContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Protect_directiveContext::TICK_PROTECT() {
  return getToken(SV3_1aParser::TICK_PROTECT, 0);
}


size_t SV3_1aParser::Protect_directiveContext::getRuleIndex() const {
  return SV3_1aParser::RuleProtect_directive;
}

void SV3_1aParser::Protect_directiveContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterProtect_directive(this);
}

void SV3_1aParser::Protect_directiveContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitProtect_directive(this);
}

SV3_1aParser::Protect_directiveContext* SV3_1aParser::protect_directive() {
  Protect_directiveContext *_localctx = _tracker.createInstance<Protect_directiveContext>(_ctx, getState());
  enterRule(_localctx, 1294, SV3_1aParser::RuleProtect_directive);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(9772);
    match(SV3_1aParser::TICK_PROTECT);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Endprotect_directiveContext ------------------------------------------------------------------

SV3_1aParser::Endprotect_directiveContext::Endprotect_directiveContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Endprotect_directiveContext::TICK_ENDPROTECT() {
  return getToken(SV3_1aParser::TICK_ENDPROTECT, 0);
}


size_t SV3_1aParser::Endprotect_directiveContext::getRuleIndex() const {
  return SV3_1aParser::RuleEndprotect_directive;
}

void SV3_1aParser::Endprotect_directiveContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterEndprotect_directive(this);
}

void SV3_1aParser::Endprotect_directiveContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitEndprotect_directive(this);
}

SV3_1aParser::Endprotect_directiveContext* SV3_1aParser::endprotect_directive() {
  Endprotect_directiveContext *_localctx = _tracker.createInstance<Endprotect_directiveContext>(_ctx, getState());
  enterRule(_localctx, 1296, SV3_1aParser::RuleEndprotect_directive);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(9774);
    match(SV3_1aParser::TICK_ENDPROTECT);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Protected_directiveContext ------------------------------------------------------------------

SV3_1aParser::Protected_directiveContext::Protected_directiveContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Protected_directiveContext::TICK_PROTECTED() {
  return getToken(SV3_1aParser::TICK_PROTECTED, 0);
}


size_t SV3_1aParser::Protected_directiveContext::getRuleIndex() const {
  return SV3_1aParser::RuleProtected_directive;
}

void SV3_1aParser::Protected_directiveContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterProtected_directive(this);
}

void SV3_1aParser::Protected_directiveContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitProtected_directive(this);
}

SV3_1aParser::Protected_directiveContext* SV3_1aParser::protected_directive() {
  Protected_directiveContext *_localctx = _tracker.createInstance<Protected_directiveContext>(_ctx, getState());
  enterRule(_localctx, 1298, SV3_1aParser::RuleProtected_directive);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(9776);
    match(SV3_1aParser::TICK_PROTECTED);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Endprotected_directiveContext ------------------------------------------------------------------

SV3_1aParser::Endprotected_directiveContext::Endprotected_directiveContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Endprotected_directiveContext::TICK_ENDPROTECTED() {
  return getToken(SV3_1aParser::TICK_ENDPROTECTED, 0);
}


size_t SV3_1aParser::Endprotected_directiveContext::getRuleIndex() const {
  return SV3_1aParser::RuleEndprotected_directive;
}

void SV3_1aParser::Endprotected_directiveContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterEndprotected_directive(this);
}

void SV3_1aParser::Endprotected_directiveContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitEndprotected_directive(this);
}

SV3_1aParser::Endprotected_directiveContext* SV3_1aParser::endprotected_directive() {
  Endprotected_directiveContext *_localctx = _tracker.createInstance<Endprotected_directiveContext>(_ctx, getState());
  enterRule(_localctx, 1300, SV3_1aParser::RuleEndprotected_directive);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(9778);
    match(SV3_1aParser::TICK_ENDPROTECTED);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Expand_vectornets_directiveContext ------------------------------------------------------------------

SV3_1aParser::Expand_vectornets_directiveContext::Expand_vectornets_directiveContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Expand_vectornets_directiveContext::TICK_EXPAND_VECTORNETS() {
  return getToken(SV3_1aParser::TICK_EXPAND_VECTORNETS, 0);
}


size_t SV3_1aParser::Expand_vectornets_directiveContext::getRuleIndex() const {
  return SV3_1aParser::RuleExpand_vectornets_directive;
}

void SV3_1aParser::Expand_vectornets_directiveContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExpand_vectornets_directive(this);
}

void SV3_1aParser::Expand_vectornets_directiveContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExpand_vectornets_directive(this);
}

SV3_1aParser::Expand_vectornets_directiveContext* SV3_1aParser::expand_vectornets_directive() {
  Expand_vectornets_directiveContext *_localctx = _tracker.createInstance<Expand_vectornets_directiveContext>(_ctx, getState());
  enterRule(_localctx, 1302, SV3_1aParser::RuleExpand_vectornets_directive);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(9780);
    match(SV3_1aParser::TICK_EXPAND_VECTORNETS);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Noexpand_vectornets_directiveContext ------------------------------------------------------------------

SV3_1aParser::Noexpand_vectornets_directiveContext::Noexpand_vectornets_directiveContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Noexpand_vectornets_directiveContext::TICK_NOEXPAND_VECTORNETS() {
  return getToken(SV3_1aParser::TICK_NOEXPAND_VECTORNETS, 0);
}


size_t SV3_1aParser::Noexpand_vectornets_directiveContext::getRuleIndex() const {
  return SV3_1aParser::RuleNoexpand_vectornets_directive;
}

void SV3_1aParser::Noexpand_vectornets_directiveContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNoexpand_vectornets_directive(this);
}

void SV3_1aParser::Noexpand_vectornets_directiveContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNoexpand_vectornets_directive(this);
}

SV3_1aParser::Noexpand_vectornets_directiveContext* SV3_1aParser::noexpand_vectornets_directive() {
  Noexpand_vectornets_directiveContext *_localctx = _tracker.createInstance<Noexpand_vectornets_directiveContext>(_ctx, getState());
  enterRule(_localctx, 1304, SV3_1aParser::RuleNoexpand_vectornets_directive);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(9782);
    match(SV3_1aParser::TICK_NOEXPAND_VECTORNETS);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Autoexpand_vectornets_directiveContext ------------------------------------------------------------------

SV3_1aParser::Autoexpand_vectornets_directiveContext::Autoexpand_vectornets_directiveContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Autoexpand_vectornets_directiveContext::TICK_AUTOEXPAND_VECTORNETS() {
  return getToken(SV3_1aParser::TICK_AUTOEXPAND_VECTORNETS, 0);
}


size_t SV3_1aParser::Autoexpand_vectornets_directiveContext::getRuleIndex() const {
  return SV3_1aParser::RuleAutoexpand_vectornets_directive;
}

void SV3_1aParser::Autoexpand_vectornets_directiveContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAutoexpand_vectornets_directive(this);
}

void SV3_1aParser::Autoexpand_vectornets_directiveContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAutoexpand_vectornets_directive(this);
}

SV3_1aParser::Autoexpand_vectornets_directiveContext* SV3_1aParser::autoexpand_vectornets_directive() {
  Autoexpand_vectornets_directiveContext *_localctx = _tracker.createInstance<Autoexpand_vectornets_directiveContext>(_ctx, getState());
  enterRule(_localctx, 1306, SV3_1aParser::RuleAutoexpand_vectornets_directive);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(9784);
    match(SV3_1aParser::TICK_AUTOEXPAND_VECTORNETS);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Disable_portfaults_directiveContext ------------------------------------------------------------------

SV3_1aParser::Disable_portfaults_directiveContext::Disable_portfaults_directiveContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Disable_portfaults_directiveContext::TICK_DISABLE_PORTFAULTS() {
  return getToken(SV3_1aParser::TICK_DISABLE_PORTFAULTS, 0);
}


size_t SV3_1aParser::Disable_portfaults_directiveContext::getRuleIndex() const {
  return SV3_1aParser::RuleDisable_portfaults_directive;
}

void SV3_1aParser::Disable_portfaults_directiveContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDisable_portfaults_directive(this);
}

void SV3_1aParser::Disable_portfaults_directiveContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDisable_portfaults_directive(this);
}

SV3_1aParser::Disable_portfaults_directiveContext* SV3_1aParser::disable_portfaults_directive() {
  Disable_portfaults_directiveContext *_localctx = _tracker.createInstance<Disable_portfaults_directiveContext>(_ctx, getState());
  enterRule(_localctx, 1308, SV3_1aParser::RuleDisable_portfaults_directive);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(9786);
    match(SV3_1aParser::TICK_DISABLE_PORTFAULTS);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Enable_portfaults_directiveContext ------------------------------------------------------------------

SV3_1aParser::Enable_portfaults_directiveContext::Enable_portfaults_directiveContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Enable_portfaults_directiveContext::TICK_ENABLE_PORTFAULTS() {
  return getToken(SV3_1aParser::TICK_ENABLE_PORTFAULTS, 0);
}


size_t SV3_1aParser::Enable_portfaults_directiveContext::getRuleIndex() const {
  return SV3_1aParser::RuleEnable_portfaults_directive;
}

void SV3_1aParser::Enable_portfaults_directiveContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterEnable_portfaults_directive(this);
}

void SV3_1aParser::Enable_portfaults_directiveContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitEnable_portfaults_directive(this);
}

SV3_1aParser::Enable_portfaults_directiveContext* SV3_1aParser::enable_portfaults_directive() {
  Enable_portfaults_directiveContext *_localctx = _tracker.createInstance<Enable_portfaults_directiveContext>(_ctx, getState());
  enterRule(_localctx, 1310, SV3_1aParser::RuleEnable_portfaults_directive);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(9788);
    match(SV3_1aParser::TICK_ENABLE_PORTFAULTS);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Nosuppress_faults_directiveContext ------------------------------------------------------------------

SV3_1aParser::Nosuppress_faults_directiveContext::Nosuppress_faults_directiveContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Nosuppress_faults_directiveContext::TICK_NOSUPPRESS_FAULTS() {
  return getToken(SV3_1aParser::TICK_NOSUPPRESS_FAULTS, 0);
}


size_t SV3_1aParser::Nosuppress_faults_directiveContext::getRuleIndex() const {
  return SV3_1aParser::RuleNosuppress_faults_directive;
}

void SV3_1aParser::Nosuppress_faults_directiveContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNosuppress_faults_directive(this);
}

void SV3_1aParser::Nosuppress_faults_directiveContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNosuppress_faults_directive(this);
}

SV3_1aParser::Nosuppress_faults_directiveContext* SV3_1aParser::nosuppress_faults_directive() {
  Nosuppress_faults_directiveContext *_localctx = _tracker.createInstance<Nosuppress_faults_directiveContext>(_ctx, getState());
  enterRule(_localctx, 1312, SV3_1aParser::RuleNosuppress_faults_directive);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(9790);
    match(SV3_1aParser::TICK_NOSUPPRESS_FAULTS);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Suppress_faults_directiveContext ------------------------------------------------------------------

SV3_1aParser::Suppress_faults_directiveContext::Suppress_faults_directiveContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Suppress_faults_directiveContext::TICK_SUPPRESS_FAULTS() {
  return getToken(SV3_1aParser::TICK_SUPPRESS_FAULTS, 0);
}


size_t SV3_1aParser::Suppress_faults_directiveContext::getRuleIndex() const {
  return SV3_1aParser::RuleSuppress_faults_directive;
}

void SV3_1aParser::Suppress_faults_directiveContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSuppress_faults_directive(this);
}

void SV3_1aParser::Suppress_faults_directiveContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSuppress_faults_directive(this);
}

SV3_1aParser::Suppress_faults_directiveContext* SV3_1aParser::suppress_faults_directive() {
  Suppress_faults_directiveContext *_localctx = _tracker.createInstance<Suppress_faults_directiveContext>(_ctx, getState());
  enterRule(_localctx, 1314, SV3_1aParser::RuleSuppress_faults_directive);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(9792);
    match(SV3_1aParser::TICK_SUPPRESS_FAULTS);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Signed_directiveContext ------------------------------------------------------------------

SV3_1aParser::Signed_directiveContext::Signed_directiveContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Signed_directiveContext::TICK_SIGNED() {
  return getToken(SV3_1aParser::TICK_SIGNED, 0);
}


size_t SV3_1aParser::Signed_directiveContext::getRuleIndex() const {
  return SV3_1aParser::RuleSigned_directive;
}

void SV3_1aParser::Signed_directiveContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSigned_directive(this);
}

void SV3_1aParser::Signed_directiveContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSigned_directive(this);
}

SV3_1aParser::Signed_directiveContext* SV3_1aParser::signed_directive() {
  Signed_directiveContext *_localctx = _tracker.createInstance<Signed_directiveContext>(_ctx, getState());
  enterRule(_localctx, 1316, SV3_1aParser::RuleSigned_directive);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(9794);
    match(SV3_1aParser::TICK_SIGNED);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Unsigned_directiveContext ------------------------------------------------------------------

SV3_1aParser::Unsigned_directiveContext::Unsigned_directiveContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Unsigned_directiveContext::TICK_UNSIGNED() {
  return getToken(SV3_1aParser::TICK_UNSIGNED, 0);
}


size_t SV3_1aParser::Unsigned_directiveContext::getRuleIndex() const {
  return SV3_1aParser::RuleUnsigned_directive;
}

void SV3_1aParser::Unsigned_directiveContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUnsigned_directive(this);
}

void SV3_1aParser::Unsigned_directiveContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUnsigned_directive(this);
}

SV3_1aParser::Unsigned_directiveContext* SV3_1aParser::unsigned_directive() {
  Unsigned_directiveContext *_localctx = _tracker.createInstance<Unsigned_directiveContext>(_ctx, getState());
  enterRule(_localctx, 1318, SV3_1aParser::RuleUnsigned_directive);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(9796);
    match(SV3_1aParser::TICK_UNSIGNED);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Remove_gatename_directiveContext ------------------------------------------------------------------

SV3_1aParser::Remove_gatename_directiveContext::Remove_gatename_directiveContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Remove_gatename_directiveContext::TICK_REMOVE_GATENAME() {
  return getToken(SV3_1aParser::TICK_REMOVE_GATENAME, 0);
}


size_t SV3_1aParser::Remove_gatename_directiveContext::getRuleIndex() const {
  return SV3_1aParser::RuleRemove_gatename_directive;
}

void SV3_1aParser::Remove_gatename_directiveContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRemove_gatename_directive(this);
}

void SV3_1aParser::Remove_gatename_directiveContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRemove_gatename_directive(this);
}

SV3_1aParser::Remove_gatename_directiveContext* SV3_1aParser::remove_gatename_directive() {
  Remove_gatename_directiveContext *_localctx = _tracker.createInstance<Remove_gatename_directiveContext>(_ctx, getState());
  enterRule(_localctx, 1320, SV3_1aParser::RuleRemove_gatename_directive);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(9798);
    match(SV3_1aParser::TICK_REMOVE_GATENAME);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Noremove_gatenames_directiveContext ------------------------------------------------------------------

SV3_1aParser::Noremove_gatenames_directiveContext::Noremove_gatenames_directiveContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Noremove_gatenames_directiveContext::TICK_NOREMOVE_GATENAMES() {
  return getToken(SV3_1aParser::TICK_NOREMOVE_GATENAMES, 0);
}


size_t SV3_1aParser::Noremove_gatenames_directiveContext::getRuleIndex() const {
  return SV3_1aParser::RuleNoremove_gatenames_directive;
}

void SV3_1aParser::Noremove_gatenames_directiveContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNoremove_gatenames_directive(this);
}

void SV3_1aParser::Noremove_gatenames_directiveContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNoremove_gatenames_directive(this);
}

SV3_1aParser::Noremove_gatenames_directiveContext* SV3_1aParser::noremove_gatenames_directive() {
  Noremove_gatenames_directiveContext *_localctx = _tracker.createInstance<Noremove_gatenames_directiveContext>(_ctx, getState());
  enterRule(_localctx, 1322, SV3_1aParser::RuleNoremove_gatenames_directive);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(9800);
    match(SV3_1aParser::TICK_NOREMOVE_GATENAMES);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Remove_netname_directiveContext ------------------------------------------------------------------

SV3_1aParser::Remove_netname_directiveContext::Remove_netname_directiveContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Remove_netname_directiveContext::TICK_REMOVE_NETNAME() {
  return getToken(SV3_1aParser::TICK_REMOVE_NETNAME, 0);
}


size_t SV3_1aParser::Remove_netname_directiveContext::getRuleIndex() const {
  return SV3_1aParser::RuleRemove_netname_directive;
}

void SV3_1aParser::Remove_netname_directiveContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRemove_netname_directive(this);
}

void SV3_1aParser::Remove_netname_directiveContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRemove_netname_directive(this);
}

SV3_1aParser::Remove_netname_directiveContext* SV3_1aParser::remove_netname_directive() {
  Remove_netname_directiveContext *_localctx = _tracker.createInstance<Remove_netname_directiveContext>(_ctx, getState());
  enterRule(_localctx, 1324, SV3_1aParser::RuleRemove_netname_directive);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(9802);
    match(SV3_1aParser::TICK_REMOVE_NETNAME);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Noremove_netnames_directiveContext ------------------------------------------------------------------

SV3_1aParser::Noremove_netnames_directiveContext::Noremove_netnames_directiveContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Noremove_netnames_directiveContext::TICK_NOREMOVE_NETNAMES() {
  return getToken(SV3_1aParser::TICK_NOREMOVE_NETNAMES, 0);
}


size_t SV3_1aParser::Noremove_netnames_directiveContext::getRuleIndex() const {
  return SV3_1aParser::RuleNoremove_netnames_directive;
}

void SV3_1aParser::Noremove_netnames_directiveContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNoremove_netnames_directive(this);
}

void SV3_1aParser::Noremove_netnames_directiveContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNoremove_netnames_directive(this);
}

SV3_1aParser::Noremove_netnames_directiveContext* SV3_1aParser::noremove_netnames_directive() {
  Noremove_netnames_directiveContext *_localctx = _tracker.createInstance<Noremove_netnames_directiveContext>(_ctx, getState());
  enterRule(_localctx, 1326, SV3_1aParser::RuleNoremove_netnames_directive);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(9804);
    match(SV3_1aParser::TICK_NOREMOVE_NETNAMES);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Accelerate_directiveContext ------------------------------------------------------------------

SV3_1aParser::Accelerate_directiveContext::Accelerate_directiveContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Accelerate_directiveContext::TICK_ACCELERATE() {
  return getToken(SV3_1aParser::TICK_ACCELERATE, 0);
}


size_t SV3_1aParser::Accelerate_directiveContext::getRuleIndex() const {
  return SV3_1aParser::RuleAccelerate_directive;
}

void SV3_1aParser::Accelerate_directiveContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAccelerate_directive(this);
}

void SV3_1aParser::Accelerate_directiveContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAccelerate_directive(this);
}

SV3_1aParser::Accelerate_directiveContext* SV3_1aParser::accelerate_directive() {
  Accelerate_directiveContext *_localctx = _tracker.createInstance<Accelerate_directiveContext>(_ctx, getState());
  enterRule(_localctx, 1328, SV3_1aParser::RuleAccelerate_directive);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(9806);
    match(SV3_1aParser::TICK_ACCELERATE);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Noaccelerate_directiveContext ------------------------------------------------------------------

SV3_1aParser::Noaccelerate_directiveContext::Noaccelerate_directiveContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Noaccelerate_directiveContext::TICK_NOACCELERATE() {
  return getToken(SV3_1aParser::TICK_NOACCELERATE, 0);
}


size_t SV3_1aParser::Noaccelerate_directiveContext::getRuleIndex() const {
  return SV3_1aParser::RuleNoaccelerate_directive;
}

void SV3_1aParser::Noaccelerate_directiveContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNoaccelerate_directive(this);
}

void SV3_1aParser::Noaccelerate_directiveContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNoaccelerate_directive(this);
}

SV3_1aParser::Noaccelerate_directiveContext* SV3_1aParser::noaccelerate_directive() {
  Noaccelerate_directiveContext *_localctx = _tracker.createInstance<Noaccelerate_directiveContext>(_ctx, getState());
  enterRule(_localctx, 1330, SV3_1aParser::RuleNoaccelerate_directive);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(9808);
    match(SV3_1aParser::TICK_NOACCELERATE);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Default_trireg_strenght_directiveContext ------------------------------------------------------------------

SV3_1aParser::Default_trireg_strenght_directiveContext::Default_trireg_strenght_directiveContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Default_trireg_strenght_directiveContext::TICK_DEFAULT_TRIREG_STRENGTH() {
  return getToken(SV3_1aParser::TICK_DEFAULT_TRIREG_STRENGTH, 0);
}

SV3_1aParser::NumberContext* SV3_1aParser::Default_trireg_strenght_directiveContext::number() {
  return getRuleContext<SV3_1aParser::NumberContext>(0);
}


size_t SV3_1aParser::Default_trireg_strenght_directiveContext::getRuleIndex() const {
  return SV3_1aParser::RuleDefault_trireg_strenght_directive;
}

void SV3_1aParser::Default_trireg_strenght_directiveContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDefault_trireg_strenght_directive(this);
}

void SV3_1aParser::Default_trireg_strenght_directiveContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDefault_trireg_strenght_directive(this);
}

SV3_1aParser::Default_trireg_strenght_directiveContext* SV3_1aParser::default_trireg_strenght_directive() {
  Default_trireg_strenght_directiveContext *_localctx = _tracker.createInstance<Default_trireg_strenght_directiveContext>(_ctx, getState());
  enterRule(_localctx, 1332, SV3_1aParser::RuleDefault_trireg_strenght_directive);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(9810);
    match(SV3_1aParser::TICK_DEFAULT_TRIREG_STRENGTH);
    setState(9811);
    number();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Default_decay_time_directiveContext ------------------------------------------------------------------

SV3_1aParser::Default_decay_time_directiveContext::Default_decay_time_directiveContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Default_decay_time_directiveContext::TICK_DEFAULT_DECAY_TIME() {
  return getToken(SV3_1aParser::TICK_DEFAULT_DECAY_TIME, 0);
}

SV3_1aParser::NumberContext* SV3_1aParser::Default_decay_time_directiveContext::number() {
  return getRuleContext<SV3_1aParser::NumberContext>(0);
}

tree::TerminalNode* SV3_1aParser::Default_decay_time_directiveContext::Simple_identifier() {
  return getToken(SV3_1aParser::Simple_identifier, 0);
}


size_t SV3_1aParser::Default_decay_time_directiveContext::getRuleIndex() const {
  return SV3_1aParser::RuleDefault_decay_time_directive;
}

void SV3_1aParser::Default_decay_time_directiveContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDefault_decay_time_directive(this);
}

void SV3_1aParser::Default_decay_time_directiveContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDefault_decay_time_directive(this);
}

SV3_1aParser::Default_decay_time_directiveContext* SV3_1aParser::default_decay_time_directive() {
  Default_decay_time_directiveContext *_localctx = _tracker.createInstance<Default_decay_time_directiveContext>(_ctx, getState());
  enterRule(_localctx, 1334, SV3_1aParser::RuleDefault_decay_time_directive);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(9813);
    match(SV3_1aParser::TICK_DEFAULT_DECAY_TIME);
    setState(9816);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SV3_1aParser::TICK_b0:
      case SV3_1aParser::TICK_b1:
      case SV3_1aParser::TICK_B0:
      case SV3_1aParser::TICK_B1:
      case SV3_1aParser::TICK_0:
      case SV3_1aParser::TICK_1:
      case SV3_1aParser::ONE_TICK_b0:
      case SV3_1aParser::ONE_TICK_b1:
      case SV3_1aParser::ONE_TICK_bx:
      case SV3_1aParser::ONE_TICK_bX:
      case SV3_1aParser::ONE_TICK_B0:
      case SV3_1aParser::ONE_TICK_B1:
      case SV3_1aParser::ONE_TICK_Bx:
      case SV3_1aParser::ONE_TICK_BX:
      case SV3_1aParser::Integral_number:
      case SV3_1aParser::Real_number: {
        setState(9814);
        number();
        break;
      }

      case SV3_1aParser::Simple_identifier: {
        setState(9815);
        match(SV3_1aParser::Simple_identifier);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Delay_mode_distributed_directiveContext ------------------------------------------------------------------

SV3_1aParser::Delay_mode_distributed_directiveContext::Delay_mode_distributed_directiveContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Delay_mode_distributed_directiveContext::TICK_DELAY_MODE_DISTRIBUTED() {
  return getToken(SV3_1aParser::TICK_DELAY_MODE_DISTRIBUTED, 0);
}


size_t SV3_1aParser::Delay_mode_distributed_directiveContext::getRuleIndex() const {
  return SV3_1aParser::RuleDelay_mode_distributed_directive;
}

void SV3_1aParser::Delay_mode_distributed_directiveContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDelay_mode_distributed_directive(this);
}

void SV3_1aParser::Delay_mode_distributed_directiveContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDelay_mode_distributed_directive(this);
}

SV3_1aParser::Delay_mode_distributed_directiveContext* SV3_1aParser::delay_mode_distributed_directive() {
  Delay_mode_distributed_directiveContext *_localctx = _tracker.createInstance<Delay_mode_distributed_directiveContext>(_ctx, getState());
  enterRule(_localctx, 1336, SV3_1aParser::RuleDelay_mode_distributed_directive);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(9818);
    match(SV3_1aParser::TICK_DELAY_MODE_DISTRIBUTED);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Delay_mode_path_directiveContext ------------------------------------------------------------------

SV3_1aParser::Delay_mode_path_directiveContext::Delay_mode_path_directiveContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Delay_mode_path_directiveContext::TICK_DELAY_MODE_PATH() {
  return getToken(SV3_1aParser::TICK_DELAY_MODE_PATH, 0);
}


size_t SV3_1aParser::Delay_mode_path_directiveContext::getRuleIndex() const {
  return SV3_1aParser::RuleDelay_mode_path_directive;
}

void SV3_1aParser::Delay_mode_path_directiveContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDelay_mode_path_directive(this);
}

void SV3_1aParser::Delay_mode_path_directiveContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDelay_mode_path_directive(this);
}

SV3_1aParser::Delay_mode_path_directiveContext* SV3_1aParser::delay_mode_path_directive() {
  Delay_mode_path_directiveContext *_localctx = _tracker.createInstance<Delay_mode_path_directiveContext>(_ctx, getState());
  enterRule(_localctx, 1338, SV3_1aParser::RuleDelay_mode_path_directive);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(9820);
    match(SV3_1aParser::TICK_DELAY_MODE_PATH);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Delay_mode_unit_directiveContext ------------------------------------------------------------------

SV3_1aParser::Delay_mode_unit_directiveContext::Delay_mode_unit_directiveContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Delay_mode_unit_directiveContext::TICK_DELAY_MODE_UNIT() {
  return getToken(SV3_1aParser::TICK_DELAY_MODE_UNIT, 0);
}


size_t SV3_1aParser::Delay_mode_unit_directiveContext::getRuleIndex() const {
  return SV3_1aParser::RuleDelay_mode_unit_directive;
}

void SV3_1aParser::Delay_mode_unit_directiveContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDelay_mode_unit_directive(this);
}

void SV3_1aParser::Delay_mode_unit_directiveContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDelay_mode_unit_directive(this);
}

SV3_1aParser::Delay_mode_unit_directiveContext* SV3_1aParser::delay_mode_unit_directive() {
  Delay_mode_unit_directiveContext *_localctx = _tracker.createInstance<Delay_mode_unit_directiveContext>(_ctx, getState());
  enterRule(_localctx, 1340, SV3_1aParser::RuleDelay_mode_unit_directive);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(9822);
    match(SV3_1aParser::TICK_DELAY_MODE_UNIT);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Delay_mode_zero_directiveContext ------------------------------------------------------------------

SV3_1aParser::Delay_mode_zero_directiveContext::Delay_mode_zero_directiveContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Delay_mode_zero_directiveContext::TICK_DELAY_MODE_ZERO() {
  return getToken(SV3_1aParser::TICK_DELAY_MODE_ZERO, 0);
}


size_t SV3_1aParser::Delay_mode_zero_directiveContext::getRuleIndex() const {
  return SV3_1aParser::RuleDelay_mode_zero_directive;
}

void SV3_1aParser::Delay_mode_zero_directiveContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDelay_mode_zero_directive(this);
}

void SV3_1aParser::Delay_mode_zero_directiveContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDelay_mode_zero_directive(this);
}

SV3_1aParser::Delay_mode_zero_directiveContext* SV3_1aParser::delay_mode_zero_directive() {
  Delay_mode_zero_directiveContext *_localctx = _tracker.createInstance<Delay_mode_zero_directiveContext>(_ctx, getState());
  enterRule(_localctx, 1342, SV3_1aParser::RuleDelay_mode_zero_directive);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(9824);
    match(SV3_1aParser::TICK_DELAY_MODE_ZERO);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Surelog_macro_not_definedContext ------------------------------------------------------------------

SV3_1aParser::Surelog_macro_not_definedContext::Surelog_macro_not_definedContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Surelog_macro_not_definedContext::SURELOG_MACRO_NOT_DEFINED() {
  return getToken(SV3_1aParser::SURELOG_MACRO_NOT_DEFINED, 0);
}


size_t SV3_1aParser::Surelog_macro_not_definedContext::getRuleIndex() const {
  return SV3_1aParser::RuleSurelog_macro_not_defined;
}

void SV3_1aParser::Surelog_macro_not_definedContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSurelog_macro_not_defined(this);
}

void SV3_1aParser::Surelog_macro_not_definedContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSurelog_macro_not_defined(this);
}

SV3_1aParser::Surelog_macro_not_definedContext* SV3_1aParser::surelog_macro_not_defined() {
  Surelog_macro_not_definedContext *_localctx = _tracker.createInstance<Surelog_macro_not_definedContext>(_ctx, getState());
  enterRule(_localctx, 1344, SV3_1aParser::RuleSurelog_macro_not_defined);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(9826);
    match(SV3_1aParser::SURELOG_MACRO_NOT_DEFINED);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SllineContext ------------------------------------------------------------------

SV3_1aParser::SllineContext::SllineContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::SllineContext::TICK_LINE() {
  return getToken(SV3_1aParser::TICK_LINE, 0);
}

std::vector<tree::TerminalNode *> SV3_1aParser::SllineContext::Integral_number() {
  return getTokens(SV3_1aParser::Integral_number);
}

tree::TerminalNode* SV3_1aParser::SllineContext::Integral_number(size_t i) {
  return getToken(SV3_1aParser::Integral_number, i);
}

tree::TerminalNode* SV3_1aParser::SllineContext::String() {
  return getToken(SV3_1aParser::String, 0);
}


size_t SV3_1aParser::SllineContext::getRuleIndex() const {
  return SV3_1aParser::RuleSlline;
}

void SV3_1aParser::SllineContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSlline(this);
}

void SV3_1aParser::SllineContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSlline(this);
}

SV3_1aParser::SllineContext* SV3_1aParser::slline() {
  SllineContext *_localctx = _tracker.createInstance<SllineContext>(_ctx, getState());
  enterRule(_localctx, 1346, SV3_1aParser::RuleSlline);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(9828);
    match(SV3_1aParser::TICK_LINE);
    setState(9829);
    match(SV3_1aParser::Integral_number);
    setState(9830);
    match(SV3_1aParser::String);
    setState(9831);
    match(SV3_1aParser::Integral_number);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Config_declarationContext ------------------------------------------------------------------

SV3_1aParser::Config_declarationContext::Config_declarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Config_declarationContext::CONFIG() {
  return getToken(SV3_1aParser::CONFIG, 0);
}

std::vector<SV3_1aParser::IdentifierContext *> SV3_1aParser::Config_declarationContext::identifier() {
  return getRuleContexts<SV3_1aParser::IdentifierContext>();
}

SV3_1aParser::IdentifierContext* SV3_1aParser::Config_declarationContext::identifier(size_t i) {
  return getRuleContext<SV3_1aParser::IdentifierContext>(i);
}

std::vector<tree::TerminalNode *> SV3_1aParser::Config_declarationContext::SEMICOLON() {
  return getTokens(SV3_1aParser::SEMICOLON);
}

tree::TerminalNode* SV3_1aParser::Config_declarationContext::SEMICOLON(size_t i) {
  return getToken(SV3_1aParser::SEMICOLON, i);
}

SV3_1aParser::Design_statementContext* SV3_1aParser::Config_declarationContext::design_statement() {
  return getRuleContext<SV3_1aParser::Design_statementContext>(0);
}

tree::TerminalNode* SV3_1aParser::Config_declarationContext::ENDCONFIG() {
  return getToken(SV3_1aParser::ENDCONFIG, 0);
}

std::vector<SV3_1aParser::Local_parameter_declarationContext *> SV3_1aParser::Config_declarationContext::local_parameter_declaration() {
  return getRuleContexts<SV3_1aParser::Local_parameter_declarationContext>();
}

SV3_1aParser::Local_parameter_declarationContext* SV3_1aParser::Config_declarationContext::local_parameter_declaration(size_t i) {
  return getRuleContext<SV3_1aParser::Local_parameter_declarationContext>(i);
}

std::vector<SV3_1aParser::Config_rule_statementContext *> SV3_1aParser::Config_declarationContext::config_rule_statement() {
  return getRuleContexts<SV3_1aParser::Config_rule_statementContext>();
}

SV3_1aParser::Config_rule_statementContext* SV3_1aParser::Config_declarationContext::config_rule_statement(size_t i) {
  return getRuleContext<SV3_1aParser::Config_rule_statementContext>(i);
}

tree::TerminalNode* SV3_1aParser::Config_declarationContext::COLON() {
  return getToken(SV3_1aParser::COLON, 0);
}


size_t SV3_1aParser::Config_declarationContext::getRuleIndex() const {
  return SV3_1aParser::RuleConfig_declaration;
}

void SV3_1aParser::Config_declarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterConfig_declaration(this);
}

void SV3_1aParser::Config_declarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitConfig_declaration(this);
}

SV3_1aParser::Config_declarationContext* SV3_1aParser::config_declaration() {
  Config_declarationContext *_localctx = _tracker.createInstance<Config_declarationContext>(_ctx, getState());
  enterRule(_localctx, 1348, SV3_1aParser::RuleConfig_declaration);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(9833);
    match(SV3_1aParser::CONFIG);
    setState(9834);
    identifier();
    setState(9835);
    match(SV3_1aParser::SEMICOLON);
    setState(9841);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == SV3_1aParser::LOCALPARAM) {
      setState(9836);
      local_parameter_declaration();
      setState(9837);
      match(SV3_1aParser::SEMICOLON);
      setState(9843);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(9844);
    design_statement();
    setState(9848);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 481036337152) != 0)) {
      setState(9845);
      config_rule_statement();
      setState(9850);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(9851);
    match(SV3_1aParser::ENDCONFIG);
    setState(9854);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SV3_1aParser::COLON) {
      setState(9852);
      match(SV3_1aParser::COLON);
      setState(9853);
      identifier();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Design_statementContext ------------------------------------------------------------------

SV3_1aParser::Design_statementContext::Design_statementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Design_statementContext::DESIGN() {
  return getToken(SV3_1aParser::DESIGN, 0);
}

tree::TerminalNode* SV3_1aParser::Design_statementContext::SEMICOLON() {
  return getToken(SV3_1aParser::SEMICOLON, 0);
}

std::vector<SV3_1aParser::IdentifierContext *> SV3_1aParser::Design_statementContext::identifier() {
  return getRuleContexts<SV3_1aParser::IdentifierContext>();
}

SV3_1aParser::IdentifierContext* SV3_1aParser::Design_statementContext::identifier(size_t i) {
  return getRuleContext<SV3_1aParser::IdentifierContext>(i);
}

std::vector<tree::TerminalNode *> SV3_1aParser::Design_statementContext::DOT() {
  return getTokens(SV3_1aParser::DOT);
}

tree::TerminalNode* SV3_1aParser::Design_statementContext::DOT(size_t i) {
  return getToken(SV3_1aParser::DOT, i);
}


size_t SV3_1aParser::Design_statementContext::getRuleIndex() const {
  return SV3_1aParser::RuleDesign_statement;
}

void SV3_1aParser::Design_statementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDesign_statement(this);
}

void SV3_1aParser::Design_statementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDesign_statement(this);
}

SV3_1aParser::Design_statementContext* SV3_1aParser::design_statement() {
  Design_statementContext *_localctx = _tracker.createInstance<Design_statementContext>(_ctx, getState());
  enterRule(_localctx, 1350, SV3_1aParser::RuleDesign_statement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(9856);
    match(SV3_1aParser::DESIGN);
    setState(9865);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (((((_la - 326) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 326)) & 4672924483589) != 0)) {
      setState(9860);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1165, _ctx)) {
      case 1: {
        setState(9857);
        identifier();
        setState(9858);
        match(SV3_1aParser::DOT);
        break;
      }

      default:
        break;
      }
      setState(9862);
      identifier();
      setState(9867);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(9868);
    match(SV3_1aParser::SEMICOLON);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Config_rule_statementContext ------------------------------------------------------------------

SV3_1aParser::Config_rule_statementContext::Config_rule_statementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SV3_1aParser::Default_clauseContext* SV3_1aParser::Config_rule_statementContext::default_clause() {
  return getRuleContext<SV3_1aParser::Default_clauseContext>(0);
}

SV3_1aParser::Liblist_clauseContext* SV3_1aParser::Config_rule_statementContext::liblist_clause() {
  return getRuleContext<SV3_1aParser::Liblist_clauseContext>(0);
}

tree::TerminalNode* SV3_1aParser::Config_rule_statementContext::SEMICOLON() {
  return getToken(SV3_1aParser::SEMICOLON, 0);
}

SV3_1aParser::Inst_clauseContext* SV3_1aParser::Config_rule_statementContext::inst_clause() {
  return getRuleContext<SV3_1aParser::Inst_clauseContext>(0);
}

SV3_1aParser::Use_clause_configContext* SV3_1aParser::Config_rule_statementContext::use_clause_config() {
  return getRuleContext<SV3_1aParser::Use_clause_configContext>(0);
}

SV3_1aParser::Use_clauseContext* SV3_1aParser::Config_rule_statementContext::use_clause() {
  return getRuleContext<SV3_1aParser::Use_clauseContext>(0);
}

SV3_1aParser::Cell_clauseContext* SV3_1aParser::Config_rule_statementContext::cell_clause() {
  return getRuleContext<SV3_1aParser::Cell_clauseContext>(0);
}


size_t SV3_1aParser::Config_rule_statementContext::getRuleIndex() const {
  return SV3_1aParser::RuleConfig_rule_statement;
}

void SV3_1aParser::Config_rule_statementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterConfig_rule_statement(this);
}

void SV3_1aParser::Config_rule_statementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitConfig_rule_statement(this);
}

SV3_1aParser::Config_rule_statementContext* SV3_1aParser::config_rule_statement() {
  Config_rule_statementContext *_localctx = _tracker.createInstance<Config_rule_statementContext>(_ctx, getState());
  enterRule(_localctx, 1352, SV3_1aParser::RuleConfig_rule_statement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(9898);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1167, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(9870);
      default_clause();
      setState(9871);
      liblist_clause();
      setState(9872);
      match(SV3_1aParser::SEMICOLON);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(9874);
      inst_clause();
      setState(9875);
      liblist_clause();
      setState(9876);
      match(SV3_1aParser::SEMICOLON);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(9878);
      inst_clause();
      setState(9879);
      use_clause_config();
      setState(9880);
      match(SV3_1aParser::SEMICOLON);
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(9882);
      inst_clause();
      setState(9883);
      use_clause();
      setState(9884);
      match(SV3_1aParser::SEMICOLON);
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(9886);
      cell_clause();
      setState(9887);
      liblist_clause();
      setState(9888);
      match(SV3_1aParser::SEMICOLON);
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(9890);
      cell_clause();
      setState(9891);
      use_clause_config();
      setState(9892);
      match(SV3_1aParser::SEMICOLON);
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(9894);
      cell_clause();
      setState(9895);
      use_clause();
      setState(9896);
      match(SV3_1aParser::SEMICOLON);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Default_clauseContext ------------------------------------------------------------------

SV3_1aParser::Default_clauseContext::Default_clauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Default_clauseContext::DEFAULT() {
  return getToken(SV3_1aParser::DEFAULT, 0);
}


size_t SV3_1aParser::Default_clauseContext::getRuleIndex() const {
  return SV3_1aParser::RuleDefault_clause;
}

void SV3_1aParser::Default_clauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDefault_clause(this);
}

void SV3_1aParser::Default_clauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDefault_clause(this);
}

SV3_1aParser::Default_clauseContext* SV3_1aParser::default_clause() {
  Default_clauseContext *_localctx = _tracker.createInstance<Default_clauseContext>(_ctx, getState());
  enterRule(_localctx, 1354, SV3_1aParser::RuleDefault_clause);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(9900);
    match(SV3_1aParser::DEFAULT);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Inst_clauseContext ------------------------------------------------------------------

SV3_1aParser::Inst_clauseContext::Inst_clauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Inst_clauseContext::INSTANCE() {
  return getToken(SV3_1aParser::INSTANCE, 0);
}

SV3_1aParser::Inst_nameContext* SV3_1aParser::Inst_clauseContext::inst_name() {
  return getRuleContext<SV3_1aParser::Inst_nameContext>(0);
}


size_t SV3_1aParser::Inst_clauseContext::getRuleIndex() const {
  return SV3_1aParser::RuleInst_clause;
}

void SV3_1aParser::Inst_clauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInst_clause(this);
}

void SV3_1aParser::Inst_clauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInst_clause(this);
}

SV3_1aParser::Inst_clauseContext* SV3_1aParser::inst_clause() {
  Inst_clauseContext *_localctx = _tracker.createInstance<Inst_clauseContext>(_ctx, getState());
  enterRule(_localctx, 1356, SV3_1aParser::RuleInst_clause);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(9902);
    match(SV3_1aParser::INSTANCE);
    setState(9903);
    inst_name();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Inst_nameContext ------------------------------------------------------------------

SV3_1aParser::Inst_nameContext::Inst_nameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<SV3_1aParser::IdentifierContext *> SV3_1aParser::Inst_nameContext::identifier() {
  return getRuleContexts<SV3_1aParser::IdentifierContext>();
}

SV3_1aParser::IdentifierContext* SV3_1aParser::Inst_nameContext::identifier(size_t i) {
  return getRuleContext<SV3_1aParser::IdentifierContext>(i);
}

std::vector<tree::TerminalNode *> SV3_1aParser::Inst_nameContext::DOT() {
  return getTokens(SV3_1aParser::DOT);
}

tree::TerminalNode* SV3_1aParser::Inst_nameContext::DOT(size_t i) {
  return getToken(SV3_1aParser::DOT, i);
}


size_t SV3_1aParser::Inst_nameContext::getRuleIndex() const {
  return SV3_1aParser::RuleInst_name;
}

void SV3_1aParser::Inst_nameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInst_name(this);
}

void SV3_1aParser::Inst_nameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInst_name(this);
}

SV3_1aParser::Inst_nameContext* SV3_1aParser::inst_name() {
  Inst_nameContext *_localctx = _tracker.createInstance<Inst_nameContext>(_ctx, getState());
  enterRule(_localctx, 1358, SV3_1aParser::RuleInst_name);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(9905);
    identifier();
    setState(9910);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == SV3_1aParser::DOT) {
      setState(9906);
      match(SV3_1aParser::DOT);
      setState(9907);
      identifier();
      setState(9912);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Cell_clauseContext ------------------------------------------------------------------

SV3_1aParser::Cell_clauseContext::Cell_clauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Cell_clauseContext::CELL() {
  return getToken(SV3_1aParser::CELL, 0);
}

std::vector<SV3_1aParser::IdentifierContext *> SV3_1aParser::Cell_clauseContext::identifier() {
  return getRuleContexts<SV3_1aParser::IdentifierContext>();
}

SV3_1aParser::IdentifierContext* SV3_1aParser::Cell_clauseContext::identifier(size_t i) {
  return getRuleContext<SV3_1aParser::IdentifierContext>(i);
}

tree::TerminalNode* SV3_1aParser::Cell_clauseContext::DOT() {
  return getToken(SV3_1aParser::DOT, 0);
}


size_t SV3_1aParser::Cell_clauseContext::getRuleIndex() const {
  return SV3_1aParser::RuleCell_clause;
}

void SV3_1aParser::Cell_clauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCell_clause(this);
}

void SV3_1aParser::Cell_clauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCell_clause(this);
}

SV3_1aParser::Cell_clauseContext* SV3_1aParser::cell_clause() {
  Cell_clauseContext *_localctx = _tracker.createInstance<Cell_clauseContext>(_ctx, getState());
  enterRule(_localctx, 1360, SV3_1aParser::RuleCell_clause);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(9913);
    match(SV3_1aParser::CELL);
    setState(9917);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1169, _ctx)) {
    case 1: {
      setState(9914);
      identifier();
      setState(9915);
      match(SV3_1aParser::DOT);
      break;
    }

    default:
      break;
    }
    setState(9919);
    identifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Liblist_clauseContext ------------------------------------------------------------------

SV3_1aParser::Liblist_clauseContext::Liblist_clauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Liblist_clauseContext::LIBLIST() {
  return getToken(SV3_1aParser::LIBLIST, 0);
}

std::vector<SV3_1aParser::IdentifierContext *> SV3_1aParser::Liblist_clauseContext::identifier() {
  return getRuleContexts<SV3_1aParser::IdentifierContext>();
}

SV3_1aParser::IdentifierContext* SV3_1aParser::Liblist_clauseContext::identifier(size_t i) {
  return getRuleContext<SV3_1aParser::IdentifierContext>(i);
}


size_t SV3_1aParser::Liblist_clauseContext::getRuleIndex() const {
  return SV3_1aParser::RuleLiblist_clause;
}

void SV3_1aParser::Liblist_clauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLiblist_clause(this);
}

void SV3_1aParser::Liblist_clauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLiblist_clause(this);
}

SV3_1aParser::Liblist_clauseContext* SV3_1aParser::liblist_clause() {
  Liblist_clauseContext *_localctx = _tracker.createInstance<Liblist_clauseContext>(_ctx, getState());
  enterRule(_localctx, 1362, SV3_1aParser::RuleLiblist_clause);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(9921);
    match(SV3_1aParser::LIBLIST);
    setState(9925);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (((((_la - 326) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 326)) & 4672924483589) != 0)) {
      setState(9922);
      identifier();
      setState(9927);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Use_clause_configContext ------------------------------------------------------------------

SV3_1aParser::Use_clause_configContext::Use_clause_configContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Use_clause_configContext::USE() {
  return getToken(SV3_1aParser::USE, 0);
}

std::vector<SV3_1aParser::IdentifierContext *> SV3_1aParser::Use_clause_configContext::identifier() {
  return getRuleContexts<SV3_1aParser::IdentifierContext>();
}

SV3_1aParser::IdentifierContext* SV3_1aParser::Use_clause_configContext::identifier(size_t i) {
  return getRuleContext<SV3_1aParser::IdentifierContext>(i);
}

tree::TerminalNode* SV3_1aParser::Use_clause_configContext::COLON() {
  return getToken(SV3_1aParser::COLON, 0);
}

tree::TerminalNode* SV3_1aParser::Use_clause_configContext::CONFIG() {
  return getToken(SV3_1aParser::CONFIG, 0);
}

tree::TerminalNode* SV3_1aParser::Use_clause_configContext::DOT() {
  return getToken(SV3_1aParser::DOT, 0);
}

std::vector<SV3_1aParser::Named_parameter_assignmentContext *> SV3_1aParser::Use_clause_configContext::named_parameter_assignment() {
  return getRuleContexts<SV3_1aParser::Named_parameter_assignmentContext>();
}

SV3_1aParser::Named_parameter_assignmentContext* SV3_1aParser::Use_clause_configContext::named_parameter_assignment(size_t i) {
  return getRuleContext<SV3_1aParser::Named_parameter_assignmentContext>(i);
}

std::vector<tree::TerminalNode *> SV3_1aParser::Use_clause_configContext::COMMA() {
  return getTokens(SV3_1aParser::COMMA);
}

tree::TerminalNode* SV3_1aParser::Use_clause_configContext::COMMA(size_t i) {
  return getToken(SV3_1aParser::COMMA, i);
}


size_t SV3_1aParser::Use_clause_configContext::getRuleIndex() const {
  return SV3_1aParser::RuleUse_clause_config;
}

void SV3_1aParser::Use_clause_configContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUse_clause_config(this);
}

void SV3_1aParser::Use_clause_configContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUse_clause_config(this);
}

SV3_1aParser::Use_clause_configContext* SV3_1aParser::use_clause_config() {
  Use_clause_configContext *_localctx = _tracker.createInstance<Use_clause_configContext>(_ctx, getState());
  enterRule(_localctx, 1364, SV3_1aParser::RuleUse_clause_config);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(9968);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1175, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(9928);
      match(SV3_1aParser::USE);
      setState(9932);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1171, _ctx)) {
      case 1: {
        setState(9929);
        identifier();
        setState(9930);
        match(SV3_1aParser::DOT);
        break;
      }

      default:
        break;
      }
      setState(9934);
      identifier();
      setState(9935);
      match(SV3_1aParser::COLON);
      setState(9936);
      match(SV3_1aParser::CONFIG);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(9938);
      match(SV3_1aParser::USE);
      setState(9939);
      named_parameter_assignment();
      setState(9944);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == SV3_1aParser::COMMA) {
        setState(9940);
        match(SV3_1aParser::COMMA);
        setState(9941);
        named_parameter_assignment();
        setState(9946);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(9947);
      match(SV3_1aParser::COLON);
      setState(9948);
      match(SV3_1aParser::CONFIG);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(9950);
      match(SV3_1aParser::USE);
      setState(9954);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1173, _ctx)) {
      case 1: {
        setState(9951);
        identifier();
        setState(9952);
        match(SV3_1aParser::DOT);
        break;
      }

      default:
        break;
      }
      setState(9956);
      identifier();
      setState(9957);
      named_parameter_assignment();
      setState(9962);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == SV3_1aParser::COMMA) {
        setState(9958);
        match(SV3_1aParser::COMMA);
        setState(9959);
        named_parameter_assignment();
        setState(9964);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(9965);
      match(SV3_1aParser::COLON);
      setState(9966);
      match(SV3_1aParser::CONFIG);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Use_clauseContext ------------------------------------------------------------------

SV3_1aParser::Use_clauseContext::Use_clauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SV3_1aParser::Use_clauseContext::USE() {
  return getToken(SV3_1aParser::USE, 0);
}

std::vector<SV3_1aParser::IdentifierContext *> SV3_1aParser::Use_clauseContext::identifier() {
  return getRuleContexts<SV3_1aParser::IdentifierContext>();
}

SV3_1aParser::IdentifierContext* SV3_1aParser::Use_clauseContext::identifier(size_t i) {
  return getRuleContext<SV3_1aParser::IdentifierContext>(i);
}

tree::TerminalNode* SV3_1aParser::Use_clauseContext::DOT() {
  return getToken(SV3_1aParser::DOT, 0);
}

std::vector<SV3_1aParser::Named_parameter_assignmentContext *> SV3_1aParser::Use_clauseContext::named_parameter_assignment() {
  return getRuleContexts<SV3_1aParser::Named_parameter_assignmentContext>();
}

SV3_1aParser::Named_parameter_assignmentContext* SV3_1aParser::Use_clauseContext::named_parameter_assignment(size_t i) {
  return getRuleContext<SV3_1aParser::Named_parameter_assignmentContext>(i);
}

std::vector<tree::TerminalNode *> SV3_1aParser::Use_clauseContext::COMMA() {
  return getTokens(SV3_1aParser::COMMA);
}

tree::TerminalNode* SV3_1aParser::Use_clauseContext::COMMA(size_t i) {
  return getToken(SV3_1aParser::COMMA, i);
}

SV3_1aParser::Parameter_value_assignmentContext* SV3_1aParser::Use_clauseContext::parameter_value_assignment() {
  return getRuleContext<SV3_1aParser::Parameter_value_assignmentContext>(0);
}


size_t SV3_1aParser::Use_clauseContext::getRuleIndex() const {
  return SV3_1aParser::RuleUse_clause;
}

void SV3_1aParser::Use_clauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUse_clause(this);
}

void SV3_1aParser::Use_clauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SV3_1aParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUse_clause(this);
}

SV3_1aParser::Use_clauseContext* SV3_1aParser::use_clause() {
  Use_clauseContext *_localctx = _tracker.createInstance<Use_clauseContext>(_ctx, getState());
  enterRule(_localctx, 1366, SV3_1aParser::RuleUse_clause);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(10003);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1180, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(9970);
      match(SV3_1aParser::USE);
      setState(9974);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1176, _ctx)) {
      case 1: {
        setState(9971);
        identifier();
        setState(9972);
        match(SV3_1aParser::DOT);
        break;
      }

      default:
        break;
      }
      setState(9976);
      identifier();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(9977);
      match(SV3_1aParser::USE);
      setState(9978);
      named_parameter_assignment();
      setState(9983);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == SV3_1aParser::COMMA) {
        setState(9979);
        match(SV3_1aParser::COMMA);
        setState(9980);
        named_parameter_assignment();
        setState(9985);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(9986);
      match(SV3_1aParser::USE);
      setState(9990);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1178, _ctx)) {
      case 1: {
        setState(9987);
        identifier();
        setState(9988);
        match(SV3_1aParser::DOT);
        break;
      }

      default:
        break;
      }
      setState(9992);
      identifier();
      setState(9993);
      named_parameter_assignment();
      setState(9998);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == SV3_1aParser::COMMA) {
        setState(9994);
        match(SV3_1aParser::COMMA);
        setState(9995);
        named_parameter_assignment();
        setState(10000);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(10001);
      match(SV3_1aParser::USE);
      setState(10002);
      parameter_value_assignment();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

bool SV3_1aParser::sempred(RuleContext *context, size_t ruleIndex, size_t predicateIndex) {
  switch (ruleIndex) {
    case 230: return property_exprSempred(antlrcpp::downCast<Property_exprContext *>(context), predicateIndex);
    case 233: return sequence_exprSempred(antlrcpp::downCast<Sequence_exprContext *>(context), predicateIndex);
    case 264: return block_event_expressionSempred(antlrcpp::downCast<Block_event_expressionContext *>(context), predicateIndex);
    case 282: return select_expressionSempred(antlrcpp::downCast<Select_expressionContext *>(context), predicateIndex);
    case 341: return if_generate_constructSempred(antlrcpp::downCast<If_generate_constructContext *>(context), predicateIndex);
    case 344: return generate_begin_end_blockSempred(antlrcpp::downCast<Generate_begin_end_blockContext *>(context), predicateIndex);
    case 400: return event_expressionSempred(antlrcpp::downCast<Event_expressionContext *>(context), predicateIndex);
    case 409: return conditional_statementSempred(antlrcpp::downCast<Conditional_statementContext *>(context), predicateIndex);
    case 572: return constant_expressionSempred(antlrcpp::downCast<Constant_expressionContext *>(context), predicateIndex);
    case 581: return expressionSempred(antlrcpp::downCast<ExpressionContext *>(context), predicateIndex);
    case 584: return module_path_expressionSempred(antlrcpp::downCast<Module_path_expressionContext *>(context), predicateIndex);

  default:
    break;
  }
  return true;
}

bool SV3_1aParser::property_exprSempred(Property_exprContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 0: return precpred(_ctx, 30);
    case 1: return precpred(_ctx, 29);
    case 2: return precpred(_ctx, 12);
    case 3: return precpred(_ctx, 11);
    case 4: return precpred(_ctx, 10);
    case 5: return precpred(_ctx, 9);
    case 6: return precpred(_ctx, 8);
    case 7: return precpred(_ctx, 7);

  default:
    break;
  }
  return true;
}

bool SV3_1aParser::sequence_exprSempred(Sequence_exprContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 8: return precpred(_ctx, 7);
    case 9: return precpred(_ctx, 6);
    case 10: return precpred(_ctx, 5);
    case 11: return precpred(_ctx, 2);
    case 12: return precpred(_ctx, 12);

  default:
    break;
  }
  return true;
}

bool SV3_1aParser::block_event_expressionSempred(Block_event_expressionContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 13: return precpred(_ctx, 3);

  default:
    break;
  }
  return true;
}

bool SV3_1aParser::select_expressionSempred(Select_expressionContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 14: return precpred(_ctx, 5);
    case 15: return precpred(_ctx, 3);

  default:
    break;
  }
  return true;
}

bool SV3_1aParser::if_generate_constructSempred(If_generate_constructContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 16: return _input->LA(1) != ELSE;

  default:
    break;
  }
  return true;
}

bool SV3_1aParser::generate_begin_end_blockSempred(Generate_begin_end_blockContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 17: return _input->LA(1) != COLON;
    case 18: return _input->LA(1) != COLON;

  default:
    break;
  }
  return true;
}

bool SV3_1aParser::event_expressionSempred(Event_expressionContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 19: return precpred(_ctx, 2);

  default:
    break;
  }
  return true;
}

bool SV3_1aParser::conditional_statementSempred(Conditional_statementContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 20: return _input->LA(1) != ELSE;

  default:
    break;
  }
  return true;
}

bool SV3_1aParser::constant_expressionSempred(Constant_expressionContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 21: return precpred(_ctx, 14);
    case 22: return precpred(_ctx, 13);
    case 23: return precpred(_ctx, 12);
    case 24: return precpred(_ctx, 11);
    case 25: return precpred(_ctx, 10);
    case 26: return precpred(_ctx, 9);
    case 27: return precpred(_ctx, 8);
    case 28: return precpred(_ctx, 7);
    case 29: return precpred(_ctx, 6);
    case 30: return precpred(_ctx, 5);
    case 31: return precpred(_ctx, 4);
    case 32: return precpred(_ctx, 3);
    case 33: return precpred(_ctx, 2);

  default:
    break;
  }
  return true;
}

bool SV3_1aParser::expressionSempred(ExpressionContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 34: return precpred(_ctx, 15);
    case 35: return precpred(_ctx, 14);
    case 36: return precpred(_ctx, 13);
    case 37: return precpred(_ctx, 12);
    case 38: return precpred(_ctx, 11);
    case 39: return precpred(_ctx, 10);
    case 40: return precpred(_ctx, 9);
    case 41: return precpred(_ctx, 8);
    case 42: return precpred(_ctx, 7);
    case 43: return precpred(_ctx, 6);
    case 44: return precpred(_ctx, 5);
    case 45: return precpred(_ctx, 4);
    case 46: return precpred(_ctx, 3);
    case 47: return precpred(_ctx, 2);
    case 48: return precpred(_ctx, 1);

  default:
    break;
  }
  return true;
}

bool SV3_1aParser::module_path_expressionSempred(Module_path_expressionContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 49: return precpred(_ctx, 2);
    case 50: return precpred(_ctx, 1);

  default:
    break;
  }
  return true;
}

void SV3_1aParser::initialize() {
#if ANTLR4_USE_THREAD_LOCAL_CACHE
  sv3_1aparserParserInitialize();
#else
  ::antlr4::internal::call_once(sv3_1aparserParserOnceFlag, sv3_1aparserParserInitialize);
#endif
}
